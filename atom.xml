<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-13T12:35:05.704Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring 5</title>
    <link href="http://example.com/2021/10/13/Spring-5/"/>
    <id>http://example.com/2021/10/13/Spring-5/</id>
    <published>2021-10-13T12:35:05.000Z</published>
    <updated>2021-10-13T12:35:05.704Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="http://example.com/2021/10/11/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/10/11/%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-11T13:39:04.000Z</published>
    <updated>2021-10-11T13:39:04.733Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>linux 文件权限和目录配置</title>
    <link href="http://example.com/2021/10/03/linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2021/10/03/linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</id>
    <published>2021-10-03T01:33:25.000Z</published>
    <updated>2021-10-03T01:37:35.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux-文件权限和目录配置"><a href="#linux-文件权限和目录配置" class="headerlink" title="linux 文件权限和目录配置"></a>linux 文件权限和目录配置</h2><p>涉及命令：</p><ul><li>切换用户：su -用户名      exit退出</li><li>显示文件的所有属性权限：ls - al</li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li><p>Linux的每个文件中,可可分别给予使用者，群组，与其他人三种方式的rwx的权限。</p></li><li><p>root，一般用户的用户相关信息记录在/etc/passwd;个人密码记录在 /etc/shadow/;组名记录在 /etc/group</p></li><li><p>访问文件需要相关的权限，</p></li><li><p>群组最有用的功能之一，就是当你的团队开发资源的时候，每个账户都可以有多个群组支持。</p></li><li><p>利用ls -l显示的文件属性中，第一个字段是文件的权限，共有十位，</p><p>第一位是文件类型，：d:目录，-:文件,I:连接档，b：接口设备。c:串行端口设备。</p><p>接下来三个为一组，分为使用者，群组，其他人权限，权限有rwx三种，：可读 可写 可执行</p></li></ul><p><strong>linux文件权限重要性：</strong> </p><ul><li>系统保护</li><li>文件开发、数据共享</li><li>权限设置避免安全问题</li></ul><p>修改文件属性和群组</p><p><strong>更改文件的群组支持chgrp</strong></p><p>要被改变的组名必须要在/etc/group 文件内存在才 行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] dirname&#x2F;filename</span><br><span class="line">注：[-R] 是递归修改，更改文件目录下的所有文件或者目录的权限</span><br></pre></td></tr></table></figure><p><strong>修改文件的拥有者为chown</strong>，更改一个文件的拥有者与群组，使用什么指令。chown chgrp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将目录中所有文件或目录更改文件拥有者</span><br><span class="line">chown [-R] 帐号名称 文件或目录</span><br><span class="line">chown [-R] 帐号名称：用户组名称 文件或目录</span><br></pre></td></tr></table></figure><p><strong>修改文件的权限用chmod</strong></p><ul><li><p>chmod修改权限的方式：</p><ul><li><p>符号法：u 、g、o、分别代表 user、group、others三种身份</p><p>​        +、-、=分别代表加入、移除、设置三种操作</p><p>例如：增加某个文件的让所有人可写入的权限 ：chmod a+w  文件名</p></li><li><p>数字法：rwx分数 分别为421；各种身份的权限数字进行累加</p><p>例如：当一个文件的修改权限为 -rwx-xr–指令：chmod 754  文件名  或者chmod u=rwx，g=rx，o=r 文件名 </p></li></ul></li></ul><h3 id="权限的意义"><a href="#权限的意义" class="headerlink" title="权限的意义"></a>权限的意义</h3><p>权限对于目录和文件的作用略有不同，下面我们分开概述：</p><ul><li><p>文件</p><ul><li>r，可读此文件的实际内容，如读取文本文件的文字内容等。</li><li>w，可以编辑，新增或者修改该文件的内容（不能删除）</li><li>x，该文件具有可以被系统执行的权利。</li></ul></li><li><p>目录：</p><ul><li>r：read contents in directory    可以查询文件名数据</li><li>w：modify contents directory  可以对文件进行改动，包括 移动、新建、删除、重命名等。</li><li>x：accessdirectory    能够进入该目录作为当前工作目录</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>要开放目录给任何人浏览，应该至少也要给予r及x的权限，但w的权限不可随便给。</li><li>能否读取到某个文件内容，跟该文件所在的目录权限有关系，目录至少需要x的权限</li></ul><h3 id="linux文件种类："><a href="#linux文件种类：" class="headerlink" title="linux文件种类："></a>linux文件种类：</h3><p>常规文件：包括文本文件、二进制文件、数据文件  第一个字符为 -</p><p>目录   director</p><p>链接文件   类似windows的快捷方式</p><p>设备与设备文件 device  包括 区块blocks和字符文件character </p><p>数据接口文件  sockets</p><p>数据接送文件   FIFO pipe</p><ul><li><p>Linux档名的限制，单一文件或目录最大容许的文件名为255个英文字符或者128 个汉字字符。</p></li><li><p>linux一个文件能否执行和文件扩展名没有关系，文件扩展名是用来便于用户是别文件功能，能否执行与 文件权限中的  权限的是个属性有关</p></li><li><p>文件能否执行成功最终要看件的内容</p></li></ul><h3 id="linux目录配置："><a href="#linux目录配置：" class="headerlink" title="linux目录配置："></a>linux目录配置：</h3><ul><li><p>绝对路径文件名为从根目录/开始写起，否则都为相对路径。</p></li><li><p>.  表示当前目录          ..  表示上级目录</p></li></ul><p>常见目录功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;：根目录 ，最重要的目录</span><br><span class="line">&#x2F;etc&#x2F;:几乎系统所有的配置文件案都在这里，尤其是passwd和shaow</span><br><span class="line">&#x2F;boot&#x2F;:开机配置文件。也是预设摆放核心vmlinuz的地方。</span><br><span class="line">&#x2F;usr&#x2F;bin,&#x2F;bin:一般执行档摆放的地方。</span><br><span class="line">&#x2F;var&#x2F;log:摆放系统注册表文件的地方法</span><br><span class="line">&#x2F;dev:摆放所有系统装置文件的目录</span><br><span class="line">&#x2F;use&#x2F;sbin,&#x2F;sbin：系统管理员常用的指令集</span><br><span class="line">&#x2F;run:将经常变动的项目移动到内存暂存</span><br></pre></td></tr></table></figure><p>根目录：</p><p><img src="https://www.hualigs.cn/image/615904e2ddc91.jpg"></p><p><img src="https://www.hualigs.cn/image/615904e3495de.jpg"></p><p>/usr</p><p><img src="https://www.hualigs.cn/image/615904e341b8c.jpg"></p><p>/var</p><p> <img src="https://www.hualigs.cn/image/615904e33db17.jpg"></p><ul><li>文档名有【.】开头表示为隐藏文档，需要使用ls-a这个-a选项才可以显示出隐藏文档的内容，而使用ls -al才能显示出属性。</li></ul>]]></content>
    
    
    <summary type="html">some of my essay</summary>
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="essay" scheme="http://example.com/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>summery-of -advanced-SQL</title>
    <link href="http://example.com/2021/10/02/summery-of-advanced-SQL/"/>
    <id>http://example.com/2021/10/02/summery-of-advanced-SQL/</id>
    <published>2021-10-02T02:27:50.000Z</published>
    <updated>2021-10-02T02:28:57.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql并发参数调整"><a href="#Mysql并发参数调整" class="headerlink" title="Mysql并发参数调整"></a><a href="https://www.cnblogs.com/roadlandscape/p/12808422.html">Mysql并发参数调整</a></h1><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p><p>1.max_connections</p><p>　　采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。<br>　　Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><p>　　　　show variables like ‘max_connections’　　最大连接数</p><p>　　　　show status like ‘max_used_connections’　　响应的连接数</p><p>　　　　max_used_connections / max_connections * 100% （理想值≈ 85%）</p><p>2.back_log</p><p>　　back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 +（max_connections / 5）， 但最大不超过900。<br>　　如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><p>3.table_open_cache</p><p>　　该参数用来控制所有SQL语句执行线程可打开表缓存的数量（针对整个数据库，不是session会话）， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：max_connections*N</p><p>4.thread_cache_size</p><p>　　为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p><p>5.innodb_lock_wait_timeout</p><p>　　该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说，可以将行锁的等待时间调大， 以避免发生大的回滚操作</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>尚硅谷_宋红康_JDBC</title>
    <link href="http://example.com/2021/08/02/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-JDBC-1/"/>
    <id>http://example.com/2021/08/02/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-JDBC-1/</id>
    <published>2021-08-02T02:17:49.000Z</published>
    <updated>2021-10-02T02:19:48.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><hr><h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul><li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p></li><li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566741430592.png" alt="1566741430592"> </p></li></ul><h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul><li><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p>JDO (Java Data Object )技术</p></li><li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p></li></ul></li><li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p></li></ul><h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul><li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555575760234.png" alt="1555575760234"></p><hr><ul><li>有了JDBC，Java程序访问数据库时是这样的：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555575981203.png" alt="1555575981203"></p><hr><ul><li>总结如下：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566741692804.png" alt="1566741692804"></p><h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p></blockquote><h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1565969323908.png" alt="1565969323908"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li><li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li></ul></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576157618.png" alt="1555576157618"></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576170074.png" alt="1555576170074"></p><ul><li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li></ul><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566134718955.png" alt="1566134718955"></p><p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566134781682.png" alt="1566134781682"></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566135290460.png" alt="1566135290460"></p><h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li></ul></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566136831283.png" alt="1566136831283"></p></li></ul></li></ul><h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><ul><li><strong>jdbc:子协议:子名称</strong></li><li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li><li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li><li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li></ul></li><li><p>举例：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576477107.png" alt="1555576477107"></p></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/atguigu</li><li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p></li><li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p></li></ul></li></ul></li></ul><h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul><li>user,password可以用“属性名=属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul><li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p></li><li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566573842140.png" alt="1566573842140"></p></li></ul><h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">String userName = scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">User user = get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line">String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566569819744.png" alt="1566569819744"></p><h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul><li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p></li><li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul><li><p>代码的可读性和可维护性。</p></li><li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li></ul></li><li><p>PreparedStatement 可以防止 SQL 注入 </p></li></ul><h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY  ,    VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123;Connection conn = null;PreparedStatement ps = null;try &#123;//1.获取数据库的连接conn = JDBCUtils.getConnection();//2.获取PreparedStatement的实例 (或：预编译sql语句)ps = conn.prepareStatement(sql);//3.填充占位符for(int i = 0;i &lt; args.length;i++)&#123;ps.setObject(i + 1, args[i]);&#125;//4.执行sql语句ps.execute();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;finally&#123;//5.关闭资源JDBCUtils.closeResource(conn, ps);&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;try &#123;// 1.获取数据库连接conn = JDBCUtils.getConnection();// 2.预编译sql语句，得到PreparedStatement对象ps = conn.prepareStatement(sql);// 3.填充占位符for (int i = 0; i &lt; args.length; i++) &#123;ps.setObject(i + 1, args[i]);&#125;// 4.执行executeQuery(),得到结果集：ResultSetrs = ps.executeQuery();// 5.得到结果集的元数据：ResultSetMetaDataResultSetMetaData rsmd = rs.getMetaData();// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值int columnCount = rsmd.getColumnCount();if (rs.next()) &#123;T t = clazz.newInstance();for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列// 获取列值Object columnVal = rs.getObject(i + 1);// 获取列的别名:列的别名，使用类的属性名充当String columnLabel = rsmd.getColumnLabel(i + 1);// 6.2使用反射，给对象的相应属性赋值Field field = clazz.getDeclaredField(columnLabel);field.setAccessible(true);field.set(t, columnVal);&#125;return t;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;// 7.关闭资源JDBCUtils.closeResource(conn, ps, rs);&#125;return null;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li><p>boolean next()</p></li><li><p>getString()</p></li><li><p>…</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580152530.png" alt="1555580152530"></p></li></ul><h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta = rs.getMetaData();</p><ul><li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p></li><li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p></li><li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p></li><li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p></li><li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p></li><li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p></li><li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p></li></ul></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555579494691.png" alt="1555579494691"></p><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li><li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555579816884.png" alt="1555579816884"></p><h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul><li><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。</p></blockquote></li><li><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><hr><h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580275036.png" alt="1555580275036"></p><p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580735377.png" alt="1555580735377"></p><p>向数据表中添加如下数据：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580763636.png" alt="1555580763636"></p><p><strong>代码实现1：插入一个新的student 信息</strong></p><p>请输入考生的详细信息</p><p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p><p>信息录入成功!</p><p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580937490.png" alt="1555580937490"></p><p><strong>代码实现3：完成学生信息的删除功能</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580965019.png" alt="1555580965019"></p><hr><h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555581069798.png" alt="1555581069798"></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接Connection conn = JDBCUtils.getConnection();String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="comment">// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;conn = getConnection();ps = conn.prepareStatement(sql);ps.setInt(<span class="number">1</span>, <span class="number">8</span>);rs = ps.executeQuery();<span class="keyword">if</span>(rs.next())&#123;Integer id = rs.getInt(<span class="number">1</span>);    String name = rs.getString(<span class="number">2</span>);String email = rs.getString(<span class="number">3</span>);    Date birth = rs.getDate(<span class="number">4</span>);Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);    System.out.println(cust);     <span class="comment">//读取Blob类型的字段Blob photo = rs.getBlob(5);InputStream is = photo.getBinaryStream();OutputStream os = new FileOutputStream(&quot;c.jpg&quot;);byte [] buffer = new byte[1024];int len = 0;while((len = is.read(buffer)) != -1)&#123;os.write(buffer, 0, len);&#125;    JDBCUtils.closeResource(conn, ps, rs);if(is != null)&#123;is.close();&#125;if(os !=  null)&#123;os.close();&#125;    &#125;</span></span><br></pre></td></tr></table></figure><h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li><li><strong>executeBatch()：执行批量处理语句；</strong></li><li><strong>clearBatch():清空缓存的数据</strong></li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li>数据库中提供一个goods表。创建如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,NAME <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;st.executeUpdate(sql);&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);ps.executeUpdate();&#125;<span class="keyword">long</span> end = System.currentTimeMillis();System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 *  ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar *  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);<span class="comment">//1.“攒”sqlps.addBatch();if(i % 500 == 0)&#123;//2.执行ps.executeBatch();//3.清空ps.clearBatch();&#125;&#125;long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625                                                                         //1000000条:14733  JDBCUtils.closeResource(conn, ps);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false)  /  commit()*/</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();<span class="comment">//1.设置为不自动提交数据conn.setAutoCommit(false);String sql = &quot;insert into goods(name)values(?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);for(int i = 1;i &lt;= 1000000;i++)&#123;ps.setString(1, &quot;name_&quot; + i);//1.“攒”sqlps.addBatch();if(i % 500 == 0)&#123;//2.执行ps.executeBatch();//3.清空ps.clearBatch();&#125;&#125;//2.提交数据conn.commit();long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p></li><li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p></li><li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p></li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p><ul><li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li><li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;Connection conn = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;<span class="comment">// 1.获取数据库连接conn = JDBCUtils.getConnection();// 2.开启事务conn.setAutoCommit(false);// 3.进行数据库操作String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;update(conn, sql1, &quot;AA&quot;);// 模拟网络异常//System.out.println(10 / 0);String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;update(conn, sql2, &quot;BB&quot;);// 4.若没有异常，则提交事务conn.commit();&#125; catch (Exception e) &#123;e.printStackTrace();// 5.若有异常，则回滚事务try &#123;conn.rollback();&#125; catch (SQLException e1) &#123;e1.printStackTrace();&#125;    &#125; finally &#123;        try &#123;//6.恢复每次DML操作的自动提交功能conn.setAutoCommit(true);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125;        //7.关闭连接JDBCUtils.closeResource(conn, null, null);     &#125;  &#125;</span></span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123;PreparedStatement ps = null;try &#123;// 1.获取PreparedStatement的实例 (或：预编译sql语句)ps = conn.prepareStatement(sql);// 2.填充占位符for (int i = 0; i &lt; args.length; i++) &#123;ps.setObject(i + 1, args[i]);&#125;// 3.执行sql语句ps.execute();&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;// 4.关闭资源JDBCUtils.closeResource(null, ps);&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol><li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul><li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p></li><li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p></li></ul><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul><li><p>数据库提供的4种事务隔离级别：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555586275271.png" alt="1555586275271"></p></li><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li></ul><ul><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li><li><p>设置当前 mySQL 连接的隔离级别:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;;  #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566726681515.png" alt="1566726681515"></p><ul><li>层次结构：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566745811244.png" alt="1566745811244"></p><h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.lang.reflect.ParameterizedType;<span class="keyword">import</span> java.lang.reflect.Type;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;<span class="comment">/** * 定义一个用来被继承的对数据库进行基本操作的Dao *  * <span class="doctag">@author</span> HanYanBing * * <span class="doctag">@param</span> &lt;T&gt; */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();<span class="comment">// 定义一个变量来接收泛型的类型private Class&lt;T&gt; type;// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定public BaseDao() &#123;// 获取子类的类型Class clazz = this.getClass();// 获取父类的类型// getGenericSuperclass()用来获取当前类的父类的类型// ParameterizedType表示的是带泛型的类型ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型// 这个方法会返回一个Type的数组Type[] types = parameterizedType.getActualTypeArguments();// 获取具体的泛型的类型·this.type = (Class&lt;T&gt;) types[0];&#125;/** * 通用的增删改操作 *  * @param sql * @param params * @return */public int update(Connection conn,String sql, Object... params) &#123;int count = 0;try &#123;count = queryRunner.update(conn, sql, params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return count;&#125;/** * 获取一个对象 *  * @param sql * @param params * @return */public T getBean(Connection conn,String sql, Object... params) &#123;T t = null;try &#123;t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return t;&#125;/** * 获取所有对象 *  * @param sql * @param params * @return */public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123;List&lt;T&gt; list = null;try &#123;list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return list;&#125;/** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 *  * @param sql * @param params * @return */public Object getValue(Connection conn,String sql, Object... params) &#123;Object count = null;try &#123;// 调用queryRunner的query方法获取一个单一的值count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return count;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> com.atguigu.bookstore.beans.Book;<span class="keyword">import</span> com.atguigu.bookstore.beans.Page;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;<span class="comment">/** * 从数据库中查询出所有的记录 *  * <span class="doctag">@return</span> */</span><span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;<span class="comment">/** * 向数据库中插入一条记录 *  * <span class="doctag">@param</span> book */</span><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;<span class="comment">/** * 从数据库中根据图书的id删除一条记录 *  * <span class="doctag">@param</span> bookId */</span><span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;<span class="comment">/** * 根据图书的id从数据库中查询出一条记录 *  * <span class="doctag">@param</span> bookId * <span class="doctag">@return</span> */</span><span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;<span class="comment">/** * 根据图书的id从数据库中更新一条记录 *  * <span class="doctag">@param</span> book */</span><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;<span class="comment">/** * 获取带分页的图书信息 *  * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象 */</span><span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;<span class="comment">/** * 获取带分页和价格范围的图书信息 *  * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象 */</span><span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> com.atguigu.bookstore.beans.User;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;<span class="comment">/** * 根据User对象中的用户名和密码从数据库中获取一条记录 *  * <span class="doctag">@param</span> user * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录 */</span><span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;<span class="comment">/** * 根据User对象中的用户名从数据库中获取一条记录 *  * <span class="doctag">@param</span> user * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录 */</span><span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;<span class="comment">/** * 向数据库中插入User对象 *  * <span class="doctag">@param</span> user */</span><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> com.atguigu.bookstore.beans.Book;<span class="keyword">import</span> com.atguigu.bookstore.beans.Page;<span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;<span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;<span class="comment">// 调用BaseDao中得到一个List的方法List&lt;Book&gt; beanList = null;// 写sql语句String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;;beanList = getBeanList(conn,sql);return beanList;&#125;@Overridepublic void saveBook(Connection conn,Book book) &#123;// 写sql语句String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;// 调用BaseDao中通用的增删改的方法update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());&#125;@Overridepublic void deleteBookById(Connection conn,String bookId) &#123;// 写sql语句String sql = &quot;DELETE FROM books WHERE id = ?&quot;;// 调用BaseDao中通用增删改的方法update(conn,sql, bookId);&#125;@Overridepublic Book getBookById(Connection conn,String bookId) &#123;// 调用BaseDao中获取一个对象的方法Book book = null;// 写sql语句String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;book = getBean(conn,sql, bookId);return book;&#125;@Overridepublic void updateBook(Connection conn,Book book) &#123;// 写sql语句String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;;// 调用BaseDao中通用的增删改的方法update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());&#125;@Overridepublic Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123;// 获取数据库中图书的总记录数String sql = &quot;select count(*) from books&quot;;// 调用BaseDao中获取一个单一值的方法long totalRecord = (long) getValue(conn,sql);// 将总记录数设置都page对象中page.setTotalRecord((int) totalRecord);// 获取当前页中的记录存放的ListString sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;;// 调用BaseDao中获取一个集合的方法List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);// 将这个List设置到page对象中page.setList(beanList);return page;&#125;@Overridepublic Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123;// 获取数据库中图书的总记录数String sql = &quot;select count(*) from books where price between ? and ?&quot;;// 调用BaseDao中获取一个单一值的方法long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);// 将总记录数设置都page对象中page.setTotalRecord((int) totalRecord);// 获取当前页中的记录存放的ListString sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;;// 调用BaseDao中获取一个集合的方法List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);// 将这个List设置到page对象中page.setList(beanList);return page;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> com.atguigu.bookstore.beans.User;<span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;<span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;<span class="comment">// 调用BaseDao中获取一个对象的方法User bean = null;// 写sql语句String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;;bean = getBean(conn,sql, user.getUsername(), user.getPassword());return bean;&#125;@Overridepublic boolean checkUsername(Connection conn,User user) &#123;// 调用BaseDao中获取一个对象的方法User bean = null;// 写sql语句String sql = &quot;select id,username,password,email from users where username = ?&quot;;bean = getBean(conn,sql, user.getUsername());return bean != null;&#125;@Overridepublic void saveUser(Connection conn,User user) &#123;//写sql语句String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;//调用BaseDao中通用的增删改的方法update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="comment">/** * 图书类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;<span class="keyword">private</span> Integer id;<span class="keyword">private</span> String title; <span class="comment">// 书名private String author; // 作者private double price; // 价格private Integer sales; // 销量private Integer stock; // 库存private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径//构造器，get()，set()，toString()方法略&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="keyword">import</span> java.util.List;<span class="comment">/** * 页码类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合public static final int PAGE_SIZE = 4; // 每页显示的记录数private int pageNo; // 当前页//private int totalPageNo; // 总页数，通过计算得到private int totalRecord; // 总记录数，通过查询数据库得到</span></span><br></pre></td></tr></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="comment">/** * 用户类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;<span class="keyword">private</span> Integer id;<span class="keyword">private</span> String username;<span class="keyword">private</span> String password;<span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p><ul><li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li><li><strong>进行sql操作</strong></li><li><strong>断开数据库连接</strong></li></ul></li><li><p>这种模式开发，存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li><li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p></li><li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p></li><li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p></li><li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555593464033.png" alt="1555593464033"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555593598606.png" alt="1555593598606"></p><ul><li><p><strong>数据库连接池技术的优点</strong></p><p><strong>1. 资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2. 更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><p><strong>3. 新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p><p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul><li>获取连接方式一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123;ComboPooledDataSource cpds = new ComboPooledDataSource();cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);cpds.setUser(&quot;root&quot;);cpds.setPassword(&quot;abc123&quot;);//cpds.setMaxPoolSize(100);Connection conn = cpds.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>获取连接方式二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123;Connection conn = cpds.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;BasicDataSource source = <span class="keyword">new</span> BasicDataSource();source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);source.setUsername(<span class="string">&quot;root&quot;</span>);source.setPassword(<span class="string">&quot;abc123&quot;</span>);<span class="comment">//source.setInitialSize(10);Connection conn = source.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123;try &#123;Properties pros = new Properties();InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);pros.load(is);//根据提供的BasicDataSourceFactory创建对应的DataSource对象source = BasicDataSourceFactory.createDataSource(pros);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;public static Connection getConnection4() throws Exception &#123;Connection conn = source.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【dbcp.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#...</span></span><br></pre></td></tr></table></figure><h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> javax.sql.DataSource;<span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;Properties pro = <span class="keyword">new</span> Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));DataSource ds = DruidDataSourceFactory.createDataSource(pro);Connection conn = ds.getConnection();System.out.println(conn);&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=123456driverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall</span></span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th><strong>配置</strong></th><th><strong>缺省</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils   </li></ul></li><li><p>API包说明：</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555595163263.png" alt="1555595163263"></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555595198644.png" alt="1555595198644"></p><h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p><ul><li><strong>更新</strong><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul></li><li><strong>插入</strong><ul><li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li><li>….</li></ul></li><li><strong>批处理</strong><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>…..</li></ul></li><li><strong>查询</strong><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…… </li></ul></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加@Testpublic void testInsert() throws Exception &#123;QueryRunner runner = new QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;);System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除@Testpublic void testDelete() throws Exception &#123;QueryRunner runner = new QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = &quot;delete from customers where id &lt; ?&quot;;int count = runner.update(conn, sql,3);System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p></li><li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p></li><li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p></li><li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p></li><li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p></li><li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p></li><li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p></li><li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p></li><li><p><strong>ScalarHandler：</strong>查询单个值对象</p></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 测试查询:查询一条记录 *  * 使用ResultSetHandler的实现类：BeanHandler */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;<span class="comment">//BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class);Customer customer = runner.query(conn, sql, handler, 23);System.out.println(customer);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 测试查询:查询多条记录构成的集合 *  * 使用ResultSetHandler的实现类：BeanListHandler */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;<span class="comment">//BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class);List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23);list.forEach(System.out::println);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 自定义ResultSetHandler的实现类 */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;System.out.println(<span class="string">&quot;handle&quot;</span>);<span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));if(rs.next())&#123;int id = rs.getInt(&quot;id&quot;);String name = rs.getString(&quot;name&quot;);String email = rs.getString(&quot;email&quot;);Date birth = rs.getDate(&quot;birth&quot;);return new Customer(id, name, email, birth);&#125;return null;&#125;&#125;;Customer customer = runner.query(conn, sql, handler, 23);System.out.println(customer);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler *  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();<span class="comment">//测试一：//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;//ScalarHandler handler = new ScalarHandler();//long count = (long) runner.query(conn, sql, handler, 20);//System.out.println(count);//测试二：String sql = &quot;select max(birth) from customers&quot;;ScalarHandler handler = new ScalarHandler();Date birth = (Date) runner.query(conn, sql, handler);System.out.println(birth);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结<span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;Connection conn = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;<span class="comment">//1.获取连接的操作（//① 手写的连接：JDBCUtils.getConnection();//② 使用数据库连接池：C3P0;DBCP;Druid//2.对数据表进行一系列CRUD操作//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;//② 使用dbutils提供的jar包中提供的QueryRunner类//提交数据conn.commit();&#125; catch (Exception e) &#123;e.printStackTrace();try &#123;//回滚数据conn.rollback();&#125; catch (SQLException e1) &#123;e1.printStackTrace();&#125;&#125;finally&#123;//3.关闭连接等操作//① JDBCUtils.closeResource();//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Jdbc</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/17/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/07/17/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-17T15:49:31.952Z</published>
    <updated>2021-10-02T02:05:55.468Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">title: 尚硅谷_宋红康_JDBC</span><br><span class="line">date: 2021-09-20 20:04:28</span><br><span class="line">tags: thinks</span><br><span class="line">categories: thinks</span><br><span class="line">keywords:</span><br><span class="line">description: some of my thinks</span><br><span class="line">top_img: </span><br><span class="line">comments: </span><br><span class="line">cover: https:&#x2F;&#x2F;ae01.alicdn.com&#x2F;kf&#x2F;Ue5889eaf11594a4aabca090c5d5060798.jpg</span><br><span class="line">toc:  </span><br><span class="line">toc_number:</span><br><span class="line">copyright:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br></pre></td></tr></table></figure><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><h3 id="何为编程"><a href="#何为编程" class="headerlink" title="何为编程"></a>何为编程</h3><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</p><p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p><h3 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h3><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="jdk1.5之后的三大版本"></a>jdk1.5之后的三大版本</h3><ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li><li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li><li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h3 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h3><p>JVM</p><p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p><p>JRE</p><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p><p>JDK</p><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p><p>JVM&amp;JRE&amp;JDK关系图</p><h3 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p><p>面向对象（封装，继承，多态）</p><p>平台无关性（Java虚拟机实现平台无关性）</p><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p><p>安全性</p><h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h3><p>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><h4 id="采用字节码的好处："><a href="#采用字节码的好处：" class="headerlink" title="采用字节码的好处："></a>采用字节码的好处：</h4><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h4 id="先看下java中的编译器和解释器："><a href="#先看下java中的编译器和解释器：" class="headerlink" title="先看下java中的编译器和解释器："></a>先看下java中的编译器和解释器：</h4><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure><h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><h3 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><h4 id="Java基本数据类型图"><a href="#Java基本数据类型图" class="headerlink" title="Java基本数据类型图"></a>Java基本数据类型图</h4><h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h4 id="什么Java注释"><a href="#什么Java注释" class="headerlink" title="什么Java注释"></a>什么Java注释</h4><p>定义：用于解释说明程序的文字</p><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>单行注释<br>格式： // 注释文字</li><li>多行注释<br>格式： / <em>注释文字</em> /</li><li>文档注释<br>格式：/** 注释文字* /</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p><p>注意事项：多行和文档注释都不能嵌套使用。</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><p>定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p><p>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p><p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p><p>public : 对所有类可见。使用对象：类、接口、变量、方法</p><h4 id="访问修饰符图"><a href="#访问修饰符图" class="headerlink" title="访问修饰符图"></a>访问修饰符图</h4><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h4 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h4><p>用于修饰类、属性和方法；</p><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表<br>示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块<br>中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调<br>用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的<br>最后判断。</li></ul><h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p>this的用法在java中大体可以分为3种：</p><p>1.普通的直接引用，this相当于是指向当前对象本身。</p><p>2.形参与成员名字重名，用this来区分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.引用本类的构造函数</p><p>class Person{ private String name; private int age; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> { }  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> {     <span class="hljs-built_in">this</span>.name = name; } <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, int age</span>)</span> {     <span class="hljs-built_in">this</span>(name);     <span class="hljs-built_in">this</span>.age = age; }</p><p><code>&#125;</code></p><h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super也有三种用法：</p><p>1.普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><p>class Person{ protected String name; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> {     <span class="hljs-built_in">this</span>.name = name; }  } class Student extends Person{ private String name; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> name1</span>)</span> {     <span class="hljs-built_in">super</span>(name);     <span class="hljs-built_in">this</span>.name = name1; }  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span>{     System.out.println(<span class="hljs-built_in">this</span>.name);      <span class="hljs-comment">//Child</span>     System.out.println(<span class="hljs-built_in">super</span>.name);     <span class="hljs-comment">//Father</span> }  } public class Test { public static void main(String[] args) { Student s1 = new Student(“Father”,”Child”); s1.getInfo(); }</p><p><code>&#125;</code></p><p>3.引用父类构造函数</p><p>3、引用父类构造函数</p><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul><h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul><li>super:它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h4><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。 <strong>以致于即使没有创建对象，也能使用属性和调用方法</strong> ！</p><p>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong> 。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法 <strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong> 。</p><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p><p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p><p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果 某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量 。</p><p>因此比较常见的static应用场景有：</p><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p><h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><p><code>public static void main(String[] args) &#123; ok: for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j); if (j == 5) &#123; break ok; &#125;    &#125; &#125; </code></p><p><code>&#125;</code></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h4><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p><p>缺点：没有面向对象易维护、易复用、易扩展</p><h4 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h4><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><h4 id="面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。"><a href="#面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。" class="headerlink" title="面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。"></a>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</h4><h4 id="面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。"><a href="#面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。" class="headerlink" title="面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。"></a>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</h4><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><h4 id="面向对象的特征主要有以下几个方面："><a href="#面向对象的特征主要有以下几个方面：" class="headerlink" title="面向对象的特征主要有以下几个方面："></a>面向对象的特征主要有以下几个方面：</h4><p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p>封装</p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p>继承</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p>多态</p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>其中Java 面向对象编程三大特性：封装 继承 多态</p><p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p><h4 id="关于继承如下-3-点请记住："><a href="#关于继承如下-3-点请记住：" class="headerlink" title="关于继承如下 3 点请记住："></a>关于继承如下 3 点请记住：</h4><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><p>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul><h4 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p>继承：在多态中必须存在有继承关系的子类和父类。</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ul><li>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p><p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p><p>成员变量：方法外部，类内部定义的变量</p><p>局部变量：类的方法中的变量。</p><p>成员变量和局部变量的区别</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>成员变量：针对整个类有效。</p><p>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><h4 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h4><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</p><p>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p><p>局部变量：当方法调用完，或者语句结束后，就自动释放。</p><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>成员变量：有默认初始值。</p><p>局部变量：没有默认初始值，使用前必须赋值。</p><p>使用原则</p><p>在使用变量时需要遵循的原则为：就近原则</p><p>首先在局部范围找，有就使用；接着在成员位置找。</p><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>帮助子类做初始化工作。</p><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><p>名字与类名相同；</p><p>没有返回值，但不能用void声明构造函数；</p><p>生成类的对象时自动执行，无需调用。</p><h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p><h4 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p>静态方法和实例方法的区别主要体现在两个方面：</p><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h4 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是 <strong>内部类</strong> 。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><h4 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h4><p>内部类可以分为四种： <strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong> 。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义在类内部的静态类，就是静态内部类。</p><p>public class Outer { <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> radius = <span class="hljs-number">1</span>;  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInner</span> </span>{     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>{         System.out.println(<span class="hljs-string">“visit outer static  variable:”</span> + radius);     } }</p><p><code>&#125;</code></p><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式， <code>new 外部类.静态内部类()</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner &#x3D; new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><p>public class Outer { <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span> radius = <span class="hljs-number">1</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> =<span class="hljs-number">2</span>;   <span class="hljs-keyword">class</span> Inner {     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> visit() {         System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">“visit outer static  variable:”</span> + radius);         System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">“visit outer   variable:”</span> + <span class="hljs-keyword">count</span>);     } }</p><p><code>&#125;</code></p><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式 <code>外部类实例.new 内部类()</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner inner &#x3D; outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的内部类，就是局部内部类。</p><p>public class Outer { private  <span class="hljs-type">int</span> out_a = <span class="hljs-number">1</span>; private static <span class="hljs-type">int</span> STATIC_b = <span class="hljs-number">2</span>;  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testFunctionClass(){     <span class="hljs-type">int</span> inner_c =<span class="hljs-number">3</span>;     <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> {         private <span class="hljs-type">void</span> fun(){             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(out_a);             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(STATIC_b);             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(inner_c);         }     }     <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();     <span class="hljs-keyword">inner</span>.fun(); } <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> testStaticFunctionClass(){     <span class="hljs-type">int</span> d =<span class="hljs-number">3</span>;     <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> {         private <span class="hljs-type">void</span> fun(){             // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(STATIC_b);             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(d);         }     }     <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();     <span class="hljs-keyword">inner</span>.fun(); }</p><p><code>&#125;</code></p><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内， <code>new 内部类()</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void testStaticFunctionClass()&#123;</span><br><span class="line">class Inner &#123;</span><br><span class="line">&#125;</span><br><span class="line">Inner  inner &#x3D; new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><p>public class Outer { <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>{     <span class="hljs-keyword">new</span> Service() {         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>{             <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {                 System.out.println(<span class="hljs-string">“匿名内部类”</span> );             }         }     }.method(); }</p><p><code>&#125; //匿名内部类必须继承或实现一个已有的接口  interface Service&#123; void method(); &#125;</code></p><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><p>匿名内部类创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类&#x2F;接口&#123;</span><br><span class="line">&#x2F;&#x2F;匿名内部类实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h4><p>我们为什么要使用内部类呢？因为它有以下优点：</p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h4 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h4><ol><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ol><h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</p><p>先看这段代码：</p><p>public class Outer { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outMethod</span><span class="hljs-params">()</span></span>{     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a =<span class="hljs-number">10</span>;     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerMethod</span><span class="hljs-params">()</span></span>{             System.out.println(a);         }      } }</p><p><code>&#125;</code></p><p>以上例子，为什么要加final呢？是因为 <strong>生命周期不一致</strong> ， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><h4 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h4><p>public class Outer { private int age = 12; <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> {     private <span class="hljs-type">int</span> age = <span class="hljs-number">13</span>;     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> print() {         <span class="hljs-type">int</span> age = <span class="hljs-number">14</span>;         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“局部变量：” + age);         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“内部类变量：” + this.age);         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“外部类变量：” + <span class="hljs-keyword">Outer</span>.this.age);     } }  <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) {     <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">in</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();     <span class="hljs-keyword">in</span>.print(); }</p><p><code>&#125;</code></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：14</span><br><span class="line">内部类变量：13</span><br><span class="line">外部类变量：12</span><br></pre></td></tr></table></figure><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p><h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="== 和 equals 的区别是什么"></a>== 和 equals 的区别是什么</h4><p>: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p><p>equals(): 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“”比较这两个对象。</p><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; a 为一个引用</span><br><span class="line">String b &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; b为另一个引用,对象的内容一样</span><br><span class="line">String aa &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 放在常量池中</span><br><span class="line">String bb &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 从常量池中查找</span><br><span class="line">if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true</span><br><span class="line">System.out.println(&quot;aabb&quot;);</span><br><span class="line">if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象</span><br><span class="line">System.out.println(&quot;ab&quot;);</span><br><span class="line">if (a.equals(b)) &#x2F;&#x2F; true</span><br><span class="line">System.out.println(&quot;aEQb&quot;);</span><br><span class="line">if (42 &#x3D;&#x3D; 42.0) &#123; &#x2F;&#x2F; true</span><br><span class="line">System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h4><p>HashSet如何检查重复</p><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p><p>hashCode和equals方法的关系</p><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><h4 id="我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode："><a href="#我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode：" class="headerlink" title="我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode："></a>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</h4><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h4 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h4><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><h4 id="因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖"><a href="#因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖" class="headerlink" title="因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖"></a>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</h4><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。 按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><h4 id="Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。"><a href="#Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。" class="headerlink" title="Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。"></a>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</h4><h4 id="下面通过-3-个例子来给大家说明"><a href="#下面通过-3-个例子来给大家说明" class="headerlink" title="下面通过 3 个例子来给大家说明"></a>下面通过 3 个例子来给大家说明</h4><p>example 1</p><p>public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2);  <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“num1 = “ + num1); <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“num2 = “ + num2);  } public static void swap(int a, int b) { int temp = a; a = b; b = temp; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“a = “ + a); <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“b = “ + b);</p><p><code>&#125;</code></p><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><h4 id="通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看-example2"><a href="#通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看-example2" class="headerlink" title="通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2."></a>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</h4><p>example 2</p><p>public class Test { <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) {     // TODO Auto-<span class="hljs-keyword">generated</span> <span class="hljs-keyword">method</span> stub     Student s1 = <span class="hljs-built_in">new</span> Student(“小张”);     Student s2 = <span class="hljs-built_in">new</span> Student(“小李”);     Test.swap(s1, s2);     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“s1:” + s1.getName());     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“s2:” + s2.getName()); }  <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(Student x, Student y) {     Student <span class="hljs-keyword">temp</span> = x;     x = y;     y = <span class="hljs-keyword">temp</span>;     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“x:” + x.getName());     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“y:” + y.getName()); }</p><p><code>&#125;</code></p><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><p>交换之前：</p><p>交换之后：</p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p><p>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h4 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h4><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p>按操作对象分类结构图：</p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><p>简答</p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><p>详细回答</p><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>静态编译和动态编译</p><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul><h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p><h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private int id;</span><br><span class="line">String name;</span><br><span class="line">protected boolean sex;</span><br><span class="line">public float score;</span><br><span class="line">&#125;</span><br><span class="line">public class Get &#123;</span><br><span class="line">&#x2F;&#x2F;获取反射机制三种方式</span><br><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">&#x2F;&#x2F;方式一(通过建立对象)</span><br><span class="line">Student stu &#x3D; new Student();</span><br><span class="line">Class classobj1 &#x3D; stu.getClass();</span><br><span class="line">System.out.println(classobj1.getName());</span><br><span class="line">&#x2F;&#x2F;方式二（所在通过路径-相对路径）</span><br><span class="line">Class classobj2 &#x3D; Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">System.out.println(classobj2.getName());</span><br><span class="line">&#x2F;&#x2F;方式三（通过类名）</span><br><span class="line">Class classobj3 &#x3D; Student.class;</span><br><span class="line">System.out.println(classobj3.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ol><h4 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><h4 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h4><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><h4 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h4><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h4 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final char value[];</span><br></pre></td></tr></table></figure><h4 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p><h4 id="1-String不可变但不代表引用不可以变"><a href="#1-String不可变但不代表引用不可以变" class="headerlink" title="1) String不可变但不代表引用不可以变"></a>1) String不可变但不代表引用不可以变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;Hello&quot;;</span><br><span class="line">str &#x3D; str + &quot; World&quot;;</span><br><span class="line">System.out.println(&quot;str&#x3D;&quot; + str);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str&#x3D;Hello World</span><br></pre></td></tr></table></figure><p>解析：</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><h4 id="2-通过反射是可以修改所谓的“不可变”对象"><a href="#2-通过反射是可以修改所谓的“不可变”对象" class="headerlink" title="2) 通过反射是可以修改所谓的“不可变”对象"></a>2) 通过反射是可以修改所谓的“不可变”对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建字符串&quot;Hello World&quot;， 并赋给引用s</span><br><span class="line">String s &#x3D; &quot;Hello World&quot;;</span><br><span class="line">System.out.println(&quot;s &#x3D; &quot; + s); &#x2F;&#x2F; Hello World</span><br><span class="line">&#x2F;&#x2F; 获取String类中的value字段</span><br><span class="line">Field valueFieldOfString &#x3D; String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line">&#x2F;&#x2F; 改变value属性的访问权限</span><br><span class="line">valueFieldOfString.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F; 获取s对象上的value属性的值</span><br><span class="line">char[] value &#x3D; (char[]) valueFieldOfString.get(s);</span><br><span class="line">&#x2F;&#x2F; 改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] &#x3D; &#39;_&#39;;</span><br><span class="line">System.out.println(&quot;s &#x3D; &quot; + s); &#x2F;&#x2F; Hello_World</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; Hello World</span><br><span class="line">s &#x3D; Hello_World</span><br></pre></td></tr></table></figure><p>解析：</p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><h4 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h4><p>String 类是 final 类，不可以被继承。</p><h4 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;hello&quot;; &#x2F;&#x2F;str1指向静态区</span><br><span class="line">String str2 &#x3D; new String(&quot;hello&quot;);  &#x2F;&#x2F;str2指向堆上的对象</span><br><span class="line">String str3 &#x3D; &quot;hello&quot;;</span><br><span class="line">String str4 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">System.out.println(str1.equals(str2)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str2.equals(str4)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; str4); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;false</span><br><span class="line">str2 &#x3D; str1;</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba</span><br><span class="line">&#x2F;&#x2F; StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba</span><br></pre></td></tr></table></figure><h4 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h4><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p><h4 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><h4 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>String类中使用字符数组保存字符串，privatefinalcharvalue[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h4 id="对于三者使用的总结"><a href="#对于三者使用的总结" class="headerlink" title="对于三者使用的总结"></a>对于三者使用的总结</h4><p>如果要操作少量的数据用 = String</p><p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p><p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p><h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="Integer a= 127 与 Integer b = 127相等吗"></a>Integer a= 127 与 Integer b = 127相等吗</h4><p>对于对象引用类型：比较的是对象的内存地址。</p><p>对于基本数据类型：比较的是值。</p><p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p><p>public static void main(String[] args) { Integer a = new Integer(3); Integer b = 3;  // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true <span class="hljs-type">Integer</span> a1 = <span class="hljs-number">128</span>; <span class="hljs-type">Integer</span> b1 = <span class="hljs-number">128</span>; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a1 == b1); // <span class="hljs-keyword">false</span>  <span class="hljs-type">Integer</span> a2 = <span class="hljs-number">127</span>; <span class="hljs-type">Integer</span> b2 = <span class="hljs-number">127</span>; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a2 == b2);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Wireshark 学习心得</title>
    <link href="http://example.com/2021/07/11/Wireshark-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>http://example.com/2021/07/11/Wireshark-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</id>
    <published>2021-07-11T04:50:01.000Z</published>
    <updated>2021-07-11T06:17:38.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>首先介绍软件基本页面布局和功能</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711135223797.png" alt="image-20210711135223797"></p><p>如图：</p><p>包括最上方的选向窗口和下面的工具栏</p><table><thead><tr><th>名称</th><th>功能</th><th>补充</th></tr></thead><tbody><tr><td>文件</td><td>包括文件存储</td><td></td></tr><tr><td>编辑</td><td></td><td></td></tr><tr><td>视图</td><td></td><td></td></tr><tr><td>跳转</td><td></td><td></td></tr><tr><td>捕获</td><td></td><td></td></tr><tr><td>分析</td><td>捕获信息的分析</td><td></td></tr><tr><td>统计</td><td>对于所捕获信息的统计</td><td></td></tr><tr><td>电话</td><td></td><td></td></tr><tr><td>无线</td><td></td><td></td></tr></tbody></table><h1 id="2-过滤"><a href="#2-过滤" class="headerlink" title="2.过滤"></a>2.过滤</h1><p>接着重点是Wirshark的过滤功能，通过过滤器可以筛选许多不必要的信息，（设置 Caputure Filter 之前一定要三思而后行，避免筛除有用的包）</p><p>过滤是wireshark最难，最有趣的地方，值得深入学习。</p><p>wireshark还设置了查找功能，如果对于过滤命令不够熟悉，可是使用查找功能进行筛选，效果是一样的。具体操作：</p><ul><li>点击感兴趣的一条内容–&gt;右键 Prepare a filter–&gt;select–》自动生成过滤表达式</li></ul><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711135015254.png" alt="image-20210711135015254" style="zoom:80%;" /><p>以下是常用的筛选命令：来自 <a href="https://www.wireshark.org/">Wireshark官网</a> ,过多信息在此不做赘述，具体参见    Wireshark User’s Guide&amp;&amp;<a href="https://www.wireshark.org/docs/dfref/">参考标准</a></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>在过滤器中输入IP.之后会有相应的显示，和java的方法类似</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711130532533.png" alt="image-20210711130532533"></p><p>常见的IP筛选如下:</p><table><thead><tr><th>FIELD NAME</th><th>DESCRIPTION</th><th>TYPE</th></tr></thead><tbody><tr><td>ip.addr</td><td>Source or Destination Address</td><td>IPv4 address</td></tr><tr><td>ip.dst</td><td>Destination Address</td><td>IPv4 address</td></tr><tr><td>ip.id</td><td>Identification</td><td>Unsigned integer, 2 bytes</td></tr><tr><td>ip.len</td><td>Total Length</td><td>Unsigned integer, 2 bytes</td></tr><tr><td>ip.flags</td><td>Flags</td><td>Unsigned integer, 1 byte</td></tr><tr><td>ip.opt.mtu</td><td>MTU</td><td>Unsigned integer, 2 bytes</td></tr><tr><td>ip.src</td><td>Source Address</td><td>IPv4 address</td></tr><tr><td>ip.src_host</td><td>Source Host</td><td>Character string</td></tr><tr><td>ip.ttl</td><td>Time to Live</td><td>Unsigned integer, 1 byte</td></tr><tr><td>ip.version</td><td>Version</td><td>Unsigned integer, 1 byte</td></tr></tbody></table><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Capture only traffic to or from IP address 172.18.5.4:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host 172.18.5.4</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic to or from a range of IP addresses:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure></li></ul><p>or</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net 192.168.0.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic from a range of IP addresses:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure></li></ul><p>or</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src net 192.168.0.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic to a range of IP addresses:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure></li></ul><p>or</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst net 192.168.0.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><p>Capture only DNS (port 53) traffic:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 53</span><br></pre></td></tr></table></figure></li></ul><p>Capture non-HTTP and non-SMTP traffic on your server (both are equivalent):</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host www.example.com and not (port 80 or port 25)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host www.example.com and not port 80 and not port 25</span><br></pre></td></tr></table></figure></li></ul><p>Capture except all ARP and DNS traffic:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port not 53 and not arp</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic within a range of ports</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tcp[0:2] &gt; 1500 and tcp[0:2] &lt; 1550) or (tcp[2:2] &gt; 1500 and tcp[2:2] &lt; 1550)</span><br></pre></td></tr></table></figure></li></ul><p>or, with newer versions of libpcap (0.9.1 and later):</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp portrange 1501-1549</span><br></pre></td></tr></table></figure></li></ul><p>Capture only Ethernet type EAPOL:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ether proto 0x888e</span><br></pre></td></tr></table></figure></li></ul><p>Reject ethernet frames towards the Link Layer Discovery Protocol Multicast group:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not ether dst 01:80:c2:00:00:0e</span><br></pre></td></tr></table></figure></li></ul><p>Capture only IPv4 traffic - the shortest filter, but sometimes very useful to get rid of lower layer protocols like ARP and STP:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip</span><br></pre></td></tr></table></figure></li></ul><p>Capture only unicast traffic - useful to get rid of noise on the network if you only want to see traffic to and from your machine, not, for example, broadcast and multicast announcements:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not broadcast and not multicast</span><br></pre></td></tr></table></figure></li></ul><p>Capture IPv6 “all nodes” (router and neighbor advertisement) traffic. Can be used to find rogue RAs:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst host ff02::1</span><br></pre></td></tr></table></figure></li></ul><p>Capture HTTP GET requests. This looks for the bytes ‘G’, ‘E’, ‘T’, and ‘ ‘ (hex values 47, 45, 54, and 20) just after the TCP header. “tcp[12:1] &amp; 0xf0) &gt;&gt; 2” figures out the TCP header length. From Jefferson Ogata via the <a href="http://seclists.org/tcpdump/2004/q4/95">tcpdump-workers mailing list</a>.</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 80 and tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] &#x3D; 0x47455420</span><br></pre></td></tr></table></figure></li></ul><h2 id="Useful-Filters"><a href="#Useful-Filters" class="headerlink" title="Useful Filters"></a>Useful Filters</h2><p>Blaster and Welchia are RPC worms. (Does anyone have better links, i.e. ones that describe or show the actual payload?)</p><p><a href="http://www.sans.org/security-resources/malwarefaq/w32_blasterworm.php">Blaster worm</a>:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst port 135 and tcp port 135 and ip[2:2]&#x3D;&#x3D;48</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://securityresponse.symantec.com/avcenter/venc/data/detecting.traffic.due.to.rpc.worms.html">Welchia worm</a>:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icmp[icmptype]&#x3D;&#x3D;icmp-echo and ip[2:2]&#x3D;&#x3D;92 and icmp[8:4]&#x3D;&#x3D;0xAAAAAAAA</span><br></pre></td></tr></table></figure><p>The filter looks for an icmp echo request that is 92 bytes long and has an icmp payload that begins with 4 bytes of A’s (hex). It is the signature of the welchia worm just before it tries to compromise a system.</p></li></ul><p>Many worms try to spread by contacting other hosts on ports 135, 445, or 1433. This filter is independent of the specific worm instead it looks for SYN packets originating from a local network on those specific ports. Please change the network filter to reflect your own network.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst port 135 or dst port 445 or dst port 1433  and tcp[tcpflags] &amp; (tcp-syn) !&#x3D; 0 and tcp[tcpflags] &amp; (tcp-ack) &#x3D; 0 and src net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure><p><a href="https://web.archive.org/web/20140419183909/http://www.riverbed.com/blogs/Retroactively-detecting-a-prior-Heartbleed-exploitation-from-stored-packets-using-a-BPF-expression.html">Heartbleed Exploit</a>:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp src port 443 and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) * 4] &#x3D; 0x18) and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) * 4 + 1] &#x3D; 0x03) and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) * 4 + 2] &lt; 0x04) and ((ip[2:2] - 4 * (ip[0] &amp; 0x0F)  - 4 * ((tcp[12] &amp; 0xF0) &gt;&gt; 4) &gt; 69))</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-常见功能"><a href="#3-常见功能" class="headerlink" title="3.常见功能"></a>3.常见功能</h1><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h3><p>在wireshark中的分析选项中</p><ul><li><p>Analyze–&gt;Export info Composite</p></li><li><p>statistics–&gt;service response time–&gt;选定相关协议响应（<strong>时间统计表</strong>）———-衡量服务器性能</p></li><li><p>statistic–&gt;TCP Stream Graph   (<strong>信息统计图</strong>)</p></li></ul><h3 id="2-搜索功能"><a href="#2-搜索功能" class="headerlink" title="2.搜索功能"></a>2.搜索功能</h3><ul><li><p>快捷键：ctrl+f</p></li><li><p>效果图：</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711140444529.png" alt="image-20210711140444529" style="zoom:200%;" /></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.基本介绍&quot;&gt;&lt;/a&gt;1.基本介绍&lt;/h1&gt;&lt;p&gt;首先介绍软件基本页面布局和功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\ASUS\AppData</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初步理解JAVA 虚拟机（黑马）</title>
    <link href="http://example.com/2021/06/20/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E9%BB%91%E9%A9%AC%EF%BC%89/"/>
    <id>http://example.com/2021/06/20/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E9%BB%91%E9%A9%AC%EF%BC%89/</id>
    <published>2021-06-20T12:12:56.000Z</published>
    <updated>2021-06-20T12:36:49.468Z</updated>
    
    <content type="html"><![CDATA[<p> 定义：java Virtural Machine  （java二进制代码<strong>运行环境</strong>）</p><p>优点：</p><ul><li><p>一次编写，到处运行</p></li><li><p>自动内存管理，垃圾回收机制</p></li><li><p>数组下标越界检查</p></li><li><p>多态机制</p></li></ul><p>JVM屏蔽java和底层操作系统的差异：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618122158873.png" alt="image-20210618122158873"></p><p>常见JVM：</p><p>学习路线：<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618122633191.png" alt="image-20210618122633191"></p><h1 id="一-内存结构"><a href="#一-内存结构" class="headerlink" title="一.内存结构"></a>一.内存结构</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps1.png" alt="img"></p><p>\1. 程序计数器</p><p>\2. 虚拟机栈</p><p>\3. 本地方法栈</p><p>\4. 堆</p><p>\5. 方法区</p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器     "></a>1. 程序计数器    <a href="af://n31/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps2.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps3.png" alt="img"> </p><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><ul><li><p>特点：</p><p>Program Counter Register 程序计数器（寄存器</p><ul><li><p>作用：记住下一条jvm指令的执行地址</p></li><li><p>是线程私有的</p></li><li><p><strong>不会存在内存溢出</strong> </p></li></ul></li></ul><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><p> 线程私有的，每个线程都有自身计数器</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618131139123.png" alt="image-20210618131139123">  </p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li><p>（虚拟机）栈：每个线程运行时所需要的内存   </p></li><li><p>每个栈由多个栈帧（Frame）组成</p></li><li><p>栈帧（Frame）：一个方法运行时需要的内存</p></li><li><p>每个线程只能有一个活动栈帧（正在执行的方法）</p></li></ul><p><strong>问题辨析</strong></p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>-栈内存自动清除，垃圾是对堆得数据进行回收 </p></li><li><p>栈内存分配越大越好吗？</p><p>栈内存越大，可同时运行的线程会减少，一般不建议增大内存</p></li><li><p>方法内的局部变量是否线程安全？</p><p>取决于使用的局部变量是否共享</p></li></ol><ul><li><p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围（return 返回），需要考虑线程安全 </p></li></ul><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p>报错显示 <strong>java.lang.StackOverflowError</strong></p><ul><li><p>栈帧过多导致栈内存溢出</p><p>例：方法递归调用</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618133324333.png" alt="image-20210618133324333" style="zoom:25%;" /></li><li><p>栈帧过大导致栈内存溢出</p> <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618133359416.png" alt="image-20210618133359416" style="zoom:25%;" /></li></ul><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><p>案例1： cpu 占用过多定位</p><p>用top定位哪个进程对cpu的占用过高</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps10.png" alt="img">ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） jstack 进程id</p><p>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>案例2：程序运行很长时间没有结果</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps11.png" alt="img"></p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps12.png" alt="img"></p><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存特点</li></ul><p>它是线程共享的，堆中对象都需要考虑线程安全的问题  </p><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><ol><li>jps 工具</li></ol><ul><li> 查看当前系统中有哪些 java 进程</li></ul><ol start="2"><li><p>jmap 工具 <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps16.png" alt="img"> 查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具</p><p>图形界面的，多功能的监测工具，可以连续监测</p></li></ol><p>案例 ： 垃圾回收后，内存占用仍然很高</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps19.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps20.png" alt="img"> </p><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">J</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">VM</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">规范</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">-</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">方法区定义</a></p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成     "></a>5.2 组成    <a href="af://n248/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps21.png" alt="img"></p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出     "></a>5.3 方法区内存溢出    <a href="af://n265/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps22.png" alt="img">    1.8 以前会导致永久代内存溢出</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps23.png" alt="img"></p><p> 场景</p><p>​    mybatis</p><p>​    spring </p><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池     "></a>5.4 运行时常量池    <a href="af://n325/"> </a></h3><ul><li><p>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p></li><li><p>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p></li></ul><h3 id="5-5-StringTable-先看几道面试题："><a href="#5-5-StringTable-先看几道面试题：" class="headerlink" title="5.5 StringTable     先看几道面试题："></a>5.5 StringTable    <a href="af://n350/"> </a>先看几道面试题：</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps26.png" alt="img"></p><h3 id="5-5-StringTable-特性"><a href="#5-5-StringTable-特性" class="headerlink" title="5.5 StringTable 特性     "></a>5.5 StringTable 特性    <a href="af://n353/"> </a></h3><p>常量池中的字符串仅是符号，第一次用到时才变为对象利用串池的机制，来避免重复创建字符串对象</p><ul><li><p>字符串变量拼接的原理是 StringBuilder （1.8)字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用 <strong>intern</strong> 方法，主动将串池中还没有的字符串对象放入串池</p></li></ul><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</p><p>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回</p><h3 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置     "></a>5.6 StringTable 位置    <a href="af://n375/"> </a></h3><h3 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收     "></a>5.7 StringTable 垃圾回收    <a href="af://n388/"> </a></h3><h3 id="5-8-StringTable-性能调优"><a href="#5-8-StringTable-性能调优" class="headerlink" title="5.8 StringTable 性能调优     "></a>5.8 StringTable 性能调优    <a href="af://n401/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps28.png" alt="img"> 调整 -XX:StringTableSize=桶个数</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps29.png" alt="img"> 考虑将字符串对象是否入池</p><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h2 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义     "></a>6.1 定义    <a href="af://n432/"> </a></h2><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区分配回收成本较高，但读写性能高不受 JVM 内存回收管理</li></ul><h3 id="6-2-分配和回收原理"><a href="#6-2-分配和回收原理" class="headerlink" title="6.2 分配和回收原理     "></a>6.2 分配和回收原理    <a href="af://n452/"> </a></h3><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，</li><li>使用了 Cleaner （虚引用)来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><h1 id="二-垃圾回收"><a href="#二-垃圾回收" class="headerlink" title="二.垃圾回收"></a>二.垃圾回收</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps33.png" alt="img"></p><ol><li><p> 如何判断对象可以回收</p></li><li><p> 垃圾回收算法</p></li><li><p> 分代垃圾回收</p></li><li><p> 垃圾回收器</p></li><li><p> 垃圾回收调优</p></li></ol><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps34.png" alt="img"> </p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><ol><li><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收</p></li><li><p>哪些对象可以作为 GC Root ?</p></li></ol><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><ol><li> 强引用</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps38.png" alt="img"> 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><ol start="2"><li><p>软引用（SoftReference）</p><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</p></li></ol><p>可以配合引用队列来释放软引用自身</p><ol start="3"><li><p>弱引用（WeakReference）</p><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象可以配合引用队列来释放弱引用自身</p></li><li><p>虚引用（PhantomReference）</p><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li><li><p>终结器引用（FinalReference）</p><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p></li></ol><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1标记回收"><a href="#2-1标记回收" class="headerlink" title="2.1标记回收"></a>2.1标记回收</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps43.png" alt="img"></p><ol><li>标记可回收垃圾</li><li>回收垃圾</li></ol><ul><li>优点：速度快效率高</li><li>缺点：造成内存碎片（内存空间不连续）</li></ul><h2 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理     "></a>2.2 标记整理    <a href="af://n170/"> </a></h2><p>定义：Mark Compact <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps44.png" alt="img"> 速度慢</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps45.png" alt="img"></p><ol><li>标记可回收垃圾（存活多）</li><li>回收垃圾（内存空间向前移动）</li></ol><ul><li>优点：速度较慢（设计地址的变化等操作）</li><li>缺点：不会造成内存碎片 </li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制     "></a>2.3 复制    <a href="af://n188/"> </a></h3><p>定义：Copy</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps46.png" alt="img"></p><p>把可以保存的对象复制到另一份内存空间，并交换from和to</p><ul><li><p>优点：没有内存碎片</p></li><li><p>占用双倍的内存空间 </p></li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收     "></a>3. 分代垃圾回收    <a href="af://n207/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps47.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps48.png" alt="img"> </p><ol><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中（其他对象空间 被回收），存活的对象年龄加 1并且交换 from to</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215049838.png" alt="image-20210619215049838"></p></li><li><p>minor gc 会引发 stop the world（避免线程混乱，涉及地质改变），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215117828.png" alt="image-20210619215117828"></p></li><li><p>当老年代空间不足，会先尝试触发 minor gc（初级垃圾清除），如果之后空间仍不足，那么触发 full gc，STW的时间更长</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215139218.png" alt="image-20210619215139218"></p></li></ol><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数     "></a>3.1 相关 VM 参数    <a href="af://n224/"> </a></h3><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><p> <strong>大对象直接送到老年代机制</strong></p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器    @@@@@"></a>4. 垃圾回收器    @@@@@</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps50.png" alt="img"></p><ol><li><p>串行</p><ul><li>底层是单线程，- </li><li>适用于堆内存较小，适合个人电脑</li></ul></li><li><p>吞吐量优先</p><ul><li>多线程</li><li>适用于堆内存较大，多核 cpu </li><li>让<strong>单位时间</strong>内，STW 的时间最短 0.2 0.2 = 4，垃圾回收时间占比最低，这样就称吞吐量高</li></ul></li><li><p>响应时间优先</p><ul><li><p>多线程</p></li><li><p>适用于堆内存较大，</p></li><li><p>多核 cpu</p></li><li><p>尽可能让单次 STW 的单次时间最短     0.1 0.1 0.1 0.1 0.1 = 0.5</p></li></ul></li></ol><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行     "></a>4.1 串行    <a href="af://n311/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps54.png" alt="img"></p><ol><li>空间不足</li><li>在安全点暂停（阻塞）——-》开启单个垃圾回收线程</li><li>垃圾回收完成————》线程继续</li></ol><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><p>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps56.png" alt="img"></p><ol><li> 内存空间不足</li><li> 在安全点暂停（阻塞）——-》开启多个垃圾回收线程（）</li><li> 垃圾回收完成————》线程继续</li></ol><h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先     "></a>4.3 响应时间优先    <a href="af://n341/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps57.png" alt="img"></p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1     "></a>4.4 G1    <a href="af://n363/"> </a></h3><p>定义：Garbage First</p><ul><li><p>2004 论文发布</p></li><li><p>2009 JDK 6u14 体验</p></li><li><p>2012 JDK 7u4 官方支持 </p></li><li><p>2017 JDK 9 默认成为垃圾回收器</p></li></ul><p>适用场景</p><ul><li><p>同时注重吞吐量（Throughput）和低延迟（Low latency)，默认的暂停目标是 200 ms</p></li><li><p>超大堆内存，会将堆划分为多个大小相等的 Region </p></li><li><p>整体上是<strong>标记+整理算法</strong>，两个区域之间是<strong>复制算法</strong></p></li><li><p>相关 JVM 参数</p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize=size</p><p>-XX:MaxGCPauseMillis=time</p></li></ul><h4 id="1-G1-垃圾回收阶段"><a href="#1-G1-垃圾回收阶段" class="headerlink" title="1) G1 垃圾回收阶段"></a>1) G1 垃圾回收阶段</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps63.png" alt="img"> </p><h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection     "></a>2) Young Collection    <a href="af://n406/"> </a></h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps64.png" alt="img"> 会 STW</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps65.png" alt="img"> </p><p> S:幸存区</p><p>O:老年代</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps66.png" alt="img"> </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps67.png" alt="img"> </p><h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM     "></a>3) Young Collection + CM    <a href="af://n436/"> </a></h4><ul><li><p>在 Young GC 时会进行 GC Root 的初始标记</p></li><li><p>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定 </p></li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps69.png" alt="img"></p><h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>混合收集阶段</p><ul><li>会对 E、S、O 进行全面垃圾回收最终标记（Remark）会 STW </li><li>拷贝存活（Evacuation）会 STW </li><li>不是所有老年代都被回收，优先回收垃圾最多的标记，</li></ul><p>-XX:MaxGCPauseMillis=ms</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps71.png" alt="img"> </p><h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC     "></a>5) Full GC    <a href="af://n459/"> </a></h4><ul><li><p>SerialGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p></li><li><p>ParallelGC </p><p>新生代内存不足发生的垃圾收集 - minor gc </p><p>老年代内存不足发生的垃圾收集- </p></li><li><p>full gc</p><p>新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足</p><p>新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足</p></li></ul><h4 id="6）Young-Collection跨代引用"><a href="#6）Young-Collection跨代引用" class="headerlink" title="6）Young Collection跨代引用"></a>6）Young Collection跨代引用</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps73.png" alt="img"></p><p> 老年代引用了新生代被标记成脏卡区</p><p> 垃圾回收时，对脏卡去进行查找，加快垃圾回收速度</p><ul><li><p>卡表与 Remembered Set</p></li><li><p>在引用变更时通过 <strong>post-write barrier</strong> （标记脏卡）+ dirty card queue </p></li><li><p>concurrent refinement threads 更新 Remembered Set</p></li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps75.png" alt="img"> </p><h4 id="7-Remark"><a href="#7-Remark" class="headerlink" title="7) Remark     "></a>7) Remark    <a href="af://n530/"> </a></h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps76.png" alt="img"></p><p> 注：黑色处理完；    灰色正在处理；    白色尚未处理</p><p>并发标记阶段，如果回收期间引用关系发生了改变：</p><ol><li><p>C被A 引用（A是根引用）</p></li><li><p>C就会被添加<strong>写屏障</strong>，进入队列中，被<strong>重新标记</strong>成灰色</p></li><li><p>并发标记结束，进入重新标记阶段（remark），其他线程结束</p></li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620100531126.png" alt="image-20210620100531126"></p><h4 id="8-JDK-8u20-字符串去重"><a href="#8-JDK-8u20-字符串去重" class="headerlink" title="8) JDK 8u20 字符串去重"></a>8) JDK 8u20 字符串去重</h4><p>优点：节省大量内存</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps77.png" alt="img">优点：节省大量内存</p><h4 id="9-JDK-8u40-并发标记类卸载"><a href="#9-JDK-8u40-并发标记类卸载" class="headerlink" title="9) JDK 8u40 并发标记类卸载"></a>9) JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4 id="10-JDK-8u60-回收巨型对象"><a href="#10-JDK-8u60-回收巨型对象" class="headerlink" title="10) JDK 8u60 回收巨型对象     "></a>10) JDK 8u60 回收巨型对象    <a href="af://n587/"> </a></h4><ul><li><p>一个对象大于 region 的一半时，称之为巨型对象 </p></li><li><p>G1 不会对巨型对象进行拷贝</p></li><li><p>回收时被优先考虑</p></li><li><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉(回收得越早越好)</p></li></ul><h4 id="11-JDK-9-并发标记起始时间的调整"><a href="#11-JDK-9-并发标记起始时间的调整" class="headerlink" title="11) JDK 9 并发标记起始时间的调整     "></a>11) JDK 9 并发标记起始时间的调整    <a href="af://n614/"> </a></h4><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p><ul><li><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent（默认45%)</p></li><li><p>JDK 9 可以动态调整</p></li><li><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p></li><li><p>进行数据采样并动态调整</p></li><li><p>总会添加一个安全的空档空间</p></li><li></li></ul><h4 id="12-JDK-9-更高效的回收"><a href="#12-JDK-9-更高效的回收" class="headerlink" title="12) JDK 9 更高效的回收     "></a>12) JDK 9 更高效的回收    <a href="af://n645/"> </a></h4><p>250+增强</p><p>180+bug修复</p><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">j</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">ava/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">j</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">avase/12/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">g</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">ctunin</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">g</a></p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优     "></a>5. 垃圾回收调优    <a href="af://n670/"> </a></h2><p>预备知识</p><ul><li><p>掌握 GC 相关的 VM 参数，会基本的空间调整掌握相关工具</p></li><li><p>知识点：调优跟应用、环境有关，没有放之四海而皆准的法则</p></li></ul><h3 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps85.png" alt="img">内存锁竞争</p><p>cpu 占用 io</p><h3 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h3><p>【低延迟】还是【高吞吐量】，选择合适的回收器</p><p>CMS，G1，ZGC</p><p>ParallelGC</p><h3 id="5-3-最快的-GC"><a href="#5-3-最快的-GC" class="headerlink" title="5.3 最快的 GC     "></a>5.3 最快的 GC    <a href="af://n742/"> </a></h3><p>答案是不发生 GC 查看 FullGC 前后的内存占用，考虑下面几个问题</p><p>数据是不是太多？</p><p>resultSet = statement.executeQuery(“select * from 大表 limit n”) 数据表示是否太臃肿？</p><p>对象图</p><p>对象大小 16 Integer 24 int 4 是否存在内存泄漏？</p><p>static Map map =</p><p>软弱第三方缓存实现</p><h3 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优     "></a>5.4 新生代调优    <a href="af://n798/"> </a></h3><p>新生代的特点所有的 new 操作的内存分配非常廉价</p><p>TLAB thread-local allocation buffer 死亡对象的回收代价是零大部分对象用过即死</p><p>Minor GC 的时间远远低于 Full GC</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps89.png" alt="img"> 越大越好吗？</p><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps90.png" alt="img">新生代能容纳所有【并发量 * (请求-响应)】的数据幸存区大到能保留【当前活跃对象+需要晋升对象】</p><h3 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优     "></a>5.5 老年代调优    <a href="af://n860/"> </a></h3><p>以 CMS 为例</p><p>CMS 的老年代内存越大越好</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps91.png" alt="img">先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</p><p>-XX:CMSInitiatingOccupancyFraction=percent</p><h3 id="5-6-案例"><a href="#5-6-案例" class="headerlink" title="5.6 案例     "></a>5.6 案例    <a href="af://n882/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps92.png" alt="img">案例1 Full GC 和 Minor GC频繁</p><p>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</p><h1 id="三-类加载与字节码技术"><a href="#三-类加载与字节码技术" class="headerlink" title="三. 类加载与字节码技术"></a>三. 类加载与字节码技术</h1><p> 类加载与字节码技术     </p><ol><li>类文件结构 </li><li>字节码指令 </li><li>编译期处理</li><li>类加载阶</li><li>类加载器</li><li>运行期优化</li></ol><h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h2><p>一个简单的 HelloWorld.java</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620123640244.png" alt="image-20210620123640244"></p><p>编译为 HelloWorld.class 后是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# od -t xC HelloWorld.class </span><br><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00</span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00</span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><p>根据 JVM 规范，类文件结构如下：<br> <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620123750334.png" alt="image-20210620123750334"></p><p>下面分别进行解释：</p><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><p>表示文件类型</p><p>0~3 字节，表示它是否是【class】类型的文件<br>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h3 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h3><p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8<br>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池     @@@@"></a>1.3 常量池     @@@@</h3><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td>CONSTANT_Class</td><td>7</td></tr><tr><td>CONSTANT_Fieldref</td><td>9</td></tr><tr><td>CONSTANT_Methodref</td><td>10</td></tr><tr><td>CONSTANT_InterfaceMethodref</td><td>11</td></tr><tr><td>CONSTANT_String</td><td>8</td></tr><tr><td>CONSTANT_Integer</td><td>3</td></tr><tr><td>CONSTANT_Float</td><td>4</td></tr><tr><td>CONSTANT_Long</td><td>5</td></tr><tr><td>CONSTANT_Double</td><td>6</td></tr><tr><td>CONSTANT_NameAndType</td><td>12</td></tr><tr><td>CONSTANT_Utf8</td><td>1</td></tr><tr><td>CONSTANT_MethodHandle</td><td>15</td></tr><tr><td>CONSTANT_MethodType</td><td>16</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>8<del>9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1</del>#34项，注意 #0 项不计入，也没有值<br>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09##</li></ul><p>第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p><p>第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26 项来获得这个方法的【所属类】和【方法名】<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07<br>第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【<init>】<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e<br>0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</p><p>第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】<br>0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63<br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</p><p>第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】<br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01<br>0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</p><p>第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】<br>0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63<br>0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p><p>第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p><p>第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16<br>0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p><p>第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p><p>第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e<br>67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</p><p>第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】<br>0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61<br>0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</p><p>第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】<br>0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46<br>0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</p><p>第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】<br>0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e<br>第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e<br>0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】<br>0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74<br>0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c<br>0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</p><p>第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】<br>0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61<br>0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</p><p>第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】<br>0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</p><p>第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f<br>0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p><p>第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】<br>0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72<br>0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76<br>第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】<br>0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76<br>0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</p><p>第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】<br>0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</p><p>第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】<br>0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a<br>0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h3 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h3><p>21 表示该 class 是一个类，公共的<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>05表示根据常量池中 #5 找到本类全限定名<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>06表示根据常量池中 #6 找到父类全限定名<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>表示接口的数量，本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>Flag Name    Value    Interpretation<br>ACC_PUBLIC    0x0001    Declared public ; may be accessed from outside its package.<br>ACC_FINAL    0x0010    Declared final ; no subclasses allowed.<br>ACC_SUPER    0x0020    Treat superclass methods specially when invoked by the invokespecial instruction.<br>ACC_INTERFACE    0x0200    Is an interface, not a class.<br>ACC_ABSTRACT    0x0400    Declared abstract ; must not be instantiated.<br>ACC_SYNTHETIC    0x1000    Declared synthetic; not present in the source code.<br>ACC_ANNOTATION    0x2000    Declared as an annotation type.<br>ACC_ENUM    0x4000    Declared as an enum type.</p><h3 id="1-5-Field-信息"><a href="#1-5-Field-信息" class="headerlink" title="1.5 Field 信息"></a>1.5 Field 信息</h3><p>表示成员变量数量，本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><table><thead><tr><th>FieldType</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L ClassName</td><td>reference</td><td>an instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><h3 id="1-6-Method-信息"><a href="#1-6-Method-信息" class="headerlink" title="1.6 Method 信息"></a>1.6 Method 信息</h3><p>表示方法数量，本类为 2<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><ul><li><p>一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成<br>红色代表访问修饰符（本类中是 public）<br>蓝色代表引用了常量池 #07 项作为方法名称<br>绿色代表引用了常量池 #08 项作为方法参数描述黄色代表方法属性数量，本方法是 1 红色代表方法属性<br>00 09 表示引用了常量池 #09 项，发现是【Code】属性<br>00 00 00 2f 表示此属性的长度是 47<br>00 01 表示【操作数栈】 大深度<br>00 01 表示【局部变量表】 大槽（slot）数<br>00 00 00 05 表示字节码长度，本例是 5</p></li><li><p>2a b7 00 01 b1 是字节码指令</p></li><li><p>00 00 00 02 表示方法细节属性数量，本例是 2</p></li><li><p>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<br>00 00 00 06 表示此属性的总长度，本例是 6<br>00 01 表示【LineNumberTable】长度<br>00 00 表示【字节码】行号 00 04 表示【java 源码】行号</p></li><li><p>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<br>00 00 00 0c 表示此属性的总长度，本例是 12<br>00 01 表示【LocalVariableTable】长度<br>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<br>00 05 表示局部变量覆盖的范围长度<br>00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】<br>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是<br>【Lcn/itcast/jvm/t5/HelloWorld;】<br>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</p></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line"></span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br></pre></td></tr></table></figure><p>红色代表访问修饰符（本类中是 public static）蓝色代表引用了常量池 #14 项作为方法名称绿色代表引用了常量池 #15 项作为方法参数描述黄色代表方法属性数量，本方法是 2 红色代表方法属性（属性1）<br>00 09 表示引用了常量池 #09 项，发现是【Code】属性<br>00 00 00 37 表示此属性的长度是 55<br>00 02 表示【操作数栈】 大深度<br>00 01 表示【局部变量表】 大槽（slot）数 00 00 00 05 表示字节码长度，本例是 9<br>b2 00 02 12 03 b6 00 04 b1 是字节码指令<br>00 00 00 02 表示方法细节属性数量，本例是 2<br>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<br>00 00 00 0a 表示此属性的总长度，本例是 10<br>00 02 表示【LineNumberTable】长度<br>00 00 表示【字节码】行号 00 06 表示【java 源码】行号<br>00 08 表示【字节码】行号 00 07 表示【java 源码】行号<br>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<br>00 00 00 0c 表示此属性的总长度，本例是 12<br>00 01 表示【LocalVariableTable】长度<br>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<br>00 09 表示局部变量覆盖的范围长度<br>00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】<br>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】<br>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</p><p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00<br>0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00<br>0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a<br>0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b<br>0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</p><p>红色代表方法属性（属性2）<br>00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性<br>0000 00 05 表示此属性的总长度，本例是 5<br>01参数数量<br>00 10 表示引用了常量池 #16 项，是【args】<br>00 00 访问修饰符<br>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00<br>0001120 00 00 02 00 14<br>1.7 附加属性<br>00 01 表示附加属性数量<br>00 13 表示引用了常量池 #19 项，即【SourceFile】<br>00 00 00 02 表示此属性的长度<br>00 14 表示引用了常量池 #20 项，即【HelloWorld.java】<br>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00<br>0001120 00 00 02 00 14</p><p>参考文献<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2.字节码指令"></a>2.字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是<br>public cn.itcast.jvm.t5.HelloWorld(); 构造方法的字节码指令</p><p>1.2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数<br>2.b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</p><ol start="3"><li>00 01 引用常量池中 #1 项，即【Method java/lang/Object.”<init>“:()V】</li><li>b1 表示返回</li></ol><p>1.b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？<br>2.00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】<br>3.12 =&gt; ldc 加载参数，哪个参数呢？<br>4.03 引用常量池中 #3 项，即 【String hello world】<br>5.b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？<br>6.00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】<br>7.b1 表示返回</p><p>请参考<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件<br>[root@localhost ~]# javap -v HelloWorld.class<br>Classfile /root/HelloWorld.class<br>  Last modified Jul 7, 2019; size 597 bytes<br>  MD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbc   Compiled from “HelloWorld.java” public class cn.itcast.jvm.t5.HelloWorld   minor version: 0   major version: 52   flags: ACC_PUBLIC, ACC_SUPER Constant pool:<br>   #1 = Methodref          #6.#21         // java/lang/Object.”<init>“:()V<br>   #2 = Fieldref           #22.#23        // java/lang/System.out:Ljava/io/PrintStream;    #3 = String             #24            // hello world    #4 = Methodref          #25.#26        // java/io/PrintStream.println:<br>(Ljava/lang/String;)V<br>   #5 = Class              #27            // cn/itcast/jvm/t5/HelloWorld<br>   #6 = Class              #28            // java/lang/Object<br>   #7 = Utf8               <init><br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               LocalVariableTable<br>  #12 = Utf8               this<br>  #13 = Utf8               Lcn/itcast/jvm/t5/HelloWorld;</p><p>  #14 = Utf8               main   #15 = Utf8               ([Ljava/lang/String;)V<br>  #16 = Utf8               args<br>  #17 = Utf8               [Ljava/lang/String;<br>  #18 = Utf8               MethodParameters<br>  #19 = Utf8               SourceFile<br>  #20 = Utf8               HelloWorld.java<br>  #21 = NameAndType        #7:#8          // “<init>“:()V<br>  #22 = Class              #29            // java/lang/System<br>  #23 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;<br>  #24 = Utf8               hello world<br>  #25 = Class              #32            // java/io/PrintStream<br>  #26 = NameAndType        #33:#34        // println:(Ljava/lang/String;)V<br>  #27 = Utf8               cn/itcast/jvm/t5/HelloWorld<br>  #28 = Utf8               java/lang/Object<br>  #29 = Utf8               java/lang/System<br>  #30 = Utf8               out<br>  #31 = Utf8               Ljava/io/PrintStream;<br>  #32 = Utf8               java/io/PrintStream<br>  #33 = Utf8               println   #34 = Utf8               (Ljava/lang/String;)V<br>{   public cn.itcast.jvm.t5.HelloWorld();     descriptor: ()V<br>    flags: ACC_PUBLIC     Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0          1: invokespecial #1                  // Method java/lang/Object.”<br><init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 4: 0       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature             0       5     0  this   Lcn/itcast/jvm/t5/HelloWorld;<br>  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=2, locals=1, args_size=1<br>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;          3: ldc           #3                  // String hello world<br>         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V          8: return<br>      LineNumberTable:<br>        line 6: 0<br>        line 7: 8       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       9     0  args   [Ljava/lang/String;     MethodParameters:       Name                           Flags<br>      args<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090</p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><p> 1）原始 java 代码     </p><p>2）编译后的字节码文件<br>[root@localhost ~]# javap -v Demo3_1.class Classfile /root/Demo3_1.class<br>  Last modified Jul 7, 2019; size 665 bytes<br>  MD5 checksum a2c29a22421e218d4924d31e6990cfc5   Compiled from “Demo3_1.java” public class cn.itcast.jvm.t3.bytecode.Demo3_1   minor version: 0   major version: 52   flags: ACC_PUBLIC, ACC_SUPER Constant pool:<br>   #1 = Methodref          #7.#26         // java/lang/Object.”<init>“:()V    #2 = Class              #27            // java/lang/Short<br>   #3 = Integer            32768<br>   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;    #5 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V<br>   #6 = Class              #32            // cn/itcast/jvm/t3/bytecode/Demo3_1<br>   #7 = Class              #33            // java/lang/Object<br>   #8 = Utf8               <init><br>   #9 = Utf8               ()V<br>  #10 = Utf8               Code<br>  #11 = Utf8               LineNumberTable<br>  #12 = Utf8               LocalVariableTable<br>  #13 = Utf8               this   #14 = Utf8               Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>  #15 = Utf8               main   #16 = Utf8               ([Ljava/lang/String;)V<br>  #17 = Utf8               args   #18 = Utf8               [Ljava/lang/String;<br>  #19 = Utf8               a</p><p>  #20 = Utf8               I<br>  #21 = Utf8               b<br>  #22 = Utf8               c<br>  #23 = Utf8               MethodParameters<br>  #24 = Utf8               SourceFile<br>  #25 = Utf8               Demo3_1.java<br>  #26 = NameAndType        #8:#9          // “<init>“:()V<br>  #27 = Utf8               java/lang/Short<br>  #28 = Class              #34            // java/lang/System<br>  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;<br>  #30 = Class              #37            // java/io/PrintStream<br>  #31 = NameAndType        #38:#39        // println:(I)V   #32 = Utf8               cn/itcast/jvm/t3/bytecode/Demo3_1<br>  #33 = Utf8               java/lang/Object<br>  #34 = Utf8               java/lang/System<br>  #35 = Utf8               out<br>  #36 = Utf8               Ljava/io/PrintStream;<br>  #37 = Utf8               java/io/PrintStream<br>  #38 = Utf8               println<br>  #39 = Utf8               (I)V {   public cn.itcast.jvm.t3.bytecode.Demo3_1();     descriptor: ()V<br>    flags: ACC_PUBLIC     Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0          1: invokespecial #1                  // Method java/lang/Object.”<br><init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 6: 0       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature             0       5     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=2, locals=4, args_size=1<br>         0: bipush        10<br>         2: istore_1<br>         3: ldc           #3                  // int 32768<br>         5: istore_2<br>         6: iload_1<br>         7: iload_2<br>         8: iadd<br>         9: istore_3<br>        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;         13: iload_3<br>        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br>        17: return<br>      LineNumberTable:<br>        line 8: 0<br>        line 9: 3</p><p>3）常量池载入运行时常量池     </p><p>4）方法字节码载入方法区     </p><p>5）main 线程开始运行，分配栈帧内存<br>（stack=2，locals=4）</p><p>6）执行引擎开始执行字节码     </p><p>bipush 10<br>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） ldc 将一个 int 压入操作数栈 ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）<br>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><p>istore_1      将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p>istore_2     </p><p>iload_1     </p><p>iload_2     </p><p>iadd     </p><p>istore_3     </p><p>getstatic #4     </p><p>iload_3     </p><p>invokevirtual #5<br>va/io/PrintStream.println:(I)V 方法<br>生成新的栈帧（分配 locals、stack等）<br>传递参数，执行新栈帧中的字节码</p><p>完成 main 方法调用，弹出 main 栈帧程序结束</p><h3 id="2-4-练习-分析-i"><a href="#2-4-练习-分析-i" class="headerlink" title="2.4 练习 - 分析 i++"></a>2.4 练习 - 分析 i++</h3><p>目的：从字节码角度分析 a++ 相关题目源码：</p><p>字节码：</p><p>分析：</p><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p>指令    助记符    含义<br>0x99    ifeq    判断是否 == 0<br>0x9a    ifne    判断是否 != 0<br>0x9b    iflt    判断是否 &lt; 0<br>0x9c    ifge    判断是否 &gt;= 0<br>0x9d    ifgt    判断是否 &gt; 0<br>0x9e    ifle    判断是否 &lt;= 0<br>0x9f    if_icmpeq    两个int是否 ==<br>0xa0    if_icmpne    两个int是否 !=<br>0xa1    if_icmplt    两个int是否 &lt;<br>0xa2    if_icmpge    两个int是否 &gt;=<br>0xa3    if_icmpgt    两个int是否 &gt;<br>0xa4    if_icmple    两个int是否 &lt;=<br>0xa5    if_acmpeq    两个引用是否 ==<br>0xa6    if_acmpne    两个引用是否 !=<br>0xc6    ifnull    判断是否 == null<br>0xc7    ifnonnull    判断是否 != null<br>几点说明：<br>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节 goto 用来进行跳转到指定行号的字节码源码：</p><p>字节码：</p><h3 id="2-6-循环控制指令-其实循环控制还是前面介绍的那些指令，例如-while-循环："><a href="#2-6-循环控制指令-其实循环控制还是前面介绍的那些指令，例如-while-循环：" class="headerlink" title="2.6 循环控制指令     其实循环控制还是前面介绍的那些指令，例如 while 循环："></a>2.6 循环控制指令     其实循环控制还是前面介绍的那些指令，例如 while 循环：</h3><p>字节码是：</p><p>再比如 do while 循环：</p><p>字节码是：<br>0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return<br>后再看看 for 循环：</p><p>字节码是：</p><h3 id="2-7-练习-判断结果"><a href="#2-7-练习-判断结果" class="headerlink" title="2.7 练习 - 判断结果"></a>2.7 练习 - 判断结果</h3><p>请从字节码角度分析，下列代码运行的结果：</p><h3 id="2-8-构造方法"><a href="#2-8-构造方法" class="headerlink" title="2.8 构造方法"></a>2.8 构造方法</h3><p>1）<cinit>()V     </p><p>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方</p><p>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在 后<br>public cn.itcast.jvm.t3.bytecode.Demo3_8_2(java.lang.String, int);<br>    descriptor: (Ljava/lang/String;I)V<br>    flags: ACC_PUBLIC     Code:<br>      stack=2, locals=3, args_size=3<br>         0: aload_0<br>         1: invokespecial #1    // super.<init>()V<br>         4: aload_0<br>         5: ldc           #2    // &lt;- “s1”<br>         7: putfield      #3    // -&gt; this.a<br>        10: aload_0<br>        11: bipush        20    // &lt;- 20<br>        13: putfield      #4    // -&gt; this.b<br>        16: aload_0<br>        17: bipush        10    // &lt;- 10<br>        19: putfield      #4    // -&gt; this.b<br>        22: aload_0<br>        23: ldc           #5    // &lt;- “s2”<br>        25: putfield      #3    // -&gt; this.a<br>        28: aload_0             // ——————————<br>        29: aload_1             // &lt;- slot 1(a) “s3”            |         30: putfield      #3    // -&gt; this.a                    |         33: aload_0                                             |         34: iload_2             // &lt;- slot 2(b) 30              |         35: putfield      #4    // -&gt; this.b ——————–<br>        38: return<br>      LineNumberTable: …<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0      39     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_8_2;<br>            0      39     1     a   Ljava/lang/String;<br>            0      39     2     b   I     MethodParameters: …</p><h3 id="2-9-方法调用"><a href="#2-9-方法调用" class="headerlink" title="2.9 方法调用"></a>2.9 方法调用</h3><p>看一下几种不同的方法调用对应的字节码指令</p><p>字节码：<br>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈<br>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “<init>“:()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量<br>终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定<br>普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态<br>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了还有一个执行 invokespecial 的情况是通过 super 调用父类方法</p><h3 id="2-10-多态的原理"><a href="#2-10-多态的原理" class="headerlink" title="2.10 多态的原理"></a>2.10 多态的原理</h3><p>1）运行代码<br>停在 System.in.read() 方法上，这时运行 jps 获取进程 id<br>2）运行 HSDB 工具<br>进入 JDK 安装目录，执行</p><p>进入图形界面 attach 进程 id<br>3）查找某个对象     </p><p>4）查看对象内存结构<br>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br>MarkWord，后 8 字节就是对象的 Class 指针但目前看不到它的实际地址</p><p>5）查看对象 Class 的内存地址<br>可以通过 Windows -&gt; Console 进入命令行模式，执行</p><p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p><p>6）查看类的 vtable<br> 方法1：Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面</p><p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态相关的，final，static 不会列入）<br>那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到：</p><p>通过 Windows -&gt; Console 进入命令行模式，执行</p><p>就得到了 6 个虚方法的入口地址<br>7）验证方法地址<br>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知<br>Dog - public void eat() @0x000000001b7d3fa8<br>Animal - public java.lang.String toString() @0x000000001b7d35e8;<br>Object - protected void finalize() @0x000000001b3d1b10;<br>Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;<br>Object - public native int hashCode() @0x000000001b3d1540; Object - protected native java.lang.Object clone() @0x000000001b3d1678;<br>对号入座，发现<br>    eat() 方法是 Dog 类自己的<br>toString() 方法是继承 String 类的<br>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的<br>8）小结<br>当执行 invokevirtual 指令时，<br>1.先通过栈帧中的对象引用找到对象<br>2.分析对象头，找到对象的实际 Class<br>3.Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了<br>4.查表得到方法的具体地址<br>5.执行方法的字节码</p><h3 id="2-11-异常处理-try-catch"><a href="#2-11-异常处理-try-catch" class="headerlink" title="2.11 异常处理     try-catch"></a>2.11 异常处理     try-catch</h3><pre><code>    11: istore_1    12: return  Exception table:     from    to  target type         2     5     8   Class java/lang/Exception  LineNumberTable: ...              LocalVariableTable:    Start  Length  Slot  Name   Signature        9       3     2     e   Ljava/lang/Exception;        0      13     0  args   [Ljava/lang/String;        2      11     1     i   I       StackMapTable: ...MethodParameters: ...</code></pre><p>}<br>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号<br>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置</p><p>多个 single-catch 块的情况     </p><p>multi-catch 的情况     </p><p>finally     </p><p>public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=1, locals=4, args_size=1<br>         0: iconst_0<br>1istore_1            // 0 -&gt; i<br>2bipush        10    // try ————————————-         4 istore_1            // 10 -&gt; i                                  |          5 bipush        30    // finally                                  |          7 istore_1            // 30 -&gt; i                                  |<br>         8 goto          27    // return ———————————-11 astore_2            // catch Exceptin -&gt; e ———————-</p><pre><code>    12: bipush        20    //                                          |         14: istore_1            // 20 -&gt; i                                  |         15: bipush        30    // finally                                  |         17: istore_1            // 30 -&gt; i                                  |         18: goto          27    // return ----------------------------------        21: astore_3            // catch any -&gt; slot 3 ---------------------        22: bipush        30    // finally                                  |         24: istore_1            // 30 -&gt; i                                  |    25: aload_3             // &lt;- slot 3                                |    26: athrow              // throw ------------------------------------    27: return  Exception table:     from    to  target type         2     5    11   Class java/lang/Exception         2     5    21   any    // 剩余的异常类型，比如 Error</code></pre><p>1115    21   any    // 剩余的异常类型，比如 Error       LineNumberTable: …<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>123     2     e   Ljava/lang/Exception;<br>            0      28     0  args   [Ljava/lang/String;<br>            2      26     1     i   I       StackMapTable: …<br>    MethodParameters: …<br>可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</p><h3 id="2-12-练习-finally-面试题"><a href="#2-12-练习-finally-面试题" class="headerlink" title="2.12 练习 - finally 面试题"></a>2.12 练习 - finally 面试题</h3><p>finally 出现了 return<br>先问问自己，下面的题目输出什么？</p><pre><code>     2: istore_0            // 10 -&gt; slot 0 (从栈顶移除了)     3: bipush        20    // &lt;- 20 放入栈顶     5: ireturn             // 返回栈顶 int(20)     6: astore_1            // catch any -&gt; slot 1     7: bipush        20    // &lt;- 20 放入栈顶          9: ireturn             // 返回栈顶 int(20)       Exception table:     from    to  target type              0     3     6   any       LineNumberTable: ...  StackMapTable: ...</code></pre><p>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子<br>跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常 ，可以试一下下面的代码</p><p>finally 对返回值影响<br>同样问问自己，下面的题目输出什么？</p><h3 id="2-13-synchronized"><a href="#2-13-synchronized" class="headerlink" title="2.13 synchronized"></a>2.13 synchronized</h3><h2 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3. 编译期处理"></a>3. 编译期处理</h2><p>所谓的 语法糖，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）<br>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h3><p>编译成class后的代码：</p><h3 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h3><p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 代码片段1 都会在编译阶段被转换为 代码片段2</p><h3 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：<br>public class Candy3 {<br>    public static void main(String[] args) {<br>        List<Integer> list = new ArrayList&lt;&gt;();<br>        list.add(10); // 实际调用的是 List.add(Object e)<br>        Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);<br>    }<br>}<br>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><p>如果前面的 x 变量类型修改为 int 基本类型那么 终生成的字节码是：</p><p>还好这些麻烦事都不用自己做。</p><p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p><p>使用反射，仍然能够获得这些信息：</p><p>输出</p><h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><h3 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 foreach 循环</h3><p>会被编译器转换为：</p><p>而集合的循环：</p><p>实际被编译器转换为对迭代器的调用：</p><h3 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 switch 字符串</h3><p>可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。</p><p>会被编译器转换为：</p><h3 id="3-7-switch-枚举-switch-枚举的例子，原始代码："><a href="#3-7-switch-枚举-switch-枚举的例子，原始代码：" class="headerlink" title="3.7 switch 枚举     switch 枚举的例子，原始代码："></a>3.7 switch 枚举     switch 枚举的例子，原始代码：</h3><p>转换后代码：</p><h3 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h3><h3 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h3><p>息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：</p><p>输出：</p><p>如以上代码所示，两个异常信息都不会丢。</p><h3 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：父子类的返回值完全一致</p><p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证：</p><p>会输出：</p><h3 id="3-11-匿名内部类-源代码："><a href="#3-11-匿名内部类-源代码：" class="headerlink" title="3.11 匿名内部类     源代码："></a>3.11 匿名内部类     源代码：</h3><p>转换后代码：</p><p>引用局部变量的匿名内部类，源代码：</p><p>转换后代码：</p><h2 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4 . 类加载阶段"></a>4 . 类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><p>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有：<br>_java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴露给 java 使用 _super 即父类<br>_fields 即成员变量<br>_methods 即方法<br>_constants 即常量池<br>_class_loader 即类加载器<br>_vtable 虚方法表<br>_itable 接口方法表<br>如果这个类还有父类没有加载，先加载父类加载和链接可能是交替运行的<br>instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中可以通过前面介绍的 HSDB 工具查看</p><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>验证<br>验证类是否符合 JVM规范，安全性检查<br>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行<br>E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld<br>Error: A JNI error has occurred, please check your installation and try again<br>Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value<br>3405691578 in class file cn/itcast/jvm/t5/HelloWorld<br>        at java.lang.ClassLoader.defineClass1(Native Method)<br>        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)<br>        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)         at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)<br>        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)<br>        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)<br>        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)<br>        at java.security.AccessController.doPrivileged(Native Method)<br>        at java.net.URLClassLoader.findClass(URLClassLoader.java:361)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)<br>        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)         at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)<br>准备<br>为 static 变量分配空间，设置默认值<br>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成<br>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成</p><p>解析     将常量池中的符号引用解析为直接引用</p><h3 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h3><p><cinit>()V 方法<br>初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全<br>发生的时机<br>概括得说，类初始化是【懒惰的】<br>main 方法所在的类，总会被首先初始化首次访问这个类的静态变量或静态方法时子类初始化，如果父类还没初始化，会引发子类访问父类的静态变量，只会触发父类的初始化<br>Class.forName<br>new 会导致初始化不会导致类初始化的情况<br>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化<br>类对象.class 不会触发初始化<br>创建该类的数组不会触发初始化<br>类加载器的 loadClass 方法<br>Class.forName 的参数 2 为 false 时</p><p>实验</p><p>验证（实验时请先全部注释，每次只执行其中一个）</p><h3 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p><p>典型应用 - 完成懒惰初始化单例模式</p><p>以上的实现特点是：懒惰实例化<br>初始化时的线程安全是有保障的</p><h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h2><p>以 JDK 8 为例：<br>名称    加载哪的类    说明<br>Bootstrap ClassLoader    JAVA_HOME/jre/lib    无法直接访问<br>Extension ClassLoader    JAVA_HOME/jre/lib/ext    上级为 Bootstrap，显示为 null<br>Application ClassLoader    classpath    上级为 Extension<br>自定义类加载器    自定义    上级为 Application</p><h3 id="5-1-启动类加载器-用-Bootstrap-类加载器加载类："><a href="#5-1-启动类加载器-用-Bootstrap-类加载器加载类：" class="headerlink" title="5.1 启动类加载器     用 Bootstrap 类加载器加载类："></a>5.1 启动类加载器     用 Bootstrap 类加载器加载类：</h3><p>执行</p><p>输出</p><h3 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h3><p>执行</p><p>输出</p><p>写一个同名的类</p><p>打个 jar 包<br>E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class 已添加清单<br>正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%) 将 jar 包拷贝到 JAVA_HOME/jre/lib/ext 重新执行 Load5_2 输出</p><h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则<br> 注意</p><p>执行流程为：</p><ol><li>sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有<br>2.sun.misc.Launcher$AppClassLoader // 2 处，委派上级 sun.misc.Launcher$ExtClassLoader.loadClass()<br>3.sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有<br>4.sun.misc.Launcher$ExtClassLoader // 3 处，没有上级了，则委派 BootstrapClassLoader 查找<br>5.BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有</li><li>sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在<br>JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader</li><li>到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在 classpath 下查找，找到了</li></ol><h3 id="5-4-线程上下文类加载器"><a href="#5-4-线程上下文类加载器" class="headerlink" title="5.4 线程上下文类加载器"></a>5.4 线程上下文类加载器</h3><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p><p>让我们追踪一下源码：</p><p>先不看别的，看看 DriverManager 的类加载器：</p><p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但<br>JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？继续看 loadInitialDrivers() 方法：</p><p>先看 2）发现它 后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载<br>再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI）<br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称</p><p>这样就可以使用</p><p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：<br>JDBC<br>Servlet 初始化器<br>Spring 容器<br>Dubbo（对 SPI 进行了扩展）接着看 ServiceLoader.load 方法：</p><p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类<br>LazyIterator 中：</p><h3 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h3><p>问问自己，什么时候需要自定义类加载器<br>1）想加载非 classpath 随意路径中的类文件<br>2）都是通过接口来使用实现，希望解耦时，常用在框架设计<br>3）这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</p><p>步骤：<br>1.继承 ClassLoader 父类<br>2.要遵从双亲委派机制，重写 findClass 方法<br> 注意不是重写 loadClass 方法，否则不会走双亲委派机制<br>3.读取类文件的字节码<br>4.调用父类的 defineClass 方法来加载类<br>5.使用者调用该类加载器的 loadClass 方法示例：<br>准备好两个类文件放入 E:\myclasspath，它实现了 java.util.Map 接口，可以先反编译看一下：</p><h2 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6. 运行期优化"></a>6. 运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><p>分层编译<br>（TieredCompilation）<br>先来个例子</p><p>2357173<br>2450346<br>2552906<br>2650346<br>2747786<br>2849920<br>2964000<br>3049067<br>3163574<br>3263147<br>3356746<br>3449494<br>3564853<br>36107520<br>3746933<br>3851627<br>3945653<br>40103680<br>4151626<br>4260160<br>4349067<br>4445653<br>4549493<br>4651626<br>4749066<br>4847360<br>4950774<br>5070827<br>5164000<br>5272107<br>5349066<br>5446080<br>5544800<br>5646507<br>5773813<br>5861013<br>5957600<br>6083200<br>617024204<br>6249493<br>6320907<br>6420907<br>6520053<br>6620906<br>6720907<br>6821333<br>6922187<br>7020480<br>7121760<br>7219200<br>7315360<br>7418347<br>7519627<br>7617067<br>7734134<br>7819200<br>7918347<br>8017493</p><p>8115360<br>8218774<br>8317067<br>8421760<br>8523467<br>8617920<br>8717920<br>8818774<br>8918773<br>9019200<br>9120053<br>9218347<br>9322187<br>9417920<br>9518774<br>9619626<br>9733280<br>9820480<br>9920480<br>10018773<br>10147786<br>10217493<br>10322614<br>10464427<br>10518347<br>10619200<br>10726027<br>10821333<br>10920480<br>11024747<br>11132426<br>11221333<br>11317920<br>11417920<br>11519200<br>11618346<br>11715360<br>11824320<br>11919200<br>12020053<br>12117920<br>12218773<br>12320053<br>12418347<br>12518347<br>12622613<br>12718773<br>12819627<br>12920053<br>13020480<br>13119627<br>13220053<br>13315360<br>134136533<br>13543093<br>136853<br>137853<br>138853</p><p>139853<br>140854<br>141853<br>142853<br>143853<br>144853<br>145853<br>146853<br>147854<br>148853<br>149853<br>150854<br>151853<br>152853<br>153853<br>1541280<br>155853<br>156853<br>157854<br>158853<br>159853<br>160854<br>161854<br>162853<br>163854<br>164854<br>165854<br>166854<br>167853<br>168853<br>169854<br>170853<br>171853<br>172853<br>1731280 174 853<br>1751280<br>176853<br>177854<br>178854<br>179427<br>180853<br>181854<br>182854<br>183854<br>184853<br>185853<br>186854<br>187853<br>188853<br>189854<br>1901280<br>191853<br>192853<br>193853<br>194853<br>195854<br>196853</p><p>原因是什么呢？<br>JVM 将执行状态分成了 5 个层次：<br>0层，解释执行（Interpreter）<br>1层，使用 C1 即时编译器编译执行（不带 profiling）<br>2层，使用 C1 即时编译器编译执行（带基本的 profiling）<br>3层，使用 C1 即时编译器编译执行（带完全的 profiling）<br>4层，使用 C2 即时编译器编译执行<br>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等<br>即时编译器（JIT）与解释器的区别<br>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释<br>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译<br>解释器是将字节码解释为针对所有平台都通用的机器码<br>JIT 会根据平台类型，生成平台特定的机器码<br>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），优化之</p><p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:-<br>DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p><p>参考资料：<a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</a> 方法内联<br>（Inlining）</p><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p><p>还能够进行常量折叠（constant folding）的优化</p><p>实验：</p><p>字段优化<br>JMH 基准测试请参考：<a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a> 创建 maven 工程，添加依赖如下</p><p>编写基准测试代码：</p><p>import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder;<br>import java.util.Random; import java.util.concurrent.ThreadLocalRandom;<br>@Warmup(iterations = 2, time = 1)<br>@Measurement(iterations = 5, time = 1)<br>@State(Scope.Benchmark) public class Benchmark1 {<br>    int[] elements = randomInts(1_000);<br>    private static int[] randomInts(int size) {<br>        Random random = ThreadLocalRandom.current();<br>        int[] values = new int[size];<br>        for (int i = 0; i &lt; size; i++) {<br>            values[i] = random.nextInt();<br>        }<br>        return values;<br>    }<br>    @Benchmark<br>    public void test1() {<br>        for (int i = 0; i &lt; elements.length; i++) {<br>            doSum(elements[i]);<br>        }<br>    }<br>    @Benchmark<br>    public void test2() {<br>        int[] local = this.elements;<br>        for (int i = 0; i &lt; local.length; i++) {<br>            doSum(local[i]);<br>        }<br>    }<br>    @Benchmark<br>    public void test3() {<br>        for (int element : elements) {<br>            doSum(element);<br>        }<br>    }<br>    static int sum = 0;<br>    @CompilerControl(CompilerControl.Mode.INLINE)<br>    static void doSum(int x) {<br>        sum += x;<br>    }<br>    public static void main(String[] args) throws RunnerException {<br>        Options opt = new OptionsBuilder()<br>                .include(Benchmark1.class.getSimpleName())<br>                .forks(1)                 .build();<br>        new Runner(opt).run();<br>北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090</p><p>首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：<br>Benchmark              Mode  Samples        Score  Score error  Units t.Benchmark1.test1    thrpt        5  2420286.539   390747.467  ops/s<br>t.Benchmark1.test2    thrpt        5  2544313.594    91304.136  ops/s<br>t.Benchmark1.test3    thrpt        5  2469176.697   450570.647  ops/s<br>接下来禁用 doSum 方法内联</p><p>测试结果如下：<br>Benchmark              Mode  Samples       Score  Score error  Units t.Benchmark1.test1    thrpt        5  296141.478    63649.220  ops/s<br>t.Benchmark1.test2    thrpt        5  371262.351    83890.984  ops/s<br>t.Benchmark1.test3    thrpt        5  368960.847    60163.391  ops/s<br>分析：<br>在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化：如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：</p><p>可以节省 1999 次 Field 读取操作<br>但如果 doSum 方法没有内联，则不会进行上面的优化</p><p>练习：在内联情况下将 elements 添加 volatile 修饰符，观察测试结果</p><h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉 初的实现，可以通过 debug 得到类名为 sun.reflect.GeneratedMethodAccessor1 可以使用阿里的 arthas 工具：</p><p>选择 1 回车表示分析该进程</p><p>1 [INFO] arthas home: /root/.arthas/lib/3.1.1/arthas<br>[INFO] Try to attach process 13065 [INFO] Attach process 13065 success.<br>[INFO] arthas-client connect 127.0.0.1 3658<br>  ,—.  ,——. ,——–.,–.  ,–.  ,—.   ,—.                            /  O  \ |  .–. ‘’–.  .–’|  ‘–’  | /  O  \ ‘   .-‘<br>|  .-.  ||  ‘–’.’   |  |   |  .–.  ||  .-.  |<code>.  </code>-.                          |  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-‘    |                         <code>--&#39; </code>–’<code>--&#39; &#39;--&#39;   </code>–’   <code>--&#39;  </code>–’<code>--&#39; </code>–’`—–’<br>wiki      <a href="https://alibaba.github.io/arthas">https://alibaba.github.io/arthas</a>                                      tutorials <a href="https://alibaba.github.io/arthas/arthas-tutorials">https://alibaba.github.io/arthas/arthas-tutorials</a>                     version   3.1.1                                                                 pid       13065                                                                 time      2019-06-10 12:23:54<br>再输入【jad + 类名】来进行反编译<br>$ jad sun.reflect.GeneratedMethodAccessor1<br>ClassLoader:<br>+-sun.reflect.DelegatingClassLoader@15db9742                                     </p><p>  +-sun.misc.Launcher$AppClassLoader@4e0e2f2a<br>    +-sun.misc.Launcher$ExtClassLoader@2fdb006e<br>Location:                                                                       </p><p>/*<br>*Decompiled with CFR 0_132.</p><ul><li>*Could not load the following classes:<br>*cn.itcast.jvm.t3.reflect.Reflect1<br> <em>/<br>package sun.reflect;<br>import cn.itcast.jvm.t3.reflect.Reflect1; import java.lang.reflect.InvocationTargetException; import sun.reflect.MethodAccessorImpl;<br>public class GeneratedMethodAccessor1 extends MethodAccessorImpl {<br> /</em><br>*Loose catch block<br>*Enabled aggressive block sorting<br>*Enabled unnecessary exception pruning<br>*Enabled aggressive exception aggregation<br>*Lifted jumps to return sites<br>  */</li></ul><h1 id="四-内存模型"><a href="#四-内存模型" class="headerlink" title="四.内存模型"></a>四.内存模型</h1><h2 id="1-java-内存模型"><a href="#1-java-内存模型" class="headerlink" title="1. java 内存模型"></a>1. java 内存模型</h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p><p><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b">关于它的权威解释，请参考</a></p><p>简单的说，JMM 定义了一套在<strong>多线程读写</strong>共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性     "></a>1.1 原子性    <a href="af://n13/"> </a></h3><p>原子性在学习线程时讲过，下面来个例子简单回顾一下：</p><p>问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><h3 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps95.png" alt="img"></p><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps96.png" alt="img"> </p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps97.png" alt="img"></p><p>但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps98.png" alt="img"></p><p>出现正数的情况：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps99.png" alt="img"></p><h3 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法     "></a>1.3 解决方法    <a href="af://n29/"> </a></h3><p>synchronized（同步关键字)</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps101.png" alt="img"></p><p>如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。</p><ol><li><p>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。</p></li><li><p>这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。</p></li><li><p>当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count– 代码。</p></li></ol><p>注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps104.png" alt="img"></p><p>为什么呢？ </p><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps105.png" alt="img"> </p><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps106.png" alt="img"> </p><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps107.png" alt="img"> </p><h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h3><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以*<!--避免线程从自己的工作缓存中查找变量的值-->*，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620131455851.png" alt="image-20210620131455851" style="zoom:80%;" /><h3 id="2-3-可见性"><a href="#2-3-可见性" class="headerlink" title="2.3 可见性     "></a>2.3 可见性    <strong><a href="af://n71/"> </a></strong></h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， <u><em>不能保证原子性</em></u>，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true</span><br><span class="line"></span><br><span class="line">putstatic   run  &#x2F;&#x2F;  线程 main 修改 run 为 false， 仅此一次 getstatic   run  &#x2F;&#x2F; 线程 t 获取 run false</span><br></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到 新值，不能解决指令交错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设i的初始值为0 getstatic   i  </span><br><span class="line">&#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;0 getstatic   i  </span><br><span class="line">&#x2F;&#x2F; 线程2-获取静态变量i的值 线程内i&#x3D;0 iconst_1     </span><br><span class="line">&#x2F;&#x2F; 线程1-准备常量1 iadd       </span><br><span class="line">&#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 putstatic   i </span><br><span class="line">&#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1 iconst_1     </span><br><span class="line">&#x2F;&#x2F; 线程2-准备常量1 isub       </span><br><span class="line">&#x2F;&#x2F; 线程2-自减 线程内i&#x3D;-1</span><br><span class="line"></span><br><span class="line">putstatic   i  &#x2F;&#x2F; 线程2-将修改后的值存入静态变量i 静态变量i&#x3D;-1</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><p>​    <u>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性</u>。但缺点是synchronized是属于重量级操作，性能相对更低</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性     "></a>3. 有序性    <a href="af://n81/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps110.png" alt="img"></p><h3 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3.1 诡异的结果     "></a>3.1 诡异的结果    <a href="af://n82/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps111.png" alt="img"></p><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？有同学这么分析</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>但我告诉你，结果还有可能是 0 ，信不信吧！</p><p>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2</p><p>相信很多人已经晕了 </p><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p><p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.open</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">dk</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">.j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">ava.net/displa</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">y</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">/CodeTools/</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">cstress</a></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps112.png" alt="img">mvn archetype:generate  -DinteractiveMode=false DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-testarchetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0</p><p>创建 maven 项目，提供如下测试类</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps113.png" alt="img"></p><p>执行</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps114.png" alt="img"></p><p>会输出我们感兴趣的结果，摘录其中一次结果：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps115.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0   1,729  ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">1   42,617,915        ACCEPTABLE  ok</span><br><span class="line">4   5,146,627        ACCEPTABLE  ok</span><br><span class="line">[OK] test.ConcurrencyTest</span><br><span class="line"></span><br><span class="line">(JVM args: [])</span><br><span class="line"> Observed state  Occurrences        Expectation  Interpretation         0     1,652  ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line"></span><br><span class="line">​        1   46,460,657        ACCEPTABLE  ok</span><br><span class="line"></span><br><span class="line">​        4   4,571,072        ACCEPTABLE  ok</span><br></pre></td></tr></table></figure><p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法     "></a>3.2 解决方法    <a href="af://n104/"> </a></h3><p>volatile 修饰的变量，可以禁用指令重排</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps117.png" alt="img"></p><p>结果为：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps118.png" alt="img"></p><h3 id="3-3-有序性理解"><a href="#3-3-有序性理解" class="headerlink" title="3.3 有序性理解     "></a>3.3 有序性理解    <a href="af://n111/"> </a></h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps119.png" alt="img"></p><p>可以看到，至于是先执行 i 还是 先执行 j ，对 终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps120.png" alt="img"></p><p>也可以是</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps121.png" alt="img"></p><p>这种特性称之为<strong>『指令重排』</strong>，</p><p> 单线程不会产生问题；多线程下『指令重排』会影响正确性。</p><p>例如著名的 double-checked locking 模式实现单例</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps122.png" alt="img"></p><p>以上的实现特点是：</p><ul><li><p>懒惰实例化</p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p><p>但在多线程环境下，上面的代码是有问题的，INSTANCE = new Singleton() 对应的字节码为：</p></li></ul><p>0: new      #2          // class cn/itcast/jvm/t4/Singleton</p><p>3: dup</p><p>4: invokespecial #3          // Method “<init>“:()V</p><p>7: putstatic   #4          // Field </p><p>INSTANCE:Lcn/itcast/jvm/t4/Singleton;</p><p>其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1，t2 按如下时间序列执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间1  t1 线程执行到 INSTANCE &#x3D; new Singleton(); 时间2  t1 线程分配空间，为Singleton对象生成了引用地址（0 处）时间3  t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE !&#x3D; null（7 处）时间4  t2 线程进入getInstance() 方法，发现 INSTANCE !&#x3D; null（synchronized块外），直接返回 INSTANCE时间5  t1 线程执行Singleton的构造方法（4 处）</span><br></pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 <strong>JDK 5 以上</strong>的版本的 volatile 才会真正有效</p><h3 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3.4 happens-before     "></a>3.4 happens-before    <a href="af://n133/"> </a></h3><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，</p><p>抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps126.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps127.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps128.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps129.png" alt="img"> 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps130.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps131.png" alt="img"> 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps132.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps133.png" alt="img"></p><ul><li><p>对变量默认值（0，false，null)的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z 变量都是指成员变量或静态成员变量参考： 第17页</p></li></ul><h2 id="4-CAS-与-原子类"><a href="#4-CAS-与-原子类" class="headerlink" title="4. CAS 与 原子类     "></a>4. CAS 与 原子类    <a href="af://n168/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps135.png" alt="img"></p><h3 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4.1 CAS     "></a>4.1 CAS    <a href="af://n169/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps136.png" alt="img"></p><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps137.png" alt="img">因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps138.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(() -&gt; &#123;      for (int i &#x3D; 0; i &lt; count; i++) &#123;     dc.increase();      &#125;    &#125;);          t1.start();    t1.join();    System.out.println(dc.getData());  &#125; &#125;class DataContainer &#123;  private volatile int data;  static final Unsafe unsafe; static final long DATA_OFFSET;  static &#123;   try &#123;      &#x2F;&#x2F; Unsafe 对象不能直接调用，只能通过反射获得      Field theUnsafe &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);      theUnsafe.setAccessible(true);      unsafe &#x3D; (Unsafe) theUnsafe.get(null);    &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;      throw new Error(e);    &#125;    try &#123;      &#x2F;&#x2F; data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性      DATA_OFFSET &#x3D; unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(&quot;data&quot;));    &#125; catch (NoSuchFieldException e) &#123;      throw new Error(e);    &#125;  &#125;  </span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620141319373.png" alt="image-20210620141319373"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps139.png" alt="img"></p><h3 id="4-2-乐观锁与悲观锁"><a href="#4-2-乐观锁与悲观锁" class="headerlink" title="4.2 乐观锁与悲观锁     "></a>4.2 乐观锁与悲观锁    <a href="af://n180/"> </a></h3><p>CAS 是基于乐观锁的思想： 乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p><p>synchronized 是基于悲观锁的思想： 悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p><h3 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4.3 原子操作类     "></a>4.3 原子操作类    <a href="af://n201/"> </a></h3><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，</p><p>例如：AtomicInteger、AtomicBoolean等，</p><p>它们底层就是采用 CAS 技术 + volatile 来实现的。</p><p>可以使用 AtomicInteger 改写之前的例子：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps141.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps142.png" alt="img"></p><h2 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5. synchronized 优化     "></a>5. synchronized 优化    <a href="af://n220/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps143.png" alt="img"></p><ul><li>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word)。Mark Word 平时存储这个对象的 哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为 标记位、线程锁记录指针、重量级锁指针、线程ID 等内容</li></ul><h3 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁     "></a>5.1 轻量级锁    <a href="af://n233/"> </a></h3><p>*<!--如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化-->*。</p><p>这就好比：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即升级为重量级锁(锁膨胀)，进入重量级锁的流程。而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁</span><br></pre></td></tr></table></figure><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps146.png" alt="img"></p><p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p><table><thead><tr><th>线程 1</th><th>对象 Mark Word</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块 A，把 Mark 复制到线程 1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 A</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>访问同步块 B，把 Mark 复制到线程 1 的锁记录</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>失败（发现是自己的锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>锁重入</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 B</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 B 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 A 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>-</td></tr><tr><td>-</td><td>01（无锁）</td><td>访问同步块 A，把 Mark 复制到线程 2 的锁记录</td></tr><tr><td>-</td><td>01（无锁）</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>-</td><td>00（轻量锁）线程 2 锁记录地址</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5.2 锁膨胀     "></a>5.2 锁膨胀    <a href="af://n310/"> </a></h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps147.png" alt="img"></p><table><thead><tr><th>线程 1</th><th>对象 Mark</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块，把 Mark 复制到线程1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>访问同步块，把 Mark 复制到线程 2</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>失败（发现别人已经占了锁）</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>失败（解锁）</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争</td><td>01（无锁）</td><td>阻塞中</td></tr><tr><td>-</td><td>10（重量锁）</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10（重量锁）</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5.3 重量锁     "></a>5.3 重量锁    <a href="af://n378/"> </a></h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><ul><li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p></li><li><p><strong>自旋会占用 CPU 时间</strong>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p><p>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）</p></li><li><p>Java 7 之后不能控制是否开启自旋功能 </p></li></ul><p>自旋重试成功的情况</p><table><thead><tr><th>线程 1 （cpu 1 上）</th><th>对象 Mark</th><th>线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况</p><table><thead><tr><th>线程 1（cpu 1 上）</th><th>对象 Mark</th><th>线程 2（cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-4-偏向锁"><a href="#5-4-偏向锁" class="headerlink" title="5.4 偏向锁"></a>5.4 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</p><ul><li><p>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW)</p></li><li><p>访问对象的 hashCode 也会撤销偏向锁</p></li><li><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p></li><li><p>撤销偏向和重偏向都是批量进行的，以类为单位</p></li><li><p>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</p></li><li><p>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</p></li></ul><p><a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">可以参考这篇论文：</a></p><p>假设有两个方法同步块，利用同一个对象加锁</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps150.png" alt="img"></p><table><thead><tr><th>线程 1</th><th>对象 Mark</th></tr></thead><tbody><tr><td>访问同步块 A，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）</td></tr><tr><td>尝试加偏向锁</td><td>101（无锁可偏向）对象 hashCode</td></tr><tr><td>成功</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 A</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>访问同步块 B，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>是自己的线程 ID，锁是自己的，无需做更多操作</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 B</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行完毕</td><td>101（无锁可偏向）对象 hashCode</td></tr></tbody></table><h3 id="5-5-其它优化"><a href="#5-5-其它优化" class="headerlink" title="5.5 其它优化"></a>5.5 其它优化</h3><ol><li>减少上锁时间    </li></ol><p>同步代码块中尽量短</p><ol start="2"><li><p>减少锁的粒度    </p><p>将一个锁拆分为多个锁提高并发度，例如：</p></li></ol><ul><li><p>ConcurrentHashMap</p></li><li><p>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改， 后将数组中每个 cell 累加，再加上 base 就是 终的值</p></li><li><p>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</p></li></ul><ol start="3"><li>锁粗化    <a href="af://n542/"> </a></li></ol><p>多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps153.png" alt="img"></p><ol start="4"><li>锁消除    </li></ol><p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p><ol start="5"><li>读写分离    </li></ol><p>CopyOnWriteArrayList ConyOnWriteSet</p><p>参考：</p><p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.open</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">j</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">dk</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">.j</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">ava.net/displa</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">y</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">/HotSpot/S</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">y</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">nchronization </a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luo</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">j</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">inpin</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">g</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">.com/2015/07/09/</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">j</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">ava</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">锁优化</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">/ </a><a href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">j</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">ava-se-16-s</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">y</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">nchronized </a><a href="https://www.jianshu.com/p/9932047a89be">https://www</a><a href="https://www.jianshu.com/p/9932047a89be">.j</a><a href="https://www.jianshu.com/p/9932047a89be">ianshu.com/p/9932047a89be </a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblo</a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">g</a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">s.com/sheeva/p/6366782.html</a></p><p><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-</a><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">j</a><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">ava-ever-rebias-an-individual-lock</a></p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Markdown格式解析</title>
    <link href="http://example.com/2021/06/20/Markdown%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/20/Markdown%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-20T12:05:48.000Z</published>
    <updated>2021-06-20T12:36:31.211Z</updated>
    
    <content type="html"><![CDATA[<p>————-正文开始———————–</p><p>==（1）标题==</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>==（2）字体==</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><em><strong>斜体加粗</strong></em></p><p><del>删除线</del></p><p>==高亮==</p><p>我是^上标^</p><p>我是<del>下标</del></p><p>==（3）列表==</p><ul><li><p>一二三四五</p><ul><li><p>上山打老虎</p><ul><li><p>老虎没打到</p><ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><ol><li><p>一二三四五</p></li><li><p>上山打老虎</p></li><li><p>老虎没打到</p></li><li><p>打到小松鼠</p></li></ol><p>==（4）表格==</p><table><thead><tr><th>Mon</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>——</th><th>——</th><th>——</th><th>——</th><th>——</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>上山</th><th>上山</th><th>上山</th><th>上山</th><th>上山</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>打老虎</th><th>打老虎</th><th>打老虎</th><th>打老虎</th><th>打老虎</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>==（5）引用 ==</p><blockquote><p>一二三四五</p></blockquote><blockquote><blockquote><p>上山打老虎</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>老虎没打到</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>打到小松鼠</p></blockquote></blockquote></blockquote></blockquote><p>==（6）分割线==</p><hr><p>==（7）代码==</p><p><code>我是代码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是代码框</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Maven尚硅谷复习总结</title>
    <link href="http://example.com/2021/06/20/Maven%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/06/20/Maven%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-20T12:04:56.000Z</published>
    <updated>2021-06-20T12:36:38.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven尚硅谷复习总结"><a href="#Maven尚硅谷复习总结" class="headerlink" title="Maven尚硅谷复习总结"></a>Maven尚硅谷复习总结</h1><p>导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。 </p><p>1 Why? </p><p>1.1 真的需要吗？ </p><p>Maven 是干什么用的？这是很多同学在刚开始接触 Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用 Maven 我们仍然可以进行 B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用 Maven 我们一样可以开发项目啊？ </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps1.jpg" alt="img"> </p><p>这里给大家纠正一个误区，Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。 </p><p>1.2 究竟为什么？ </p><p>为什么要使用 Maven？它能帮助我们解决什么问题？ </p><p>①添加第三方 jar 包 </p><p>在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。 </p><p>而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。 </p><p>  ②jar 包之间的依赖关系 </p><p>jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。 </p><p>那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar 包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。 </p><p>而引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.3.jar 后，commons-io-2.0.1.jar 会被自动导入，程序员不必了解这个依赖关系。 </p><p>下图是 Spring 所需 jar 包的部分依赖关系 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps2.png" alt="img"> </p><p>③获取第三方 jar 包 </p><p>JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。 </p><p>使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载，并同时下载这个 jar 包所依赖的其他 jar 包 ——规范、完整、准确！一次性解决所有问题！ </p><p>Tips：在这里我们顺便说一下，统一的规范几乎可以说成是程序员的最高信仰。如果没有统一的规范，就意味着每个具体的技术都各自为政，需要以诸多不同的特殊的方式加入到项目中；好不容易加入进来还会和其他技术格格不入，最终受苦的是我们。而任何一个领域的统一规范都能够极大的降低程序员的工作难度，减少工作量。例如：USB 接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备对应的接口，无疑是非常繁琐的。 </p><p>④将项目拆分成多个工程模块 </p><p>随着 JavaEE 项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 JavaEE 项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 Java 工程，有的是 Web 工程。 </p><p>那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。大家请看我们的 Survey 调查项目拆分的情况： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps3.png" alt="img"> 上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。 </p><p>2 What? </p><p>2.1 Maven 简介 </p><p>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps4.jpg" alt="img"> </p><p>2.2 什么是构建 </p><p>构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看： </p><p>①纯 Java 代码 </p><p>大家都知道，我们 Java 是一门编译型语言，.java 扩展名的源文件需要编译成.class 扩展名的字节码文件才能够执行。所以编写任何 Java 代码想要执行的话就必须经过编译得到对应的.class 文件。 </p><p>②Web 工程 </p><p>当我们需要通过浏览器访问 Java 程序时就必须将包含 Java 程序的 Web 工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。 </p><p>我们可以将未编译的 Web 工程比喻为一只生的鸡，编译好的 Web 工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。 </p><p>Web 工程和其编译结果的目录结构对比见下图： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps5.png" alt="img"> </p><p>③实际项目 </p><p>在实际项目中整合第三方框架，Web 工程中除了 Java 程序和 JSP 页面、图片等静态资源之外，还包括第三方框架的 jar 包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。 </p><p>所以综上所述：构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 </p><p>那么项目构建的全过程中都包含哪些环节呢？ </p><p>2.3 构建过程的几个主要环节 </p><p>①清理：删除以前的编译结果，为重新编译做好准备。 </p><p>②编译：将 Java 源程序编译为字节码文件。 </p><p>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 </p><p>④报告：在每一次测试后以标准的格式记录和展示测试结果。 </p><p>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 </p><p>⑥安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 </p><p>⑦部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 </p><p>2.4 自动化构建 </p><p>其实上述环节我们在 Eclipse 中都可以找到对应的操作，只是不太标准。那么既然 IDE 已经可以进行构建了我们为什么还要使用 Maven 这样的构建工具呢？我们来看一个小故事：这是阳光明媚的一天。托马斯向往常一样早早的来到了公司，冲好一杯咖啡，进入了自己的邮箱——很不幸，QA 小组发来了一封邮件，报告了他昨天提交的模块的测试结果——有 BUG。“好吧，反正也不是第一次”，托马斯摇摇头，进入 IDE，运行自己的程序，编译、打包、部署到服务器上，然后按照邮件中的操作路径进行测试。“嗯，没错，这个地方确实有问题”，托马斯说道。于是托马斯开始尝试修复这个 BUG，当他差不多有眉目的时候已经到了午饭时间。 </p><p>下午继续工作。BUG 很快被修正了，接着托马斯对模块重新进行了编译、打包、部署，测试之后确认没有问题了，回复了 QA 小组的邮件。 </p><p>一天就这样过去了，明媚的阳光化作了美丽的晚霞，托马斯却觉得生活并不像晚霞那样美好啊。 </p><p>让我们来梳理一下托马斯这一天中的工作内容 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps6.jpg" alt="img"> </p><p>从中我们发现，托马斯的很大一部分时间花在了“编译、打包、部署、测试”这些程式化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps7.jpg" alt="img"> 能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps8.jpg" alt="img"> </p><p>此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps9.png" alt="img"> </p><p>2.5 Maven 核心概念 </p><p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，看看 Maven 是如何实现自动化构建的 </p><p>①POM </p><p>②约定的目录结构 </p><p>③坐标 </p><p>④依赖管理 </p><p>⑤仓库管理 </p><p>⑥生命周期 </p><p>⑦插件和目标 </p><p>⑧继承 </p><p>⑨聚合 </p><p>3 How? </p><p>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是</p><p>Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 </p><p>下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。 </p><p>如果不能联网可以使用我们提供的 RepMaven.zip 解压得到。具体操作参见“Maven 操作指南.txt”。 </p><p>4 约定的目录结构 </p><p>约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。 </p><p>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式： </p><p>①通过配置的形式明确告诉它 </p><p>②基于第三方工具或框架的约定 </p><p>Maven 对工程目录结构的要求就属于后面的一种。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps10.jpg" alt="img"> </p><p>现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。 </p><p>5 POM </p><p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。 Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。 </p><p>6 坐标 </p><p>6.1 几何中的坐标 </p><p>[1]在一个平面中使用 x、y 两个向量可以唯一的确定平面中的一个点。 </p><p>[2]在空间中使用 x、y、z 三个向量可以唯一的确定空间中的一个点。 </p><p>6.2 Maven 的坐标 </p><p>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。 </p><p>[1]groupid：公司或组织的域名倒序+当前项目名称 </p><p>[2]artifactId：当前项目的模块名称 </p><p>[3]version：当前模块的版本 </p><p> &lt;****g****roupId&gt;com.atguigu.maven</groupId> </p><p> &lt;****a****rtifactId&gt;Hello</artifactId> </p><p> &lt;****v****ersion&gt;0.0.1-SNAPSHOT</version> </p><p>6.3 如何通过坐标到仓库中查找 jar 包？ </p><p>[1]将 gav 三个向量连起来 </p><p>com.atguigu.maven+Hello+0.0.1-SNAPSHOT </p><p>[2]以连起来的字符串作为目录结构到仓库中查找 </p><p>com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar </p><p>※注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install </p><p>7 依赖 </p><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决一下几个问题： </p><p>①依赖的目的是什么 </p><p>当A jar包用到了B jar包中的某些类时，A就对B产生了依赖，这是概念上的描述。那么如何在项目</p><p>中以依赖的方式引入一个我们需要的jar包呢？答案非常简单，就是使用dependency标签指定被依赖jar包的坐标就可以了。 </p><dependency> <p> <groupId>com.atguigu.maven</groupId> </p><p> <artifactId>Hello</artifactId> </p><p> <version>0.0.1-SNAPSHOT</version> </p><p> <scope>compile</scope> </dependency> </p><p>②依赖的范围大家注意到上面的依赖信息中除了目标jar包的坐标还有一个scope设置，这是依赖的范围。依赖的范围有几个可选值，我们用得到的是：compile、test、provided三个。 </p><p>[1]从项目结构角度理解compile和test的区别 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps11.jpg" alt="img"> </p><p>结合具体例子：对于HelloFriend来说，Hello就是服务于主程序的，junit是服务于测试程序的。 </p><p>HelloFriend 主程序需要 Hello 是非常明显的，测试程序由于要调用主程序所以也需要 Hello，所以 compile范围依赖对主程序和测试程序都应该有效。 </p><p>HelloFriend的测试程序部分需要junit也是非常明显的，而主程序是不需要的，所以test范围依赖仅仅对于主程序有效。 </p><p>[2]从开发和运行这两个不同阶段理解compile和provided的区别 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps12.jpg" alt="img"> </p><p>[3]有效性总结 </p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th></tr></thead><tbody><tr><td>主程序</td><td>√</td><td>×</td><td>√</td></tr><tr><td>测试程序</td><td>√</td><td>√</td><td>√</td></tr><tr><td>参与部署</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><p>③依赖的传递性 </p><p>A依赖B，B依赖C，A能否使用C呢？那要看B依赖C的范围是不是compile，如果是则可用，否则不可用。 </p><table><thead><tr><th>Maven 工程</th><th></th><th>依赖范围</th><th>对 A 的可见性</th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>compile</td><td>√</td></tr><tr><td>D</td><td>test</td><td>×</td><td></td><td></td></tr><tr><td>E</td><td>provided</td><td>×</td><td></td><td></td></tr></tbody></table><p>④依赖的排除 </p><p>如果我们在当前工程中引入了一个依赖是A，而A又依赖了B，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。 </p><p>[1]情景举例 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps13.png" alt="img"> </p><p>[2]配置方式 </p><dependency> <p>   <groupId>com.atguigu.maven</groupId> </p><p>   <artifactId>HelloFriend</artifactId> </p><p>   <version>0.0.1-SNAPSHOT</version> </p><p>   <type>jar</type> </p><p>   <scope>compile</scope> </p>   <exclusions> <p>​     <exclusion> </p><p>​       <groupId>commons-logging</groupId> </p><p>​       <artifactId>commons-logging</artifactId> </p><p>​     </exclusion> </p>   </exclusions> </dependency> <p>[3]排除后的效果 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps14.png" alt="img"> </p><p>⑤统一管理所依赖jar包的版本 </p><p>对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将jar包的版本信息统一提</p><p>取出来 </p><p>[1]统一声明版本号 </p><properties> <p>   &lt;atguigu.spring.version&gt;4.1.1.RELEASE&lt;/atguigu.spring.version&gt; </p></properties> <p>其中atguigu.spring.version部分是自定义标签。 </p><p>[2]引用前面声明的版本号 </p><dependencies>    <dependency> <p>​     <groupId>org.springframework</groupId> </p><p>​     <artifactId>spring-core</artifactId> </p><p>​     <version>${atguigu.spring.version}</version> </p>   </dependency> <p>…… </p></dependencies> <p>[3]其他用法 </p><properties> <p>   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; </p></properties> <p>⑥依赖的原则：解决 jar 包冲突 </p><p>[1]路径最短者优先 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps15.png" alt="img"> </p><p>[2]路径相同时先声明者优先 </p><p>  <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps16.png" alt="img"> 这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 </p><p>8 仓库 </p><p>8.1 分类 </p><p>[1]本地仓库：为当前本机电脑上的所有 Maven 工程服务。 </p><p>[2]远程仓库 </p><p>(1)私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps17.png" alt="img"> </p><p>(2)中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。 </p><p>(3)中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 </p><p>8.2 仓库中的文件 </p><p>[1]Maven 的插件 </p><p>[2]我们自己开发的项目的模块 </p><p>[3]第三方框架或工具的 jar 包 </p><p>※不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。 </p><p>9 生命周期 </p><p>9.1 什么是 Maven 的生命周期？ </p><p>●Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 </p><p>●Maven 有三套相互独立的生命周期，分别是： </p><p>①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 </p><p>②Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 </p><p>③Site Lifecycle 生成项目报告，站点，发布站点。 </p><p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 </p><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 </p><p>9.2 Clean 生命周期 </p><p>Clean 生命周期一共包含了三个阶段： </p><p>①pre-clean 执行一些需要在 clean 之前完成的工作 </p><p>②clean 移除所有上一次构建生成的文件 </p><p>③post-clean 执行一些需要在 clean 之后立刻完成的工作 </p><p>9.3 Site 生命周期 </p><p>①pre-site 执行一些需要在生成站点文档之前完成的工作 </p><p>②site 生成项目的站点文档 </p><p>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 </p><p>④site-deploy 将生成的站点文档部署到特定的服务器上 </p><p>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 </p><p>9.4 Default 生命周期 </p><p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources </p><p>generate-resources </p><p>process-resources 复制并处理资源文件，至目标目录，准备打包。 </p><p>compile 编译项目的源代码。 </p><p>process-classes generate-test-sources process-test-sources </p><p>generate-test-resources </p><p>process-test-resources 复制并处理资源文件，至目标测试目录。 </p><p>test-compile 编译测试源代码。 </p><p>process-test-classes </p><p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 </p><p>prepare-package </p><p>package 接受编译好的代码，打包成可发布的格式，如 JAR。 </p><p>pre-integration-test integration-test post-integration-test verify </p><p>install 将包安装至本地仓库，以让其它项目依赖。 </p><p>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 </p><p>9.5 生命周期与自动化构建 </p><p>运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。 </p><p>10 插件和目标 </p><p>●Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。 </p><p>●每个插件都能实现多个功能，每个功能就是一个插件目标。 </p><p>●Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。 </p><p>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 </p><p>11 继承 </p><p>11.1 为什么需要继承机制？由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如： </p><table><thead><tr><th>Hello</th><th><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version> <scope>test</scope> </dependency></th></tr></thead><tbody><tr><td>HelloFriend</td><td><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version></td></tr><tr><td></td><td><scope>test</scope> </dependency></td></tr><tr><td>MakeFriend</td><td><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version> <scope>test</scope> </dependency></td></tr></tbody></table><p>此时如果项目需要将各个模块的junit版本统一为 4.9，那么到各个工程中手动修改无疑是非常不可取的。</p><p>使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。 </p><p>11.2 创建父工程创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是：打包方式处要设置为 pom。 </p><p>11.3 在子工程中引用父工程 </p><parent> <p>​     <!-- 父工程坐标 --> </p><p><groupId>…</groupId> </p><p>​     <artifactId>…</artifactId> </p><p>​     <version>…</version> </p><p>​     <relativePath>从当前目录到父项目的 pom.xml 文件的相对路径</relativePath> </p></parent> <parent> <p> <groupId>com.atguigu.maven</groupId> </p><p> <artifactId>Parent</artifactId> </p><h1 id="0-0-1-SNAPSHOT"><a href="#0-0-1-SNAPSHOT" class="headerlink" title="0.0.1-SNAPSHOT"></a><version>0.0.1-SNAPSHOT</version></h1> <!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --> <p> <relativePath>../Parent/pom.xml</relativePath> </p></parent> <p> 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 </p><p>11.4 在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来 </p><dependencyManagement>  <dependencies>  <dependency> <p>  <groupId>junit</groupId> </p><p>  <artifactId>junit</artifactId> </p><p>  <version>4.9</version> </p><p>  <scope>test</scope> </p> </dependency>  </dependencies> </dependencyManagement> <p>在子项目中重新指定需要的依赖，删除范围和版本号 </p><dependencies>  <dependency> <p> <groupId>junit</groupId> </p><p> <artifactId>junit</artifactId> </p> </dependency> </dependencies> <p>12 聚合 </p><p>12.1 为什么要使用聚合？ </p><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 </p><p>12.2 如何配置聚合？在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 </p><modules> <p> <module>../Hello</module> </p><h1 id="HelloFriend-MakeFriends"><a href="#HelloFriend-MakeFriends" class="headerlink" title="../HelloFriend ../MakeFriends"></a><module>../HelloFriend</module> <module>../MakeFriends</module></h1></modules> <p>13 Maven 酷站我们可以到 <a href="http://mvnrepository.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84">http://mvnrepository.com/搜索需要的</a> jar 包的依赖信息。 </p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>javaweb Summery</title>
    <link href="http://example.com/2021/06/20/javaweb-Summery/"/>
    <id>http://example.com/2021/06/20/javaweb-Summery/</id>
    <published>2021-06-20T12:03:20.000Z</published>
    <updated>2021-06-20T12:36:01.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;                    &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;                        &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;                        &lt;/body&gt;            &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例        * 案例：公司简介            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;ch&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;黑马程序员简介&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                        &lt;h1&gt;                公司简介            &lt;/h1&gt;            &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;p&gt;            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。            &lt;/p&gt;                        &lt;p&gt;            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。            &lt;/p&gt;                        &lt;p&gt;                        黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。            &lt;/p&gt;                        &lt;p&gt;                        一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。            &lt;/p&gt;                        &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                &lt;center&gt;                    江苏传智播客教育科技股份有限公司&lt;br&gt;                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                &lt;/center&gt;            &lt;/font&gt;</code></pre><p>​<br>​                </p><pre><code>            &lt;/body&gt;            &lt;/html&gt;    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;4. 代码实现    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;黑马旅游网&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            &lt;!--采用table来完成布局--&gt;        &lt;!--最外层的table，用于整个页面的布局--&gt;        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;           &lt;!-- 第1行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第2行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第3行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;                            &lt;td&gt;                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第4行 轮播图 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第5行 黑马精选--&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;                    黑马精选                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第6行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第7行 国内游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;                    国内游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第8行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第9行 境外游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;                    境外游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第10行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第11行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第12行 --&gt;            &lt;tr&gt;                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    江苏传智播客教育科技股份有限公司                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                    &lt;/font&gt;                &lt;/td&gt;            &lt;/tr&gt;                    &lt;/table&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><pre><code>1. HTML标签：表单标签2. CSS：</code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性</code></pre><p>​        </p><pre><code>    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;注册页面&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0px;            padding: 0px;            box-sizing: border-box;        &#125;        body&#123;            background: url(&quot;img/register_bg.png&quot;) no-repeat center;            padding-top: 25px;        &#125;            .rg_layout&#123;            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;            background-color: white;            /*让div水平居中*/            margin: auto;        &#125;            .rg_left&#123;            /*border: 1px solid red;*/            float: left;            margin: 15px;        &#125;        .rg_left &gt; p:first-child&#123;            color:#FFD026;            font-size: 20px;        &#125;            .rg_left &gt; p:last-child&#123;            color:#A6A6A6;            font-size: 20px;            &#125;</code></pre><p>​        </p><pre><code>        .rg_center&#123;            float: left;           /* border: 1px solid red;*/            &#125;            .rg_right&#123;            /*border: 1px solid red;*/            float: right;            margin: 15px;        &#125;            .rg_right &gt; p:first-child&#123;            font-size: 15px;            &#125;        .rg_right p a &#123;            color:pink;        &#125;            .td_left&#123;            width: 100px;            text-align: right;            height: 45px;        &#125;        .td_right&#123;            padding-left: 50px ;        &#125;            #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        &#125;        #checkcode&#123;            width: 110px;        &#125;            #img_check&#123;            height: 32px;            vertical-align: middle;        &#125;            #btn_sub&#123;            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        &#125;        &lt;/style&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;</code></pre><p>​        </p><pre><code>                        &lt;tr&gt;                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/form&gt;</code></pre><p>​        </p><pre><code>            &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>GIT 常用命令</title>
    <link href="http://example.com/2021/06/20/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/06/20/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-06-20T12:02:39.000Z</published>
    <updated>2021-06-20T12:34:57.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT常用命令"><a href="#GIT常用命令" class="headerlink" title="GIT常用命令"></a>GIT常用命令</h1><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>Git branch -v</td><td>查看当前分支</td></tr><tr><td>Git branch hot-fix</td><td>添加热分支（紧急修复）</td></tr><tr><td>Git checkout  分支名</td><td>切换当前分支</td></tr><tr><td>Git merge  分支名</td><td>合并分支（没有产生合并冲突）</td></tr><tr><td>手动更改合文件 vim</td><td>合并分支（产生合并冲突）</td></tr><tr><td></td><td></td></tr></tbody></table><p>冲突产生的原因：</p><p>合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替</p><p>我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network summery  网络层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-06-20T12:01:53.000Z</published>
    <updated>2021-07-04T07:51:18.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-network-summery-网络层"><a href="#Computer-network-summery-网络层" class="headerlink" title="Computer network summery :网络层"></a>Computer network summery :网络层</h1><h2 id="一、功能和服务"><a href="#一、功能和服务" class="headerlink" title="一、功能和服务"></a>一、功能和服务</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><ul><li><p>路由器不运行应用层和运输层协议</p></li><li><p>功能：转发和路由选择</p></li><li><p> 网络层只向上提供简单灵活的，无连接的，尽力而为的<strong>数据报服务</strong></p></li><li><p>路由选择：网络层决定分组所采用的路径或路由；计算方法是<strong>路由选择算法</strong>( routing algorithm)</p></li><li><p>路由器都具有一张<strong>转发表</strong> (fOlwarding tahle) </p></li><li><p>某些网络体系结构也要求在数据报在路径中流动之前建立连接</p><p>​    例如：ATM 、帧中继、 MPLS</p></li></ul><h3 id="1-2-交换机"><a href="#1-2-交换机" class="headerlink" title="1.2 交换机"></a>1.2 交换机</h3><p>某些分组交换机称为</p><p>链路层交换机(link-Iayer switches) </p><p>其他分组交换机称为路由器( router) </p><h3 id="1-3-服务模型"><a href="#1-3-服务模型" class="headerlink" title="1.3 服务模型"></a>1.3 服务模型</h3><p>定义了分组在发送与接收端系统之间的端到端运输特性</p><ul><li>网络层提供的特定服务<ul><li>确保支付</li><li>具有时延上界的确 保交付</li><li>有序分组支付</li><li>确保最小带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li><li>网络层提供尽力而为服务</li></ul><h3 id="1-4虚电路和数据报网络"><a href="#1-4虚电路和数据报网络" class="headerlink" title="1.4虚电路和数据报网络"></a>1.4虚电路和数据报网络</h3><ul><li>与运输层类似，网络层也能够在两台主机之间提供无连接服务或连接服务</li></ul><ol><li><p><strong>虚电路网络</strong>:仅在网络层提供连接服务的计算机网络</p></li><li><p><strong>数据报网络</strong>:仅在网络层提供无连接服务的计算机网络</p></li><li><p>几乎所有主要计算机网络体系中都不<strong>同时</strong>提供两种服务</p></li><li><p>与运输层的<strong>区别</strong>：运输层服务在端系统中实现，网络层连接服务在端系统中，也在位于网络核心的路由器中实现</p></li><li><p>虚电路网络和数据报网络是计算机网络的两种基本类型 作出转发时，使用了非常不同的信息。</p></li></ol><ul><li><p>虚电路网络</p></li><li><p>数据报网络</p><ul><li><p>端系统要发送分组—&gt;就为该分组加上目的端系统的地</p><p>址，—&gt;将分组推进网络中  </p><p>无需建立任何虚电路，路由器不维护任何虚电路的状态信息</p></li></ul></li></ul><h2 id="二、路由转发"><a href="#二、路由转发" class="headerlink" title="二、路由转发"></a>二、路由转发</h2><h3 id="1、路由器："><a href="#1、路由器：" class="headerlink" title="1、路由器："></a>1、路由器：</h3><ul><li><p>结构</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528204542791.png" alt="image-20210528204542791"></p><ul><li>输入端口：与物理链路相连</li><li>交换结构：网络路由器中的网络</li><li>输出端口：存储和传输交换结构传出的分组</li><li>路由选择处理器：执行路由选择协议</li></ul></li></ul><h3 id="2、输入端口"><a href="#2、输入端口" class="headerlink" title="2、输入端口"></a>2、输入端口</h3><ul><li>输入端口的处理<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205032133.png" alt="image-20210528205032133"></li><li>从链路接收分组，对分组进行处理，通过路由表查找某分组的输出端口，发送到交换结构。</li><li>阻塞的分组在输入端口进行排队</li></ul></li></ul><h3 id="3、交换结构"><a href="#3、交换结构" class="headerlink" title="3、交换结构"></a>3、交换结构</h3><ul><li><p>交换结构：核心部位</p><ul><li><p>三种交换技术：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205614574.png" alt="image-20210528205614574"></p><ul><li><p>内存交换</p></li><li><p>总线交换</p></li><li><p>互联网络交换</p><p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p></li></ul></li></ul></li></ul><h3 id="4、输出端口"><a href="#4、输出端口" class="headerlink" title="4、输出端口"></a>4、输出端口</h3><ul><li>输出端口<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205817371.png" alt="image-20210528205817371"></li><li>选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能</li></ul></li><li>排队（拥塞）<ul><li>输入线路速率，比输出速率大，路由器空间耗尽，后到达的分组会丢包</li></ul></li></ul><h2 id="三、网际协议-IP"><a href="#三、网际协议-IP" class="headerlink" title="三、网际协议 IP"></a>三、网际协议 IP</h2><ul><li><p>TCP/IP 体系中最重要的协议之一</p></li><li><p>与IP配套使用的相关协议由IGMP、ARP、ICMP等</p></li><li><p>通过IP协议使不同的网络在逻辑层面互相连接（虚拟连接）</p></li><li><p>通过IP区分不同的网络，一个网络可以由多种异构网络构成</p></li><li></li></ul><p>因特网中的转发和编址</p><ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211114845.png" alt="image-20210528211114845"></li></ul><h3 id="1、数据报格式"><a href="#1、数据报格式" class="headerlink" title="1、数据报格式"></a>1、数据报格式</h3><p>（IPv4）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211224903.png" alt="image-20210528211224903"></p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本号</td><td align="center">IPv4/IPv6</td></tr><tr><td align="center">首部长度</td><td align="center">一般20字节</td></tr><tr><td align="center">服务类型</td><td align="center">服务类型</td></tr><tr><td align="center">数据报长度</td><td align="center">IP数据报总长度</td></tr><tr><td align="center">标识、标志、片偏移</td><td align="center">与ip分片有关的标示量</td></tr><tr><td align="center">寿命</td><td align="center">寿命 (Time-To- Live TTL)；避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源和目的IP</td><td align="center">转发的地址</td></tr><tr><td align="center">选项</td><td align="center">选项字段 首部扩展（超过20字节）</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table><h3 id="2、数据报分片"><a href="#2、数据报分片" class="headerlink" title="2、数据报分片"></a>2、数据报分片</h3><ul><li><p>数据报不能超过链路层所能承受的最大网络层分组</p></li><li><p>数据报过大时，进行分组，分成的较小数据报叫做片</p></li><li><p>片在目的地端系统进行重新组装，而不是路由器（简便网络内核）</p></li><li><p>发送方为它发送的每个数据报的标识号加1；也就是同一数据报，不同的片 标志相同</p></li><li><p>分片之后转发的片中，最后一个片的标志比特被设为0 ，而所有其他片的标志比特被设为1，</p></li><li><p>偏移字段指定该片应放在初始 数据报的哪个位置</p></li></ul><h3 id="3、IP编址"><a href="#3、IP编址" class="headerlink" title="3、IP编址"></a>3、IP编址</h3><ul><li>网络IP编制涉及以下几个问题：<ul><li>子网划分</li><li>分类的IP地址</li><li>子网掩码</li></ul></li></ul><p><strong>3.1 IP地址分类</strong>：</p><ul><li><p>a类地址：1~126<br>127被lookupback（回环地址）占用–》测试tcp/ip协议的是否正常，任何一台计算机上都有这个地址，这个地址代表本机（127.0.0.1）<br>网络+主机+主机+主机<br>1.0.0.0/8 –》google –》2^24 = 16777216<br>1.0.0.1 1.0.0.2<br>2.0.0.0/8 –&gt;Harvard<br>3.0.0.0/8 –&gt;ibm<br>4.0.0.0/8 –&gt;microsoft</p></li><li><p>b类地址：128~191<br>网络+网络+主机+主机<br>网络的个数：2^14 = 16384<br>每个网络里可以容纳的主机数=2^16 -2<br>129.1.0.0/16</p></li><li><p>c类地址：192~223<br>网络+网络+网络+主机<br>网络的个数：2^21 = 2097152<br>每个网络里可以容纳的主机数=2^8 - 2 =254<br>主机部分全为0代表网段<br>主机部分全为1代表这个网段的广播地址</p></li><li><p>d类：224~239拥有组播通信</p></li><li><p>E类：240~255 保留给科学研究使用</p><!--公网上使用的ip地址是A,B,C类--></li><li><p>私有地址</p><ul><li>满足企业用户在内部网络中使用的需求</li><li>私有地址不能在Internet上使用</li><li>私有地址包括3组<br>A类：10.0.0.0<del>10.255.255.255<br>B类：172.16.0.0</del>172.31.255.255<br>C类：192.168.0.0~192.168.255.255</li></ul></li></ul><p> <strong>具体详解：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">1. A类IP地址</span><br><span class="line">   1.1 网络号——占1个字节</span><br><span class="line">   A类地址的网络号字段占1个字节，但前面的1位(0)已经固定，只剩下7位可以进行分配。即可指派的网络号是126个(即2^7-2)。</span><br><span class="line">   网络号字段为全0的IP地址是个保留地址，意思是“本网络”。</span><br><span class="line">   网络号为127(即01111111)保留作为本地软件环回测试(loopback test)本主机的进程之间的通信只用。</span><br><span class="line">   若主机发送一个目的地址为环回地址(例如 127.0.0.1)的IP数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。</span><br><span class="line">   目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。。</span><br><span class="line">   1.2 主机号——占3个字节</span><br><span class="line">   A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是2^24-2，即16777214。</span><br><span class="line">   全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为5.6.7.8，则该主机所在的网络地址就是5.0.0.0)。</span><br><span class="line">   全1的主机号字段表示该IP地址是“所有的”，即该网络上的所有主机。</span><br><span class="line">   注：IP地址空间共有2^32(即4294967296)个地址。整个A类地址空间共有2^31个地址，占有整个IP地址空间的50%。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. B类IP地址</span><br><span class="line">   2.1 网络号——占2个字节</span><br><span class="line">   B类地址的网络号字段占2个字节，但前面的2位(1 0)已经固定，只剩下14位可以进行分配。</span><br><span class="line">   B类网络地址128.0.0.0是不指派的，而可以指派的B类最小网络地址是128.1.0.0。因此B类地址可指派的网络数是2^14-1，即16383。</span><br><span class="line">   2.2 主机号——占2个字节</span><br><span class="line">   B类地址的每一个网络上的最大主机数是2^16-2，即65534，这里需要减2是因为要扣除全0和全1的主机号。</span><br><span class="line">   注：整个B类地址空间共约2^30个地址，占有整个IP地址空间的25%。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. C类IP地址</span><br><span class="line">   3.1 网络号——占3个字节</span><br><span class="line">   C类地址的网络号字段占3个字节，但前面的3位(1 1 0)已经固定，只剩下21位可以进行分配。</span><br><span class="line"></span><br><span class="line">   C类网络地址192.0.0.0是不指派的，而可以指派的C类最小网络地址是192.0.1.0。因此B类地址可指派的网络数是2^21-1，即2097151。</span><br><span class="line"></span><br><span class="line">   3.2 主机号——占1个字节</span><br><span class="line">   C类地址的每一个网络上的最大主机数是2^8-2，即254，这里需要减2是因为要扣除全0和全1的主机号。</span><br><span class="line">   注：整个C类地址空间共约2^29个地址，占有整个IP地址空间的12.5%。</span><br><span class="line"></span><br><span class="line">一些特殊的网络地址：</span><br><span class="line">一、0.0.0.0</span><br><span class="line">严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。</span><br><span class="line">二、255.255.255.255</span><br><span class="line">限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。</span><br><span class="line">三、127.0.0.1</span><br><span class="line">本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。</span><br><span class="line">四、224.0.0.1</span><br><span class="line">组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP(Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。</span><br><span class="line">五、169.254.X.X</span><br><span class="line">如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</span><br><span class="line">六、10.X.X.X、172.16.X.X～172.31.X.X、192.168.X.X</span><br><span class="line">私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。</span><br><span class="line">七，广播地址(Broadcast Address)</span><br><span class="line">是专门用于同时向网络中（通常指同一子网）所有工作站进行发送的一个地址。在使用TCP&#x2F;IP 协议的网络中，主机标识段host ID（简称主机 ID） 为全 1 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为 2 进制的 11111111 ），当发出一个目的地址为10.1.1.255 的数据包时，它将被分发给该网段上的所有计算机。广播地址应用于网络内的所有主机。</span><br><span class="line">八，网络地址</span><br><span class="line">指的是互联网上的节点在网络中具有的逻辑地址，可对节点进行寻址。主机地址指的是IP地址右边部分用来标识主机本身的部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个 IP地址的网络部分被称为网络号或者网络地址,主机可以与具有相同的网络号的设备直接通讯，在没有连接设备的情况下，即使共享相同的物理网段，网络号不同则无法进行通讯，IP 地址的网络地址使路由器可以将分组置于正确的网段上 。</span><br></pre></td></tr></table></figure><p><strong>2.子网掩码：</strong><br>16 表示网络部分的长度 –》子网掩码也是32位<br>作用：标识ip地址里网络部分的长度<br>用来确定IP的网络地址<br>11111111.11111111.00000000.00000000</p><p>32个二进制位<br>对应IP地址的网络部分用1表示<br>对应IP地址的主机部分用0表示<br>IP地址和子网掩码作逻辑“与”运算得到网络地址</p><p>0和任何数相与都等于0<br>1和任何数相与都等于任何数本身</p><p>网段：就是网络部分的内容<br>192.168.0.4/24 –&gt;192.168.0.0</p><p>A、B、C三类地址的默认子网掩码<br>A类：255.0.0.0<br>B类：255.255.0.0<br>C类：255.255.255.0</p><p><strong>3.子网划分：</strong></p><p>将一个大网络划分为许多的小网络（网络位向主机位借位）<br>子网划分的原因：</p><ul><li>满足不同网络对IP地址的需求</li><li>实现网络的层次性</li></ul><h3 id="4、互联网控制报文协议-ICMP"><a href="#4、互联网控制报文协议-ICMP" class="headerlink" title="4、互联网控制报文协议 (ICMP)"></a>4、互联网控制报文协议 (ICMP)</h3><ul><li><p>主机和路由器用来彼此沟通网络层的信息，用来进行差错报告。</p></li><li><p>ICMP报文是承载在ip 分组中，但是也被看做ip的一部分</p></li><li><p>ICMP协议的功能主要是：</p><ul><li><ol><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ol></li></ul></li><li><p>ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6</p></li><li><p><strong>ICMP的报文格式</strong><br>ICMP报文包含在IP数据报中 。</p><p>​    一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）    和ICMP报文（属于ICMP报文的数据部分）<strong>。当IP报头中的协议字段值    为1时，就说明这是一个ICMP报文。</strong>ICMP报头如下图所示。<br> <img src="https://img-blog.csdn.net/201805301801365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>字段说明：</p><ul><li>类型    一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</li><li>代码    占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</li><li>校验和    这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与在我们介绍IP报头中的校验和计算方法是一样的） </li></ul></li><li></li><li><p>ICMP报文分类：</p><ul><li><p>一类是通知出错原因 （差错报告报文）；</p></li><li><p>一类是用于诊断查询（询问报文）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210704145410714.png" alt="image-20210704145410714"></p></li></ul></li><li><p>众所周知的 ping 程序发送一个 ICMP 类型 编码 的报文到指定主机</p></li></ul><h3 id="5、IGMP网际组管理协议"><a href="#5、IGMP网际组管理协议" class="headerlink" title="5、IGMP网际组管理协议"></a>5、IGMP网际组管理协议</h3><h3 id="6、arp地址解析协议"><a href="#6、arp地址解析协议" class="headerlink" title="6、arp地址解析协议"></a>6、arp地址解析协议</h3><ul><li>逆地址解析协议RARP（现在几乎已经不使用了）</li><li>具体功能是：由IP地址解析得到硬件地址（MAC）</li></ul><p>1.要点</p><ul><li>在主机的高速缓存ARP 缓存中存放一个IP到硬件地址的动态映射表<ul><li>通过响应分组和请求分组动态获取想要发送的IP的未知硬件地址</li><li>响应分组是单播；请求分组是广播</li><li>每一个地址映射信息都有生存时间</li></ul></li></ul><h3 id="7、ipv6"><a href="#7、ipv6" class="headerlink" title="7、ipv6"></a>7、ipv6</h3><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528213948939.png" alt="image-20210528213948939"></p><p><strong>概述</strong></p><ul><li><p>解决ipv4地址不足的问题</p></li><li><p>报文结构</p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本</td><td align="center">IPv4/IPv6                         4比特</td></tr><tr><td align="center">流标签</td><td align="center">于标识一条数据报的流    20比特</td></tr><tr><td align="center">流量类型</td><td align="center">与TOS 字段的含义相似   8比特</td></tr><tr><td align="center">有效负载长度</td><td align="center">IP首部后数据字节数量  16比特</td></tr><tr><td align="center">下一个首部</td><td align="center">标识数据包交付对象（TCP/UDP ）</td></tr><tr><td align="center">跳限制</td><td align="center">与TTL类似  避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源地址</td><td align="center">128比特</td></tr><tr><td align="center">目的地址</td><td align="center">128比特</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table></li><li><p>IPv6首部40字节</p></li></ul><p><strong>相对ipv4特点（不同）：</strong></p><ul><li>不允许在中间路由器上进行分片与重新组装，只能在源与目的地上执行———-没有了分片标志</li><li>没有首部检验和字段，检验在运输层和数据链路层中完成</li><li>没有选项字段，删除选项字段使得 IP 首部成为定长的 40 字节</li><li>地址容量扩大了</li><li>拥有流标签和优先级</li></ul><h2 id="四、路由选择算法"><a href="#四、路由选择算法" class="headerlink" title="四、路由选择算法"></a>四、路由选择算法</h2><p>主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器 (default router) , 又称为该主机的第一跳路由器 (first- hop router）</p><p>源主机的默认路由器称作源路由器( source 川出r) ，把目的主机的默认路由器称作目的路由器 (destination router)</p><p>一个分组从源主机到目的主机的路由选择的较好 方法即路由选择算法</p><p>在两个路由之间根据链路开销，存在一条或者多条最低开销路径。</p><p>最低开销路径也就是最短路径———————最短路径算法SPF；</p><p><strong>路由控制</strong></p><ul><li><p>每路由控制。</p><p>每台路由器中运行一种路由选择算法的情况，每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。这种每路由器控制的方法在因特网中已经使用了几十年。</p><p>OSPF和BGP协议都是基于这种每路由器的方法进行控制的。</p></li><li><p>逻辑集中式控制。</p><p>逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况。通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能(负载共享、防火墙功能、NAT)的丰富集合，而这些功能先前是在单独的中间盒中实现的。</p><p>SDN采用了逻辑集中控制器的概念，而这种方法在生产部署中得到了越来越多的应用。</p></li></ul><h4 id="1-路由选择算法"><a href="#1-路由选择算法" class="headerlink" title="1.路由选择算法"></a>1.路由选择算法</h4><p><strong>分类：</strong></p><ul><li><p><code>全局式路由选择算法</code> (globaJ routing aJgorithm) </p><p>：用完整的、全局性的网络知识计算从源到目的地之间的最低开销路径，即 以所有结点之间的连通</p><p>性及所有链路的费用为输入</p><p>例：链路状态算法  LS  </p><p>​       适应每路由和逻辑集中控制：路由计算可以在集中式路由选择器 开门中，也可以在每台路由器的路优选择组件</p></li></ul><p>​        <code>分散式路由选择算法**</code> (dece t.ralized routing aJgorithm)</p><p>​                以迭代、分布式的方式计算最低开销路径 ，没有结点拥有关于所有网络链路费用的完整信息，                而每个结点仅有与其直接相连链路的费用知识即可开始工作</p><p>​        例：距离向量算法 DV   </p><p>​                天然适应逻辑集中式控制</p><ul><li><p><code>静态路由选择算法</code> (SlaLÌc rouling aJgorithm)：**手工配置、路由更新慢、优先级高</p><p>简单，开销小，但不能及时适应网络状态的变化，适用于小型网络。</p><p><code>动态路由选择算法</code>(dynamic rouling aJ gorithm)**：路由更新快（定期更新、及时响应链路费用或网络拓扑变化）</p><p>能较好地适应网络状态的变化，实现较为复杂，适用于大型网络。</p><p>容易受到路优选择循环、路由震荡的影响</p></li><li><p><code>负载敏感算法</code> load-sensiLÌve aJ gorithm)</p><p>：链路开销动态变化，反映当前链路底层链路的拥塞水平</p><p><code>负载迟钝算法</code>(load-insensitive) </p><p>当今的路由选择算法都是负载迟钝的。</p></li></ul><p><strong>常见算法：</strong></p><ul><li><p>电路交换路由选择算 (circuiL- swiLched routing algorith m)</p></li><li><p>距离向量(Distance- Vector, DV) 算法</p><ul><li>路由器周期性地向其相邻路由器广播自己知道的路由信息，用以通知相邻路由器自己可以到达的网络以及到达该网络的距离。相邻路由器可以根据收到的路由信息修改和刷新自己的路由表。</li><li>优点：算法简单、易于实现。</li><li>缺点：慢收敛问题，路由器的路径变化需要像波浪一样从相邻路由器传播出去，过程缓慢。</li></ul></li><li><p>链路状态广播 (link state broadcast) 算法 </p><ul><li>也叫最短路径优先(shortest path first SPF)算法，它的主要做法如下：<ul><li>首先由路由器向相邻路由器发送查询报文，测试和它相邻路由器的链路状态。如果可以收到相邻路由器发回的响应，则说明该相邻路由器和这个路由器之间可以正常通信；</li><li>在收到该路由器和其他相邻路由器的链路状态后，还向系统中所有参加最短路径优先算法的路由器发送链路状态报文；</li><li>各路由器收到其他路由器发来的链路状态报文后，根据报文中的数据刷新本路由器所保存的网络拓扑结构图。如果链路发生变化，路由器将启用Dijkstra算法生成新的最短路径优先数，并刷新本地路由表；</li></ul></li></ul></li></ul><p><em><strong>分层次的路由选择协议：</strong></em></p><p>因特网采用的路由选择协议主要是<strong>自适应的、动态的、分布式的、分层次的</strong>路由选择协议。</p><p><em><strong>自治系统（autonomous system,AS）</strong></em></p><p> 就是几个路由器组成了一个小团体，小团体内部使用专用的协议进行通信，而小团体和小团体之间也使用专用的协议进行通信。</p><p>目前的因特网中，ISP就是一个自治系统。</p><h2 id="五、路由选择协议"><a href="#五、路由选择协议" class="headerlink" title="五、路由选择协议"></a>五、路由选择协议</h2><p>计算出用于在网络中转发分组的转发表</p><p>两种 AS 内部路由选择协议 (RIP/OSPF) 和一种 AS 间路由选择协议 (BGP)</p><h3 id="1、AS-内部路由选择协议"><a href="#1、AS-内部路由选择协议" class="headerlink" title="1、AS 内部路由选择协议"></a>1、AS 内部路由选择协议</h3><h4 id="1-1-路由信息协议-RIP"><a href="#1-1-路由信息协议-RIP" class="headerlink" title="1.1 路由信息协议 RIP"></a>1.1 路由信息协议 RIP</h4><p> (Routing Information Protocol)</p><p>✅ 它是一种分布式的、基于距离向量的路由选择协议。<br>✅ 它要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。<br><strong>关于距离的定义：</strong></p><p>从一个路由器到直接连接的网络的距离定义为 1。<br>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。<br>“距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。<br>这里的“距离”实际上指的是“最短距离”。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p><p>RIP 允许一条路径最多只能包含 15 个路由器。</p><p>这意味着 RIP 只会选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p><p><strong>RIP 协议的三个特点:</strong></p><ul><li><p>仅和相邻路由器交换信息。</p></li><li><p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</p></li><li><p>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p><p><strong>AS（自治系统）之内的路由器如何建立路由表？</strong></p></li></ul><p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。它的路由表是空的。以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。<br>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。<br>RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</p><p> <strong>RIP2的报文格式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414151233228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>RIP2 报文由首部和路由部分组成。</p><ul><li>RIP2 报文中的路由部分由若干个路由信息组成。</li><li>地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</li><li>路由标记填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。</li><li>再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。</li></ul><p>一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4 + 20 × 25 = 504 4+20\times25=5044+20×25=504字节。如超过，必须再用一个 RIP 报文来传送。</p><h4 id="1-2-开放最短路径优先-OSPF"><a href="#1-2-开放最短路径优先-OSPF" class="headerlink" title="1.2 开放最短路径优先 OSPF"></a>1.2 开放最短路径优先 OSPF</h4><ul><li><p>OSPF (Open Shortest Path First) 是为克服 RIP 的缺点在<code>1989</code>年开发出来的。</p></li><li><p>使用了 Dijkstra 提出的最短路径算法 SPF</p></li></ul><p><strong>区域</strong></p><p>OSPF 将一个自治系统再划分为若干个更小的范围，叫作<code>区域</code>。</p><p>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</p><p><img src="https://img-blog.csdnimg.cn/20200414174248189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>OSPF 使用 IP 数据报传送：</strong></p><ul><li>✅ OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>✅ OSPF 构成的数据报很短。好处是可以不必将长的数据报分片传送。</li><li>✅ 支持可变长度的子网划分和无分类编址 CIDR。</li></ul><p><strong>OSPF 分组</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414174524743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>五种分组类型</p><p>1️⃣ 类型1：问候 (Hello) 分组。<br>2️⃣ 类型2：数据库描述 (Database Description) 分组。<br>3️⃣ 类型3：链路状态请求 (Link State Request) 分组。<br>4️⃣ 类型4：链路状态更新 (Link State Update) 分组，用洪泛法对全网更新链路状态。<br>5️⃣ 类型5：链路状态确认 (Link State Acknowledgment) 分组。</p><h3 id="2、AS-间路由选择协议"><a href="#2、AS-间路由选择协议" class="headerlink" title="2、AS 间路由选择协议"></a>2、AS 间路由选择协议</h3><p> <strong>(边界网关协议 BGP）</strong></p><ul><li><p>BGP 是不同自治系统的路由器之间交换路由信息的协议</p></li><li><p>要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200414174933546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>BGP-4 共使用四种报文</strong> </p><ol><li> 打开 (OPEN) 报文：用来与相邻的另一个BGP发言人建立关系。</li><li> 更新 (UPDATE) 报文：用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li> 保活 (KEEPALIVE) 报文：用来确认打开报文和周期性地证实邻站关系。</li><li> 通知 (NOTIFICATION) 报文：用来发送检测到的差错。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200414175219726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="六、简单网络管理协议（SNMP）"><a href="#六、简单网络管理协议（SNMP）" class="headerlink" title="六、简单网络管理协议（SNMP）"></a>六、简单网络管理协议（SNMP）</h2><p>基于T C P / I P的网络管理包含两个部分：网络管理站（也叫管理进程， m a n a g e r）和被管的网络单元（也叫被管设备）。被管设备端和管理相关的软件叫做代理程序( a g e n t )或代理进程。</p><p>管理进程和代理进程之间的通信可以有两种方式。一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的 I C M P端口？）。另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生。</p><p>基于T C P / I P的网络管理包含3个组成部分：</p><ol><li><p> 一个管理信息库M I B（Management Information Base）。管理信息库包含所有代理进程的所有可被查询和修改的参数。</p></li><li><p> 关于M I B的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。</p></li><li><p> 管理进程和代理进程之间的通信协议，叫做简单网络管理协议 S N M P（Simple Network Management Protocol）。</p></li></ol><p>协议<br>关于管理进程和代理进程之间的交互信息， S N M P定义了5种报文：</p><ol><li><p> get - r e q u e s t操作：从代理进程处提取一个或多个参数值。</p></li><li><p> get - n e x t - r e q u e s t操作：从代理进程处提取一个或多个参数的下一个参数值</p></li><li><p> set - r e q u e s t操作：设置代理进程的一个或多个参数值。</p></li><li><p> get - r e s p o n s e操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</p></li><li><p>t r a p 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</p></li></ol><p>前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的。</p><p>管理信息结构<br>SNMP中，数据类型不多，只有INTEGER，OCTER STRING，IPAddress等</p><p>对象标识符<br>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</p><p>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于 D N S或U n i x的文件系统</p><p> 管理信息库介绍<br>所谓管理信息库，或者M I B，就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p><p>M I B组：s y s t e m（系统标识）、i f（接口）、a t（地址转换）、i p、i c m p和t c p。</p><p>s y s t e m组非常简单，它包含7个简单变量</p><p>interface组只定义了一个简单变量，那就是系统的接口数量</p><p>i p组定义了很多简单变量和3个表格变量</p><p>i c m p组包含4个普通计数器变量（ I C M P报文的输出和输入数量以及 I C M P差错报文的输入和输出数量）和2 2个其他I C M P报文数量的计数器：11个是输出计数器，另外11个是输入计数器。</p><p>t c p组中的简单变量几乎都和T C P状态有关。</p><h2 id="七、SDN-控制平面"><a href="#七、SDN-控制平面" class="headerlink" title="七、SDN 控制平面"></a>七、SDN 控制平面</h2>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network summery  应用层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-06-20T12:01:24.000Z</published>
    <updated>2021-06-20T12:35:22.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-summery-应用层"><a href="#Computer-Network-summery-应用层" class="headerlink" title="Computer Network summery  应用层"></a>Computer Network summery  应用层</h1><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><h3 id="1-协议原理"><a href="#1-协议原理" class="headerlink" title="1.协议原理"></a>1.协议原理</h3><ul><li><p>常见的网络应用程序： Web 、电子邮件、 DNS 、对等文件分发</p></li><li><p>主要概念：应用程序的网络服务、客户和服务器、进程、运输层接口</p></li><li><p>应用软件在端系统上运行 </p></li></ul><h3 id="2-应用程序体系结构"><a href="#2-应用程序体系结构" class="headerlink" title="2.应用程序体系结构"></a>2.应用程序体系结构</h3><ul><li><p>网络应用程序体系结构：</p><ul><li><p>客户-服务器体系结构：（配备大量数据中心，创建虚拟服务器）</p><p>​                常见应用程序Telnet 、电子邮件、Web/FTP</p></li><li><p>对等P2P体系结构</p><ul><li>当前流行的、流量密集型应用  包括文件共享(例如 BitTorrenl) 、对等方协助下载加速器(例如迅雷)、因特网电话(例如 Skype) IPTV</li><li>P2P 的自扩展性 self- scalab i1 ity)</li></ul></li></ul></li></ul><h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3.进程"></a>3.进程</h3><ul><li><p>进行通信的实际上是进程，而不是程序</p></li><li><p>客户和服务器进程</p><ul><li>客户进程/服务器进程   例：web服务中，浏览器：客户进程；web服务器：服务进程</li></ul></li><li><p>API</p><ul><li><p>进程通过一个称为<strong>套接字</strong> (socket)的软件接口向网络发送报文和从网络接收报文 </p></li><li><p>套接字是建立网络应用程序的可编程接口，也称为应用程序和网络之间的<strong>应用程序编程接口</strong> (Application Programming Interface , API)</p></li><li><p>可以控制套接字在<strong>应用层端</strong>，对套接字的<strong>运输层端</strong>几乎没有控制权 </p><p>应用程序开发者对于运输层的控制仅限于：</p><p>①选择运输层协议;</p><p>②几个运输层参数</p></li></ul></li><li><p>进程寻址</p><ul><li>标识进程：目的地端口号(port number)：用来标识 运行在主机上的进程</li></ul></li></ul><h3 id="4-运输服务"><a href="#4-运输服务" class="headerlink" title="4.运输服务"></a>4.运输服务</h3><h4 id="4-1应用程序"><a href="#4-1应用程序" class="headerlink" title="4.1应用程序"></a>4.1应用程序</h4><ul><li><p>可靠数据传输：一端发送的应用数据正确、完全地交付给该应用程序的另一端</p><ul><li><p>容忍丢失的应用：能够接受不可靠传输的应用进程</p><p>例如 多媒体应用</p></li></ul></li><li><p>吞吐量：运输层协议能够以某种特定的速率提供确保的可用吞吐量</p><ul><li><p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong> (bandwidth- sensitive applicaLi on)</p></li><li><p><strong>弹性应用</strong>( el皑白 applicaLi on) 能够根据情况或多或少地利用可供使用的吞吐量</p><p>例如：电子邮件、文件传输以及 Web 传送 </p></li></ul></li><li><p>定时 </p><ul><li><p>某些服务为了有效性 ，要求数据交付有严格的时间限制</p><p>例如 :交互式实时应用程序</p></li></ul></li><li><p>安全性</p></li></ul><h4 id="4-2因特网"><a href="#4-2因特网" class="headerlink" title="4.2因特网"></a>4.2因特网</h4><ul><li><p>因特网(更一般的是 TCP/IP 网络)为应用程序提供两个运输层协议，即 UDP和 TCP</p></li><li><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527112725518.png" alt="image-20210527112725518"></p></li><li><p><strong>TCP</strong></p></li><li><p><strong>UDP</strong></p></li><li><p>互联网运输协议不能提供任何<strong>定时</strong>或<strong>带宽保证</strong></p></li><li><p>流行的因特网应用及其应用层协议和支撑的运输协议</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527113131403.png" alt="image-20210527113131403"></p></li></ul><h4 id="5-应用层协议"><a href="#5-应用层协议" class="headerlink" title="5.应用层协议"></a>5.应用层协议</h4><ul><li><p>作用：定义了运行在不同端系统上的应用程序进程如何相互传递报文：</p><ul><li>交换的报文类型，</li><li>各种报文类型的语法，</li><li>字段的语义</li><li>一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul></li><li><p>应用层协议只是网络应用的一部分</p></li><li><p>讨论几种重要的应用: Web 、文件传输、电子邮件、目录服务和P2P</p><p>以及他们的相关协议。</p></li></ul><h2 id="二、Web与HTTP"><a href="#二、Web与HTTP" class="headerlink" title="二、Web与HTTP"></a>二、Web与HTTP</h2><h3 id="1-http"><a href="#1-http" class="headerlink" title="1.http"></a>1.http</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><ul><li><p>Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) </p></li><li><p>由两个程序实现：客户端程序和服务器程序</p></li><li><p>使用TCP 作为支撑运输协议</p></li><li><p>无状态协议：不保存关于客户的任何信息</p></li><li><p>HTTP 既能够使用非持续连接，也能够使用持续连接，默认状态是持续性连接</p><ul><li>持续性连接</li><li>非持续性连接</li></ul></li></ul><h4 id="1-2报文格式"><a href="#1-2报文格式" class="headerlink" title="1.2报文格式"></a>1.2报文格式</h4><p>​    分类:请求报文和响应报文</p><ul><li><p>请求报文</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527201409324.png" alt="image-20210527201409324"></p></li></ul><p>HTTP 请求报文的第一行 <strong>请求行</strong> (request line) ，</p><p>后继的行叫做<strong>首部行</strong>( header line) </p><p>请求行有3个字段:方法字段、 URL 字段和 HTTP 版本字段 </p><p>方法宇段可以取几种不同的值，包括 GET OST HEAD PUT DELETE</p><p>Connec Li on: close 首部行</p><p>User- agent: 首部行</p><p>Accept -language 首部行</p><p>首部行 Host: www. someschool. edu</p><ul><li>请求报文通用首部格式</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202001957.png" alt="image-20210527202001957"></p><ul><li>响应报文</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202207984.png" alt="image-20210527202207984"></p><p>​                组成：一个初始状态行 (sLatus line) 、首部行 (header 1ine) 、实体体                 (enLity body)—–报文的主要部分</p><p>​                Connection: close 首部行</p><p>​                Date: 首部行</p><p>​                Server: 首部行</p><p>​                Last- Moclified: 首部行</p><p>​                Conlenl- Length: 首部行</p><p>​                Conlent- Type: 首部行</p><ul><li>响应报文通用格式：</li></ul><p>​    <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202521768.png" alt="image-20210527202521768"></p><ul><li>响应报文常见的状态码和相关的短语:</li></ul><p> 200 OK: 请求成功信息在返回的响应报文中</p><p>• 301 Movecl Pennanenùy: 请求的对象已经被永久转移了，新的 URL 定义在响应报文的LocaLi oD: 首部行中 客户软件将自动获取新的 URL</p><p>• 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解72 </p><p>• 404 Not FO lll1 d: 被请求的文档不在服务器上</p><p>• 505 HTTP Version Not Supported: 服务器不支持请求报文使用的 HTTP 协议版本</p><h4 id="1-3Cookie"><a href="#1-3Cookie" class="headerlink" title="1.3Cookie"></a>1.3Cookie</h4><ul><li><p>cookie 技术的4个组件:</p><ul><li>①在 HTTP 响应报文中的 cookie 首部行;</li><li>②在 HTTP 请求报文中的一个 cookie 首部行;</li><li>③在用户端系统中保留有 cookie件，并由用户的浏览器进行管理;</li><li>④位于 Web 站点的一个后端数据库</li></ul></li><li><p>流程：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527203342657.png" alt="image-20210527203342657"></p></li></ul><ul><li><hr></li></ul><ol><li><p>用户首次访问 个站点时，可能需要提供 个用户标识(可能是名字)</p></li><li><p>在后继会话中，浏览器向服务器传递cookie 首部，从而向该服务器标识了用户</p></li><li><p>因此 cookie 可以在无状态的 HTTP 之上建立个用户会话层 </p></li></ol><ul><li>注:它的使用仍具有争议，因为它们被认为是对用户隐私的一种侵害</li></ul><h4 id="1-4Web缓存"><a href="#1-4Web缓存" class="headerlink" title="1.4Web缓存"></a>1.4Web缓存</h4><ul><li><p><strong>Web 缓存器</strong>也叫<strong>代理服务器</strong></p></li><li><p>拥有自己的存储空间；</p></li><li><p>Web 缓存器是服务器同时又是客户（可以发送和接收响应）</p></li><li><p>部署 Web 缓存器有两个原因：</p><ul><li><p>大大减少对客户请求的响应时间</p><ul><li><p>是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之</p><p>间的瓶颈带宽时更是如此</p></li></ul></li><li><p>大大减少一个机构的接入链路到闲特网的通信量</p><ul><li>减少通信量， 不必急于增加带宽，降低了费用。</li></ul></li></ul></li></ul><p>具体详见 图解http</p><h2 id="三、文件传输协议：FTP"><a href="#三、文件传输协议：FTP" class="headerlink" title="三、文件传输协议：FTP"></a>三、文件传输协议：FTP</h2><h4 id="1-协议运行"><a href="#1-协议运行" class="headerlink" title="1. 协议运行"></a>1. 协议运行</h4><p>，用户通过一个阿?用户代理与阿?交五 该用</p><p>户首先提供远程主机的主机名，使本地主机的归?客户进程建立一个到远程主机凹?服务</p><p>器进程的 TCP 连接。该用户接着提供用户标识和口令，作为 FTP 命令的一部分在该 TCP</p><p>连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者</p><p>多个文件复制到远程文件系统(反之亦然)。</p><h4 id="2-FTP-和HTTP-的区别"><a href="#2-FTP-和HTTP-的区别" class="headerlink" title="2. FTP 和HTTP 的区别"></a>2. FTP 和HTTP 的区别</h4><h5 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1 连接"></a>2.1 连接</h5><ul><li>FTP 使用了两个并行的 TCP 连接来传输文件<ul><li>控制连接 (control connection)：在两主机之间传输控制信息</li><li>数据连接( data connection)：实际发送一个文件</li><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527205305119.png" alt="image-20210527205305119"></li></ul></li><li>HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行</li></ul><h5 id="2-2-状态"><a href="#2-2-状态" class="headerlink" title="2.2 状态"></a>2.2 状态</h5><ul><li>FTP 服务器必须在整个会话期间保留用户的状态( state)；</li><li>HTTP 是无状态的，即它不必对任何用户状态进行追踪</li></ul><h4 id="3-常见命令和回答"><a href="#3-常见命令和回答" class="headerlink" title="3.常见命令和回答"></a>3.常见命令和回答</h4><ul><li>命令和回答都是7比特 ASCII格式在控制连接上传送</li></ul><h5 id="3-1-命令"><a href="#3-1-命令" class="headerlink" title="3.1 命令"></a>3.1 命令</h5><ul><li><p>每个命令由 个大写字母 ASCII 字符组成，有些还具有可选参数</p></li><li><p>为常见的命令如下:</p><ul><li><p>USER usemame: 用于向服务器传送用户标识</p></li><li><p>P ASS password: 用于向服务器发送用户口令</p></li><li><p>UST: 用于请求服务器回送当前远程目录中的所有文件列表 该文件列表是经一个(新建且非持续连接)数据连接传送的，而不是在控制 TCP 连接上传送。</p></li><li><p>RETR filename: 用于从远程主机当前目录检索(自 gel) 文件 该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件</p></li><li><p>STOR filename: 用于在远程主机的当前目录上存放(即 put) 文件</p></li></ul></li><li><p>每个命令都对应着一个从服务器发向客户的回答。</p></li></ul><h5 id="3-2-回答"><a href="#3-2-回答" class="headerlink" title="3.2 回答"></a>3.2 回答</h5><ul><li><p>回答是一个三位数字，加上可选信息。</p></li><li><p>一些典型的回答连同它们可能的报文：</p><ul><li>331 Usemame OK , Password requüed (用户名 OK ，需要口令)</li><li>125 Dala connection already open; transfer starting (数据连接已经打开，开始传送)</li><li>425 Can’ L open daLa connection (无法打开数据连接)</li><li>452 Error writing (写文件差错)</li></ul></li></ul><h2 id="四、电子邮件"><a href="#四、电子邮件" class="headerlink" title="四、电子邮件"></a>四、电子邮件</h2><h2 id="五、DNS"><a href="#五、DNS" class="headerlink" title="五、DNS"></a>五、DNS</h2><p>因特网的目录服务</p><h2 id="六、P2P"><a href="#六、P2P" class="headerlink" title="六、P2P"></a>六、P2P</h2>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network  summery：运输层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-06-20T11:59:58.000Z</published>
    <updated>2021-07-04T08:55:55.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-summery：运输层"><a href="#Computer-Network-summery：运输层" class="headerlink" title="Computer Network  summery：运输层"></a>Computer Network  summery：运输层</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul><li><p>为运行在不同主机上的进程提供服务（逻辑通信）</p></li><li><p>运输层协议在端系统中实现，不是在路由器中实现。</p></li><li><p>应用层报文段 ：将应用层报文分块，添加运输层首部</p></li><li><p>应用层协议：TCP  / UDP</p><ul><li>TCP :面向连接的，可靠的服务</li><li>UDP：无连接的，不可靠服务</li></ul></li><li><p>网络层可能会使分组丢失，篡改，冗余，运输层可以提供可靠数据传输</p></li><li><p>多路复用和多路分解</p><ul><li><p>多路分解：运输层报文段正确交付到相应 套接字</p></li><li><p>多路复用：主机收集套接字信息，生成运输层报文，并传输到网络层中</p></li><li><p>UDP 的多路复用和分解</p><ul><li>一个UDP套接字：二元组（目的IP，目的端口号）</li></ul></li></ul></li><li><ul><li>tcp的多路复用和分解<ul><li>TCP套接字（目的IP，目的端口号，源IP，源端口号）<ul><li>后续报文段与之匹配，发送到该端口</li></ul></li><li>服务器主机支持很多并行套接字，每个与一个进程相连</li></ul></li></ul></li><li><p>== 端口扫描技术 == </p></li></ul><h2 id="二、UDP协议"><a href="#二、UDP协议" class="headerlink" title="二、UDP协议"></a>二、UDP协议</h2><p>  1.概述</p><ul><li>特点<ul><li>无需建立连接：无连接传输</li><li>分组首部开销小: 首部8个字节</li><li>控制更加精细（与应用层相比）</li><li>无连接的状态：无连接状态参数</li></ul></li><li>用于承载网络管理数据SNMP</li><li>运行的协议和服务：DNS、</li></ul><ol start="2"><li><p>报文结构‘</p><p>2.1 报文结构:</p></li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526194949625.png" alt="image-20210526194949625"></p><p>​     2.2 检验和：检测传输比特是否改变  </p><ul><li>方法：</li></ul><ul><li>原因：端到端服务需要差错检测，各链路情况不同，无法逐链路确保可靠性   即:</li></ul><h2 id="三、可靠传输原理"><a href="#三、可靠传输原理" class="headerlink" title="三、可靠传输原理"></a>三、可靠传输原理</h2><ol><li><p>流水线可靠数据传输协议</p><ul><li>不使用停等方式运行，允许发送方发送多个分组而无需等待确认， 许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，这种技术被称为流水线( pipelining)</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526195644330.png" alt="image-20210526195644330"></p><ul><li><p>流水线可靠传输协议带来的问题：</p><ul><li><p>必须增加序号范围</p></li><li><p>发送方和接收方两端也许必须缓存多个分组</p></li><li><p>解决流水线的差错恢复有两种基本方法是:回退 (Go- Back- N)</p><p>GBN) 和选择重传 (Selective Repeat. SR)</p></li></ul></li></ul></li><li><p>回退N步</p></li></ol><ol start="3"><li>选择重传</li></ol><h2 id="四、TCP协议"><a href="#四、TCP协议" class="headerlink" title="四、TCP协议"></a>四、TCP协议</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>提供的是全双工服务(full- duplex service)</li><li>TCP 连接是点对点( point-to-point) 的</li><li>连接的建立：三次握手</li><li>连接的断开：四次挥手</li><li>TCP  最大报文段长度 (Maximum Segmenl Size , MSS) ， MSS 的典型值为 1460 字节</li><li>TCP/IP 首部字段长度20字节</li><li>TCP 数据发送和接收依赖两端主机维护的接收缓存和发送缓存。应用程序从此缓存中读取数据流。（每一端都有各自的发送缓存和接收缓存）</li></ul><h3 id="2-报文结构"><a href="#2-报文结构" class="headerlink" title="2.报文结构"></a>2.报文结构</h3><p>：通常是20个字节（选项部分可变长，平常是0）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526201119908.png" alt="image-20210526201119908"></p><ul><li>32 比特的序号字段 (sequence number field) <ul><li>标记发送方数据报文段首字节的字节流编号</li></ul></li><li>32 比特的确认号字段( acknowledgment number field) <ul><li>主机 期望从主机 收到的下一字节的序号</li></ul></li><li>16 比特的接收窗口字段 (receive window field)<ul><li>用于流量控制</li></ul></li><li>可选与变长的选项字段（options field) </li><li>4 比特的首部长度字段 (header length field)</li><li>6 比特的标志字段 (fLag field) <ul><li>RST SYN FIN 比特用于连接建立和拆除</li><li>PSH ： 指示接收方应立即尽可能得将数据交给上层</li><li>URG ：指示报文段存在着被发送端的上层实体置为”紧急”的数据 紧急数据的最后一个字节由 16 比特的数据指针字段指出。</li></ul></li><li>接收窗口</li></ul><h3 id="3-累计确认"><a href="#3-累计确认" class="headerlink" title="3.累计确认"></a>3.累计确认</h3><p>对客户到服务器的数据的确认被装载在</p><p>个承载服务器到客户的数据的报文段中;这种确认被称为是被捎带( piggybacked )在服务器到客户的数据报文段中的</p><h3 id="4-超时重传"><a href="#4-超时重传" class="headerlink" title="4.超时重传"></a>4.超时重传</h3><p>4.1往返时间的估计</p><ul><li><p>样本RTT:某报文段的确认被收到之间的时间量</p><ul><li>为已发送，未确认的报文段估计 SampleRTT</li><li>不为已被重传的报文段计算 SampleRTT; </li></ul></li><li><p>SampleRTT 均值  (称为 EstimatedRTT)</p><ul><li><p>计算方法：</p><p>EstÌmatedRTT = (1 -α) . EstimatedRTT +α. SampleRTT </p></li><li><p>α的 参考值是α=0.125 </p></li></ul></li><li><p>RTT 偏差DevRTT</p><ul><li>DevRTT = (1 -β) . DevRTT +β. I SampleRTT matedRTT I </li><li>β 的推荐值为 0.25</li></ul></li><li><p>重传超时间隔</p><ul><li>算法：TimeoutInterval = EstimatedRTI +4 . DevRTT</li><li>推荐的初始 TimeoutInterval 值为1 秒</li></ul></li></ul><h3 id="5-可靠数据传输："><a href="#5-可靠数据传输：" class="headerlink" title="5.可靠数据传输："></a>5.可靠数据传输：</h3><ul><li><p>TCP 发送方与发送和重传有关的主要事件:从应用程序接收数据;定时器超时和收到 ACK </p><ul><li>定时器：当报文段被传给 IP时， TCP 启动定时器</li><li>超时：重传报文段，TCP重启定时器</li><li>ACK：包含了有效 ACK 字段值的报文段的接受和比较</li></ul></li><li><h2 id="一些特殊情况："><a href="#一些特殊情况：" class="headerlink" title="一些特殊情况："></a>一些特殊情况：</h2></li><li><p>超时间隔加倍</p></li><li><p>快速重传：一旦收到 个冗余 ACK ，TCP 就执行快速重传(fast retransmil) </p><ul><li>超时重传超时周期长，增加了端到端时延</li><li>冗余 ACK(duplicate ACK)   （出现在报文丢失）对相同数据的 ACK</li></ul></li><li><p>TCP 确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的</p></li></ul><h3 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6.流量控制"></a>6.流量控制</h3><p>6.1概念：</p><p>流量控制服务( fl0w- control service) 以消除发送方使接收方缓存溢出的可能性。</p><ul><li><p>接收缓存</p><ul><li><p>用RcvBuffer 来表示其大小</p></li><li><p>• LastByteReacl: 主机 上的应用进程从发送缓存读出的数据流的最后 个字节的编号</p><p>• LastByteRcvd:  到达的并已放入主机 接收缓存中的数据流的最后字节编号</p></li><li><p>算法：LasLByteRcvd - LastByteRead ~ RcvBuffer </p></li></ul></li><li><p>接收窗口用：rwnd </p><ul><li>根据缓存可用空间的数量来设置:</li><li>rwnd = RcvBuffer - [LastByteRcvd - LastßyteRead ] </li><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211048201.png" alt="image-20210526211048201"></li></ul></li><li><p>主机在该连接的整个生命周期应保证:</p><p>​                LastByteSent - LastByteAcked &lt;=rwnd</p></li></ul><h3 id="7-TCP连接"><a href="#7-TCP连接" class="headerlink" title="7.TCP连接"></a>7.TCP连接</h3><p>7.1建立连接</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211607326.png" alt="image-20210526211607326"></p><p>7.2 连接的断开</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211636290.png" alt="image-20210526211636290"></p><p>7.3 状态的变迁</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211720656.png" alt="image-20210526211720656"></p><p>7.4 SYN泛洪攻击</p><h3 id="8-拥塞控制"><a href="#8-拥塞控制" class="headerlink" title="8.拥塞控制"></a>8.拥塞控制</h3><p>7.1 概念：TCP 发送方因 网络的拥塞而被遏制;这种形式的发送方的控制被称为拥塞控制 (congestion control)</p><ul><li><p>在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥塞窗口</p><p>(congeslion window) 。</p><ul><li><p>拥塞窗口表示为 cwnd  对 TCP 发送方 发送流量的速率进行了限制 </p></li><li><p>在一个发送方中未被确认的数据量不会超过 cwnd rwnd 中的最小值，即：</p><p>LastyleSent - LastByteAcked&lt;= min { cwnd ，rwnd }</p></li></ul></li></ul><p>7.2拥塞控制：</p><ul><li><p>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率</p></li><li><p>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此 ，当对先前未确认报文段的确认到达时，增加发送方的速率。</p></li><li><p>带宽探测：为探测拥塞开始出现的速率， TCP 发送方增加它的</p><p>传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化</p></li></ul><p>7.3拥塞控制算法</p><p>该算法包括 个主要部分 ①慢启动;②拥塞避免;③快速恢复</p><p>如图所示：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526213509588.png" alt="image-20210526213509588"></p><ol><li><p>慢启动</p><p>TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据包的数量</p><p>慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 <strong>ACK</strong>，拥塞窗⼝ <strong>cwnd</strong> 的⼤⼩就会加 <strong>1</strong>。</p><p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</p><p>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</p><p>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</p><p>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发</p><p>4 个，所以这⼀次能够发送 8 个。</p></li><li><p>拥塞避免算法</p></li></ol><ul><li><p>当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。</p></li><li><p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。</p></li><li><p>规则：每当收到⼀个 <strong>ACK</strong> 时，<strong>cwnd</strong> 增加 <strong>1/cwnd</strong>。</p></li><li><p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ： </p></li></ul><p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9</p><p>个 MSS ⼤⼩的数据，变成了线性增⻓。</p><ul><li>拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶段，但是增⻓速度缓慢了。</li></ul><p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」。</p><p>拥塞发⽣</p><p>当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：</p><p>超时重传</p><p>快速重传</p><p>这两种使⽤的拥塞发送算法是不同的， </p><ol><li>发⽣超时重传的拥塞发⽣算法</li></ol><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。</p><ul><li><p>ssthresh 和 cwnd 的值会发⽣变化：</p><p>​                ssthresh 设为 cwnd/2 ，cwnd 重置为 1</p></li></ul><p>2.发⽣快速重传的拥塞发⽣算法</p><p>还有更好的⽅式，前⾯我们讲过「快速重传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地᯿传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：</p><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p><p>ssthresh = cwnd ;进⼊快速恢复算法</p><p>3.快速恢复</p><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也不那么糟</p><p>糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：</p><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p><p>ssthresh = cwnd ;</p><p>然后，进⼊快速恢复算法如下：</p><p>拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</p><p>重传丢失的数据包；</p><p>如果再收到重复的 ACK，那么 cwnd 增加 1；</p><p>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说</p><p>明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进</p><p>⼊拥塞避免状态；也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。</p><ol start="4"><li><p>回顾</p><p>TCP 的拥塞控制是:</p></li></ol><p>每个 RTT cwnd 线性(加性)增加 lMSS ，然后出现 个冗余ACK 事件时 cwnd 减半(乘性减) 。</p><p>因此， TCP 拥塞控制常常被称为加性增、乘性减(Additive-lncrease , Multiplicati 吨- Decrease , AIMD) 拥塞控制方式 </p><ul><li><p>整体流程</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526214305050.png" alt="image-20210526214305050"></p></li><li><p>其他算法：Reno 算法、TCPVegas 算法</p></li></ul><p>参考文献  :计算机网络自顶向下方法</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer network Summery 数据链路层</title>
    <link href="http://example.com/2021/06/02/Computer-network-Summery-of-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/06/02/Computer-network-Summery-of-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-06-02T02:31:55.000Z</published>
    <updated>2021-10-02T02:33:46.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="network-Summery-of-数据链路层"><a href="#network-Summery-of-数据链路层" class="headerlink" title="network Summery of 数据链路层"></a>network Summery of 数据链路层</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><ul><li><p>数据链路层设备的关系及作用</p></li><li><p>两种通信：点对点通信；广播通信</p></li><li><p>三种基本问题：透明传输；差错检测；封装成帧</p></li><li><p>以太网以及MAC地址</p></li></ul><h2 id="二-三种问题"><a href="#二-三种问题" class="headerlink" title="二.三种问题"></a>二.三种问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1.封装成帧"></a>1.封装成帧</h3><ul><li><p>帧长加上帧首部和帧尾部的长度</p></li><li><p>采用特殊的帧定界符，确定帧的启始和结束：SOH,EOT</p></li><li><p>数据部分传输上限：MTU（以太网：46~1500）</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626103006101.png" alt="image-20210626103006101"></p></li></ul><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2.透明传输"></a>2.透明传输</h3><ul><li><p>尽可能将出现的SOH,EOT在接收端不被看成控制字符</p><ul><li>字节填充法：在两个控制字符前加上ESC转义字符，如果转义字符也出现在数据中，则在ecs前也加上ECS，由接收端进行删除第一个ECS</li></ul></li></ul><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3.差错检测"></a>3.差错检测</h3><ul><li><p>实现的是误比特差错传输，不是可靠传输</p><ul><li>没有比特差错但是可能出现：帧丢失；帧重复；帧失序</li></ul></li><li><p>循环冗余检测CRC</p><ul><li><a href="https://blog.csdn.net/wenqiang1208/article/details/71641414?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162467580116780271519343%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162467580116780271519343&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-71641414.first_rank_v2_pc_rank_v29_1&utm_term=%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E6%B5%8B&spm=1018.2226.3001.4187">具体参见</a></li><li>FCS是冗余码，CRC是循环冗余算法，不要混淆</li></ul></li><li><p>凡是链路层接收的数据在传输的过程均无产生差错</p></li></ul><h2 id="三-点对点通信"><a href="#三-点对点通信" class="headerlink" title="三. 点对点通信"></a>三. 点对点通信</h2><h3 id="1-链路和数据链路的区别"><a href="#1-链路和数据链路的区别" class="headerlink" title="1.链路和数据链路的区别"></a>1.链路和数据链路的区别</h3><ul><li><p>链路（物理链路）：相邻节点之间的物理线路</p></li><li><p>数据链路（逻辑链路）：实现控制一条线路数据传输的协议的硬件和软件与链路共同组成了数据链路</p></li><li><p>基本数据单元：（数据）帧</p></li></ul><h3 id="2-点对点协议PPP"><a href="#2-点对点协议PPP" class="headerlink" title="2.点对点协议PPP"></a>2.点对点协议PPP</h3><p>1.特点：【RFC 1661】</p><ul><li>数据链路层协议</li><li>用户计算机和ISP通信的协议</li></ul><p>2.要求</p><ul><li>简单：相对IP简单很多</li><li>封装成帧：添加收首部，尾部添加FCS差错检测帧；添加帧定界符，确认帧的起始和结束</li><li>多种链路类型：可以使用多种链路类型</li><li>多种网络层协议：同一条链路支持多种网络协议（IP ,IPx）</li><li>透明性：避免帧定界符与数据中一样的比特组合出现混淆</li><li>差错检测：丢弃由差错的帧</li><li>检测连接状态：每隔几分钟查看链路工作状态</li><li>最大传输单元：MTU（数据链路层最大传输的<strong>数据</strong>长度）</li></ul><p>3.组成</p><ul><li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626100122931.png" alt="image-20210626100122931"></p></li><li><p>以一个标志字节起始和结束的，该字节为0x7E （区分出每个PPP帧）</p></li><li><p>标志字节后的一个字节是 地址域，该字节为 0x FF。 （ <!--PPP协议是被运用在点对点的链路上的，点对点的链路就可以唯一标示对方，因此使用PPP协议互连的通信设备的两端无须知道对方的数据链路层地址，所以该字节已无任何意义，按照协议的规定将该字节填充为全1的广播地址。-->）</p></li><li><p>同地址域一样，PPP数据帧的控制域也没有实际意义，按照协议的规定通信双方将该字节的内容填充为0x03。 </p></li><li><p>协议域可用来区分PPP数据帧中信息域所承载的数据报文的内容。协议域的内容必须依据ISO 3309的地址扩展机制所给出的规定。该机制规定协议域所填充的内容必须为奇数，也即是要求低字节的最低位为“1”，高字节的最低位为“0”。如果当发送端发送的PPP数据帧的协议域字段不符合上述规定，则接收端会认为此数据帧是不可识别的，那么接收端会向发送端发送一个Protocol-Reject报文，在该报文尾部将完整地填充被拒绝的报文。</p></li><li><p><strong>信息域缺省时最大长度不能超过1500字节</strong>，（<!--其中包括填充域的内容，1500字节大小等于PPP协议中配置参数选项MRU（Maximum Receive Unit）的缺省值，在实际应用当中可根据实际需要进行信息域最大封装长度选项的协商。信息域如果不足1500字节时可被填充，但不是必须的，如果填充则需通信双方的两端能辨认出有用与无用的信息方可正常通信。-->）</p></li><li><p>协议域和信息域是需要合在一起看的 ，主要用到的协议类型有LCP、NCP和普通的IP协议，而他们相对应的协议域字段则为0×C021、0×8021和0×0021 </p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626100950995.png" alt="image-20210626100950995"></p></li><li><p>尾部FCS（帧检验序列）差错检测，</p></li></ul><p>4.字节填充：信息字段出现和标志字段相同的比特组合时进行比特填充</p><ul><li>方法<ul><li>信息字段出现的每一个0x7E转变成(0x7D,0x5e)</li></ul></li></ul><p>5.零比特填充：同步传输时，采用零比特传输的方式实现透明传输（避免与标志字段混淆）</p><ul><li>发送端：扫描，出现连续的五个1，立即填入一个0</li><li>接收端：接受，出现连续五个1，把下一个0删除</li></ul><h2 id="四-局域网通信"><a href="#四-局域网通信" class="headerlink" title="四.局域网通信"></a>四.局域网通信</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h3><ul><li>局域网的优点<ul><li>具有广播功能</li><li>实现了系统的可靠性，可用性和生存性</li><li>系统扩展方便灵活</li></ul></li><li>局域网的分类<ul><li>总线网</li><li>星形网</li><li>环形网</li></ul></li><li>传输设备:双绞线（适用于10Mbit/s~~~10Gbit/s）</li><li>两个标准：Ethernet2；802.3</li><li>信道的划分采用动态媒体接入控制（多点接入），又分为：<ul><li>随机接入（常见）</li><li>控制接入</li></ul></li></ul><h3 id="2-以太网"><a href="#2-以太网" class="headerlink" title="2.以太网"></a>2.以太网</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li><p>两个标准：Ethernet2；802.3</p></li><li><p>CSMA/CD协议：</p><p><a href="https://blog.csdn.net/lucyxiaomeng/article/details/80563845?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162469137716780366575772%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162469137716780366575772&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80563845.first_rank_v2_pc_rank_v29_1&utm_term=CSMA/CD%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187">CSMA/CD协议</a></p></li></ul><h4 id="2-以太网帧"><a href="#2-以太网帧" class="headerlink" title="2.以太网帧"></a>2.以太网帧</h4><p>以太网帧字节的范围应该是72~1526。<br>以太网帧格式如下图：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626111904849.png" alt="image-20210626111904849"></p><p>Preamble：前导同步码7个字节+帧开始定界符1个字节，共计8个字节；<br>Destination MAC address：目的MAC地址，占用6个字节；<br>Source MAC address：源MAC地址，占用6个字节；<br>Type/Length：帧类型，占用2个字节；<br>User Data：数据信息，最少46个字节，最大1500字节；<br>Frame Check Sequence（FCS）：帧校验序列，占用4个字节；<br>从帧结构可以看出</p><p>，<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626111922033.png" alt="image-20210626111922033" style="zoom:80%;" /></p><p>8+6+6+2+（46<del>1500）+4=72</del>1526<br>因此以太网帧字节的范围是应该是72~1526，</p><p>以太网帧字节的范围是64~1518</p><h4 id="3-MAC"><a href="#3-MAC" class="headerlink" title="3.MAC"></a>3.MAC</h4><ul><li>也叫物理地址，硬件地址 16进制表示</li><li>48位，6字节（全球唯一）；前三字节代表<strong>组织唯一标识符OUI</strong>；后三位：<strong>扩展唯一标识符EUI</strong></li><li>固化在适配器的ROM 中</li></ul><h4 id="4-通道利用率"><a href="#4-通道利用率" class="headerlink" title="4.通道利用率"></a>4.通道利用率</h4><ul><li><p>假设┏ 是以太网单程端的传播时延。则争用期长度为2┏ ，即端到端传播时延的两倍；检测到碰撞后不发送干扰信号；<br>设帧长为L（bit），数据发送速率为C（bit/s）,则帧的发送时间To=L/C(s);<br>成功发送一个帧需要占用信道的时间为To+┏ ,比这个帧的发送时间To还要多一个单程端到端时延</p></li><li><p>参数a和利用率<br>参数a越小，以太网的信道利用率就越高————a=┏ /To;</p><ul><li>a趋向0时，表示一发生碰撞就可以立即检测出来，并立即停止发送，因而信道利用率很高；</li><li>a越大，表明争用期所占的比列增大，每发生一次碰撞就浪费许多信道资源，使信道利用率明显降低；</li></ul></li><li><p>对参数a的要求：</p><p>当数据率一定时，以太网的连线长度受到限制，否则┏ 的数值会变大；<br>以太网的帧长不能太短，否则To的值会太小，使a的值太大</p></li><li><p>信道利用率的最大值Smax = To/(To+┏ )=1/（1+a）;</p><ol><li><p>To为帧本身的发送时间，To+┏ 是发送一帧占用线路的时间；</p></li><li><p>当参数a远小于1才能得到尽可能高的极限信道利用率；</p></li><li><p>当以太网的信道利用率达到30%时 ，处于重载的情况 </p></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注：数据帧能够重传的一个条件：以太网要实现重传，必须保证这个站在收到冲突信号的时候这个帧没有传完。</span><br><span class="line">所以基于这种情况，以太网规定了一个最短帧的长度为64个字节，即512bit。因为64字节正好是争用期长度，如果在争用期内没有发生碰撞，那么就不会发生碰撞了。因此，凡长度小于64字节的帧都是由于冲突而异常停止的无效帧。接收端收到这种帧会直接丢弃。（对于10Mb&#x2F;s传统以太网而言）--&gt;</span><br></pre></td></tr></table></figure><h2 id="五-常见设备"><a href="#五-常见设备" class="headerlink" title="五.常见设备"></a>五.常见设备</h2><h3 id="1-集线器（hub）"><a href="#1-集线器（hub）" class="headerlink" title="1.集线器（hub）"></a>1.集线器（hub）</h3><ul><li>物理层</li><li>有多个接口的中继器</li><li>总线型结构（逻辑总线），使用CSMA/CD协议</li><li>同一时刻只允许一个站发送数据</li><li>只能处于半双工的工作状态，不能分割冲突域，网络的吞吐率会受到限制</li><li>逐渐被交换式集线器取代</li></ul><h3 id="2-适配器"><a href="#2-适配器" class="headerlink" title="2.适配器"></a>2.适配器</h3><ul><li><p>网卡NIC</p></li><li><p>物理层</p></li><li><p>数据串行传输和并行传输转换</p></li><li><p>实现以太网协议</p></li><li><p>搭载计算机硬件地址MAC</p></li></ul><h3 id="3-网关"><a href="#3-网关" class="headerlink" title="3.网关"></a>3.网关</h3><ul><li><p>一个虚拟概念</p></li><li><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，</p></li><li><p>用于两个高层协议不同的网络互连。</p></li><li><p>网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。 </p></li><li><p>网关也可以提供过滤和安全功能。大多数网关运行在OSI 7层协议的顶层–应用层</p></li></ul><h3 id="4-以太网交换机"><a href="#4-以太网交换机" class="headerlink" title="4.以太网交换机"></a>4.以太网交换机</h3><ul><li><p>数据链路层</p></li><li><p>也叫交换式集线器，第二层交换机</p></li><li><p>实质上是<strong>多接口</strong>的网桥</p></li><li><p>即插即用，内部包含交换表（通过自学习的方式）</p></li></ul><h3 id="5-路由器"><a href="#5-路由器" class="headerlink" title="5.路由器"></a>5.路由器</h3><ul><li>第三层交换机 </li><li>网络层</li><li>主要进行分组转发，网络层核心设备</li><li>实现路由选择协议，同时具有将网络地址（IP地址）到下层链路层地址（mac）的转换能力：ARP</li></ul><h3 id="6-调制解调器"><a href="#6-调制解调器" class="headerlink" title="6.调制解调器"></a>6.调制解调器</h3><ul><li>物理层</li><li>将<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字信号</a><a href="https://zh.wikipedia.org/wiki/%E8%AA%BF%E8%AE%8A">调变</a>到<a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E4%BF%A1%E8%99%9F">模拟信号</a>上进行传输，并<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E8%AA%BF">解调</a>收到的模拟信号以得到数字信号 的电子设备</li></ul><h3 id="7-网桥"><a href="#7-网桥" class="headerlink" title="7.网桥"></a>7.网桥</h3><ul><li><p>网桥又称桥接器，英文名Network Bridge，</p></li><li><p>数据链路层设备。 </p></li><li><p>网桥能从发来的数据包中提取MAC信息，并且根据MAC信息对数据包进行有目的的转发，而不采用广播的方式</p></li><li><p>高级（避免广播）的集线器</p></li><li><p>只有两个端口，MAC表记录的是MAC-PortNum</p><p>​        HUB 所有端口都在同一个广播域，冲突域内。<br>　　Switch所有端口都在同一个广播域内，而每一个端口就是一个冲突域。<br>　　Router的每个端口属于不同的广播域。 </p></li></ul><h3 id="8-中继器"><a href="#8-中继器" class="headerlink" title="8.中继器"></a>8.中继器</h3><ul><li><p>物理层</p></li><li><p>将信号整形再放大转发出去，消除信号经过长段电缆而产生的失真和衰减</p></li><li><p>有两个端口</p><ul><li>输入端口</li><li>输出端口</li></ul></li><li><p>连接同一网络，具有相同速率，相同协议。</p></li></ul><h2 id="六-高速以太网"><a href="#六-高速以太网" class="headerlink" title="六.高速以太网"></a>六.高速以太网</h2><p>速率达到或超过100Mb/s的以太网称为高速以太网。</p><ul><li><p>100BASE-T：（快速以太网）</p><ul><li>双绞线传输</li><li>100Mbit/s</li><li>使用802.3的CSMA/CD</li></ul></li><li><p>吉比特以太网——千兆以太网</p><ul><li><p>吉比特以太网可用作现有网络的主干网，也可在高带宽(即高速率)的应用场合中用来连接工作站和服务器。</p></li><li><p>吉比特以太网的物理层使用以下两种成熟的技术：<br>(1)来自现有的以太网。<br>(2)ANSI制定的光纤通道FC(Fibre Channel)。</p></li><li><p>吉比特以太网的标准IEEE802.3z有以下几个特点：</p><ol><li><p>允许在1Gb/s下全双工和半双工两种工作方式。</p></li><li><p>使用IEEE802.3协议规定的帧格式。</p></li><li><p>在半双工方式下使用CSMA/CD协议，而在全双工方式下不需要使用CSMA/CD协议</p></li><li><p>与10BASE-T和100BASE-T技术向后兼容。</p></li></ol></li></ul></li><li><p>10吉比特以太网——万兆以太网</p><ul><li>由于10GE的出现，以太网的工作范围已经从局域网扩大到城域网和广域网，从而实现了端到端的以太网传输。 </li></ul></li><li><p>以太网是：</p><ol><li>可扩展的</li><li>灵活的</li><li>易于安装的</li><li>稳健性好的</li></ol></li></ul><p><strong>参考文献：</strong><br>[1]《计算机网络(第5版)》谢希仁</p><p>[2]《计算机网络自顶向下方法》</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="network" scheme="http://example.com/categories/network/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>SQL常见问题</title>
    <link href="http://example.com/2021/04/28/SQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/04/28/SQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-28T09:16:53.000Z</published>
    <updated>2021-10-02T02:29:20.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="delete-truncate-drop-的区别"><a href="#delete-truncate-drop-的区别" class="headerlink" title="delete truncate drop 的区别"></a>delete truncate drop 的区别</h2><p>TRUNCATE TABLE 在功能上与不带 Where 子句的 Delete 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 Delete 速度快，且使用的系统和事务日志资源少。</p><p> Delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p> TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 Delete。</p><p> 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 Where 子句的 Delete 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><p> TRUNCATE TABLE 不能用于参与了索引视图的表。</p><p> truncate,delete,drop的异同点：<br> 注意:这里说的delete是指不带where子句的delete语句</p><p>相同点:truncate和不带where子句的delete, 以及drop都会删除表内的数据 </p><p>不同点:<br>   1.truncate和 delete只删除数据不删除表的结构(定义)<br>    drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.</p><p>   2.delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.<br>    truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p><p>   3.delete语句不影响表所占用的extent, 高水线(high w2atermark)保持原位置不动<br>    显然drop语句将表所占用的空间全部释放<br>    truncate 语句缺省情况下将空间释放到 minextents个 extent,除非使用reuse storage;  truncate会将高水线复位(回到最开始).</p><p>   4.速度,一般来说: drop&gt; truncate &gt; delete</p><p>   5.安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及</p><p>   使用上：<br>   想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.</p><p>   想删除表,当然用drop</p><p>   想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.</p><p>   如果是整理表内部的碎片,可以用truncate跟上reuse stroage,再重新导入/插入数据</p><p>delete pk truncate【面试题★】</p><p>1.delete 可以加where 条件，truncate不能加</p><p>2.truncate删除，效率高一丢丢<br>3.假如要删除的表中有自增长列，<br>如果用delete删除后，再插入数据，自增长列的值从断点开始，<br>而truncate删除后，再插入数据，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值</p><p>5.truncate删除不能回滚，delete删除可以回滚.</p><h2 id="sql基本组成"><a href="#sql基本组成" class="headerlink" title="sql基本组成"></a>sql基本组成</h2><p><strong>DDL****（Data</strong> <strong>Definition Language</strong>）<strong>数据库<strong><strong>定义</strong></strong>语言</strong></p><p>  DDL不需要commit. eg. CREATE ALTER DROP TRUNCATE COMMENT RENAME</p><p>****DML**（*<em>Data Manipulation Language*<em>）*<em>数据操纵语言*</em></em></em></p><p>  DML需要commit. eg. SELECT INSERT UPDATE DELETE MERGE CALL EXPLAIN PLAN LOCK TABLE</p><p><strong>DCL<strong><strong>（</strong></strong>Data Control Language****）</strong>数据控制语言** <strong>授权，角色控制等</strong><br>  GRANT 授权, REVOKE 取消授权<br><strong>TCL<strong><strong>（</strong></strong>Transaction Control Language****）</strong>事务控制语言**<br>  SAVEPOINT 设置保存点, ROLLBACK 回滚, SET TRANSACTION</p><h2 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h2><p>sql执行顺序<br>(1)from<br>(3) join<br>(2) on<br>(4) where<br>(5)group by(开始使用select中的别名，后面的语句中都可以使用)<br>(6) avg,sum….<br>(7)having<br>(8) select<br>(9) distinct<br>(10) order by</p><h2 id="is-null-VS-lt-gt"><a href="#is-null-VS-lt-gt" class="headerlink" title="is null     VS      &lt;=&gt;"></a><strong>is null     VS      &lt;=&gt;</strong></h2><!--IS NULL:仅仅可以判断NULL值，可读性较高，建议使用--><!--<=>    :既可以判断NULL值，又可以判断普通的数值，可读性较低--><h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><p>1、<strong>和分组函数一同查询的字段必须是group by后出现的字段</strong><br>2、筛选分为两类：分组前筛选和分组后筛选</p><table><thead><tr><th>针对的表</th><th>位置</th><th>连接的关键字</th></tr></thead><tbody><tr><td>分组前筛选</td><td>原始表</td><td>group by前    where</td></tr><tr><td>分组后筛选</td><td>group by后的结果集</td><td>group by后    having</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p><p>问题2：where——group by——having</p><p>一般来讲，能用分组前筛选的，<strong>尽量使用分组前筛选</strong>，提高效率</p><p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Summery of SQL Basic</title>
    <link href="http://example.com/2021/04/28/Summery-of-SQL-Basic/"/>
    <id>http://example.com/2021/04/28/Summery-of-SQL-Basic/</id>
    <published>2021-04-28T09:05:48.000Z</published>
    <updated>2021-10-02T02:07:30.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql知识点总结"><a href="#Mysql知识点总结" class="headerlink" title="Mysql知识点总结"></a>Mysql知识点总结</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li><p>使用mysql需要启动mysql服务 ：推荐命令行键入net  start\stop +mysql版本</p></li><li><p>Windows的命令行键入mysql -h localhost -P 3306 -u root -p 登录mysql服务端</p></li><li><p>查看mysql版本 ：   mysql –V/verson</p></li><li><p>mysql 不区分大小写，命令用分号结尾</p></li><li><p>mysql可以使用注释</p><ul><li>单行注释：#注释文字</li><li>单行注释：– 注释文字</li><li>多行注释：/* 注释文字  */</li></ul></li><li><p>SQL的常见命令</p><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre></li><li><p>SQL的语言分类</p><p>​    DQL（Data Query Language）：数据查询语言<br>​        select<br>​    DML(Data Manipulate Language):数据操作语言<br>​        insert 、update、delete<br>​    DDL（Data Define Languge）：数据定义语言<br>​        create、drop、alter<br>​    TCL（Transaction Control Language）：事务控制语言<br>​        commit、rollback</p></li></ul><h2 id="二、DQL"><a href="#二、DQL" class="headerlink" title="二、DQL"></a>二、DQL</h2><h3 id="1：基础查询"><a href="#1：基础查询" class="headerlink" title="1：基础查询"></a>1：基础查询</h3><p><strong>语法</strong>：<br>    <em>select     查询列表     from     表名;</em></p><p>特点：</p><ul><li>1、查询列表可以是：表中的字段、常量值、表达式、函数</li><li>2、查询的结果是一个虚拟的表格</li></ul><h5 id="1-查询表中的单个字段"><a href="#1-查询表中的单个字段" class="headerlink" title="1.查询表中的单个字段"></a>1.查询表中的单个字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*SELECT last_name FROM employees;*</span><br></pre></td></tr></table></figure><h5 id="2-查询表中的多个字段"><a href="#2-查询表中的多个字段" class="headerlink" title="2.查询表中的多个字段"></a>2.查询表中的多个字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary,email FROM employees;</span><br></pre></td></tr></table></figure><h5 id="3-查询表中的所有字段"><a href="#3-查询表中的所有字段" class="headerlink" title="3.查询表中的所有字段"></a>3.查询表中的所有字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line"></span><br><span class="line">​SELECT </span><br><span class="line">​    *&#96;employee_id&#96;,*</span><br><span class="line">​    *&#96;first_name&#96;,*</span><br><span class="line">​    *&#96;last_name&#96;,*</span><br><span class="line">​    *&#96;phone_number&#96;,*</span><br><span class="line">​    *&#96;last_name&#96;,*</span><br><span class="line">​    *&#96;job_id&#96;,*</span><br><span class="line">​    *&#96;phone_number&#96;,*</span><br><span class="line">​    *&#96;job_id&#96;,*</span><br><span class="line">​    *&#96;salary&#96;,*</span><br><span class="line">​    *&#96;commission_pct&#96;,*</span><br><span class="line">​    *&#96;manager_id&#96;,*</span><br><span class="line">​    *&#96;department_id&#96;,*</span><br><span class="line">​    &#96;hiredate&#96;</span><br><span class="line">FROM</span><br><span class="line">​    employees ;</span><br><span class="line"></span><br><span class="line">方式二：  </span><br><span class="line"></span><br><span class="line"> *SELECT * FROM employees;</span><br></pre></td></tr></table></figure><h5 id="4-查询常量值"><a href="#4-查询常量值" class="headerlink" title="4.查询常量值"></a>4.查询常量值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 100;</span><br></pre></td></tr></table></figure><h5 id="5-查询表达式"><a href="#5-查询表达式" class="headerlink" title="5.查询表达式"></a>5.查询表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 100%98;</span><br></pre></td></tr></table></figure><h5 id="6-查询函数"><a href="#6-查询函数" class="headerlink" title="6.查询函数"></a>6.查询函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure><h5 id="7-起别名"><a href="#7-起别名" class="headerlink" title="7.起别名"></a>7.起别名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> ①便于理解</span><br><span class="line"> ②如果要查询的字段有重名的情况，使用别名可以区分开来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式一：使用as</span><br><span class="line"></span><br><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br><span class="line"></span><br><span class="line">方式二：使用空格</span><br><span class="line"></span><br><span class="line">SELECT last_name 姓,first_name 名 FROM employees;</span><br><span class="line"></span><br><span class="line">案例：查询salary，显示结果为 out put</span><br><span class="line"></span><br><span class="line">SELECT salary AS &quot;out put&quot; FROM employees;</span><br></pre></td></tr></table></figure><h5 id="8-去重"><a href="#8-去重" class="headerlink" title="8.去重"></a>8.去重</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">案例：查询员工表中涉及到的所有的部门编号</span><br><span class="line"></span><br><span class="line">SELECT ***DISTINCT*** department_id FROM employees;</span><br></pre></td></tr></table></figure><h5 id="9-号的作用"><a href="#9-号的作用" class="headerlink" title="9.+号的作用"></a>9.+号的作用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java中的+号：</span><br><span class="line"></span><br><span class="line">- 运算符，两个操作数都为数值型</span><br><span class="line">- 连接符，只要有一个操作数为字符串</span><br><span class="line"></span><br><span class="line">mysql中的+号： </span><br><span class="line"></span><br><span class="line">​仅仅只有一个功能：运算符</span><br><span class="line"></span><br><span class="line">select 100+90; 两个操作数都为数值型，则做加法运算</span><br><span class="line"></span><br><span class="line">select &#39;123&#39;+90;只要其中一方为字符型，试图将字符型数值转换成数值型,如果转换成功，则继续做加法运算</span><br><span class="line"></span><br><span class="line">select &#39;john&#39;+90;如果转换失败，则将字符型数值转换成0</span><br><span class="line"></span><br><span class="line">select null+10; 只要其中一方为null，则结果肯定为null </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><pre><code> 1.    下面的语句是否可以执行成功    SELECT last_name , job_id , salary AS salFROM employees;   2.下面的语句是否可以执行成功  SELECT  *  FROM employees;   3.找出下面语句中的错误 SELECT employee_id , last_name,salary * 12 AS &quot;ANNUAL  SALARY&quot;FROM employees; 4.显示表departments的结构，并查询其中的全部数据DESC departments;SELECT * FROM `departments`;5.显示出表employees中的全部job_id（不能重复）SELECT DISTINCT job_id FROM employees;//distinct可以去重6.显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUTSELECT     IFNULL(commission_pct,0) AS 奖金率,    commission_pctFROM     employees;    SELECT    CONCAT(`first_name`,&#39;,&#39;,`last_name`,&#39;,&#39;,`job_id`,&#39;,&#39;,IFNULL(commission_pct,0)) AS out_putFROM    employees;</code></pre><h3 id="2：条件查询"><a href="#2：条件查询" class="headerlink" title="2：条件查询"></a>2：条件查询</h3><p><strong>语法</strong>：<br>    <em><em>select  查询列表</em><br>    <em>from   表名</em><br>    where    筛选条件;</em></p><p><strong>分类</strong>：<br>一、按条件表达式筛选<br>        简单条件运算符<em>：&gt; &lt; =  !=  &lt;&gt;  &gt;=   &lt;=</em></p><p>二、按逻辑表达式筛选<br>逻辑运算符：<br>作用：用于连接条件表达式<br>    <em>&amp;&amp; || !</em><br>    <em>and or not</em></p><p><em>&amp;&amp;和and</em>：两个条件都为true，结果为true，反之为false<br><em>||或or</em>： 只要有一个条件为true，结果为true，反之为false<br><em>!或not</em>： 如果连接的条件本身为false，结果为true，反之为false</p><p>三、模糊查询<br>    <em>like</em><br>    <em>between and</em><br>    <em>in</em><br>    is null</p><h4 id="1、按条件表达式筛选"><a href="#1、按条件表达式筛选" class="headerlink" title="1、按条件表达式筛选"></a>1、按条件表达式筛选</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">案例1：查询工资&gt;12000的员工信息</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">*</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">salary&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例2：查询部门编号不等于90号的员工名和部门编号</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">last_name,</span><br><span class="line">department_id</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">department_id&lt;&gt;90;</span><br></pre></td></tr></table></figure><h4 id="2、按逻辑表达式筛选"><a href="#2、按逻辑表达式筛选" class="headerlink" title="2、按逻辑表达式筛选"></a>2、按逻辑表达式筛选</h4><p>案例1：查询工资z在10000到20000之间的员工名、工资以及奖金</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">salary,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">salary&gt;&#x3D;10000 AND salary&lt;&#x3D;20000;</span><br></pre></td></tr></table></figure><p>案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">NOT(department_id&gt;&#x3D;90 AND  department_id&lt;&#x3D;110) OR salary&gt;15000;</span><br></pre></td></tr></table></figure><h4 id="3、模糊查询"><a href="#3、模糊查询" class="headerlink" title="3、模糊查询"></a>3、模糊查询</h4><p><em>like</em><br><em>between and</em><br><em>in</em><br><em>is null|is not null</em></p><h5 id="1-like"><a href="#1-like" class="headerlink" title="1.like"></a><em>1.like</em></h5><p>特点：<br>一般和通配符搭配使用<br>    通配符：<br>    <strong>%</strong>   任意多个字符,包含0个字符<br>    <strong>_</strong>     任意单个字符</p><p>案例1：查询员工名中包含字符a的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">*</span><br><span class="line">from</span><br><span class="line">employees</span><br><span class="line">where</span><br><span class="line">last_name like &#39;%a%&#39;; </span><br></pre></td></tr></table></figure><p>案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">last_name,</span><br><span class="line">salary</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">last_name LIKE &#39;__n_l%&#39;;</span><br></pre></td></tr></table></figure><p>案例3：查询员工名中第二个字符为_的员工名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">last_name</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">last_name LIKE &#39;_$_%&#39; ESCAPE &#39;$&#39;;</span><br></pre></td></tr></table></figure><h4 id="2-between-and"><a href="#2-between-and" class="headerlink" title="2.between and"></a>2.between and</h4><p>①使用between and 可以提高语句的简洁度<br>②包含临界值<br>③两个临界值不要调换顺序</p><p>案例1：查询员工编号在100到120之间的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">employee_id &gt;&#x3D; 120 AND employee_id&lt;&#x3D;100;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">*</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">employee_id BETWEEN 120 AND 100; </span><br></pre></td></tr></table></figure><h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a>3.in</h4><p>含义：判断某字段的值是否属于in列表中的某一项<br>特点：<br>    ①使用in提高语句简洁度<br>    ②in列表的值类型必须一致或兼容<br>    ③in列表中<strong>不支持通配符</strong>    </p><p>案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">job_id</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">job_id &#x3D; &#39;IT_PROT&#39; OR job_id &#x3D; &#39;AD_VP&#39; OR JOB_ID &#x3D;&#39;AD_PRES&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------&gt;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">job_id</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">job_id IN( &#39;IT_PROT&#39; ,&#39;AD_VP&#39;,&#39;AD_PRES&#39;);</span><br></pre></td></tr></table></figure><h4 id="4、is-null"><a href="#4、is-null" class="headerlink" title="4、is null"></a>4、is null</h4><p>=或&lt;&gt;不能用于判断null值<br>is null或is not null 可以判断null值</p><p>案例1：查询没有奖金的员工名和奖金率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">commission_pct IS NULL;</span><br></pre></td></tr></table></figure><p>案例2：查询有奖金的员工名和奖金率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line">----------&gt;</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line"></span><br><span class="line">WHERE </span><br><span class="line">salary IS 12000;</span><br></pre></td></tr></table></figure><h4 id="安全等于-lt-gt"><a href="#安全等于-lt-gt" class="headerlink" title="安全等于  &lt;=&gt;"></a>安全等于  &lt;=&gt;</h4><h5 id="案例1：查询没有奖金的员工名和奖金率"><a href="#案例1：查询没有奖金的员工名和奖金率" class="headerlink" title="案例1：查询没有奖金的员工名和奖金率"></a>案例1：查询没有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct &lt;=&gt;NULL;        </p><h5 id="案例2：查询工资为12000的员工信息"><a href="#案例2：查询工资为12000的员工信息" class="headerlink" title="案例2：查询工资为12000的员工信息"></a>案例2：查询工资为12000的员工信息</h5><p>SELECT<br>    last_name,<br>    salary<br>FROM<br>    employees</p><p>WHERE<br>    salary &lt;=&gt; 12000;</p><p><strong>is null     VS      &lt;=&gt;</strong></p><!--IS NULL:仅仅可以判断NULL值，可读性较高，建议使用--><!--<=>    :既可以判断NULL值，又可以判断普通的数值，可读性较低--><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a><strong>案例</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1.显示系统时间(注：日期+时间)</span><br><span class="line"></span><br><span class="line">SELECT NOW();</span><br><span class="line"></span><br><span class="line">2.查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</span><br><span class="line"></span><br><span class="line">SELECT employee_id,last_name,salary,salary*1.2 &quot;new salary&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">3.将员工的姓名按首字母排序，并写出姓名的长度（length）</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(last_name) 长度,SUBSTR(last_name,1,1) 首字符,last_name</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 首字符;</span><br><span class="line"></span><br><span class="line">4.做一个查询，产生下面的结果</span><br><span class="line"></span><br><span class="line">&lt;last_name&gt; earns &lt;salary&gt; monthly but wants &lt;salary*3&gt;</span><br><span class="line">Dream Salary</span><br><span class="line">King earns 24000 monthly but wants 72000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT CONCAT(last_name,&#39; earns &#39;,salary,&#39; monthly but wants &#39;,salary*3) AS &quot;Dream Salary&quot;</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&#x3D;24000;</span><br><span class="line"></span><br><span class="line">5.使用case-when，按照下面的条件：</span><br><span class="line"></span><br><span class="line">job                  grade</span><br><span class="line">AD_PRES            A</span><br><span class="line">ST_MAN             B</span><br><span class="line">IT_PROG             C</span><br><span class="line">SA_REP              D</span><br><span class="line">ST_CLERK           E</span><br><span class="line">产生下面的结果</span><br><span class="line">Last_nameJob_idGrade</span><br><span class="line">kingAD_PRESA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id AS  job,</span><br><span class="line">CASE job_id</span><br><span class="line">WHEN &#39;AD_PRES&#39; THEN &#39;A&#39; </span><br><span class="line">WHEN &#39;ST_MAN&#39; THEN &#39;B&#39; </span><br><span class="line">WHEN &#39;IT_PROG&#39; THEN &#39;C&#39; </span><br><span class="line">WHEN &#39;SA_PRE&#39; THEN &#39;D&#39;</span><br><span class="line">WHEN &#39;ST_CLERK&#39; THEN &#39;E&#39;</span><br><span class="line">END AS Grade</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;AD_PRES&#39;; </span><br></pre></td></tr></table></figure><h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3: 排序查询"></a>3: 排序查询</h3><p>语法：</p><p>select 查询列表<br>from 表名<br>【where  筛选条件】<br>order by 排序的字段或表达式;</p><p>特点：</p><p>1、asc代表的是升序，可以省略,（默认值）; desc代表的是降序</p><p>2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段</p><p>3、order by子句在查询语句的最后面，除了limit子句</p><h5 id="1、按单个字段排序"><a href="#1、按单个字段排序" class="headerlink" title="1、按单个字段排序"></a>1、按单个字段排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees ORDER BY salary DESC;</span><br></pre></td></tr></table></figure><h5 id="2、添加筛选条件再排序"><a href="#2、添加筛选条件再排序" class="headerlink" title="2、添加筛选条件再排序"></a>2、添加筛选条件再排序</h5><p>案例：查询部门编号&gt;=90的员工信息，并按员工编号降序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id&gt;&#x3D;90</span><br><span class="line">ORDER BY employee_id DESC;</span><br></pre></td></tr></table></figure><h5 id="3、按表达式排序"><a href="#3、按表达式排序" class="headerlink" title="3、按表达式排序"></a>3、按表达式排序</h5><p>案例：查询员工信息 按年薪降序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;</span><br></pre></td></tr></table></figure><h5 id="4、按别名排序"><a href="#4、按别名排序" class="headerlink" title="4、按别名排序"></a>4、按别名排序</h5><h6 id="案例：查询员工信息-按年薪升序"><a href="#案例：查询员工信息-按年薪升序" class="headerlink" title="案例：查询员工信息 按年薪升序"></a>案例：查询员工信息 按年薪升序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 年薪 ASC;</span><br></pre></td></tr></table></figure><h5 id="5、按函数排序"><a href="#5、按函数排序" class="headerlink" title="5、按函数排序"></a>5、按函数排序</h5><h6 id="案例：查询员工名，并且按名字的长度降序"><a href="#案例：查询员工名，并且按名字的长度降序" class="headerlink" title="案例：查询员工名，并且按名字的长度降序"></a>案例：查询员工名，并且按名字的长度降序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT LENGTH(last_name),last_name </span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY LENGTH(last_name) DESC;</span><br></pre></td></tr></table></figure><h5 id="6、按多个字段排序"><a href="#6、按多个字段排序" class="headerlink" title="6、按多个字段排序"></a>6、按多个字段排序</h5><h6 id="案例：查询员工信息，要求先按工资降序，再按employee-id升序"><a href="#案例：查询员工信息，要求先按工资降序，再按employee-id升序" class="headerlink" title="案例：查询员工信息，要求先按工资降序，再按employee_id升序"></a>案例：查询员工信息，要求先按工资降序，再按employee_id升序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC,employee_id ASC;&#x2F;&#x2F;  先按照第一个排序之后再按照第二个排序</span><br></pre></td></tr></table></figure><h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_id,salary*12*(1+IFNULL(commission_pct,0)) 年薪</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 年薪 DESC,last_name ASC;</span><br><span class="line"></span><br><span class="line">2.选择工资不在8000到17000的员工的姓名和工资，按工资降序</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">WHERE salary NOT BETWEEN 8000 AND 17000</span><br><span class="line">ORDER BY salary DESC;</span><br><span class="line"></span><br><span class="line">3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</span><br><span class="line"></span><br><span class="line">SELECT *,LENGTH(email)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#39;%e%&#39;</span><br><span class="line">ORDER BY LENGTH(email) DESC,department_id ASC;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="4：常见函数"><a href="#4：常见函数" class="headerlink" title="4：常见函数"></a>4：常见函数</h3><p><strong>概念：</strong></p><p>类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p><p><strong>好处：</strong></p><ul><li><p>隐藏了实现细节 </p></li><li><p>提高代码的重用性</p></li></ul><p><strong>调用：</strong></p><p>​    select 函数名(实参列表) 【from 表】;</p><p><strong>特点：</strong></p><ul><li><p>叫什么（函数名）</p></li><li><p>干什么（函数功能）</p></li></ul><p><strong>分类：</strong></p><ul><li>单行函数<br>​        如 concat、length、if  null等</li><li>分组函数<br>​        功能：做统计使用，又称为统计函数、聚合函数、组函数</li></ul><h5 id="常见函数："><a href="#常见函数：" class="headerlink" title="常见函数："></a>常见函数：</h5><pre><code>字符函数：​    length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节)​    concat​    substr​    instr​    trim​    upper​    lower​    lpad​    rpad​    replace数学函数：​    round​    ceil​    floor​    truncate​    mod日期函数：nowcurdatecurtimeyearmonthmonthnamedayhourminutesecondstr_to_datedate_format其他函数：versiondatabaseuser控制函数ifcase</code></pre><p>​     </p><h4 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1.length 获取参数值的字节个数</span><br><span class="line">SELECT LENGTH(&#39;john&#39;);</span><br><span class="line">SELECT LENGTH(&#39;张三丰hahaha&#39;);&#x2F;&#x2F;一个汉字占三个字节 </span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#39;%char%&#39;</span><br><span class="line"></span><br><span class="line">  2.concat 拼接字符串</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(last_name,&#39;_&#39;,first_name) 姓名 FROM employees;</span><br><span class="line"></span><br><span class="line">  3.upper、lower</span><br><span class="line"></span><br><span class="line">SELECT UPPER(&#39;john&#39;);</span><br><span class="line">SELECT LOWER(&#39;joHn&#39;);</span><br><span class="line"></span><br><span class="line">  示例：将姓变大写，名变小写，然后拼接</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</span><br><span class="line"></span><br><span class="line">  4.substr、substring</span><br><span class="line"></span><br><span class="line">注意：索引从1开始</span><br><span class="line"></span><br><span class="line">  截取从指定索引处后面所有字符（包括索引处）</span><br><span class="line"></span><br><span class="line">SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,7)  out_put;</span><br><span class="line"></span><br><span class="line">  截取从指定索引处指定字符长度的字符（包括索引处字符）</span><br><span class="line"></span><br><span class="line">SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;</span><br><span class="line"></span><br><span class="line">  案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2)))  out_put</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">5.instr 返回子串第一次出现的索引，如果找不到返回0</span><br><span class="line"></span><br><span class="line">SELECT INSTR(&#39;杨不殷六侠悔爱上了殷六侠&#39;,&#39;殷八侠&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">6.trim去除字符串前后的指定的字符</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(TRIM(&#39;    张翠山    &#39;)) AS out_put;</span><br><span class="line"></span><br><span class="line">SELECT TRIM(&#39;aa&#39; FROM &#39;aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;)  AS out_put;</span><br><span class="line"></span><br><span class="line">7.lpad 用指定的字符实现左填充指定长度</span><br><span class="line"></span><br><span class="line">SELECT LPAD(&#39;殷素素&#39;,2,&#39;*&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">8.rpad 用指定的字符实现右填充指定长度</span><br><span class="line"></span><br><span class="line">SELECT RPAD(&#39;殷素素&#39;,12,&#39;ab&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">9.replace 替换</span><br><span class="line"></span><br><span class="line">SELECT REPLACE(&#39;周芷若周芷若周芷若周芷若张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;</span><br></pre></td></tr></table></figure><h4 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h4><p><strong>round 四舍五入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">SELECT ROUND(1.567,2);&#x2F;&#x2F;保留到小数点后两位</span><br></pre></td></tr></table></figure><p><strong>ceil 向上取整,返回&gt;=该参数的最小整数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br></pre></td></tr></table></figure><p><strong>floor</strong> 向下取整，返回该参数的最大整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br></pre></td></tr></table></figure><p><strong>truncate 截断</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);&#x2F;&#x2F;截断到小数点后一位</span><br></pre></td></tr></table></figure><p><strong>mod取余</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mod(a,b) ： 操作过程： a-a&#x2F;b*b   &#x2F;&#x2F;妙啊！！！</span><br><span class="line"></span><br><span class="line">--mod(-10,-3):-10- (-10)&#x2F;(-3)*（-3）&#x3D;-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT MOD(10,-3);</span><br><span class="line">SELECT 10%3;</span><br></pre></td></tr></table></figure><h4 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h4><p>now 返回当前系统日期+时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT NOW();</span><br></pre></td></tr></table></figure><p><strong>curdate 返回当前系统日期，不包含时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURDATE();</span><br></pre></td></tr></table></figure><p><strong>curtime 返回当前时间，不包含日期</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURTIME();</span><br></pre></td></tr></table></figure><p><strong>可以获取指定的部分，年、月、日、小时、分钟、秒</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">SELECT YEAR(&#39;1998-1-1&#39;) 年;</span><br><span class="line">SELECT  YEAR(hiredate) 年 FROM employees;</span><br><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br></pre></td></tr></table></figure><p><strong>str_to_date 将字符通过指定的格式转换成日期</strong></p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211001150550409.png" alt="image-20211001150550409"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) AS out_put;</span><br></pre></td></tr></table></figure><p><strong>查询入职日期为1992–4-3的员工信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees WHERE hiredate &#x3D; &#39;1992-4-3&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);</span><br></pre></td></tr></table></figure><p><strong>date_format 将日期转换成字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%y年%m月%d日&#39;) AS out_put;</span><br></pre></td></tr></table></figure><p><strong>查询有奖金的员工名和入职日期(xx月/xx日 xx年)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月&#x2F;%d日 %y年&#39;) 入职日期</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure><h4 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line"></span><br><span class="line">SELECT DATABASE();</span><br><span class="line"></span><br><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure><h4 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h4><p><strong>1.if函数：</strong></p><p> <strong>if else 的效果</strong></p><p>SELECT IF(10&lt;5,’大’,’小’);</p><p>SELECT last_name,commission_pct,IF(commission_pct IS NULL,’没奖金，呵呵’,’有奖金，嘻嘻’) 备注<br>FROM employees;</p><p><strong>2.case函数的使用一：</strong></p><p> <strong>switch case 的效果</strong></p><p>java中<br>switch(变量或表达式){<br>    case 常量1：语句1;break;<br>    …<br>    default:语句n;break;</p><p>}</p><p>mysql中</p><p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">查询员工的工资，要求</span><br><span class="line"></span><br><span class="line">部门号&#x3D;30，显示的工资为1.1倍</span><br><span class="line">部门号&#x3D;40，显示的工资为1.2倍</span><br><span class="line">部门号&#x3D;50，显示的工资为1.3倍</span><br><span class="line">其他部门，显示的工资为原工资</span><br><span class="line"></span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN </span><br><span class="line">salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><p><strong>3.case 函数的使用二：</strong></p><p><strong>类似于 多重if</strong></p><p>java中：<br>if(条件1){<br>    语句1；<br>}else if(条件2){<br>    语句2；<br>}<br>…<br>else{<br>    语句n;<br>}</p><p>mysql中：</p><p>case<br>when 条件1 then 要显示的值1或语句1<br>when 条件2 then 要显示的值2或语句2<br>。。。<br>else 要显示的值n或语句n<br>end</p><p>案例：查询员工的工资的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果工资&gt;20000,显示A级别</span><br><span class="line">如果工资&gt;15000,显示B级别</span><br><span class="line">如果工资&gt;10000，显示C级别</span><br><span class="line">否则，显示D级别</span><br><span class="line"></span><br><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &#39;A&#39;</span><br><span class="line">WHEN salary&gt;15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary&gt;10000 THEN &#39;C&#39;</span><br><span class="line">ELSE &#39;D&#39;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><h3 id="5：分组查询"><a href="#5：分组查询" class="headerlink" title="5：分组查询"></a>5：分组查询</h3><p><strong>语法：</strong></p><p>select 查询列表<br>from 表<br>【where 筛选条件】<br>group by 分组的字段<br>【order by 排序的字段】;</p><p><strong>特点：</strong></p><p>1、<strong>和分组函数一同查询的字段必须是group by后出现的字段</strong><br>2、筛选分为两类：分组前筛选和分组后筛选</p><table><thead><tr><th>针对的表</th><th>位置</th><th>连接的关键字</th></tr></thead><tbody><tr><td>分组前筛选</td><td>原始表</td><td>group by前    where</td></tr><tr><td>分组后筛选</td><td>group by后的结果集</td><td>group by后    having</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p><p>问题2：where——group by——having</p><p>一般来讲，能用分组前筛选的，<strong>尽量使用分组前筛选</strong>，提高效率</p><p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p><h4 id="一、引入："><a href="#一、引入：" class="headerlink" title="一、引入："></a>一、引入：</h4><p><strong>查询每个部门的员工个数</strong></p><p>SELECT COUNT(*) FROM employees WHERE department_id=90;</p><p><strong>1.简单的分组</strong></p><p><strong>案例1：查询每个工种的员工平均工资</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure><p><strong>案例2：查询每个位置的部门个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br></pre></td></tr></table></figure><p><strong>2、可以实现分组前的筛选</strong></p><p><strong>案例1：查询邮箱中包含a字符的 每个部门的最高工资</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#39;%a%&#39;</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure><p><strong>案例2：查询有奖金的每个领导手下员工的平均工资</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure><p><strong>3、分组后筛选</strong></p><p><strong>案例1</strong>：查询哪个部门的员工个数&gt;5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">①查询每个部门的员工个数**</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">**② 筛选刚才①结果**</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">HAVING COUNT(*)&gt;5;</span><br></pre></td></tr></table></figure><p><strong>案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT job_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br></pre></td></tr></table></figure><p><strong>案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">manager_id&gt;102</span><br><span class="line"></span><br><span class="line">SELECT manager_id,MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;5000;</span><br></pre></td></tr></table></figure><p><strong>4.添加排序</strong></p><p><strong>案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT job_id,MAX(salary) m</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING m&gt;6000</span><br><span class="line">ORDER BY m ;</span><br></pre></td></tr></table></figure><p><strong>5.按多个字段分组</strong></p><p><strong>案例</strong>：查询每个工种每个部门的最低工资,并按最低工资降序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT MIN(salary),job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><strong>1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(salary),MIN(salary),AVG(salary),SUM(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">ORDER BY job_id;</span><br></pre></td></tr></table></figure><p><strong>2.查询员工最高工资和最低工资的差距（DIFFERENCE）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(salary)-MIN(salary) DIFFRENCE</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><p><strong>3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT MIN(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id IS NOT NULL</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;&#x3D;6000;</span><br></pre></td></tr></table></figure><p><strong>4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,COUNT(*),AVG(salary) a</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY a DESC;</span><br></pre></td></tr></table></figure><p><strong>5.选择具有各个job_id的员工人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) 个数,job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure><h4 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h4><p><strong>功能：</strong></p><p>用作统计使用，又称为聚合函数或统计函数或组函数</p><p><strong>分类：</strong></p><p>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</p><p><strong>特点：</strong></p><p>1、sum、avg一般用于处理数值型<br>   max、min、count可以处理任何类型<br>2、以上分组函数都忽略null值</p><p>3、可以和distinct搭配实现去重的运算</p><p>4、count函数的单独介绍<br>一般使用count(*)用作统计行数</p><p>5、<strong>和分组函数一同查询的字段要求是group by后的字段</strong></p><p><strong>1、和distinct搭配</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure><p><strong>2、count函数的详细介绍</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br></pre></td></tr></table></figure><h5 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h5><p>MYISAM存储引擎下  ，COUNT(<em>)的效率高<br>INNODB存储引擎下，COUNT(</em>)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</p><p><strong>3、和分组函数一同查询的字段有限制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),employee_id  FROM employees;</span><br></pre></td></tr></table></figure><h3 id="6-连接查询"><a href="#6-连接查询" class="headerlink" title="6:连接查询"></a>6:连接查询</h3><p>含义：</p><p>又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p><p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p><p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p><p>分类：</p><pre><code>按年代分类：sql92标准:仅仅支持内连接sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接按功能分类：    内连接：        等值连接        非等值连接        自连接    外连接：        左外连接        右外连接        全外连接        交叉连接</code></pre><h4 id="1、连接查询-sql92标准"><a href="#1、连接查询-sql92标准" class="headerlink" title="1、连接查询 sql92标准"></a>1、连接查询 sql92标准</h4><h5 id="1、等值连接"><a href="#1、等值连接" class="headerlink" title="1、等值连接"></a>1、等值连接</h5><p>① 多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③ 多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">1、等值连接</span><br><span class="line"></span><br><span class="line">案例1：查询女神名和对应的男神名</span><br><span class="line">SELECT NAME,boyName </span><br><span class="line">FROM boys,beauty</span><br><span class="line">WHERE beauty.boyfriend_id&#x3D; boys.id;</span><br><span class="line"></span><br><span class="line">案例2：查询员工名和对应的部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.&#96;department_id&#96;&#x3D;departments.&#96;department_id&#96;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、为表起别名</span><br><span class="line"></span><br><span class="line">①提高语句的简洁度</span><br><span class="line">②区分多个重名的字段</span><br><span class="line"></span><br><span class="line">注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询员工名、工种号、工种名</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,e.job_id,j.job_title</span><br><span class="line">FROM employees  e,jobs j</span><br><span class="line">WHERE e.&#96;job_id&#96;&#x3D;j.&#96;job_id&#96;;</span><br><span class="line"></span><br><span class="line">3、两个表的顺序是否可以调换</span><br><span class="line"></span><br><span class="line">查询员工名、工种号、工种名</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,e.job_id,j.job_title</span><br><span class="line">FROM jobs j,employees e</span><br><span class="line">WHERE e.&#96;job_id&#96;&#x3D;j.&#96;job_id&#96;;</span><br><span class="line"></span><br><span class="line">4、可以加筛选</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例：查询有奖金的员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,commission_pct</span><br><span class="line"></span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;</span><br><span class="line">AND e.&#96;commission_pct&#96; IS NOT NULL;</span><br><span class="line"></span><br><span class="line">案例2：查询城市名中第二个字符为o的部门名和城市名</span><br><span class="line"></span><br><span class="line">SELECT department_name,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.&#96;location_id&#96; &#x3D; l.&#96;location_id&#96;</span><br><span class="line">AND city LIKE &#39;_o%&#39;;</span><br><span class="line"></span><br><span class="line">5、可以加分组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例1：查询每个城市的部门个数</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,city</span><br><span class="line">FROM departments d,locations l</span><br><span class="line">WHERE d.&#96;location_id&#96;&#x3D;l.&#96;location_id&#96;</span><br><span class="line">GROUP BY city;</span><br><span class="line"></span><br><span class="line">案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line">SELECT department_name,d.&#96;manager_id&#96;,MIN(salary)</span><br><span class="line">FROM departments d,employees e</span><br><span class="line">WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;</span><br><span class="line">AND commission_pct IS NOT NULL</span><br><span class="line">GROUP BY department_name,d.&#96;manager_id&#96;;</span><br><span class="line">6、可以加排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line"></span><br><span class="line">SELECT job_title,COUNT(*)</span><br><span class="line">FROM employees e,jobs j</span><br><span class="line">WHERE e.&#96;job_id&#96;&#x3D;j.&#96;job_id&#96;</span><br><span class="line">GROUP BY job_title</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7、可以实现三表连接？</span><br><span class="line"></span><br><span class="line">案例：查询员工名、部门名和所在的城市</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,city</span><br><span class="line">FROM employees e,departments d,locations l</span><br><span class="line">WHERE e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;</span><br><span class="line">AND d.&#96;location_id&#96;&#x3D;l.&#96;location_id&#96;</span><br><span class="line">AND city LIKE &#39;s%&#39;</span><br><span class="line"></span><br><span class="line">ORDER BY department_name DESC;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2、非等值连接"><a href="#2、非等值连接" class="headerlink" title="2、非等值连接"></a>2、非等值连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">案例1：查询员工的工资和工资级别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e,job_grades g</span><br><span class="line">WHERE salary BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96;</span><br><span class="line">AND g.&#96;grade_level&#96;&#x3D;&#39;A&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select salary,employee_id from employees;</span><br><span class="line">select * from job_grades;</span><br><span class="line">CREATE TABLE job_grades</span><br><span class="line">(grade_level VARCHAR(3),</span><br><span class="line"> lowest_sal  int,</span><br><span class="line"> highest_sal int);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES (&#39;A&#39;, 1000, 2999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES (&#39;B&#39;, 3000, 5999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#39;C&#39;, 6000, 9999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#39;D&#39;, 10000, 14999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#39;E&#39;, 15000, 24999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#39;F&#39;, 25000, 40000);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、自连接"><a href="#3、自连接" class="headerlink" title="3、自连接"></a>3、自连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">案例：查询 员工名和上级的名称</span><br><span class="line"></span><br><span class="line">SELECT e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;;</span><br></pre></td></tr></table></figure><h5 id="4、外查询案例"><a href="#4、外查询案例" class="headerlink" title="4、外查询案例"></a>4、外查询案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">一、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</span><br><span class="line"></span><br><span class="line">SELECT b.id,b.name,bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">LEFT OUTER JOIN boys bo</span><br><span class="line">ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;</span><br><span class="line">WHERE b.&#96;id&#96;&gt;3;</span><br><span class="line">二、查询哪个城市没有部门</span><br><span class="line"></span><br><span class="line">SELECT city</span><br><span class="line">FROM departments d</span><br><span class="line">RIGHT OUTER JOIN locations l </span><br><span class="line">ON d.&#96;location_id&#96;&#x3D;l.&#96;location_id&#96;</span><br><span class="line">WHERE  d.&#96;department_id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line">三、查询部门名为SAL或IT的员工信息</span><br><span class="line"></span><br><span class="line">SELECT e.*,d.department_name,d.&#96;department_id&#96;</span><br><span class="line">FROM departments  d</span><br><span class="line">LEFT JOIN employees e</span><br><span class="line">ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96;</span><br><span class="line">WHERE d.&#96;department_name&#96; IN(&#39;SAL&#39;,&#39;IT&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM departments</span><br><span class="line">WHERE &#96;department_name&#96; IN(&#39;SAL&#39;,&#39;IT&#39;);</span><br></pre></td></tr></table></figure><h4 id="2-连接查询-sql99语法"><a href="#2-连接查询-sql99语法" class="headerlink" title="2. 连接查询  sql99语法"></a>2. 连接查询  sql99语法</h4><p>语法：</p><p>​    select 查询列表<br>​    from 表1 别名 【连接类型】<br>​    join 表2 别名<br>​    on 连接条件<br>​    【where 筛选条件】<br>​    【group by 分组】<br>​    【having 筛选条件】<br>​    【order by 排序列表】<br>​    </p><p>分类：</p><p>内连接（★）：inner<br>外连接<br>    左外(★):left 【outer】<br>    右外(★)：right 【outer】<br>    全外：full【outer】<br>交叉连接：cross </p><h5 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1.内连接"></a>1.内连接</h5><p>语法：</p><p>select 查询列表<br>from 表1 别名<br>inner join 表2 别名<br>on 连接条件;</p><p>分类：<br>等值<br>非等值<br>自连接</p><p>特点：<br>①添加排序、分组、筛选<br>②inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p><h6 id="1、等值连接-1"><a href="#1、等值连接-1" class="headerlink" title="1、等值连接"></a>1、等值连接</h6><p>案例1.查询员工名、部门名</p><p>SELECT last_name,department_name<br>FROM departments d<br> JOIN  employees e<br>ON e.<code>department_id</code> = d.<code>department_id</code>;</p><p>案例2.查询名字中包含e的员工名和工种名（添加筛选）<br>SELECT last_name,job_title<br>FROM employees e<br>INNER JOIN jobs j<br>ON e.<code>job_id</code>=  j.<code>job_id</code><br>WHERE e.<code>last_name</code> LIKE ‘%e%’;</p><ol start="3"><li>查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</li></ol><p>①查询每个城市的部门个数<br>②在①结果上筛选满足条件的<br>SELECT city,COUNT(<em>) 部门个数<br>FROM departments d<br>INNER JOIN locations l<br>ON d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city<br>HAVING COUNT(</em>)&gt;3;</p><p>案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</p><p>①查询每个部门的员工个数<br>SELECT COUNT(*),department_name<br>FROM employees e<br>INNER JOIN departments d<br>ON e.<code>department_id</code>=d.<code>department_id</code><br>GROUP BY department_name</p><p>② 在①结果上筛选员工个数&gt;3的记录，并排序</p><p>SELECT COUNT(<em>) 个数,department_name<br>FROM employees e<br>INNER JOIN departments d<br>ON e.<code>department_id</code>=d.<code>department_id</code><br>GROUP BY department_name<br>HAVING COUNT(</em>)&gt;3<br>ORDER BY COUNT(*) DESC;</p><p>5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</p><p>SELECT last_name,department_name,job_title<br>FROM employees e<br>INNER JOIN departments d ON e.<code>department_id</code>=d.<code>department_id</code><br>INNER JOIN jobs j ON e.<code>job_id</code> = j.<code>job_id</code></p><p>ORDER BY department_name DESC;</p><h6 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2. 非等值连接"></a>2. 非等值连接</h6><p>查询员工的工资级别</p><p>SELECT salary,grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p><p> 查询工资级别的个数&gt;20的个数，并且按工资级别降序<br> SELECT COUNT(<em>),grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code><br> GROUP BY grade_level<br> HAVING COUNT(</em>)&gt;20<br> ORDER BY grade_level DESC;</p><h6 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3. 自连接"></a>3. 自连接</h6><p> 查询员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.<code>manager_id</code>= m.<code>employee_id</code>;</p><p>  查询姓名中包含字符k的员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.<code>manager_id</code>= m.<code>employee_id</code><br> WHERE e.<code>last_name</code> LIKE ‘%k%’;</p><h5 id="2、外连接"><a href="#2、外连接" class="headerlink" title="2、外连接"></a>2、外连接</h5><p> 应用场景：用于查询一个表中有，另一个表没有的记录</p><p> 特点：<br>     1、 外连接的查询结果为主表中的所有记录<br>            如果从表中有和它匹配的，则显示匹配的值<br>            如果从表中没有和它匹配的，则显示null<br>            外连接查询结果=内连接结果+主表中有而从表没有的记录<br>     2、左外连接，left join左边的是主表<br>            右外连接，right join右边的是主表<br>     3、左外和右外交换两个表的顺序，可以实现同样的效果<br>     4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</p><p> 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">查询男朋友 不在男神表的的女神名</span><br><span class="line"></span><br><span class="line"> SELECT * FROM beauty;</span><br><span class="line"> SELECT * FROM boys;</span><br><span class="line">左外连接</span><br><span class="line"></span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM boys bo</span><br><span class="line"> LEFT OUTER JOIN beauty b</span><br><span class="line"> ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;</span><br><span class="line"> WHERE b.&#96;id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line"> 案例1：查询哪个部门没有员工</span><br><span class="line"> 左外</span><br><span class="line"> SELECT d.*,e.employee_id</span><br><span class="line"> FROM departments d</span><br><span class="line"> LEFT OUTER JOIN employees e</span><br><span class="line"> ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96;</span><br><span class="line"> WHERE e.&#96;employee_id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 右外</span><br><span class="line"></span><br><span class="line">  SELECT d.*,e.employee_id</span><br><span class="line"> FROM employees e</span><br><span class="line"> RIGHT OUTER JOIN departments d</span><br><span class="line"> ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96;</span><br><span class="line"> WHERE e.&#96;employee_id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 全外</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> USE girls;</span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> FULL OUTER JOIN boys bo</span><br><span class="line"> ON b.&#96;boyfriend_id&#96; &#x3D; bo.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 交叉连接</span><br><span class="line"></span><br><span class="line"> SELECT b.*,bo.*</span><br><span class="line"> FROM beauty b</span><br><span class="line"> CROSS JOIN boys bo;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="分页查询-★"><a href="#分页查询-★" class="headerlink" title="分页查询 ★"></a>分页查询 ★</h4><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求<br>语法：<br>    <em><em>select 查询列表</em><br>    <em>from 表</em><br>    <em>【join type join 表2</em><br>    <em>on 连接条件</em><br>    <em>where 筛选条件</em><br>    <em>group by 分组字段</em><br>    <em>having 分组后的筛选</em><br>    <em>order by 排序的字段】</em><br>    limit 【offset,】size;</em></p><pre><code>offset要显示条目的起始索引（起始索引从0开始）size 要显示的条目个数</code></pre><p>特点：<br>    ①limit语句放在查询语句的最后<br>    ②公式<br>    要显示的页数 page，每页的条目数size</p><pre><code>select 查询列表from 表limit (page-1)*size,size;size=10page  1    02      103    20</code></pre><h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><p>案例1：查询前五条员工信息</p><p>SELECT * FROM  employees LIMIT 0,5;<br>SELECT * FROM  employees LIMIT 5;</p><p>案例2：查询第11条——第25条<br>SELECT * FROM  employees LIMIT 10,15;</p><p>案例3：有奖金的员工信息，并且工资较高的前10名显示出来<br>SELECT<br>    *<br>FROM<br>        employees<br>WHERE commission_pct IS NOT NULL<br>ORDER BY salary DESC<br>LIMIT 10 ;</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询</p><p>分类：<br>按子查询出现的位置：<br>    select后面：<br>        仅仅支持标量子查询</p><pre><code>from后面：    支持表子查询where或having后面：★    标量子查询（单行） √    列子查询  （多行） √        行子查询    exists后面（相关子查询）    表子查询</code></pre><p>按结果集的行列数不同：<br>    标量子查询（结果集只有一行一列）<br>    列子查询（结果集只有一列多行）<br>    行子查询（结果集有一行多列）<br>    表子查询（结果集一般为多行多列）</p><p>一、where或having后面</p><p>1、标量子查询（单行子查询）<br>2、列子查询（多行子查询）</p><p>3、行子查询（多列多行）</p><p>特点：<br>①子查询放在小括号内<br>②子查询一般放在条件的右侧<br>③标量子查询，一般搭配着单行操作符使用</p><blockquote><p>&lt; &gt;= &lt;= = &lt;&gt;</p></blockquote><p>列子查询，一般搭配着多行操作符使用<br>in、any/some、all</p><p>④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</p><p>1.标量子查询★</p><p>#案例1：谁的工资比 Abel 高?</p><p>①查询Abel的工资<br>SELECT salary<br>FROM employees<br>WHERE last_name = ‘Abel’</p><p>②查询员工的信息，满足 salary&gt;①结果<br>SELECT *<br>FROM employees<br>WHERE salary&gt;(</p><pre><code>SELECT salaryFROM employeesWHERE last_name = &#39;Abel&#39;</code></pre><p>);</p><p>案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</p><p>#①查询141号员工的job_id<br>SELECT job_id<br>FROM employees<br>WHERE employee_id = 141</p><p>②查询143号员工的salary<br>SELECT salary<br>FROM employees<br>WHERE employee_id = 143</p><p>③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</p><p>SELECT last_name,job_id,salary<br>FROM employees<br>WHERE job_id = (<br>    SELECT job_id<br>    FROM employees<br>    WHERE employee_id = 141<br>) AND salary&gt;(<br>    SELECT salary<br>    FROM employees<br>    WHERE employee_id = 143</p><p>);</p><p>案例3：返回公司工资最少的员工的last_name,job_id和salary</p><p>①查询公司的 最低工资<br>SELECT MIN(salary)<br>FROM employees</p><p>②查询last_name,job_id和salary，要求salary=①<br>SELECT last_name,job_id,salary<br>FROM employees<br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM employees<br>);</p><p>案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</p><p>①查询50号部门的最低工资<br>SELECT  MIN(salary)<br>FROM employees<br>WHERE department_id = 50</p><p>②查询每个部门的最低工资</p><p>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>③ 在②基础上筛选，满足min(salary)&gt;①<br>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>    SELECT  MIN(salary)<br>    FROM employees<br>    WHERE department_id = 50</p><p>);</p><p>非法使用标量子查询</p><p>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>    SELECT  salary<br>    FROM employees<br>    WHERE department_id = 250</p><p>);</p><p>2.列子查询（多行子查询）★<br>#案例1：返回location_id是1400或1700的部门中的所有员工姓名</p><p>#①查询location_id是1400或1700的部门编号<br>SELECT DISTINCT department_id<br>FROM departments<br>WHERE location_id IN(1400,1700)</p><p>②查询员工姓名，要求部门号是①列表中的某一个</p><p>SELECT last_name<br>FROM employees<br>WHERE department_id  &lt;&gt;ALL(<br>    SELECT DISTINCT department_id<br>    FROM departments<br>    WHERE location_id IN(1400,1700)</p><p>);</p><p>案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</p><p>①查询job_id为‘IT_PROG’部门任一工资</p><p>SELECT DISTINCT salary<br>FROM employees<br>WHERE job_id = ‘IT_PROG’</p><p>②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个<br>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ANY(<br>    SELECT DISTINCT salary<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>或<br>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>    SELECT MAX(salary)<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</p><p>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ALL(<br>    SELECT DISTINCT salary<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>或</p><p>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>    SELECT MIN( salary)<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>3、行子查询（结果集一行多列或多行多列）</p><p>#案例：查询员工编号最小并且工资最高的员工信息</p><p>SELECT *<br>FROM employees<br>WHERE (employee_id,salary)=(<br>    SELECT MIN(employee_id),MAX(salary)<br>    FROM employees<br>);</p><p>①查询最小的员工编号<br>SELECT MIN(employee_id)<br>FROM employees</p><p>②查询最高工资<br>SELECT MAX(salary)<br>FROM employees</p><p>③查询员工信息<br>SELECT *<br>FROM employees<br>WHERE employee_id=(<br>    SELECT MIN(employee_id)<br>    FROM employees</p><p>)AND salary=(<br>    SELECT MAX(salary)<br>    FROM employees</p><p>);</p><p>二、select后面</p><p>仅仅支持标量子查询</p><p>案例：查询每个部门的员工个数</p><p>SELECT d.*,(</p><pre><code>SELECT COUNT(*)FROM employees eWHERE e.department_id = d.`department_id`</code></pre><p> ) 个数<br> FROM departments d;</p><p> #案例2：查询员工号=102的部门名</p><p>SELECT (<br>    SELECT department_name,e.department_id<br>    FROM departments d<br>    INNER JOIN employees e<br>    ON d.department_id=e.department_id<br>    WHERE e.employee_id=102</p><p>) 部门名;</p><p>三、from后面</p><p>将子查询结果充当一张表，要求必须起别名</p><p>案例：查询每个部门的平均工资的工资等级<br>①查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>SELECT * FROM job_grades;</p><p>②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</p><p>SELECT  ag_dep.*,g.<code>grade_level</code><br>FROM (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>) ag_dep<br>INNER JOIN job_grades g<br>ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</p><p>四、exists后面（相关子查询）</p><p>/*<br>语法：<br>exists(完整的查询语句)<br>结果：<br>1或0</p><p>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);</p><p>案例1：查询有员工的部门名</p><p>in<br>SELECT department_name<br>FROM departments d<br>WHERE d.<code>department_id</code> IN(<br>    SELECT department_id<br>    FROM employees</p><p>)</p><p>exists</p><p>SELECT department_name<br>FROM departments d<br>WHERE EXISTS(<br>    SELECT *<br>    FROM employees e<br>    WHERE d.<code>department_id</code>=e.<code>department_id</code></p><p>);</p><p>案例2：查询没有女朋友的男神信息</p><p>in</p><p>SELECT bo.*<br>FROM boys bo<br>WHERE bo.id NOT IN(<br>    SELECT boyfriend_id<br>    FROM beauty<br>)</p><p>exists<br>SELECT bo.*<br>FROM boys bo<br>WHERE NOT EXISTS(<br>    SELECT boyfriend_id<br>    FROM beauty b<br>    WHERE bo.<code>id</code>=b.<code>boyfriend_id</code></p><p>);</p><ol><li>查询和Zlotkey相同部门的员工姓名和工资</li></ol><p>#①查询Zlotkey的部门<br>SELECT department_id<br>FROM employees<br>WHERE last_name = ‘Zlotkey’</p><p>②查询部门号=①的姓名和工资<br>SELECT last_name,salary<br>FROM employees<br>WHERE department_id = (<br>    SELECT department_id<br>    FROM employees<br>    WHERE last_name = ‘Zlotkey’</p><p>)</p><p>2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</p><p>①查询平均工资<br>SELECT AVG(salary)<br>FROM employees</p><p>②查询工资&gt;①的员工号，姓名和工资。</p><p>SELECT last_name,employee_id,salary<br>FROM employees<br>WHERE salary&gt;(</p><pre><code>SELECT AVG(salary)FROM employees</code></pre><p>);</p><p>3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资<br>①查询各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>②连接①结果集和employees表，进行筛选<br>SELECT employee_id,last_name,salary,e.department_id<br>FROM employees e<br>INNER JOIN (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id</p><p>) ag_dep<br>ON e.department_id = ag_dep.department_id<br>WHERE salary&gt;ag_dep.ag ;</p><ol start="4"><li>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名<br>#①查询姓名中包含字母u的员工的部门</li></ol><p>SELECT  DISTINCT department_id<br>FROM employees<br>WHERE last_name LIKE ‘%u%’</p><p>②查询部门号=①中的任意一个的员工号和姓名<br>SELECT last_name,employee_id<br>FROM employees<br>WHERE department_id IN(<br>    SELECT  DISTINCT department_id<br>    FROM employees<br>    WHERE last_name LIKE ‘%u%’<br>);</p><ol start="5"><li>查询在部门的location_id为1700的部门工作的员工的员工号</li></ol><p>①查询location_id为1700的部门</p><p>SELECT DISTINCT department_id<br>FROM departments<br>WHERE location_id  = 1700</p><p>②查询部门号=①中的任意一个的员工号<br>SELECT employee_id<br>FROM employees<br>WHERE department_id =ANY(<br>    SELECT DISTINCT department_id<br>    FROM departments<br>    WHERE location_id  = 1700</p><p>);<br>6.查询管理者是King的员工姓名和工资</p><p>①查询姓名为king的员工编号<br>SELECT employee_id<br>FROM employees<br>WHERE last_name  = ‘K_ing’</p><p>②查询哪个员工的manager_id = ①<br>SELECT last_name,salary<br>FROM employees<br>WHERE manager_id IN(<br>    SELECT employee_id<br>    FROM employees<br>    WHERE last_name  = ‘K_ing’</p><p>);</p><p>7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</p><p>①查询最高工资<br>SELECT MAX(salary)<br>FROM employees</p><p>②查询工资=①的姓.名</p><p>SELECT CONCAT(first_name,last_name) “姓.名”<br>FROM employees<br>WHERE salary=(<br>    SELECT MAX(salary)<br>    FROM employees</p><p>);</p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><hr><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p><p>语法：<br>查询语句1<br>union<br>查询语句2<br>union<br>…</p><p>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p><p>特点：★<br>1、要求多条查询语句的查询列数是一致的！<br>2、要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3、union关键字默认去重，如果使用union all 可以包含重复项</p><p>*/</p><p>#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</p><p>SELECT * FROM employees WHERE email LIKE ‘%a%’ OR department_id&gt;90;;</p><p>SELECT * FROM employees  WHERE email LIKE ‘%a%’<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;</p><p>#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</p><p>SELECT id,cname FROM t_ca WHERE csex=’男’<br>UNION ALL<br>SELECT t_id,tname FROM t_ua WHERE tGender=’male’;</p><h2 id="三、DDL"><a href="#三、DDL" class="headerlink" title="三、DDL"></a>三、DDL</h2><p>数据定义语言</p><h3 id="1、库和表的管理"><a href="#1、库和表的管理" class="headerlink" title="1、库和表的管理"></a>1、库和表的管理</h3><hr><ul><li><p>库的管理<br>创建、修改、删除</p></li><li><p>表的管理<br>创建、修改、删除</p><p>创建： create<br>修改： alter<br>删除： drop</p></li></ul><p><strong>一、库的管理</strong><br>1、库的创建</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database  [if not exists]库名;</span><br></pre></td></tr></table></figure><p>案例：创建库Books</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS books ;</span><br></pre></td></tr></table></figure><p>2、库的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME DATABASE books TO 新库名;</span><br></pre></td></tr></table></figure><p>更改库的字符集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br></pre></td></tr></table></figure><p><strong>3、库的删除</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS books;</span><br></pre></td></tr></table></figure><p><strong>二、表的管理</strong><br><strong>1.表的创建 ★</strong></p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">列名 列的类型【(长度) 约束】,</span><br><span class="line">列名 列的类型【(长度) 约束】,</span><br><span class="line">列名 列的类型【(长度) 约束】,</span><br><span class="line">...</span><br><span class="line">列名 列的类型【(长度) 约束】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">创建表Book</span><br><span class="line"></span><br><span class="line">CREATE TABLE book(</span><br><span class="line">id INT,#编号</span><br><span class="line">bName VARCHAR(20),#图书名</span><br><span class="line">price DOUBLE,#价格</span><br><span class="line">authorId  INT,#作者编号</span><br><span class="line">publishDate DATETIME#出版日期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESC book;</span><br><span class="line"></span><br><span class="line">创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">id INT,</span><br><span class="line">au_name VARCHAR(20),</span><br><span class="line">nation VARCHAR(10)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">DESC author;</span><br></pre></td></tr></table></figure><p><strong>2.表的修改</strong></p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br></pre></td></tr></table></figure><p>①修改列名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</span><br></pre></td></tr></table></figure><p>②修改列的类型或约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br></pre></td></tr></table></figure><p>③添加新列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE; </span><br></pre></td></tr></table></figure><p>④删除列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br></pre></td></tr></table></figure><p>⑤修改表名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE author RENAME TO book_author;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br></pre></td></tr></table></figure><p><strong>3.表的删除</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS book_author;</span><br></pre></td></tr></table></figure><p>通用的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br></pre></td></tr></table></figure><p><strong>4.表的复制</strong></p><p>INSERT INTO author VALUES<br>(1,’村上春树’,’日本’),<br>(2,’莫言’,’中国’),<br>(3,’冯唐’,’中国’),<br>(4,’金庸’,’中国’);</p><p>1.仅仅复制表的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE copy LIKE author;</span><br></pre></td></tr></table></figure><p>2.复制表的结构+数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;&#x2F;&#x2F;将auther全部复制到copy2</span><br></pre></td></tr></table></figure><p>只复制部分数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation&#x3D;&#39;中国&#39;;</span><br></pre></td></tr></table></figure><p>仅仅复制某些字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;</span><br></pre></td></tr></table></figure><h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><p>数值型：</p><ul><li>整型</li><li>小数：<ul><li>定点数</li><li>浮点数</li></ul></li></ul><p>日期型：</p><p>字符型：</p><ul><li>较短的文本：char、varchar</li><li>较长的文本：text、blob（保存较长的二进制数据）    </li></ul><p>一、整型</p><p><strong>分类：</strong></p><table><thead><tr><th>字节长度</th><th>smallint</th><th>mediumin</th><th>int/intege</th><th>bigint</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>8</td></tr></tbody></table><p><strong>特点：</strong><br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p><p>1.如何设置无符号和有符号</p><p>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>    t1 INT(7) ZEROFILL,<br>    t2 INT(7) ZEROFILL </p><p>);</p><p>DESC tab_int;</p><p>INSERT INTO tab_int VALUES(-123456);<br>INSERT INTO tab_int VALUES(-123456,-123456);<br>INSERT INTO tab_int VALUES(2147483648,4294967296);</p><p>INSERT INTO tab_int VALUES(123,123);</p><p>SELECT * FROM tab_int;</p><p>二、小数</p><p>分类：<br>1.浮点型<br>float(M,D)<br>double(M,D)<br>2.定点型<br>dec(M，D)<br>decimal(M,D)</p><p>特点：</p><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p><p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p><p>#测试M和D</p><p>DROP TABLE tab_float;<br>CREATE TABLE tab_float(<br>    f1 FLOAT,<br>    f2 DOUBLE,<br>    f3 DECIMAL<br>);<br>SELECT * FROM tab_float;<br>DESC tab_float;</p><p>INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);<br>INSERT INTO tab_float VALUES(123.456,123.456,123.456);<br>INSERT INTO tab_float VALUES(123.4,123.4,123.4);<br>INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);</p><p>#原则：</p><p>所选择的类型越简单越好，能保存数值的类型越小越好</p><p>*/</p><p>#三、字符型<br>/*<br>较短的文本：</p><p>char<br>varchar</p><p>其他：</p><p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p><p>较长的文本：<br>text<br>blob(较大的二进制)</p><p>特点：</p><pre><code>写法        M的意思                    特点            空间的耗费    效率</code></pre><p>char    char(M)        最大的字符数，可以省略，默认为1        固定长度的字符        比较耗费    高</p><p>varchar varchar(M)    最大的字符数，不可以省略        可变长度的字符        比较节省    低<br>*/</p><p>CREATE TABLE tab_char(<br>    c1 ENUM(‘a’,’b’,’c’)</p><p>);</p><p>INSERT INTO tab_char VALUES(‘a’);<br>INSERT INTO tab_char VALUES(‘b’);<br>INSERT INTO tab_char VALUES(‘c’);<br>INSERT INTO tab_char VALUES(‘m’);<br>INSERT INTO tab_char VALUES(‘A’);</p><p>SELECT * FROM tab_set;</p><p>CREATE TABLE tab_set(</p><pre><code>s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</code></pre><p>);<br>INSERT INTO tab_set VALUES(‘a’);<br>INSERT INTO tab_set VALUES(‘A,B’);<br>INSERT INTO tab_set VALUES(‘a,c,d’);</p><p>#四、日期型</p><p>/*</p><p>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</p><p>datetime保存日期+时间<br>timestamp保存日期+时间</p><p>特点：</p><pre><code>    字节        范围        时区等的影响</code></pre><p>datetime                   8        1000——9999                      不受<br>timestamp    4                   1970-2038                        受</p><p>*/</p><p>CREATE TABLE tab_date(<br>    t1 DATETIME,<br>    t2 TIMESTAMP</p><p>);</p><p>INSERT INTO tab_date VALUES(NOW(),NOW());</p><p>SELECT * FROM tab_date;</p><p>SHOW VARIABLES LIKE ‘time_zone’;</p><p>SET time_zone=’+9:00’;</p><h2 id="四、DML语言"><a href="#四、DML语言" class="headerlink" title="四、DML语言"></a>四、DML语言</h2><p>数据操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p><h3 id="1、插入语句"><a href="#1、插入语句" class="headerlink" title="1、插入语句"></a>1、插入语句</h3><p><strong>方式一：经典的插入</strong></p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(列名,...) values(值1,...);</span><br><span class="line">SELECT * FROM beauty;</span><br></pre></td></tr></table></figure><p>1.插入的值的类型要与列的类型一致或兼容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br></pre></td></tr></table></figure><p>2.不可以为null的列必须插入值，可以为null的列如何插入值？</p><ul><li><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);&#x2F;&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">VALUES(15,&#39;娜扎&#39;,&#39;女&#39;,&#39;1388888888&#39;);</span><br></pre></td></tr></table></figure></li></ul><p>3.列的顺序可以调换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);</span><br></pre></td></tr></table></figure><p>4.列数和值的个数必须一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);</span><br></pre></td></tr></table></figure><p>5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&#39;张飞&#39;,&#39;男&#39;,NULL,&#39;119&#39;,NULL,NULL);</span><br></pre></td></tr></table></figure><p><strong>方式二：</strong></p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">set 列名&#x3D;值,列名&#x3D;值,...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">INSERT INTO beauty</span><br><span class="line">SET id&#x3D;19,NAME&#x3D;&#39;刘涛&#39;,phone&#x3D;&#39;999&#39;;</span><br></pre></td></tr></table></figure><p><strong>两种方式比较 ★</strong></p><p>1、方式一支持插入多行,方式二不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(23,&#39;唐艺昕1&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)</span><br><span class="line">,(24,&#39;唐艺昕2&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)</span><br><span class="line">,(25,&#39;唐艺昕3&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br></pre></td></tr></table></figure><p>2、方式一支持子查询，方式二不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT 26,&#39;宋茜&#39;,&#39;11809866&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT id,boyname,&#39;1234567&#39;</span><br><span class="line">FROM boys WHERE id&lt;3;</span><br></pre></td></tr></table></figure><h3 id="2、修改语句"><a href="#2、修改语句" class="headerlink" title="2、修改语句"></a>2、修改语句</h3><p><strong>1.修改单表的记录★</strong></p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 列&#x3D;新值,列&#x3D;新值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure><p><strong>2.修改多表的记录【补充】</strong></p><p>语法：<br>sql92语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update 表1 别名,表2 别名</span><br><span class="line">set 列&#x3D;值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br></pre></td></tr></table></figure><p>sql99语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列&#x3D;值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure><h3 id="3、删除语句"><a href="#3、删除语句" class="headerlink" title="3、删除语句"></a>3、删除语句</h3><p><strong>方式一：delete</strong><br>语法：</p><p>1、单表的删除【★】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 筛选条件</span><br></pre></td></tr></table></figure><p>2、多表的删除【补充】</p><p>sql92语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br></pre></td></tr></table></figure><p>sql99语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure><p><strong>方式二：truncate</strong></p><p>语法：truncate table 表名;</p><p>​        删除表中的全部数据</p><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">运行以下脚本创建表my_employees</span><br><span class="line"></span><br><span class="line">USE myemployees;</span><br><span class="line">CREATE TABLE my_employees(</span><br><span class="line">Id INT(10),</span><br><span class="line">First_name VARCHAR(10),</span><br><span class="line">Last_name VARCHAR(10),</span><br><span class="line">Userid VARCHAR(10),</span><br><span class="line">Salary DOUBLE(10,2)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">id INT,</span><br><span class="line">userid VARCHAR(10),</span><br><span class="line">department_id INT</span><br><span class="line">);</span><br><span class="line">2.显示表my_employees的结构</span><br><span class="line">DESC my_employees;</span><br><span class="line">3.向my_employees表中插入下列数据</span><br><span class="line">IDFIRST_NAMELAST_NAMEUSERIDSALARY</span><br><span class="line">1patelRalphRpatel895</span><br><span class="line">2DancsBettyBdancs860</span><br><span class="line">3BiriBenBbiri1100</span><br><span class="line">4NewmanChadCnewman750</span><br><span class="line">5RopeburnAudreyAropebur1550</span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">VALUES(1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,895),</span><br><span class="line">(2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860),</span><br><span class="line">(3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100),</span><br><span class="line">(4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750),</span><br><span class="line">(5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550);</span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line">#方式二：</span><br><span class="line"></span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">SELECT 1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,895 UNION</span><br><span class="line">SELECT 2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860 UNION</span><br><span class="line">SELECT 3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100 UNION</span><br><span class="line">SELECT 4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750 UNION</span><br><span class="line">SELECT 5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550;</span><br><span class="line"></span><br><span class="line">4. 向users表中插入数据</span><br><span class="line">1Rpatel10</span><br><span class="line">2Bdancs10</span><br><span class="line">3Bbiri20</span><br><span class="line">4Cnewman30</span><br><span class="line">5Aropebur40</span><br><span class="line"></span><br><span class="line">INSERT INTO users</span><br><span class="line">VALUES(1,&#39;Rpatel&#39;,10),</span><br><span class="line">(2,&#39;Bdancs&#39;,10),</span><br><span class="line">(3,&#39;Bbiri&#39;,20);</span><br><span class="line">5.将3号员工的last_name修改为“drelxer”</span><br><span class="line">UPDATE my_employees SET last_name&#x3D;&#39;drelxer&#39; WHERE id &#x3D; 3;</span><br><span class="line">6.将所有工资少于900的员工的工资修改为1000</span><br><span class="line">UPDATE my_employees SET salary&#x3D;1000 WHERE salary&lt;900;</span><br><span class="line">7.将userid 为Bbiri的user表和my_employees表的记录全部删除</span><br><span class="line">DELETE u,e</span><br><span class="line">FROM users u</span><br><span class="line">JOIN my_employees e ON u.&#96;userid&#96;&#x3D;e.&#96;Userid&#96;</span><br><span class="line">WHERE u.&#96;userid&#96;&#x3D;&#39;Bbiri&#39;;</span><br><span class="line">8.删除所有数据</span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line">DELETE FROM users;</span><br><span class="line">9.检查所作的修正</span><br><span class="line">SELECT * FROM my_employees;</span><br><span class="line">SELECT * FROM users;</span><br><span class="line">10.清空表my_employees</span><br><span class="line">TRUNCATE TABLE my_employees;</span><br></pre></td></tr></table></figure><h3 id="子查询案例"><a href="#子查询案例" class="headerlink" title="子查询案例"></a>子查询案例</h3><hr><h4 id="1-查询工资最低的员工信息-last-name-salary"><a href="#1-查询工资最低的员工信息-last-name-salary" class="headerlink" title="1. 查询工资最低的员工信息: last_name, salary"></a>1. 查询工资最低的员工信息: last_name, salary</h4><p>#①查询最低的工资<br>SELECT MIN(salary)<br>FROM employees</p><p>#②查询last_name,salary，要求salary=①<br>SELECT last_name,salary<br>FROM employees<br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM employees<br>);</p><h4 id="2-查询平均工资最低的部门信息"><a href="#2-查询平均工资最低的部门信息" class="headerlink" title="2. 查询平均工资最低的部门信息"></a>2. 查询平均工资最低的部门信息</h4><p>#方式一：<br>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>#②查询①结果上的最低平均工资<br>SELECT MIN(ag)<br>FROM (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>) ag_dep</p><p>#③查询哪个部门的平均工资=②</p><p>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary)=(<br>    SELECT MIN(ag)<br>    FROM (<br>        SELECT AVG(salary) ag,department_id<br>        FROM employees<br>        GROUP BY department_id<br>    ) ag_dep</p><p>);</p><p>#④查询部门信息</p><p>SELECT d.*<br>FROM departments d<br>WHERE d.<code>department_id</code>=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    HAVING AVG(salary)=(<br>        SELECT MIN(ag)<br>        FROM (<br>            SELECT AVG(salary) ag,department_id<br>            FROM employees<br>            GROUP BY department_id<br>        ) ag_dep</p><pre><code>)</code></pre><p>);</p><p>#方式二：<br>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#②求出最低平均工资的部门编号<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY AVG(salary)<br>LIMIT 1;</p><p>#③查询部门信息<br>SELECT *<br>FROM departments<br>WHERE department_id=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary)<br>    LIMIT 1<br>);</p><h4 id="3-查询平均工资最低的部门信息和该部门的平均工资"><a href="#3-查询平均工资最低的部门信息和该部门的平均工资" class="headerlink" title="3. 查询平均工资最低的部门信息和该部门的平均工资"></a>3. 查询平均工资最低的部门信息和该部门的平均工资</h4><p>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>#②求出最低平均工资的部门编号<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY AVG(salary)<br>LIMIT 1;<br>#③查询部门信息<br>SELECT d.*,ag<br>FROM departments d<br>JOIN (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary)<br>    LIMIT 1</p><p>) ag_dep<br>ON d.<code>department_id</code>=ag_dep.department_id;</p><h4 id="4-查询平均工资最高的-job-信息"><a href="#4-查询平均工资最高的-job-信息" class="headerlink" title="4. 查询平均工资最高的 job 信息"></a>4. 查询平均工资最高的 job 信息</h4><p>#①查询最高的job的平均工资<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1</p><p>#②查询job信息<br>SELECT *<br>FROM jobs<br>WHERE job_id=(<br>    SELECT job_id<br>    FROM employees<br>    GROUP BY job_id<br>    ORDER BY AVG(salary) DESC<br>    LIMIT 1</p><p>);</p><h4 id="5-查询平均工资高于公司平均工资的部门有哪些"><a href="#5-查询平均工资高于公司平均工资的部门有哪些" class="headerlink" title="5. 查询平均工资高于公司平均工资的部门有哪些?"></a>5. 查询平均工资高于公司平均工资的部门有哪些?</h4><p>#①查询平均工资<br>SELECT AVG(salary)<br>FROM employees</p><p>#②查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#③筛选②结果集，满足平均工资&gt;①</p><p>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary)&gt;(<br>    SELECT AVG(salary)<br>    FROM employees</p><p>);</p><h4 id="6-查询出公司中所有-manager-的详细信息"><a href="#6-查询出公司中所有-manager-的详细信息" class="headerlink" title="6. 查询出公司中所有 manager 的详细信息."></a>6. 查询出公司中所有 manager 的详细信息.</h4><p>#①查询所有manager的员工编号<br>SELECT DISTINCT manager_id<br>FROM employees</p><p>#②查询详细信息，满足employee_id=①<br>SELECT *<br>FROM employees<br>WHERE employee_id =ANY(<br>    SELECT DISTINCT manager_id<br>    FROM employees</p><p>);</p><h4 id="7-各个部门中-最高工资中最低的那个部门的-最低工资是多少"><a href="#7-各个部门中-最高工资中最低的那个部门的-最低工资是多少" class="headerlink" title="7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少"></a>7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</h4><p>#①查询各部门的最高工资中最低的部门编号<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY MAX(salary)<br>LIMIT 1</p><p>#②查询①结果的那个部门的最低工资</p><p>SELECT MIN(salary) ,department_id<br>FROM employees<br>WHERE department_id=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY MAX(salary)<br>    LIMIT 1</p><p>);</p><h4 id="8-查询平均工资最高的部门的-manager-的详细信息-last-name-department-id-email-salary"><a href="#8-查询平均工资最高的部门的-manager-的详细信息-last-name-department-id-email-salary" class="headerlink" title="8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary"></a>8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</h4><p>#①查询平均工资最高的部门编号<br>SELECT<br>    department_id<br>FROM<br>    employees<br>GROUP BY department_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1 </p><p>#②将employees和departments连接查询，筛选条件是①<br>    SELECT<br>        last_name, d.department_id, email, salary<br>    FROM<br>        employees e<br>        INNER JOIN departments d<br>            ON d.manager_id = e.employee_id<br>    WHERE d.department_id =<br>        (SELECT<br>            department_id<br>        FROM<br>            employees<br>        GROUP BY department_id<br>        ORDER BY AVG(salary) DESC<br>        LIMIT 1) ;</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>#常见约束</p><p>/*</p><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><p>分类：六大约束<br>    NOT NULL：非空，用于保证该字段的值不能为空<br>    比如姓名、学号等<br>    DEFAULT:默认，用于保证该字段有默认值<br>    比如性别<br>    PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空<br>    比如学号、员工编号等<br>    UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空<br>    比如座位号<br>    CHECK:检查约束【mysql中不支持】<br>    比如年龄、性别<br>    FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值<br>        在从表添加外键约束，用于引用主表中某列的值<br>    比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p><p>添加约束的时机：<br>    1.创建表时<br>    2.修改表时</p><p>约束的添加分类：<br>    列级约束：<br>        六大约束语法上都支持，但外键约束没有效果</p><pre><code>表级约束：        除了非空、默认，其他的都支持</code></pre><p>​<br>主键和唯一的大对比：</p><pre><code>    保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合主键    √        ×        至多有1个           √，但不推荐唯一    √        √        可以有多个          √，但不推荐</code></pre><p>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表<br>    删除数据时，先删除从表，再删除主表</p><p>*/</p><p>CREATE TABLE 表名(<br>    字段名 字段类型 列级约束,<br>    字段名 字段类型,<br>    表级约束</p><p>)<br>CREATE DATABASE students;<br>#一、创建表时添加约束</p><p>#1.添加列级约束<br>/*<br>语法：</p><p>直接在字段名和类型后面追加 约束类型即可。</p><p>只支持：默认、非空、主键、唯一</p><p>*/</p><p>USE students;<br>DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT PRIMARY KEY,#主键<br>    stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>    gender CHAR(1) CHECK(gender=’男’ OR gender =’女’),#检查<br>    seat INT UNIQUE,#唯一<br>    age INT DEFAULT  18,#默认约束<br>    majorId INT REFERENCES major(id)#外键</p><p>);</p><p>CREATE TABLE major(<br>    id INT PRIMARY KEY,<br>    majorName VARCHAR(20)<br>);</p><p>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;</p><p>#2.添加表级约束<br>/*</p><p>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名)<br>*/</p><p>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT,</p><pre><code>CONSTRAINT pk PRIMARY KEY(id),#主键CONSTRAINT uq UNIQUE(seat),#唯一键CONSTRAINT ck CHECK(gender =&#39;男&#39; OR gender  = &#39;女&#39;),#检查CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</code></pre><p>);</p><p>SHOW INDEX FROM stuinfo;</p><p>#通用的写法：★</p><p>CREATE TABLE IF NOT EXISTS stuinfo(<br>    id INT PRIMARY KEY,<br>    stuname VARCHAR(20),<br>    sex CHAR(1),<br>    age INT DEFAULT 18,<br>    seat INT UNIQUE,<br>    majorid INT,<br>    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</p><p>);</p><p>#二、修改表时添加约束</p><p>/*<br>1、添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;</p><p>2、添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</p><p>*/<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT<br>)<br>DESC stuinfo;<br>#1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;<br>#2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br>#3.添加主键<br>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;<br>#②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p><p>#4.添加唯一</p><p>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;<br>#②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);</p><p>#5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </p><p>#三、修改表时删除约束</p><p>#1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</p><p>#2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;</p><p>#3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;</p><p>#4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;</p><p>#5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</p><p>SHOW INDEX FROM stuinfo;</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）</p><p>ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;<br>ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);</p><p>#2.    向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）</p><p>#3.    向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。<br>ALTER TABLE emp2 ADD COLUMN dept_id INT;<br>ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);</p><pre><code>    位置        支持的约束类型            是否可以起约束名</code></pre><p>列级约束：    列的后面    语法都支持，但外键没有效果    不可以<br>表级约束：    所有列的下面    默认和非空不支持，其他支持    可以（主键没有效果）</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>#视图<br>/*<br>含义：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据</p><p>比如：舞蹈班和普通班级的对比<br>    创建语法的关键字    是否实际占用物理空间    使用</p><p>视图    create view        只是保存了sql逻辑    增删改查，只是一般不能增删改</p><p>表    create table        保存了数据        增删改查</p><p>*/</p><p>#案例：查询姓张的学生名和专业名<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.<code>majorid</code>= m.<code>id</code><br>WHERE s.<code>stuname</code> LIKE ‘张%’;</p><p>CREATE VIEW v1<br>AS<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.<code>majorid</code>= m.<code>id</code>;</p><p>SELECT * FROM v1 WHERE stuname LIKE ‘张%’;</p><p>#一、创建视图<br>/*<br>语法：<br>create view 视图名<br>as<br>查询语句;</p><p>*/<br>USE myemployees;</p><p>#1.查询姓名中包含a字符的员工名、部门名和工种信息<br>#①创建<br>CREATE VIEW myv1<br>AS</p><p>SELECT last_name,department_name,job_title<br>FROM employees e<br>JOIN departments d ON e.department_id  = d.department_id<br>JOIN jobs j ON j.job_id  = e.job_id;</p><p>#②使用<br>SELECT * FROM myv1 WHERE last_name LIKE ‘%a%’;</p><p>#2.查询各部门的平均工资级别</p><p>#①创建视图查看每个部门的平均工资<br>CREATE VIEW myv2<br>AS<br>SELECT AVG(salary) ag,department_id<br>FROM employees<br>GROUP BY department_id;</p><p>#②使用<br>SELECT myv2.<code>ag</code>,g.grade_level<br>FROM myv2<br>JOIN job_grades g<br>ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p><p>#3.查询平均工资最低的部门信息</p><p>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p><p>#4.查询平均工资最低的部门名和工资</p><p>CREATE VIEW myv3<br>AS<br>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p><p>SELECT d.*,m.ag<br>FROM myv3 m<br>JOIN departments d<br>ON m.<code>department_id</code>=d.<code>department_id</code>;</p><p>#二、视图的修改</p><p>#方式一：<br>/*<br>create or replace view  视图名<br>as<br>查询语句;</p><p>*/<br>SELECT * FROM myv3 </p><p>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p><p>#方式二：<br>/*<br>语法：<br>alter view 视图名<br>as<br>查询语句;</p><p>*/<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;</p><p>#三、删除视图</p><p>/*</p><p>语法：drop view 视图名,视图名,…;<br>*/</p><p>DROP VIEW emp_v1,emp_v2,myv3;</p><p>#四、查看视图</p><p>DESC myv3;</p><p>SHOW CREATE VIEW myv3;</p><p>#五、视图的更新</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email,salary<em>12</em>(1+IFNULL(commission_pct,0)) “annual salary”<br>FROM employees;</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;</p><p>SELECT * FROM myv1;<br>SELECT * FROM employees;<br>#1.插入</p><p>INSERT INTO myv1 VALUES(‘张飞’,‘zf@qq.com’);</p><p>#2.修改<br>UPDATE myv1 SET last_name = ‘张无忌’ WHERE last_name=’张飞’;</p><p>#3.删除<br>DELETE FROM myv1 WHERE last_name = ‘张无忌’;</p><p>#具备以下特点的视图不允许更新</p><p>#①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT MAX(salary) m,department_id<br>FROM employees<br>GROUP BY department_id;</p><p>SELECT * FROM myv1;</p><p>#更新<br>UPDATE myv1 SET m=9000 WHERE department_id=10;</p><p>#②常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS</p><p>SELECT ‘john’ NAME;</p><p>SELECT * FROM myv2;</p><p>#更新<br>UPDATE myv2 SET NAME=’lucy’;</p><p>#③Select中包含子查询</p><p>CREATE OR REPLACE VIEW myv3<br>AS</p><p>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;</p><p>#更新<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资=100000;</p><p>#④join<br>CREATE OR REPLACE VIEW myv4<br>AS</p><p>SELECT last_name,department_name<br>FROM employees e<br>JOIN departments d<br>ON e.department_id  = d.department_id;</p><p>#更新</p><p>SELECT * FROM myv4;<br>UPDATE myv4 SET last_name  = ‘张飞’ WHERE last_name=’Whalen’;<br>INSERT INTO myv4 VALUES(‘陈真’,’xxxx’);</p><p>#⑤from一个不能更新的视图<br>CREATE OR REPLACE VIEW myv5<br>AS</p><p>SELECT * FROM myv3;</p><p>#更新</p><p>SELECT * FROM myv5;</p><p>UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;</p><p>#⑥where子句的子查询引用了from子句中的表</p><p>CREATE OR REPLACE VIEW myv6<br>AS</p><p>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>    SELECT  manager_id<br>    FROM employees<br>    WHERE manager_id IS NOT NULL<br>);</p><p>#更新<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary=10000 WHERE last_name = ‘k_ing’;</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p><p>CREATE OR REPLACE VIEW emp_v1<br>AS<br>SELECT last_name,salary,email<br>FROM employees<br>WHERE phone_number LIKE ‘011%’;</p><p>#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p><p>CREATE OR REPLACE VIEW emp_v2<br>AS<br>SELECT MAX(salary) mx_dep,department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MAX(salary)&gt;12000;</p><p>SELECT d.*,m.mx_dep<br>FROM departments d<br>JOIN emp_v2 m<br>ON m.department_id = d.<code>department_id</code>;</p><h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><p>/*<br>又称为自增长列<br>含义：可以不用手动的插入值，系统提供默认的序列值</p><p>特点：<br>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 SET auto_increment_increment=3;设置步长<br>可以通过 手动插入值，设置起始值</p><p>*/</p><p>#一、创建表时设置标识列</p><p>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>    id INT  ,<br>    NAME FLOAT UNIQUE AUTO_INCREMENT,<br>    seat INT </p><p>);<br>TRUNCATE TABLE tab_identity;</p><p>INSERT INTO tab_identity(id,NAME) VALUES(NULL,’john’);<br>INSERT INTO tab_identity(NAME) VALUES(‘lucy’);<br>SELECT * FROM tab_identity;</p><p>SHOW VARIABLES LIKE ‘%auto_increment%’;</p><p>SET auto_increment_increment=3;</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>/*<br>系统变量：<br>    全局变量<br>    会话变量</p><p>自定义变量：<br>    用户变量<br>    局部变量</p><p><em>/<br>#一、系统变量<br>/</em><br>说明：变量由系统定义，不是用户定义，属于服务器层面<br>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br>使用步骤：<br>1、查看所有系统变量<br>show global|【session】variables;<br>2、查看满足条件的部分系统变量<br>show global|【session】 variables like ‘%char%’;<br>3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br>4、为某个系统变量赋值<br>方式一：<br>set global|【session】系统变量名=值;<br>方式二：<br>set @@global|【session】系统变量名=值;</p><p><em>/<br>#1》全局变量<br>/</em><br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>*/<br>#①查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br>#②查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>#③查看指定的系统变量的值<br>SELECT @@global.autocommit;<br>#④为某个系统变量赋值<br>SET @@global.autocommit=0;<br>SET GLOBAL autocommit=0;</p><p>#2》会话变量<br>/*<br>作用域：针对于当前会话（连接）有效<br>*/<br>#①查看所有会话变量<br>SHOW SESSION VARIABLES;<br>#②查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE ‘%char%’;<br>#③查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;<br>#④为某个会话变量赋值<br>SET @@session.tx_isolation=’read-uncommitted’;<br>SET SESSION tx_isolation=’read-committed’;</p><p>#二、自定义变量<br>/*<br>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）<br>*/</p><p>#1》用户变量<br>/*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*/</p><p>#赋值操作符：=或:=<br>#①声明并初始化<br>SET @变量名=值;<br>SET @变量名:=值;<br>SELECT @变量名:=值;</p><p>#②赋值（更新变量的值）<br>#方式一：<br>    SET @变量名=值;<br>    SET @变量名:=值;<br>    SELECT @变量名:=值;<br>#方式二：<br>    SELECT 字段 INTO @变量名<br>    FROM 表;<br>#③使用（查看变量的值）<br>SELECT @变量名;</p><p>#2》局部变量<br>/*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*/</p><p>#①声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】;</p><p>#②赋值（更新变量的值）</p><p>#方式一：<br>    SET 局部变量名=值;<br>    SET 局部变量名:=值;<br>    SELECT 局部变量名:=值;<br>#方式二：<br>    SELECT 字段 INTO 具备变量名<br>    FROM 表;<br>#③使用（查看变量的值）<br>SELECT 局部变量名;</p><p>#案例：声明两个变量，求和并打印</p><p>#用户变量<br>SET @m=1;<br>SET @n=1;<br>SET @sum=@m+@n;<br>SELECT @sum;</p><p>#局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p><p>#用户变量和局部变量的对比</p><pre><code>    作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><p>局部变量定义 只能在 begin 和end之间 定义 否则会有语法错误</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>#TCL<br>/*<br>Transaction Control Language 事务控制语言</p><p>事务：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><p>案例：转账</p><p>张三丰  1000<br>郭襄    1000</p><p>update 表 set 张三丰的余额=500 where name=’张三丰’<br>意外<br>update 表 set 郭襄的余额=1500 where name=’郭襄’</p><p>事务的特性：<br>ACID<br>原子性：一个事务不可再分割，要么都执行要么都不执行<br>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态<br>隔离性：一个事务的执行不受其他事务的干扰<br>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</p><p>事务的创建<br>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p><p>delete from 表 where id =1;</p><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</p><p>set autocommit=0;</p><p>步骤1：开启事务<br>set autocommit=0;<br>start transaction;可选的<br>步骤2：编写事务中的sql语句(select insert update delete)<br>语句1;<br>语句2;<br>…</p><p>步骤3：结束事务<br>commit;提交事务<br>rollback;回滚事务</p><p>savepoint 节点名;设置保存点</p><p>事务的隔离级别：<br>          脏读        不可重复读    幻读<br>read uncommitted：√        √        √<br>read committed：  ×        √        √<br>repeatable read： ×        ×        √<br>serializable      ×             ×               ×</p><p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed<br>查看隔离级别<br>select @@tx_isolation;<br>设置隔离级别<br>set session|global transaction isolation level 隔离级别;</p><p>开启事务的语句;<br>update 表 set 张三丰的余额=500 where name=’张三丰’</p><p>update 表 set 郭襄的余额=1500 where name=’郭襄’<br>结束事务的语句;</p><p>*/</p><p>SHOW VARIABLES LIKE ‘autocommit’;<br>SHOW ENGINES;</p><p>#1.演示事务的使用步骤</p><p>#开启事务<br>SET autocommit=0;<br>START TRANSACTION;<br>#编写一组事务的语句<br>UPDATE account SET balance = 1000 WHERE username=’张无忌’;<br>UPDATE account SET balance = 1000 WHERE username=’赵敏’;</p><p>#结束事务<br>ROLLBACK;<br>#commit;</p><p>SELECT * FROM account;</p><p>#2.演示事务对于delete和truncate的处理的区别</p><p>SET autocommit=0;<br>START TRANSACTION;</p><p>DELETE FROM account;<br>ROLLBACK;</p><p>#3.演示savepoint 的使用<br>SET autocommit=0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id=28;<br>ROLLBACK TO a;#回滚到保存点</p><p>SELECT * FROM account;</p><h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><p>/*<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p><p><em>/<br>#存储过程<br>/</em><br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p>*/</p><p>#一、创建语法</p><p>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN</p><pre><code>存储过程体（一组合法的SQL语句）</code></pre><p>END</p><p>#注意：<br>/*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p><p>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*/</p><p>#二、调用语法</p><p>CALL 存储过程名(实参列表);</p><p>#——————————–案例演示———————————–<br>#1.空参列表<br>#案例：插入到admin表中五条记录</p><p>SELECT * FROM admin;</p><p>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>    INSERT INTO admin(username,<code>password</code>)<br>    VALUES(‘john1’,’0000’),(‘lily’,’0000’),(‘rose’,’0000’),(‘jack’,’0000’),(‘tom’,’0000’);<br>END $</p><p>#调用<br>CALL myp1()$</p><p>#2.创建带in模式参数的存储过程</p><p>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息</p><p>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.*<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>    WHERE b.name=beautyName;</p><p>END $</p><p>#调用<br>CALL myp2(‘柳岩’)$</p><p>#案例2 ：创建存储过程实现，用户是否登录成功</p><p>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>    DECLARE result INT DEFAULT 0;#声明并初始化</p><pre><code>SELECT COUNT(*) INTO result#赋值FROM adminWHERE admin.username = usernameAND admin.password = PASSWORD;SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用</code></pre><p>END $</p><p>#调用<br>CALL myp3(‘张飞’,’8888’)$</p><p>#3.创建out 模式参数的存储过程<br>#案例1：根据输入的女神名，返回对应的男神名<br>注意：默认是 in类型<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.boyname INTO boyname<br>    FROM boys bo<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName ;</p><p>END $</p><p>#案例2：根据输入的女神名，返回对应的男神名和魅力值</p><p>CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT)<br>BEGIN<br>    SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>    FROM boys<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = boys.id<br>    WHERE b.name=beautyName ;</p><p>END $</p><p>#调用<br>CALL myp7(‘小昭’,@name,@cp)$<br>SELECT @name,@cp$</p><p>#4.创建带inout模式参数的存储过程<br>#案例1：传入a和b两个值，最终a和b都翻倍并返回</p><p>CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)<br>BEGIN<br>    SET a=a<em>2;<br>    SET b=b</em>2;<br>END $</p><p>#调用<br>SET @m=10$<br>SET @n=20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$</p><p>#三、删除存储过程<br>#语法：drop procedure 存储过程名<br>DROP PROCEDURE p1;<br>DROP PROCEDURE p2,p3;#×</p><p>#四、查看存储过程的信息<br>DESC myp2;×<br>SHOW CREATE PROCEDURE  myp2;</p><p>#一、创建存储过程实现传入用户名和密码，插入到admin表中</p><p>CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))<br>BEGIN<br>    INSERT INTO admin(admin.username,PASSWORD)<br>    VALUES(username,loginpwd);<br>END $</p><p>#二、创建存储过程实现传入女神编号，返回女神名称和女神电话</p><p>CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))</p><p>BEGIN<br>    SELECT b.name ,b.phone INTO NAME,phone<br>    FROM beauty b<br>    WHERE b.id = id;</p><p>END $<br>#三、创建存储存储过程或函数实现传入两个女神生日，返回大小</p><p>CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)<br>BEGIN<br>    SELECT DATEDIFF(birth1,birth2) INTO result;<br>END $<br>#四、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回<br>CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))<br>BEGIN<br>    SELECT DATE_FORMAT(mydate,’%y年%m月%d日’) INTO strDate;<br>END $</p><p>CALL test_pro4(NOW(),@str)$<br>SELECT @str $</p><p>#五、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串<br>如 传入 ：小昭<br>返回： 小昭 AND 张无忌<br>DROP PROCEDURE test_pro5 $<br>CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))<br>BEGIN<br>    SELECT CONCAT(beautyName,’ and ‘,IFNULL(boyName,’null’)) INTO str<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName;</p><pre><code>SET str=</code></pre><p>END $</p><p>CALL test_pro5(‘柳岩’,@str)$<br>SELECT @str $</p><p>#六、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录<br>DROP PROCEDURE test_pro6$<br>CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)<br>BEGIN<br>    SELECT * FROM beauty LIMIT startIndex,size;<br>END $</p><p>CALL test_pro6(3,5)$</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>/*<br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p>区别：</p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p>*/</p><p>#一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>    函数体<br>END<br>/*</p><p>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型</p><p>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p><p>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记</p><p>*/</p><p>#二、调用语法<br>SELECT 函数名(参数列表)</p><p>#——————————案例演示—————————-<br>#1.无参有返回<br>#案例：返回公司的员工个数<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN</p><pre><code>DECLARE c INT DEFAULT 0;#定义局部变量SELECT COUNT(*) INTO c#赋值FROM employees;RETURN c;</code></pre><p>END $</p><p>SELECT myf1()$</p><p>#2.有参有返回<br>#案例1：根据员工名，返回它的工资</p><p>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    SET @sal=0;#定义用户变量<br>    SELECT salary INTO @sal   #赋值<br>    FROM employees<br>    WHERE last_name = empName;</p><pre><code>RETURN @sal;</code></pre><p>END $</p><p>SELECT myf2(‘k_ing’) $</p><p>#案例2：根据部门名，返回该部门的平均工资</p><p>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    DECLARE sal DOUBLE ;<br>    SELECT AVG(salary) INTO sal<br>    FROM employees e<br>    JOIN departments d ON e.department_id = d.department_id<br>    WHERE d.department_name=deptName;<br>    RETURN sal;<br>END $</p><p>SELECT myf3(‘IT’)$</p><p>#三、查看函数</p><p>SHOW CREATE FUNCTION myf3;</p><p>#四、删除函数<br>DROP FUNCTION myf3;</p><p>#案例<br>#一、创建函数，实现传入两个float，返回二者之和</p><p>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>    DECLARE SUM FLOAT DEFAULT 0;<br>    SET SUM=num1+num2;<br>    RETURN SUM;<br>END $</p><p>SELECT test_fun1(1,2)$</p><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><p>/*<br>顺序、分支、循环</p><p>*/</p><p>#一、分支结构<br>#1.if函数<br>/*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面</p><p>*/</p><p>#2.case结构<br>/*<br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>…<br>else 语句n;<br>end </p><p>情况2：<br>case<br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>…<br>else 语句n;<br>end </p><p>应用在begin end 中或外面</p><p>*/</p><p>#3.if结构</p><p>/*<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>….<br>else 语句n;<br>end if;<br>功能：类似于多重if</p><p>只能应用在begin end 中</p><p>*/</p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p><p>CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;<br>    IF score&gt;90 THEN SET ch=’A’;<br>    ELSEIF score&gt;80 THEN SET ch=’B’;<br>    ELSEIF score&gt;60 THEN SET ch=’C’;<br>    ELSE SET ch=’D’;<br>    END IF;<br>    RETURN ch;</p><p>END $</p><p>SELECT test_if(87)$</p><p>#案例2：创建存储过程，如果工资&lt;2000,则删除，如果5000&gt;工资&gt;2000,则涨工资1000，否则涨工资500</p><p>CREATE PROCEDURE test_if_pro(IN sal DOUBLE)<br>BEGIN<br>    IF sal&lt;2000 THEN DELETE FROM employees WHERE employees.salary=sal;<br>    ELSEIF sal&gt;=2000 AND sal&lt;5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.<code>salary</code>=sal;<br>    ELSE UPDATE employees SET salary=salary+500 WHERE employees.<code>salary</code>=sal;<br>    END IF;</p><p>END $</p><p>CALL test_if_pro(2100)$</p><p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p><p>CREATE FUNCTION test_case(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;</p><pre><code>CASE WHEN score&gt;90 THEN SET ch=&#39;A&#39;;WHEN score&gt;80 THEN SET ch=&#39;B&#39;;WHEN score&gt;60 THEN SET ch=&#39;C&#39;;ELSE SET ch=&#39;D&#39;;END CASE;RETURN ch;</code></pre><p>END $</p><p>SELECT test_case(56)$</p><p>#二、循环结构<br>/*<br>分类：<br>while、loop、repeat</p><p>循环控制：</p><p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p><p>*/</p><p>#1.while<br>/*</p><p>语法：</p><p>【标签:】while 循环条件 do<br>    循环体;<br>end while【 标签】;</p><p>联想：</p><p>while(循环条件){</p><pre><code>循环体;</code></pre><p>}</p><p>*/</p><p>#2.loop<br>/*</p><p>语法：<br>【标签:】loop<br>    循环体;<br>end loop 【标签】;</p><p>可以用来模拟简单的死循环</p><p>*/</p><p>#3.repeat<br>/*<br>语法：<br>【标签：】repeat<br>    循环体;<br>until 结束循环的条件<br>end repeat 【标签】;</p><p>*/</p><p>#1.没有添加循环控制语句<br>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘Rose’,i),’666’);<br>        SET i=i+1;<br>    END WHILE;</p><p>END $</p><p>CALL pro_while1(100)$</p><p>/*</p><p>int i=1;<br>while(i&lt;=insertcount){</p><pre><code>//插入i++;</code></pre><p>}</p><p>*/</p><p>#2.添加leave语句</p><p>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    a:WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘xiaohua’,i),’0000’);<br>        IF i&gt;=20 THEN LEAVE a;<br>        END IF;<br>        SET i=i+1;<br>    END WHILE a;<br>END $</p><p>CALL test_while1(100)$</p><p>#3.添加iterate语句</p><p>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    a:WHILE i&lt;=insertCount DO<br>        SET i=i+1;<br>        IF MOD(i,2)!=0 THEN ITERATE a;<br>        END IF;</p><pre><code>    INSERT INTO admin(username,`password`) VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);    END WHILE a;</code></pre><p>END $</p><p>CALL test_while1(100)$</p><p>/*</p><p>int i=0;<br>while(i&lt;=insertCount){<br>    i++;<br>    if(i%2==0){<br>        continue;<br>    }<br>    插入</p><p>}</p><p>*/</p><p>/*一、已知表stringcontent<br>其中字段：<br>id 自增长<br>content varchar(20)</p><p>向该表插入指定个数的，随机的字符串<br>*/<br>DROP TABLE IF EXISTS stringcontent;<br>CREATE TABLE stringcontent(<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    content VARCHAR(20)</p><p>);<br>DELIMITER $<br>CREATE PROCEDURE test_randstr_insert(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    DECLARE str VARCHAR(26) DEFAULT ‘abcdefghijklmnopqrstuvwxyz’;<br>    DECLARE startIndex INT;#代表初始索引<br>    DECLARE len INT;#代表截取的字符长度<br>    WHILE i&lt;=insertcount DO<br>        SET startIndex=FLOOR(RAND()<em>26+1);#代表初始索引，随机范围1-26<br>        SET len=FLOOR(RAND()</em>(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）<br>        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));<br>        SET i=i+1;<br>    END WHILE;</p><p>END $</p><p>CALL test_randstr_insert(10)$</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>First of my blog</title>
    <link href="http://example.com/2021/04/07/First-of-my-blog/"/>
    <id>http://example.com/2021/04/07/First-of-my-blog/</id>
    <published>2021-04-07T06:29:30.000Z</published>
    <updated>2021-10-01T05:21:45.816Z</updated>
    
    <content type="html"><![CDATA[<p> 梦从这里开始！！！</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
</feed>
