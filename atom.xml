<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-01T13:27:42.339Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络信息安全</title>
    <link href="http://example.com/2021/11/01/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2021/11/01/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</id>
    <published>2021-11-01T13:24:39.000Z</published>
    <updated>2021-11-01T13:27:42.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://example.com/2021/10/31/Zookeeper/"/>
    <id>http://example.com/2021/10/31/Zookeeper/</id>
    <published>2021-10-31T13:16:49.000Z</published>
    <updated>2021-10-31T13:23:27.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>ZooKeeper 是分布式应用程序的高性能协调服务。它在一个简单的界面中公开了公共服务——例如命名、配置管理、同步和组服务，因此您不必从头开始编写它们。您可以使用现成的它来实现共识、组管理、领导者选举和出席协议。您可以根据自己的特定需求在此基础上进行构建。</p><p>zookeeper主要是文件系统和通知机制</p><p>文件系统主要是用来存储数据<br>通知机制主要是服务器或者客户端进行通知，并且监督<br>基于观察者模式设计的分布式服务管理框架，开源的分布式框架</p><p><strong>特点</strong></p><p>一个leader，多个follower的集群<br>集群只要有半数以上包括半数就可正常服务，一般安装奇数台服务器<br>全局数据一致，每个服务器都保存同样的数据，实时更新<br>更新的请求顺序保持顺序（来自同一个服务器）<br>数据更新的原子性，数据要么成功要么失败<br>数据实时更新性很快<br>主要的集群步骤为</p><p>服务端启动时去注册信息（创建都是临时节点）<br>获取到当前在线服务器列表，并且注册监听<br>服务器节点下线<br>服务器节点上下线事件通知<br>process(){重新再去获取服务器列表，并注册监听}<br>数据结构<br>与 Unix 文件系统很类似，可看成树形结构，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据。也就是只能存储小数据</p><p>应用场景</p><p>统一命名服务（域名服务）<br>统一配置管理（一个集群中的所有配置都一致，且也要实时更新同步）<br>将配置信息写入ZooKeeper上的一个Znode，各个客户端服务器监听这个Znode。一旦Znode中的数据被修改，ZooKeeper将通知各个客户端服务器<br>统一集群管理（掌握实时状态）<br>将节点信息写入ZooKeeper上的一个ZNode。监听ZNode获取实时状态变化<br>服务器节点动态上下线<br>软负载均衡（根据每个节点的访问数，让访问数最少的服务器处理最新的数据需求）</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p><strong>目录介绍：</strong></p><p>bin目录 框架启动停止，客户端和服务端的<br>conf 配置文件信息<br>docs文档<br>lib 配置文档的依赖</p><h3 id="2-2-本地安装过程"><a href="#2-2-本地安装过程" class="headerlink" title="2.2 本地安装过程"></a>2.2 本地安装过程</h3><p>安装运行在Linux系统</p><p>官网首页： </p><p><a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><p><strong>1）</strong> 安装前准备</p><p>（1）安装 JDK </p><p>（2） 拷贝 apache-zookeeper-3.5.7-bin.tar.gz 安装包到 Linux 系统中</p><p>（3） 解压到指定目录 </p><pre><code>      tar -zxvf apache-zookeeper-3.5.7bin.tar.gz -C /opt/module/ </code></pre><p>（4） 修改名称 </p><pre><code>     mv apache-zookeeper-3.5.7 -bin/ zookeeper-3.5.7 </code></pre><p><strong>2）</strong> 配置修改 </p><p>（1） 将/opt/module/zookeeper-3.5.7/conf 这个路径下的 zoo_sample.cfg 修改为 zoo.cfg； </p><pre><code>      mv zoo_sample.cfg zoo.cfg </code></pre><p>（2） 打开 zoo.cfg 文件，修改 dataDir 路径： </p><p>​         vim zoo.cfg </p><p>​        修改如下内容： </p><p>​        dataDir=/opt/module/zookeeper-3.5.7/zkData </p><p>（3） 在/opt/module/zookeeper-3.5.7/这个目录上创建 zkData 文件夹 </p><pre><code> mkdir zkData </code></pre><p><strong>3）</strong> 操作 <strong>Zookeeper</strong> </p><p>（1） 启动 Zookeeper </p><p>​     bin/zkServer.sh start </p><p>（2） 查看进程是否启动 </p><p> jps </p><p>（3） 查看状态 </p><p>  bin/zkServer.sh status </p><p>（4） 启动客户端 </p><p>  bin/zkCli.sh </p><p>（5） 退出客户端： </p><pre><code>     quit </code></pre><p>（6） 停止 Zookeeper </p><h3 id="2-2-配置文件conf"><a href="#2-2-配置文件conf" class="headerlink" title="2.2 配置文件conf"></a>2.2 配置文件conf</h3><p><strong>5大参数</strong></p><ol><li>tickTime = 2000发送时间</li><li>initLimit = 10 第一次建立通信的时间（本例：10 x tickTime =2 s），最长容忍时间 ，超过，则建立通信失败</li><li>syncLimit = 5建立好连接后，下次的通信时间如果超过设定值，通信将会失败</li><li>dataDir保存zookeeper的数据，默认是temp会被系统定期清除（因此修改成我们自定义的路径）</li><li>clientPort = 2181客户端的连接端口 </li></ol><h2 id="3-zookeeper集群操作"><a href="#3-zookeeper集群操作" class="headerlink" title="3.zookeeper集群操作"></a>3.zookeeper集群操作</h2><h3 id="3-1-集群安装"><a href="#3-1-集群安装" class="headerlink" title="3.1 集群安装"></a><strong>3.1</strong> 集群安装</h3><p>假设三个节点部署zookeeper<br>那么需要3台服务器</p><p><strong>1）</strong> 集群规划 </p><p>在 hadoop102、hadoop103 和 hadoop104 三个节点上都部署 Zookeeper。 </p><p>思考：如果是<em>10</em> 台服务器，需要部署多少台<em>Zookeeper</em>？ </p><p><strong>2）</strong> 解压安装 </p><p>（1） 在 hadoop102 解压 Zookeeper 安装包到/opt/module/目录下 </p><p>[atguigu@hadoop102 software]$ tar -zxvf apache-zookeeper-3.5.7bin.tar.gz -C /opt/module/ </p><p>（2） 修改 apache-zookeeper-3.5.7-bin 名称为 zookeeper-3.5.7 </p><p>[atguigu@hadoop102 module]$ mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7 </p><p><strong>3）</strong> 配置服务器编号 </p><p>（1） 在/opt/module/zookeeper-3.5.7/这个目录下创建 zkData </p><p>[atguigu@hadoop102 zookeeper-3.5.7]$ mkdir zkData </p><p>（2） 在/opt/module/zookeeper-3.5.7/zkData 目录下创建一个 myid 的文件 </p><p>[atguigu@hadoop102 zkData]$ vi myid </p><p>在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格） </p><p>2 </p><p>注意：添加 myid 文件，一定要在 Linux 里面创建，在 notepad++里面很可能乱码 </p><p>（3） 拷贝配置好的 zookeeper 到其他机器上 </p><p>[atguigu@hadoop102 module ]$ xsync  zookeeper-3.5.7 </p><p>并分别在 hadoop103、hadoop104 上修改 myid 文件中内容为 3、4 </p><p><strong>4）</strong> 配置<strong>zoo.cfg</strong>文件 </p><p>（1） 重命名/opt/module/zookeeper-3.5.7/conf 这个目录下的 zoo_sample.cfg 为 zoo.cfg </p><p>[atguigu@hadoop102 conf]$ mv zoo_sample.cfg zoo.cfg </p><p>（2） 打开 zoo.cfg 文件 </p><p>[atguigu@hadoop102 conf]$ vim zoo.cfg </p><p>#修改数据存储路径配置 </p><p>dataDir=/opt/module/zookeeper-3.5.7/zkData </p><p>#增加如下配置 </p><p>#######################cluster########################## server.2=hadoop102:2888:3888 </p><p>server.3=hadoop103:2888:3888 </p><p>server.4=hadoop104:2888:3888 </p><p>（3） 配置参数解读 </p><p>server.A=B:C:D。 </p><p><strong>A</strong> 是一个数字，表示这个是第几号服务器；集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。 </p><p><strong>B</strong> 是这个服务器的地址； </p><p><strong>C</strong> 是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口； </p><p><strong>D</strong> 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的</p><p>Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 </p><p>（4） 同步 zoo.cfg 配置文件 </p><p>[atguigu@hadoop102 conf]$ xsync zoo.cfg </p><p><strong>选举机制</strong><br>面试的重点<br> 第一次启动时</p><p>非第一次启动，注意选举的规则 </p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031211854524.png" alt="image-20211031211854524"></p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031211930380.png" alt="image-20211031211930380"></p><p><strong>集群启动停止脚本</strong><br>当涉及的服务器很多，就需要逐个服务器去启动和关闭</p><p>可以创建开启和关闭脚本文件</p><p>大致如下：<br>在文件目录下建立一个后缀名为sh的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">echo ---------- zookeeper $i 启动 ------------</span><br><span class="line">ssh $i &quot;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7&#x2F;bin&#x2F;zkServer.sh </span><br><span class="line">start&quot;</span><br><span class="line">done</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">echo ---------- zookeeper $i 停止 ------------ </span><br><span class="line">ssh $i &quot;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7&#x2F;bin&#x2F;zkServer.sh </span><br><span class="line">stop&quot;</span><br><span class="line">done</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;status&quot;)&#123;</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">echo ---------- zookeeper $i 状态 ------------ </span><br><span class="line">ssh $i &quot;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.5.7&#x2F;bin&#x2F;zkServer.sh </span><br><span class="line">status&quot;</span><br><span class="line">done</span><br><span class="line">&#125;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>修改该文件的权限</p><p>chmod 777 zk.sh<br>之后在一个服务器中执行./zk.sh start就可启动脚本文件，其他命令也如此</p><p>查看其进程号<br>可以通过jpsall 就可查看所有服务器的进程</p><h3 id="3-2-客户端命令"><a href="#3-2-客户端命令" class="headerlink" title="3.2 客户端命令"></a>3.2 客户端命令</h3><p> <strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>Ls path</td><td>使用 ls 命令来查看当前 znode 的子节点 [可监听] ，-w 监听子节点变化，-s 附加次级信息</td></tr><tr><td>create</td><td>普通创建</td></tr><tr><td>create -s</td><td>创建含有序列的节点</td></tr><tr><td>create -e</td><td>临时创建节点（重启或者超时消失）</td></tr><tr><td>get path</td><td>获得节点的值 [可监听] ，-w 监听节点内容变化</td></tr><tr><td>get path -s</td><td>附加次级信息</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>deleteall</td><td>递归删除节点</td></tr><tr><td>stat</td><td>查看结点状态</td></tr></tbody></table><p><strong>客户端显示命令</strong></p><p>查看当前znode包含的信息</p><p>[zk: localhost:2181(CONNECTED) 0] ls /<br>[zookeeper]</p><p>查看当前数据节点详细信息</p><p>ls -s /</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031202949441.png" alt="image-20211031202949441"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">启动客户端的时候默认是本地的localhost</span><br><span class="line">如果要启动专门的服务器</span><br><span class="line">开启客户端服务时使用以下格式：</span><br><span class="line">bin&#x2F;zkCli.sh -server 服务器名:2181</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p> <strong>节点类型</strong><br> 持久/短暂<br>有序号/无序号</p><p>创建节点不带序号的 ：  create </p><p>创建节点带序号的 ： create  -s</p><p>创建同名节点也会区分不同</p><p>退出客户端之后，这些节点并没有被清除</p><p>创建临时节点 ：create -e<br>临时节点不带序号-e<br>临时节点带序号：create  -e -s<br>如果退出客户端，这些短暂节点将会被清除</p><p>修改节点的值 ：set key value</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031211955891.png" alt="image-20211031211955891"></p><p> <strong>监听器原理</strong></p><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，ZooKeeper 会通知客户端。监听机制保证 ZooKeeper 保存的任何的数</p><p>据的任何改变都能快速的响应到监听了该节点的应用程序。</p><p>1）节点的值变化监听 </p><p>（1） 在 hadoop104 主机上注册监听/sanguo 节点数据变化 </p><pre><code> get -w /sanguo  </code></pre><p>（2） 在 hadoop103 主机上修改/sanguo 节点的数据 </p><pre><code>  set /sanguo &quot;xisi&quot; </code></pre><p>（3） 观察 hadoop104 主机收到数据变化的监听  </p><p> 注意：在hadoop103再多次修改/sanguo的值，hadoop104上不会再收到监听。因为注册</p><p>一次，只能监听一次。想再次监听，需要再次注册。 </p><p>2 ）节点的子节点变化监听（路径变化） </p><p>（1） 在 hadoop104 主机上注册监听/sanguo 节点的子节点变化 </p><p> ls -w /sanguo  </p><p>（2） 在 hadoop103 主机/sanguo 节点上创建子节点 </p><p>  create /sanguo/jin “simayi” Created /sanguo/jin </p><p>（3） 观察 hadoop104 主机收到子节点变化的监听 </p><p>注意：节点的路径变化，也是注册一次，生效一次。想多次生效，就需要多次注册。 </p><p>3）节点删除与查看 </p><p><strong>（1）</strong> 删除节点 </p><p>  delete /sanguo/jin </p><p><strong>（2）</strong> 递归删除节点 </p><p>  deleteall /sanguo/shuguo </p><p><strong>(3）</strong> 查看节点状态 </p><p>  stat /sanguo  </p><h3 id="3-3-客户端代码操作"><a href="#3-3-客户端代码操作" class="headerlink" title="3.3 客户端代码操作"></a>3.3 客户端代码操作</h3><p>创建一个工程<br>在pom文件中配好依赖文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.7&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>资源配置文件中配置日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;INFO, stdout </span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c] </span><br><span class="line"></span><br><span class="line">- %m%n </span><br><span class="line">  log4j.appender.logfile&#x3D;org.apache.log4j.FileAppender </span><br><span class="line">  log4j.appender.logfile.File&#x3D;target&#x2F;spring.log </span><br><span class="line">  log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">  log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] </span><br><span class="line">- %m%n</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>在客户端中生成具体代码<br>初始化并且负责监听节点<br>主要通过设置连接的服务器，以及超时参数，监听匿名函数new Watcher() {}</p><pre><code> // 注意：逗号左右不能有空格 private String connectString = &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;    private int sessionTimeout = 2000;    private ZooKeeper zkClient;@Beforepublic void init() throws IOException &#123;    zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;        @Override        public void process(WatchedEvent watchedEvent) &#123;    &#125;);&#125;&#125;</code></pre><p>创建一个新的节点<br>创建的节点必须在初始化节点这些之后，通过注解，在之前中加入before</p><p>第一个参数是路径<br>第二个参数是数据，要求是字节类型，需要用getBytes()<br>第三个参数是权限，Ids.OPEN_ACL_UNSAFE允许所有人进行访问<br>第四个参数是创建节点的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void create() throws KeeperException, InterruptedException &#123;</span><br><span class="line">       String nodeCreated &#x3D; zkClient.create(&quot;&#x2F;manongyanjiuseng &quot;, &quot;123&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取子节点并且监听其变化<br>获取子节点通过getChildren()<br>关于获取子节点一共有两种</p><p>获取子节点第一个是路径，第二个是监听函数，如果使用true，则会使用初始化函数中重写的监听函数</p><pre><code>@Testpublic void getChildren() throws KeeperException, InterruptedException &#123;    List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;, true);for (String child : children) &#123;    System.out.println(child);&#125;// 延时Thread.sleep(Long.MAX_VALUE);</code></pre><p>注册一次生效一次，还需要在进行注册<br>希望通过延迟函数延迟程序的结束，继续监听Thread.sleep(Long.MAX_VALUE);<br>放在监听函数中就可以注册一次生效一次，之后在注册</p><pre><code>   zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;    @Override    public void process(WatchedEvent watchedEvent) &#123;   System.out.println(&quot;-------------------------------&quot;);    List&lt;String&gt; children = null;    try &#123;        children = zkClient.getChildren(&quot;/&quot;, true);        for (String child : children) &#123;            System.out.println(child);        &#125;        System.out.println(&quot;-------------------------------&quot;);    &#125; catch (KeeperException e) &#123;        e.printStackTrace();    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;&#125;);</code></pre><p>判断节点是否存在<br>exits函数，返回的是状态信息，通过状态信息判断是否还在<br>第一个参数是路径<br>第二个参数是是否监听</p><pre><code>@Testpublic void exist() throws KeeperException, InterruptedException &#123;Stat stat = zkClient.exists(&quot;/manongyanjiuseng&quot;, false);System.out.println(stat==null? &quot;not exist &quot; : &quot;exist&quot;);</code></pre><h3 id="3-4-写数据流程"><a href="#3-4-写数据流程" class="headerlink" title="3.4  写数据流程"></a>3.4  写数据流程</h3><p>(客户端向服务端)</p><p>发送给leader的时候<br>通俗解释：客户端给服务器的leader发送写请求，写完数据后给手下发送写请求，手下写完发送给leader，超过半票以上都写了则发回给客户端。之后leader在给其他手下让他们写，写完在发数据给leader</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031212021671.png" alt="image-20211031212021671"></p><p>发送给follower的时候<br>通俗解释：客户端给手下发送写的请求，手下给leader发送写的请求，写完后，给手下发送写的请求，手下写完后给leader发送确认，超过半票，leader确认后，发给刻划断，之后leader在发送写请求给其他手下</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031212037192.png" alt="image-20211031212037192"></p><h2 id="4-案例：服务器动态上下线监听"><a href="#4-案例：服务器动态上下线监听" class="headerlink" title="4. 案例：服务器动态上下线监听"></a>4. 案例：服务器动态上下线监听</h2><p>图示：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031212052454.png" alt="image-20211031212052454"></p><p>服务器上线的时候其实就是服务器启动时去注册信息（创建的都是临时节点）<br>客户端获取到当前在线的服务器列表后<br>服务器节点下线后给集群管理<br>集群管理服务器节点的下件时间通知给客户端<br>客户端通过获取服务器列表重选选择服务器<br>服务器代码</p><p>获取zookeeper集群的连接，通过zookeeper的构造函数ZooKeeper(connectString, sessionTimeout, new Watcher(){})<br>将其服务注册到zookeeper集群中，具体通过create的函数，通过获取每个服务器名字、其值、权限、节点类型<br>执行该函数通过延迟函数<br>public class DistributeServer {</p><pre><code>private String connectString = &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;private int sessionTimeout = 2000;private ZooKeeper zk;public static void main(String[] args) throws IOException, KeeperException, InterruptedException &#123;    DistributeServer server = new DistributeServer();    // 1 获取zk连接    server.getConnect();    // 2 注册服务器到zk集群    server.regist(args[0]);    // 3 启动业务逻辑（睡觉）    server.business();&#125;private void business() throws InterruptedException &#123;    Thread.sleep(Long.MAX_VALUE);&#125;private void regist(String hostname) throws KeeperException, InterruptedException &#123;    String create = zk.create(&quot;/servers/&quot;+hostname, hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    System.out.println(hostname +&quot; is online&quot;) ;&#125;private void getConnect() throws IOException &#123;    zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;        @Override        public void process(WatchedEvent watchedEvent) &#123;        &#125;    &#125;);&#125;</code></pre><p>客户端代码</p><p>获取zookeeper集群的连接，通过zookeeper的构造函数ZooKeeper(connectString, sessionTimeout, new Watcher(){})<br>客户端通过监听每个节点，具体监听通过getChildren函数，获取其节点位置，以及是否使用初始化的监听函数，true为使用。获取到的都是以列表存在，输出的时候通过遍历实现，输出的还是一些数组格式。将这些数组都封装到一个列表中，最后统一输出列表即可<br>执行该函数通过延迟函数<br>因为注册的时候记录一次<br>所以在初始化的时候，将其注册放在初始化内部getServerList();</p><pre><code>public class DistributeClient &#123;private String connectString = &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;private int sessionTimeout = 2000;private ZooKeeper zk;public static void main(String[] args) throws IOException, KeeperException, InterruptedException &#123;    DistributeClient client = new DistributeClient();    // 1 获取zk连接    client.getConnect();    // 2 监听/servers下面子节点的增加和删除    client.getServerList();    // 3 业务逻辑（睡觉）    client.business();&#125;private void business() throws InterruptedException &#123;    Thread.sleep(Long.MAX_VALUE);&#125;private void getServerList() throws KeeperException, InterruptedException &#123;    List&lt;String&gt; children = zk.getChildren(&quot;/servers&quot;, true);    ArrayList&lt;String&gt; servers = new ArrayList&lt;&gt;();    for (String child : children) &#123;        byte[] data = zk.getData(&quot;/servers/&quot; + child, false, null);        servers.add(new String(data));    &#125;    // 打印    System.out.println(servers);&#125;private void getConnect() throws IOException &#123;    zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;        @Override        public void process(WatchedEvent watchedEvent) &#123;            try &#123;                getServerList();            &#125; catch (KeeperException e) &#123;                e.printStackTrace();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);&#125;</code></pre><h2 id="5-案例：分布式锁"><a href="#5-案例：分布式锁" class="headerlink" title="5. 案例：分布式锁"></a>5. 案例：分布式锁</h2><h3 id="5-1-原生zookeeper分布式锁"><a href="#5-1-原生zookeeper分布式锁" class="headerlink" title="5.1 原生zookeeper分布式锁"></a>5.1 原生zookeeper分布式锁</h3><p>图示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211031212109623.png" alt="image-20211031212109623"></p><p>创建节点，判断是否是最小的节点<br>如果不是最小的节点，需要监听前一个的节点</p><p>健壮性可以通过CountDownLatch类</p><p>内部的代码中具体参数设置<br>可参考这些文章<br>java中substring用法详细分析（全）</p><p>监听函数<br>如果集群状态是连接，则释放connectlatch<br>如果集群类型是删除，且前一个节点的位置等于该节点的文职，则释放该节点</p><p>判断节点是否存在不用一直监听<br>获取节点信息要一直监听getData</p><pre><code>public class DistributedLock &#123;private final String connectString = &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;private final int sessionTimeout = 2000;private final ZooKeeper zk;private CountDownLatch connectLatch = new CountDownLatch(1);private CountDownLatch waitLatch = new CountDownLatch(1);private String waitPath;private String currentMode;public DistributedLock() throws IOException, InterruptedException, KeeperException &#123;    // 获取连接    zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;        @Override        public void process(WatchedEvent watchedEvent) &#123;            // connectLatch  如果连接上zk  可以释放            if (watchedEvent.getState() == Event.KeeperState.SyncConnected)&#123;                connectLatch.countDown();            &#125;            // waitLatch  需要释放            if (watchedEvent.getType()== Event.EventType.NodeDeleted &amp;&amp; watchedEvent.getPath().equals(waitPath))&#123;                waitLatch.countDown();            &#125;        &#125;    &#125;);    // 等待zk正常连接后，往下走程序    connectLatch.await();    // 判断根节点/locks是否存在    Stat stat = zk.exists(&quot;/locks&quot;, false);    if (stat == null) &#123;        // 创建一下根节点        zk.create(&quot;/locks&quot;, &quot;locks&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    &#125;&#125;// 对zk加锁public void zklock() &#123;    // 创建对应的临时带序号节点    try &#123;        currentMode = zk.create(&quot;/locks/&quot; + &quot;seq-&quot;, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);        // wait一小会, 让结果更清晰一些        Thread.sleep(10);        // 判断创建的节点是否是最小的序号节点，如果是获取到锁；如果不是，监听他序号前一个节点        List&lt;String&gt; children = zk.getChildren(&quot;/locks&quot;, false);        // 如果children 只有一个值，那就直接获取锁； 如果有多个节点，需要判断，谁最小        if (children.size() == 1) &#123;            return;        &#125; else &#123;            Collections.sort(children);            // 获取节点名称 seq-00000000            String thisNode = currentMode.substring(&quot;/locks/&quot;.length());            // 通过seq-00000000获取该节点在children集合的位置            int index = children.indexOf(thisNode);            // 判断            if (index == -1) &#123;                System.out.println(&quot;数据异常&quot;);            &#125; else if (index == 0) &#123;                // 就一个节点，可以获取锁了                return;            &#125; else &#123;                // 需要监听  他前一个节点变化                waitPath = &quot;/locks/&quot; + children.get(index - 1);                zk.getData(waitPath,true,new Stat());                // 等待监听                waitLatch.await();                return;            &#125;        &#125;    &#125; catch (KeeperException e) &#123;        e.printStackTrace();    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;// 解锁public void unZkLock() &#123;    // 删除节点    try &#123;        zk.delete(this.currentMode,-1);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125; catch (KeeperException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>测试代码： </p><pre><code>public class DistributedLockTest &#123; public static void main(String[] args) throws InterruptedException, IOException, KeeperException &#123;   final  DistributedLock lock1 = new DistributedLock();    final  DistributedLock lock2 = new DistributedLock();   new Thread(new Runnable() &#123;       @Override       public void run() &#123;           try &#123;               lock1.zklock();               System.out.println(&quot;线程1 启动，获取到锁&quot;);               Thread.sleep(5 * 1000);               lock1.unZkLock();               System.out.println(&quot;线程1 释放锁&quot;);           &#125; catch (InterruptedException e) &#123;               e.printStackTrace();           &#125;       &#125;   &#125;).start();    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                lock2.zklock();                System.out.println(&quot;线程2 启动，获取到锁&quot;);                Thread.sleep(5 * 1000);                lock2.unZkLock();                System.out.println(&quot;线程2 释放锁&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;).start();&#125;</code></pre><h3 id="5-2-curator分布式锁"><a href="#5-2-curator分布式锁" class="headerlink" title="5.2 curator分布式锁"></a>5.2 curator分布式锁</h3><p>原生的 Java API 开发存在的问题<br>（1）会话连接是异步的，需要自己去处理。比如使用CountDownLatch<br>（2）Watch 需要重复注册，不然就不能生效<br>（3）开发的复杂性还是比较高的<br>（4）不支持多节点删除和创建。需要自己去递归</p><p>curator可以解决上面的问题</p><p>添加相关的依赖文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>主要是通过工程类的定义</p><p>编写实现代码如下</p><pre><code>public class CuratorLockTest &#123;public static void main(String[] args) &#123;    // 创建分布式锁1    InterProcessMutex lock1 = new InterProcessMutex(getCuratorFramework(), &quot;/locks&quot;);    // 创建分布式锁2    InterProcessMutex lock2 = new InterProcessMutex(getCuratorFramework(), &quot;/locks&quot;);    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                lock1.acquire();                System.out.println(&quot;线程1 获取到锁&quot;);                lock1.acquire();                System.out.println(&quot;线程1 再次获取到锁&quot;);                Thread.sleep(5 * 1000);                lock1.release();                System.out.println(&quot;线程1 释放锁&quot;);                lock1.release();                System.out.println(&quot;线程1  再次释放锁&quot;);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;).start();    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                lock2.acquire();                System.out.println(&quot;线程2 获取到锁&quot;);                lock2.acquire();                System.out.println(&quot;线程2 再次获取到锁&quot;);                Thread.sleep(5 * 1000);                lock2.release();                System.out.println(&quot;线程2 释放锁&quot;);                lock2.release();                System.out.println(&quot;线程2  再次释放锁&quot;);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;).start();&#125;private static CuratorFramework getCuratorFramework() &#123;    ExponentialBackoffRetry policy = new ExponentialBackoffRetry(3000, 3);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;)            .connectionTimeoutMs(2000)            .sessionTimeoutMs(2000)            .retryPolicy(policy).build();    // 启动客户端    client.start();    System.out.println(&quot;zookeeper 启动成功&quot;);    return client;&#125;</code></pre><h2 id="6-总结企业面试"><a href="#6-总结企业面试" class="headerlink" title="6.总结企业面试"></a>6.总结企业面试</h2><p>企业中常考的面试有选举机制、集群安装以及常用命令</p><p>1.选举机制<br>半数机制，超过半数的投票通过，即通过。<br>（1）第一次启动选举规则：<br>投票过半数时，服务器 id 大的胜出<br>（2）第二次启动选举规则：<br>        ①EPOCH 大的直接胜出<br>        ②EPOCH 相同，事务 id 大的胜出<br>        ③事务 id 相同，服务器 id 大的胜出</p><p>2.集群安装</p><p>安装奇数台<br>服务器台数多：好处，提高可靠性；坏处：提高通信延时</p><p>3.ZK 集群中有几种不同的角色 ，以及区别？</p><p>  Leader、Follower、Observer 三种角色。</p><p> 区别：</p><p> 集群中有且只能有一个 Leader，Leader 负责对整个集群的写请求事务进行提交，在一个集群选出 Leader 之前是无法对外提供服务的。Follower 和 Observer 都只能处理读请求，区别是 Follower 有投票权可以参与 Leader 的竞选，Observer 无法参与 Leader 的竞选</p><p>4.常用命令<br>ls、get、create、delete</p><p><a href="https://zhuanlan.zhihu.com/p/">Zookeeper常见面试题</a></p><p>本文来源于尚硅谷2021 Zookeeper课程，仅供个人学习。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://example.com/2021/10/28/Mybatis/"/>
    <id>http://example.com/2021/10/28/Mybatis/</id>
    <published>2021-10-28T13:47:32.000Z</published>
    <updated>2021-10-28T13:48:03.788Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/diffx/"><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/logo.gif" alt="返回主页"></a></p><h2 id="1-MyBatis简介"><a href="#1-MyBatis简介" class="headerlink" title="1.MyBatis简介"></a>1.MyBatis简介</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO </p><p>官方文档 <a href="http://www.mybatis.org/mybatis-3/getting-started.html">http://www.mybatis.org/mybatis-3/getting-started.html</a></p><h2 id="2-Mybaits整体架构"><a href="#2-Mybaits整体架构" class="headerlink" title="2.Mybaits整体架构"></a>2.Mybaits整体架构</h2><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/image-20211026214833917.png" alt="image-20211026214833917"></p><h2 id="3-流程概述"><a href="#3-流程概述" class="headerlink" title="3.流程概述"></a>3.流程概述</h2><h3 id="3-1-引入依赖（pom-xml）"><a href="#3-1-引入依赖（pom-xml）" class="headerlink" title="3.1.引入依赖（pom.xml）"></a>3.1.引入依赖（pom.xml）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-全局配置文件（mybatis-config-xml）"><a href="#3-2-全局配置文件（mybatis-config-xml）" class="headerlink" title="3.2.全局配置文件（mybatis-config.xml）"></a>3.2.全局配置文件（mybatis-config.xml）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;!-- 根标签 --&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;mybatis-110?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 环境，可以配置多个，default：指定采用哪个环境 --&gt;</span><br><span class="line">   &lt;environments default&#x3D;&quot;test&quot;&gt;</span><br><span class="line">      &lt;!-- id：唯一标识 --&gt;</span><br><span class="line">      &lt;environment id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">         &lt;!-- 事务管理器，JDBC类型的事务管理器 --&gt;</span><br><span class="line">         &lt;transactionManager type&#x3D;&quot;JDBC&quot; &#x2F;&gt;</span><br><span class="line">         &lt;!-- 数据源，池类型的数据源 --&gt;</span><br><span class="line">         &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;mybatis-110&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot; &#x2F;&gt;</span><br><span class="line">         &lt;&#x2F;dataSource&gt;</span><br><span class="line">      &lt;&#x2F;environment&gt;</span><br><span class="line">      &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">         &lt;!-- 事务管理器，JDBC类型的事务管理器 --&gt;</span><br><span class="line">         &lt;transactionManager type&#x3D;&quot;JDBC&quot; &#x2F;&gt;</span><br><span class="line">         &lt;!-- 数据源，池类型的数据源 --&gt;</span><br><span class="line">         &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot; &#x2F;&gt; &lt;!-- 配置了properties，所以可以直接引用 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot; &#x2F;&gt;</span><br><span class="line">         &lt;&#x2F;dataSource&gt;</span><br><span class="line">      &lt;&#x2F;environment&gt;</span><br><span class="line">   &lt;&#x2F;environments&gt;</span><br><span class="line">  &lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-配置Map-xml"><a href="#3-3-配置Map-xml" class="headerlink" title="3.3.配置Map.xml"></a>3.3.配置Map.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;MyMapper&quot;&gt;</span><br><span class="line">   &lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一</span><br><span class="line">      resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表</span><br><span class="line">    --&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;selectUser&quot; resultType&#x3D;&quot;com.zpc.mybatis.User&quot;&gt;</span><br><span class="line">      select * from tb_user where id &#x3D; #&#123;id&#125;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><h3 id="3-4-修改全局配置文件（mybatis-config-xml）"><a href="#3-4-修改全局配置文件（mybatis-config-xml）" class="headerlink" title="3.4.修改全局配置文件（mybatis-config.xml）"></a>3.4.修改全局配置文件（mybatis-config.xml）</h3><p>配上MyMapper.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;!-- 环境，可以配置多个，default：指定采用哪个环境 --&gt;</span><br><span class="line">   &lt;environments default&#x3D;&quot;test&quot;&gt;</span><br><span class="line">      &lt;!-- id：唯一标识 --&gt;</span><br><span class="line">      &lt;environment id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">         &lt;!-- 事务管理器，JDBC类型的事务管理器 --&gt;</span><br><span class="line">         &lt;transactionManager type&#x3D;&quot;JDBC&quot; &#x2F;&gt;</span><br><span class="line">         &lt;!-- 数据源，池类型的数据源 --&gt;</span><br><span class="line">         &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;ssmdemo&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot; &#x2F;&gt;</span><br><span class="line">         &lt;&#x2F;dataSource&gt;</span><br><span class="line">      &lt;&#x2F;environment&gt;</span><br><span class="line">   &lt;&#x2F;environments&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">     &lt;mapper resource&#x3D;&quot;mappers&#x2F;MyMapper.xml&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="3-5-构建sqlSessionFactory（MybatisTest-java）"><a href="#3-5-构建sqlSessionFactory（MybatisTest-java）" class="headerlink" title="3.5.构建sqlSessionFactory（MybatisTest.java）"></a>3.5.构建sqlSessionFactory（MybatisTest.java）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定全局配置文件</span><br><span class="line">       String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">       &#x2F;&#x2F; 读取配置文件</span><br><span class="line">       InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">       &#x2F;&#x2F; 构建sqlSessionFactory</span><br><span class="line">       SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><h3 id="3-6-开启sqlSession会话，执行sql（MybatisTest-java）"><a href="#3-6-开启sqlSession会话，执行sql（MybatisTest-java）" class="headerlink" title="3.6.开启sqlSession会话，执行sql（MybatisTest.java）"></a>3.6.开启sqlSession会话，执行sql（MybatisTest.java）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取sqlSession</span><br><span class="line">      SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">      &#x2F;&#x2F; 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId</span><br><span class="line">      &#x2F;&#x2F; 第二个参数：指定传入sql的参数：这里是用户id</span><br><span class="line">      User user &#x3D; sqlSession.selectOne(&quot;MyMapper.selectUser&quot;, 1);</span><br><span class="line">      System.out.println(user);</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>方便在控制台显示日志信息</p><p> 步骤 1：添加 Log4J 的 jar 包</p><p>我们使用的是 Log4J，要确保它的 jar 包可以被应用使用。需要将 jar 包添加到应用的类路径中。 </p><p>步骤 2：配置 Log4J</p><p>配置 Log4J 比较简单。假设你需要记录这个映射器的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.mybatis.example;</span><br><span class="line">public interface BlogMapper &#123;</span><br><span class="line">  @Select(&quot;SELECT * FROM blog WHERE id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">  Blog selectBlog(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用的类路径中创建一个名为 <code>log4j.properties</code> 的文件，文件的具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 全局日志配置</span><br><span class="line">log4j.rootLogger&#x3D;ERROR, stdout</span><br><span class="line"># MyBatis 日志配置</span><br><span class="line">log4j.logger.org.mybatis.example.BlogMapper&#x3D;TRACE</span><br><span class="line"># 控制台输出</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%5p [%t] - %m%n</span><br></pre></td></tr></table></figure><h3 id="MyBatis使用步骤"><a href="#MyBatis使用步骤" class="headerlink" title="MyBatis使用步骤"></a>MyBatis使用步骤</h3><ol><li><p>配置mybatis-config.xml 全局的配置文件 (1、数据源，2、外部的mapper)</p></li><li><p>创建SqlSessionFactory</p></li><li><p>通过SqlSessionFactory创建SqlSession对象</p></li><li><p>通过SqlSession操作数据库 CRUD</p></li><li><p>调用session.commit()提交事务</p></li><li><p>调用session.close()关闭会话</p></li></ol><h2 id="4-mybatis-config-xml详解"><a href="#4-mybatis-config-xml详解" class="headerlink" title="4.mybatis-config.xml详解"></a>4.mybatis-config.xml详解</h2><p>mybatis-config.xml讲究严格的顺序，具体顺序遵循文档的顺序</p><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/1456626-20190327210626940-903705426.png" alt="img"></p><h3 id="4-1-properties属性读取外部资源"><a href="#4-1-properties属性读取外部资源" class="headerlink" title="4.1.properties属性读取外部资源"></a>4.1.properties属性读取外部资源</h3><p>properties配置的属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;dev_user&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;F2Fa3!33TYyg&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值。比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure><p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p><p>属性也可以被传递到 SqlSessionFactoryBuilder.build()方法中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory &#x3D; new SqlSessionFactoryBuilder().build(reader, props);</span><br><span class="line">&#x2F;&#x2F; ... or ...</span><br><span class="line">SqlSessionFactory factory &#x3D; new SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure><p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：</p><ul><li>1）在 properties 元素体内指定的属性首先被读取。</li><li>2）然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li><li>3）最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。</li></ul><p><strong>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。</strong></p><p>8.2.settings设置</p><p><img src="https://img2018.cnblogs.com/blog/1456626/201903/1456626-20190327210741776-205936991.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure><p>测试：<br>没有开启驼峰匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-07-01 13:57:56,486 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] &#x3D;&#x3D;&gt;  Preparing: select * from tb_user where id &#x3D; ? </span><br><span class="line">2018-07-01 13:57:56,524 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] &#x3D;&#x3D;&gt; Parameters: 1(String)</span><br><span class="line">2018-07-01 13:57:56,568 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] &lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">User&#123;id&#x3D;&#39;1&#39;, userName&#x3D;&#39;null&#39;, password&#x3D;&#39;123456&#39;, name&#x3D;&#39;大神&#39;, age&#x3D;20, sex&#x3D;2, birthday&#x3D;&#39;2018-07-01&#39;, created&#x3D;&#39;2018-07-01 13:36:09.0&#39;, updated&#x3D;&#39;2018-07-01 13:36:09.0&#39;&#125;</span><br></pre></td></tr></table></figure><p>开启驼峰匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-07-01 13:58:40,599 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] &#x3D;&#x3D;&gt;  Preparing: select * from tb_user where id &#x3D; ? </span><br><span class="line">2018-07-01 13:58:40,642 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] &#x3D;&#x3D;&gt; Parameters: 1(String)</span><br><span class="line">2018-07-01 13:58:40,661 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] &lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">User&#123;id&#x3D;&#39;1&#39;, userName&#x3D;&#39;bigGod222&#39;, password&#x3D;&#39;123456&#39;, name&#x3D;&#39;大神&#39;, age&#x3D;20, sex&#x3D;2, birthday&#x3D;&#39;2018-07-01&#39;, created&#x3D;&#39;2018-07-01 13:36:09.0&#39;, updated&#x3D;&#39;2018-07-01 13:36:09.0&#39;&#125;</span><br></pre></td></tr></table></figure><p>8.3.typeAliases<br>类型别名是为 Java 类型命名的一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias type&#x3D;&quot;com.zpc.mybatis.pojo.User&quot; alias&#x3D;&quot;User&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：每个pojo类都要去配置。<br><strong>解决方案</strong>：使用扫描包，扫描指定包下的所有类，扫描之后的别名就是类名（不区分大小写），建议使用的时候和类名一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;!--type:实体类的全路径。alias:别名，通常首字母大写--&gt;</span><br><span class="line">    &lt;!--&lt;typeAlias type&#x3D;&quot;com.zpc.mybatis.pojo.User&quot; alias&#x3D;&quot;User&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;package name&#x3D;&quot;com.zpc.mybatis.pojo&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure><p>Mybatis已经为普通的 Java 类型内建了许多相应的类型别名。它们都是大小写不敏感的.</p><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/1456626-20190327210946024-1568261798.png" alt="img"></p><h3 id="4-4-typeHandlers（类型处理器）"><a href="#4-4-typeHandlers（类型处理器）" class="headerlink" title="4.4.typeHandlers（类型处理器）"></a>4.4.typeHandlers（类型处理器）</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。</p><h3 id="4-5-plugins（插件）拦截器"><a href="#4-5-plugins（插件）拦截器" class="headerlink" title="4.5.plugins（插件）拦截器"></a>4.5.plugins（插件）拦截器</h3><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</span><br><span class="line">ParameterHandler (getParameterObject, setParameters)</span><br><span class="line">ResultSetHandler (handleResultSets, handleOutputParameters)</span><br><span class="line">StatementHandler (prepare, parameterize, batch, update, query)</span><br></pre></td></tr></table></figure><p>现在一些MyBatis 插件比如PageHelper都是基于这个原理，有时为了监控sql执行效率，也可以使用插件机制<br>原理：</p><p><img src="https://img2018.cnblogs.com/blog/1456626/201903/1456626-20190327211135308-2074954352.png" alt="img"></p><p>自定义拦截器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ExamplePlugin.java</span><br><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">  type&#x3D; Executor.class,</span><br><span class="line">  method &#x3D; &quot;update&quot;,</span><br><span class="line">  args &#x3D; &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">  public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    return invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  public Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">  &#125;</span><br><span class="line">  public void setProperties(Properties properties) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor&#x3D;&quot;org.mybatis.example.ExamplePlugin&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;someProperty&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。</p><h3 id="4-6-environments-环境"><a href="#4-6-environments-环境" class="headerlink" title="4.6.environments(环境)"></a>4.6.environments(环境)</h3><p>MyBatis 可以配置成适应多种环境，例如，开发、测试和生产环境需要有不同的配置；<br>尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。<br>虽然，这种方式也可以做到很方便的分离多个环境，但是实际使用场景下，我们更多的是选择使用spring来管理数据源，来做到环境的分离。</p><h3 id="4-7-mappers"><a href="#4-7-mappers" class="headerlink" title="4.7.mappers"></a>4.7.mappers</h3><p>需要告诉 MyBatis 到哪里去找到 SQL 映射语句。即告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;BlogMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;</span><br><span class="line">  &lt;mapper class&#x3D;&quot;org.mybatis.builder.BlogMapper&quot;&#x2F;&gt;</span><br><span class="line">  &lt;mapper class&#x3D;&quot;org.mybatis.builder.PostMapper&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure><p>这里所谓的mapper接口路径。实际上就是dao的接口路径。在mybatis中，通常把dao的包叫做mapper。类名，也叫做mapper</p><ul><li>1、定义一个接口。</li><li>2、在接口所在的包中定义mapper.xml，并且要求xml文件和interface的名称要相同。</li><li>3、在mybatis-config.xml 中通过class路径，引入mapper（注解方式）。要求mapper.xml 中的名称空间是类的接口的全路径。</li></ul><p>注解方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;mappers&#x2F;MyMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;mappers&#x2F;UserDaoMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--注解方式可以使用如下配置方式--&gt;</span><br><span class="line">    &lt;mapper class&#x3D;&quot;com.zpc.mybatis.dao.UserMapper&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure><p><em>问题：</em></p><ul><li>1、mapper.xml 和 java文件没有分离。 之后的教程讲述和spring整合之后解决。</li><li>2、需要一个一个的去加载mapper。</li></ul><p>当然也可以使用包扫描（必须使用注解方式，即在接口方法上使用注解，如@Select(“select * from tb_user “)）：<br><em>缺点</em>：</p><ul><li>1、如果包的路径有很多？</li><li>2、mapper.xml和mapper.java没有分离。<br>spring整合的时候解决。</li></ul><h2 id="5-Mapper-XML文件详解"><a href="#5-Mapper-XML文件详解" class="headerlink" title="5.Mapper XML文件详解"></a>5.Mapper XML文件详解</h2><h3 id="5-1-CRUD标签"><a href="#5-1-CRUD标签" class="headerlink" title="5.1.CRUD标签"></a>5.1.CRUD标签</h3><h4 id="5-1-1-select"><a href="#5-1-1-select" class="headerlink" title="5.1.1.select"></a>5.1.1.select</h4><p>select – 书写查询sql语句<br>select中的几个属性说明：<br>id属性：当前名称空间下的statement的唯一标识。必须。要求id和mapper接口中的方法的名字一致。<br>resultType：将结果集映射为java的对象类型。必须（和 resultMap 二选一）<br>parameterType：传入参数类型。可以省略</p><h4 id="5-1-2-insert"><a href="#5-1-2-insert" class="headerlink" title="5.1.2.insert"></a>5.1.2.insert</h4><p>insert 的几个属性说明：<br>id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致<br>parameterType：参数的类型，使用动态代理之后和方法的参数类型一致<br>useGeneratedKeys:开启主键回写<br>keyColumn：指定数据库的主键<br>keyProperty：主键对应的pojo属性名<br>标签内部：具体的sql语句。</p><h4 id="5-1-3-update"><a href="#5-1-3-update" class="headerlink" title="5.1.3.update"></a>5.1.3.update</h4><p>id属性：当前名称空间下的statement的唯一标识(必须属性)；<br>parameterType：传入的参数类型，可以省略。<br>标签内部：具体的sql语句。</p><h4 id="5-1-4-delete"><a href="#5-1-4-delete" class="headerlink" title="5.1.4.delete"></a>5.1.4.delete</h4><p>delete 的几个属性说明：<br>id属性：当前名称空间下的statement的唯一标识(必须属性)；<br>parameterType：传入的参数类型，可以省略。<br>标签内部：具体的sql语句。</p><h3 id="5-2-和"><a href="#5-2-和" class="headerlink" title="5.2.#{}和${}"></a>5.2.#{}和${}</h3><p>场景：数据库有两个一模一样的表。历史表，当前表<br>查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据。<br>希望使用1个方法来完成操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryUserByTableName&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from #&#123;tableName&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据表名查询用户信息（直接使用注解指定传入参数名称）</span><br><span class="line"> *</span><br><span class="line"> * @param tableName</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;User&gt; queryUserByTableName(String tableName);</span><br></pre></td></tr></table></figure><p>测试输出：</p><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/1456626-20190327211514143-697503265.png" alt="img"></p><p>有问题,报语法错误：相当于执行了这样一条sql:<br><code>select * from “tb_user”;</code><br>显然表名多了引号。</p><p>改正：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryUserByTableName&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from $&#123;tableName&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p><em>注意：</em><br><code>#&#123;&#125;</code> 只是替换？，相当于PreparedStatement使用占位符去替换参数，可以防止sql注入。<br><code>$&#123;&#125;</code> 是进行字符串拼接，相当于sql语句中的Statement，使用字符串去拼接sql；$可以是sql中的任一部分传入到Statement中，不能防止sql注入。</p><p>使用<code>$&#123;&#125;</code> 去取出参数值信息，需要使用<code>$&#123;value&#125;</code><br><code>#&#123;&#125;</code> 只是表示占位，与参数的名字无关，如果只有一个参数，会自动对应。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据表名查询用户信息（直接使用注解指定传入参数名称）</span><br><span class="line"> *</span><br><span class="line"> * @param tableName</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;User&gt; queryUserByTableName(@Param(&quot;tableName&quot;) String tableName);</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;queryUserByTableName&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from $&#123;tableName&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p><code>#&#123;&#125;</code>多个参数时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 登录（直接使用注解指定传入参数名称）</span><br><span class="line"> *</span><br><span class="line"> * @param userName</span><br><span class="line"> * @param password</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public User login( String userName, String password);</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;login&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user where user_name &#x3D; #&#123;userName&#125; and password &#x3D; #&#123;password&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.exceptions.PersistenceException: </span><br><span class="line">Error querying database.  Cause: org.apache.ibatis.binding.BindingException: Parameter &#39;userName&#39; not found. Available parameters are [0, 1, param1, param2]</span><br><span class="line">Cause: org.apache.ibatis.binding.BindingException: Parameter &#39;userName&#39; not found. Available parameters are [0, 1, param1, param2]</span><br></pre></td></tr></table></figure><p>解决方案一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;login&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user where user_name &#x3D; #&#123;0&#125; and password &#x3D; #&#123;1&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>解决方案二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;login&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user where user_name &#x3D; #&#123;param1&#125; and password &#x3D; #&#123;param2&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>最终解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 登录（直接使用注解指定传入参数名称）</span><br><span class="line"> *</span><br><span class="line"> * @param userName</span><br><span class="line"> * @param password</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public User login(@Param(&quot;userName&quot;) String userName, @Param(&quot;password&quot;) String password);</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;login&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user where user_name &#x3D; #&#123;userName&#125; and password &#x3D; #&#123;password&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通常在方法的参数列表上加上一个注释@Param(“xxxx”) 显式指定参数的名字，然后通过${“xxxx”}或#{“xxxx”}<br>sql语句动态生成的时候，使用${};<br>sql语句中某个参数进行占位的时候#{}</p></blockquote><h3 id="5-3-、-区别"><a href="#5-3-、-区别" class="headerlink" title="5.3.#、$区别"></a>5.3.#、$区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * #号</span><br><span class="line"> * @param username1</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">User queryUserListByName1(@Param(&quot;username1&quot;) String username1);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * $号</span><br><span class="line"> * @param username2</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">User queryUserListByName2(@Param(&quot;username2&quot;) String username2);</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;queryUserListByName1&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user WHERE user_name&#x3D;#&#123;username1&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;queryUserListByName2&quot; resultType&#x3D;&quot;com.zpc.mybatis.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user WHERE user_name&#x3D;&#39;$&#123;username2&#125;&#39;&#x2F;&#x2F;手动加了引号</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="5-4-resultMap"><a href="#5-4-resultMap" class="headerlink" title="5.4.resultMap"></a>5.4.resultMap</h3><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/1456626-20190327211835662-809178670.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/1456626-20190327211845574-1504006745.png" alt="img"></p><p>使用：</p><p><img src="https://img2018.cnblogs.com/blog/1456626/201903/1456626-20190327211856049-978145666.png" alt="img"></p><h3 id="5-5-sql片段"><a href="#5-5-sql片段" class="headerlink" title="5.5.sql片段"></a>5.5.sql片段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id&#x3D;””&gt;&lt;&#x2F;sql&gt;</span><br><span class="line">&lt;include refId&#x3D;”” &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>例如在UserMapper.xml中定义如下片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id&#x3D;&quot;commonSql&quot;&gt;</span><br><span class="line">id,</span><br><span class="line">user_name,</span><br><span class="line">password,</span><br><span class="line">name,</span><br><span class="line">age,</span><br><span class="line">sex,</span><br><span class="line">birthday,</span><br><span class="line">created,</span><br><span class="line">updated</span><br><span class="line">&lt;&#x2F;sql&gt; </span><br></pre></td></tr></table></figure><p>则可以在UserMapper.xml中使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryUserById&quot; resultMap&#x3D;&quot;userResultMap&quot;&gt;</span><br><span class="line">select &lt;include refid&#x3D;&quot;commonSql&quot;&gt;&lt;&#x2F;include&gt; from tb_user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;queryUsersLikeUserName&quot; resultType&#x3D;&quot;User&quot;&gt;</span><br><span class="line">select &lt;include refid&#x3D;&quot;commonSql&quot;&gt;&lt;&#x2F;include&gt; from tb_user where user_name like &quot;%&quot;#&#123;userName&#125;&quot;%&quot;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>Sql片段也可以定义在单独的.xml文件中如：<br>定义CommonSQL.xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;CommonSQL&quot;&gt;</span><br><span class="line">&lt;sql id&#x3D;&quot;commonSql&quot;&gt;</span><br><span class="line">id,</span><br><span class="line">user_name,</span><br><span class="line">password,</span><br><span class="line">name,</span><br><span class="line">age,</span><br><span class="line">sex,</span><br><span class="line">birthday,</span><br><span class="line">created,</span><br><span class="line">updated</span><br><span class="line">&lt;&#x2F;sql&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryUserById&quot; resultMap&#x3D;&quot;userResultMap&quot;&gt;</span><br><span class="line">select &lt;include refid&#x3D;&quot;CommonSQL.commonSql&quot;&gt;&lt;&#x2F;include&gt; from tb_user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;queryUsersLikeUserName&quot; resultType&#x3D;&quot;User&quot;&gt;</span><br><span class="line">select &lt;include refid&#x3D;&quot;CommonSQL.commonSql&quot;&gt;&lt;&#x2F;include&gt; from tb_user where user_name like &quot;%&quot;#&#123;userName&#125;&quot;%&quot;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>当然要完成这个功能还需要在全局配置文件mybatis-config.xml中引入该外部配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource&#x3D;&quot;CommonSQL.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 开启mapper接口的包扫描，基于class的配置方式 --&gt;</span><br><span class="line">&lt;package name&#x3D;&quot;com.zpc.mybatis.mapper&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure><h2 id="6-动态sql"><a href="#6-动态sql" class="headerlink" title="6.动态sql"></a>6.动态sql</h2><p>动态 SQL 是 MyBatis 的强大特性之一， 解决了根据不同条件拼接 SQL 语句 </p><p> 借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p><p> 动态sql常用标签</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;findActiveBlogWithTitleLike&quot;</span><br><span class="line">     resultType&#x3D;&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state &#x3D; ‘ACTIVE’</span><br><span class="line">  &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;&#x2F;&#x2F;使用text</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果 。</p><p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索.首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType&#x3D;&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state &#x3D; ‘ACTIVE’</span><br><span class="line">  &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;if test&#x3D;&quot;author !&#x3D; null and author.name !&#x3D; null&quot;&gt;</span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。 </p><p>MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType&#x3D;&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state &#x3D; ‘ACTIVE’</span><br><span class="line">  &lt;choose&gt;</span><br><span class="line">    &lt;when test&#x3D;&quot;title !&#x3D; null&quot;&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    &lt;&#x2F;when&gt;</span><br><span class="line">    &lt;when test&#x3D;&quot;author !&#x3D; null and author.name !&#x3D; null&quot;&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;&#x2F;when&gt;</span><br><span class="line">    &lt;otherwise&gt;</span><br><span class="line">      AND featured &#x3D; 1</span><br><span class="line">    &lt;&#x2F;otherwise&gt;</span><br><span class="line">  &lt;&#x2F;choose&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h3><p>前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType&#x3D;&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE</span><br><span class="line">  &lt;if test&#x3D;&quot;state !&#x3D; null&quot;&gt;</span><br><span class="line">    state &#x3D; #&#123;state&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;if test&#x3D;&quot;author !&#x3D; null and author.name !&#x3D; null&quot;&gt;</span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br></pre></td></tr></table></figure><p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br><span class="line">AND title like ‘someTitle’</span><br></pre></td></tr></table></figure><p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p><p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType&#x3D;&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;if test&#x3D;&quot;state !&#x3D; null&quot;&gt;</span><br><span class="line">         state &#x3D; #&#123;state&#125;</span><br><span class="line">    &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;if test&#x3D;&quot;author !&#x3D; null and author.name !&#x3D; null&quot;&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;&#x2F;where&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p><p>如果 <em>where</em> 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 <em>where</em> 元素的功能。比如，和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND |OR &quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;trim&gt;</span><br></pre></td></tr></table></figure><p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateAuthorIfNecessary&quot;&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">      &lt;if test&#x3D;&quot;password !&#x3D; null&quot;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">      &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">      &lt;if test&#x3D;&quot;bio !&#x3D; null&quot;&gt;bio&#x3D;#&#123;bio&#125;&lt;&#x2F;if&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line">  where id&#x3D;#&#123;id&#125;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>来看看与 <em>set</em> 元素等价的自定义 <em>trim</em> 元素吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;trim&gt;</span><br></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectPostIn&quot; resultType&#x3D;&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item&#x3D;&quot;item&quot; index&#x3D;&quot;index&quot; collection&#x3D;&quot;list&quot;</span><br><span class="line">      open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;&#x2F;foreach&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p><strong>提示</strong> 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><p>至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。</p><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Update(&#123;&quot;&lt;script&gt;&quot;,</span><br><span class="line">  &quot;update Author&quot;,</span><br><span class="line">  &quot;  &lt;set&gt;&quot;,</span><br><span class="line">  &quot;    &lt;if test&#x3D;&#39;username !&#x3D; null&#39;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;&quot;,</span><br><span class="line">  &quot;    &lt;if test&#x3D;&#39;password !&#x3D; null&#39;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;&quot;,</span><br><span class="line">  &quot;    &lt;if test&#x3D;&#39;email !&#x3D; null&#39;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;&quot;,</span><br><span class="line">  &quot;    &lt;if test&#x3D;&#39;bio !&#x3D; null&#39;&gt;bio&#x3D;#&#123;bio&#125;&lt;&#x2F;if&gt;&quot;,</span><br><span class="line">  &quot;  &lt;&#x2F;set&gt;&quot;,</span><br><span class="line">  &quot;where id&#x3D;#&#123;id&#125;&quot;,</span><br><span class="line">  &quot;&lt;&#x2F;script&gt;&quot;&#125;)</span><br><span class="line">void updateAuthorValues(Author author);</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind</code> 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectBlogsLike&quot; resultType&#x3D;&quot;Blog&quot;&gt;</span><br><span class="line">  &lt;bind name&#x3D;&quot;pattern&quot; value&#x3D;&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot; &#x2F;&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h3><p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insert&quot;&gt;</span><br><span class="line">  &lt;selectKey keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;BEFORE&quot;&gt;</span><br><span class="line">    &lt;if test&#x3D;&quot;_databaseId &#x3D;&#x3D; &#39;oracle&#39;&quot;&gt;</span><br><span class="line">      select seq_users.nextval from dual</span><br><span class="line">    &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;if test&#x3D;&quot;_databaseId &#x3D;&#x3D; &#39;db2&#39;&quot;&gt;</span><br><span class="line">      select nextval for seq_users from sysibm.sysdummy1&quot;</span><br><span class="line">    &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;&#x2F;selectKey&gt;</span><br><span class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure><h2 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7.缓存"></a>7.缓存</h2><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/image-20211026214739683.png" alt="image-20211026214739683"></p><h3 id="7-1-一级缓存"><a href="#7-1-一级缓存" class="headerlink" title="7.1.一级缓存"></a>7.1.一级缓存</h3><ul><li><p>一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。当 Session flush 或 close 后, 该Session 中的所有 Cache 将被清空。</p></li><li><p>本地缓存不能被关闭, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域. </p><p>在mybatis3.1之后, 可以配置本地缓存的作用域</p></li><li><p>在mybatis中，一级缓存默认是开启的，并且一直无法关闭</p></li></ul><p>一级缓存满足条件：</p><ul><li>1、同一个session中</li><li>2、相同的SQL和参数 </li></ul><h4 id="一级缓存失效"><a href="#一级缓存失效" class="headerlink" title="一级缓存失效"></a>一级缓存失效</h4><ol><li>sqlsession不同的情况</li><li>同一个sqlsession,查询条件不同,缓存中还没有</li><li>两次查询执行了增删改，导致缓存内容失效</li><li>手动清除了一级缓存</li></ol><h3 id="7-2-二级缓存"><a href="#7-2-二级缓存" class="headerlink" title="7.2.二级缓存"></a>7.2.二级缓存</h3><p>也就是全局缓存，：基于namespace级别的缓存：</p><p>二级缓存：  一个namespace对应一个二级缓存：</p><p>工作机制：</p><ul><li><p>1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；</p></li><li><p>2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容；</p></li><li><p>3、sqlSession===EmployeeMapper==&gt;EmployeeDepartmentMapper===&gt;Department</p><p>​        不同namespace查出的数据会放在自己对应的缓存中（map）</p><p>​        效果：数据会从二级缓存中获取</p><p>​        查出的数据都会被默认先放在一级缓存中。</p><p>​        只有<strong>会话提交或者关闭</strong>以后，一级缓存中的数据才会转移到二级缓存中</p></li></ul><p> 使用：</p><ul><li><p>```</p><pre><code>1）、开启全局二级缓存配置：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;2）mapper.xml中配置使用二级缓存：          &lt;cache&gt;        &lt;/cache&gt;3）我们的POJO需要实现序列化接口</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  缓存有关的设置&#x2F;属性：</span><br><span class="line"></span><br><span class="line">  1）cacheEnabled&#x3D;true：false：关闭缓存（二级缓存关闭）(一级缓存一直可用的)</span><br><span class="line"></span><br><span class="line">  2）每个select标签都有useCache&#x3D;&quot;true&quot;：</span><br><span class="line"></span><br><span class="line">  ​false：不使用缓存（一级缓存依然使用，二级缓存不使用）</span><br><span class="line"></span><br><span class="line">  3）每个增删改标签的：flushCache&#x3D;&quot;true&quot;：（一级二级都会清除）</span><br><span class="line"></span><br><span class="line">  ​    增删改执行完成后就会清除缓存；</span><br><span class="line"></span><br><span class="line">  ​测试：flushCache&#x3D;&quot;true&quot;：一级缓存就清空了；二级也会被清除；</span><br><span class="line"></span><br><span class="line">  ​查询标签：flushCache&#x3D;&quot;false&quot;：如果flushCache&#x3D;true;每次查询之后都会清空缓存；缓存是没有被使用的；</span><br><span class="line"></span><br><span class="line">  4）、sqlSession.clearCache();只是清除当前session的一级缓存；</span><br><span class="line"></span><br><span class="line">  5）、localCacheScope：本地缓存作用域：（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中；</span><br><span class="line"></span><br><span class="line">  ​STATEMENT：可以禁用一级缓存；       </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 8.Spring 集成Mybatis</span><br><span class="line"></span><br><span class="line">### 8.1引入spring和Mybatis相关依赖</span><br><span class="line"></span><br><span class="line">pom.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure><!--数据库连接池--><dependency>  <groupId>com.alibaba</groupId>  <artifactId>druid</artifactId>  <version>1.1.8</version></dependency><dependency>  <groupId>org.mybatis</groupId>  <artifactId>mybatis-spring</artifactId>  <version>1.2.2</version></dependency><dependency>  <groupId>org.springframework</groupId>  <artifactId>spring-jdbc</artifactId>  <version>4.1.3.RELEASE</version></dependency><!--spring集成Junit测试--><dependency>  <groupId>org.springframework</groupId>  <artifactId>spring-test</artifactId>  <version>4.1.3.RELEASE</version>  <scope>test</scope></dependency><!--spring容器--><dependency>  <groupId>org.springframework</groupId>  <artifactId>spring-context</artifactId>  <version>4.1.3.RELEASE</version></dependency><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.2配置spring配置文件</span><br><span class="line"></span><br><span class="line">applicationContext-dao.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure><beans xmlns="http://www.springframework.org/schema/beans"     xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p"     xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">  <!-- 加载配置文件 --><p>  &lt;context:property-placeholder location=”classpath:properties/*.properties”/&gt;</p>  <!-- 数据库连接池 --><p>  &lt;bean id=”dataSource” class=”com.alibaba.druid.pool.DruidDataSource”</p><pre><code>    destroy-method=&quot;close&quot;&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;  &lt;property name=&quot;url&quot;            value=&quot;jdbc:mysql://$&#123;jdbc.host&#125;:3306/$&#123;jdbc.database&#125;?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;zeroDateTimeBehavior=convertToNull&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.userName&#125;&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.passWord&#125;&quot;/&gt;  &lt;!-- 初始化连接大小 --&gt;  &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;&gt;&lt;/property&gt;  &lt;!-- 连接池最大数据库连接数  0 为没有限制 --&gt;  &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;&gt;&lt;/property&gt;  &lt;!-- 连接池最大的空闲连接数，这里取值为20，表示即使没有数据库连接时依然可以保持20空闲的连接，而不被清除，随时处于待命状态 0 为没有限制 --&gt;  &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;&gt;&lt;/property&gt;  &lt;!-- 连接池最小空闲 --&gt;  &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot;&gt;&lt;/property&gt;  &lt;!--最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制--&gt;  &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot;&gt;&lt;/property&gt;</code></pre>  </bean>  <!-- spring和MyBatis完美整合 -->  <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">      <property name="dataSource" ref="dataSource"/>      <!-- 自动扫描mapping.xml文件 -->      <property name="mapperLocations" value="classpath:mappers/*.xml"></property>      <!--如果mybatis-config.xml没有特殊配置也可以不需要下面的配置-->      <property name="configLocation" value="classpath:mybatis-config.xml" />  </bean>  <!-- DAO接口所在包名，Spring会自动查找其下的类 -->  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">      <property name="basePackage" value="com.zpc.mybatis.dao"/>      <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"></property>  </bean>  <!-- (事务管理)transaction manager --><p>  &lt;bean id=”transactionManager”</p><pre><code>    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</code></pre>  </bean></beans><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">db.properties</span><br><span class="line"></span><br></pre></td></tr></table></figure>jdbc.driver=com.mysql.jdbc.Driverjdbc.host=localhostjdbc.database=ssmdemojdbc.userName=rootjdbc.passWord=123456jdbc.initialSize=0jdbc.maxActive=20jdbc.maxIdle=20jdbc.minIdle=1jdbc.maxWait=1000<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于applicationContext-dao.xml中配置了Mapper接口扫描，所以删除mybatis-config.xml中的配置，否则报已映射错误：</span><br><span class="line">Caused by: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for MyMapper.selectUser</span><br><span class="line">删除mybatis-config.xml中的映射配置：</span><br><span class="line"></span><br></pre></td></tr></table></figure><!--<mappers>-->  <!--<mapper resource="mappers/MyMapper.xml"/>-->  <!--<mapper resource="mappers/UserDaoMapper.xml"/>-->  <!--<mapper resource="mappers/UserMapper.xml"/>-->  <!--<mapper resource="mappers/OrderMapper.xml"/>--><!--</mappers>--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者在构建sqlSessionFactory时不配置mybatis-config.xml也行：</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- spring和MyBatis完美整合 --><bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">  <property name="dataSource" ref="dataSource"/>  <!-- 自动扫描mapping.xml文件 -->  <property name="mapperLocations" value="classpath:mappers/*.xml"></property>  <!--如果mybatis-config.xml没有特殊配置也可以不需要下面的配置-->  <!--<property name="configLocation" value="classpath:mybatis-config.xml" />--></bean><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.3 测试</span><br><span class="line"></span><br><span class="line">UserMapperSpringTest.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>import com.zpc.mybatis.dao.UserMapper;import com.zpc.mybatis.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.io.InputStream;import java.util.Date;import java.util.List;</li></ul><p>//目标：测试一下spring的bean的某些功能<br>@RunWith(SpringJUnit4ClassRunner.class)//junit整合spring的测试//立马开启了spring的注解<br>@ContextConfiguration(locations=”classpath:spring/applicationContext-*.xml”)//加载核心配置文件，自动构建spring容器<br>public class UserMapperSpringTest {</p><pre><code>@Autowiredprivate UserMapper userMapper;@Testpublic void testQueryUserByTableName() &#123;    List&lt;User&gt; userList = this.userMapper.queryUserByTableName(&quot;tb_user&quot;);    for (User user : userList) &#123;        System.out.println(user);    &#125;&#125;@Testpublic void testLogin() &#123;    System.out.println(this.userMapper.login(&quot;hj&quot;, &quot;123456&quot;));&#125;@Testpublic void testQueryUserById() &#123;    System.out.println(this.userMapper.queryUserById(&quot;1&quot;));    User user = new User();    user.setName(&quot;美女&quot;);    user.setId(&quot;1&quot;);    userMapper.updateUser(user);    System.out.println(this.userMapper.queryUserById(&quot;1&quot;));&#125;@Testpublic void testQueryUserAll() &#123;    List&lt;User&gt; userList = this.userMapper.queryUserAll();    for (User user : userList) &#123;        System.out.println(user);    &#125;&#125;@Testpublic void testInsertUser() &#123;    User user = new User();    user.setAge(20);    user.setBirthday(new Date());    user.setName(&quot;大神&quot;);    user.setPassword(&quot;123456&quot;);    user.setSex(2);    user.setUserName(&quot;bigGod222&quot;);    this.userMapper.insertUser(user);    System.out.println(user.getId());&#125;@Testpublic void testUpdateUser() &#123;    User user = new User();    user.setBirthday(new Date());    user.setName(&quot;静静&quot;);    user.setPassword(&quot;123456&quot;);    user.setSex(0);    user.setUserName(&quot;Jinjin&quot;);    user.setId(&quot;1&quot;);    this.userMapper.updateUser(user);&#125;@Testpublic void testDeleteUserById() &#123;    this.userMapper.deleteUserById(&quot;1&quot;);&#125;@Testpublic void testqueryUserList() &#123;    List&lt;User&gt; users = this.userMapper.queryUserList(null);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;@Testpublic void queryUserListByNameAndAge() throws Exception &#123;    List&lt;User&gt; users = this.userMapper.queryUserListByNameAndAge(&quot;鹏程&quot;, 20);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;@Testpublic void queryUserListByNameOrAge() throws Exception &#123;    List&lt;User&gt; users = this.userMapper.queryUserListByNameOrAge(null, 16);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;@Testpublic void queryUserListByIds() throws Exception &#123;    List&lt;User&gt; users = this.userMapper.queryUserListByIds(new String[]&#123;&quot;5&quot;, &quot;2&quot;&#125;);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">目录结构：</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chen-boran&#x2F;Picture_bed&#x2F;main&#x2F;img&#x2F;1456626-20190327213559514-141765959.png)</span><br><span class="line"></span><br><span class="line">## 9.SpringBoot 集成Mybatis</span><br><span class="line"></span><br><span class="line">请参见博客：https:&#x2F;&#x2F;blog.csdn.net&#x2F;hellozpc&#x2F;article&#x2F;details&#x2F;82531834</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">###  </span><br><span class="line"></span><br><span class="line">## 10. Mabitis 逆向工程</span><br><span class="line"></span><br><span class="line">**MyBatis Generator：** </span><br><span class="line"></span><br><span class="line"> 一个专门为MyBatis框架使用者定制的代码生成器，快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写。</span><br><span class="line"></span><br><span class="line">• 官方文档地址</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.mybatis.org&#x2F;generator&#x2F; </span><br><span class="line"></span><br><span class="line">• 官方工程地址</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mybatis&#x2F;generator&#x2F;releases</span><br><span class="line"></span><br><span class="line">**使用**：创建数据库文件</span><br><span class="line"></span><br><span class="line">倒入逆向工程jar包     mybatis-generator-core-1.3.2.jar</span><br><span class="line"></span><br><span class="line">使用步骤：</span><br><span class="line"></span><br><span class="line">1）编写MBG的配置文件（重要几处配置）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1）jdbcConnection配置数据库连接信息</p><p>2）javaModelGenerator配置javaBean的生成策略</p><p>3）sqlMapGenerator 配置sql映射文件生成策略</p><p>4）javaClientGenerator配置Mapper接口的生成策略</p><p>5）table 配置要逆向解析的数据表</p><p>tableName：表名</p><p>domainObjectName：对应的javaBean名 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  2）运行代码生成器生成代码</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">## 11.Mybatis工作原理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>步骤：</p><ul><li> 1、根据配置文件（全局，sql映射）初始化出Configuration对象</li><li> 2、创建一个DefaultSqlSession对象，</li><li><pre><code>他里面包含Configuration以及</code></pre></li><li><pre><code>Executor（根据全局配置文件中的defaultExecutorType创建出对应的Executor）</code></pre></li><li> 3、DefaultSqlSession.getMapper（）：拿到Mapper接口对应的MapperProxy；</li><li> 4、MapperProxy里面有（DefaultSqlSession）；</li><li> 5、执行增删改查方法：</li><li><pre><code>    1）、调用DefaultSqlSession的增删改查（Executor）；</code></pre></li><li><pre><code>    2）、会创建一个StatementHandler对象。</code></pre></li><li><pre><code>       （同时也会创建出ParameterHandler和ResultSetHandler）</code></pre></li><li><pre><code>    3）、调用StatementHandler预编译参数以及设置参数值;</code></pre></li><li><pre><code>       使用ParameterHandler来给sql设置参数</code></pre></li><li><pre><code>    4）、调用StatementHandler的增删改查方法；</code></pre></li><li><pre><code>    5）、ResultSetHandler封装结果</code></pre></li><li> 注意：</li><li><pre><code> 四大对象每个创建的时候都有一个                         interceptorChain.pluginAll(parameterHandler);</code></pre></li><li>```</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/diffx/&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/logo.gif&quot; alt=&quot;返回主页&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>picGo+github图床创建踩坑</title>
    <link href="http://example.com/2021/10/28/picGo-github%E5%9B%BE%E5%BA%8A%E5%88%9B%E5%BB%BA%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2021/10/28/picGo-github%E5%9B%BE%E5%BA%8A%E5%88%9B%E5%BB%BA%E8%B8%A9%E5%9D%91/</id>
    <published>2021-10-28T13:22:41.000Z</published>
    <updated>2021-10-28T13:23:20.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>typora升级到最新版本 </p><p>picgo升级到最新版本：version2.3.0</p><p>一：创建GitHub仓库<br>首先登陆 GitHub，新建一个仓库或者也可以使用一个已有仓库</p><p>注意：仓库属性必须为公共（public）的，否则图片上传上去之后是没法显示，之后的调用也会出错</p><p>二：设置token</p><p>需要在 GitHub 上生成一个 token 以便 PicGo 来操作我们的仓库，</p><p>步骤如下：</p><p>个人中心Settings-&gt;Developer settings -&gt;Personal access tokens</p><p>创建 token</p><p>点击 Generate new token 创建一个新 token，选择 repo，同时它会把包含其中的都会勾选上。点击绿色按钮，Generate token 。生成一个 token ，记得复制保存到其他地方，这个 token 只显示一次！！</p><p> 3.PicGo配置<br>PicGo下载地址<br><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>配置 PicGo</p><p>打开 PicGo 面板，</p><p>选择github仓库</p><p>仓库名格式为 用户名/仓库名<br>分支名：master<br>token：上一个咱们创建的token</p><p>然后点击确定即可完成绑定，即可设置成默认图床</p><h2 id="在typore配置自动上传"><a href="#在typore配置自动上传" class="headerlink" title="在typore配置自动上传"></a>在typore配置自动上传</h2><p>打开typora，点开左上角文件，选择<strong>偏好设置</strong></p><ol><li>设置插入图片时为【上传图片】</li><li>勾选【对本地位置的图片应用上述规则】</li><li>在上传服务中选择“PicGo(app)”</li><li>在路径中选择picgo安装目录<strong>PicGo.exe</strong></li></ol><p>可以点击下面的验证图片上传选项，上传成功！</p><p> 配置完成之后，图片复制进typora之后就会自动经由picGo上传到github的仓库了，并且生成相关的URL地址。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>在上传图片到picGo的时候，显示上传失败：服务器错误</p><p>仔细检查github图床配置的相关信息</p><p>错误原因是：<strong>仓库名前面没有添加github账号</strong></p><p>​                        注意格式一定要是：账号名/仓库名</p><p>​                        缺一不可！！！！！</p><p>​                        并且仓库名中最好不要有特殊字符，空格等，避免发生不知名的错误</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>安装 picGo的时候想要更改安装路径，更改之后安装目录没有文件，应用程序无法打开。</p><p>使用了默认路径之后重新安装，才解决这个问题。</p><p>建议使用系统默认路径即可</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>picGo上传成功typore中显示加载失败</p><p>查找相关资料，原因是github屏蔽掉了图片，需要修改host。<br>路径：C:\Windows\System32\drivers\etc\hosts</p><p> 找到host文件，用记事本格式打开，添加代码</p><p>#GitHub Start </p><p>140.82.113.3      github.com<br>140.82.114.20     gist.github.com<br>151.101.184.133    assets-cdn.github.com<br>151.101.184.133    raw.githubusercontent.com<br>151.101.184.133    gist.githubusercontent.com<br>151.101.184.133    cloud.githubusercontent.com<br>151.101.184.133    camo.githubusercontent.com<br>151.101.184.133    avatars0.githubusercontent.com<br>199.232.68.133     avatars0.githubusercontent.com<br>199.232.28.133     avatars1.githubusercontent.com<br>151.101.184.133    avatars1.githubusercontent.com<br>151.101.184.133    avatars2.githubusercontent.com<br>199.232.28.133     avatars2.githubusercontent.com<br>151.101.184.133    avatars3.githubusercontent.com<br>199.232.68.133     avatars3.githubusercontent.com<br>151.101.184.133    avatars4.githubusercontent.com<br>199.232.68.133     avatars4.githubusercontent.com<br>151.101.184.133    avatars5.githubusercontent.com<br>199.232.68.133     avatars5.githubusercontent.com<br>151.101.184.133    avatars6.githubusercontent.com<br>199.232.68.133     avatars6.githubusercontent.com<br>151.101.184.133    avatars7.githubusercontent.com<br>199.232.68.133     avatars7.githubusercontent.com<br>151.101.184.133    avatars8.githubusercontent.com<br>199.232.68.133     avatars8.githubusercontent.com</p><p>#GitHub End</p><p>host更改权限具体参考：<a href="https://www.jb51.net/os/win10/526668.html">https://www.jb51.net/os/win10/526668.html</a></p><p>保存重启一下Typora软件即可</p><p>参考博客： <a href="https://blog.csdn.net/weixin_46025371/article/details/111105266">https://blog.csdn.net/weixin_46025371/article/details/111105266</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h2&gt;&lt;p&gt;typora升级到最新版本 &lt;/p&gt;
&lt;p&gt;picgo升级到最新版本：version2.3.0&lt;/p&gt;
&lt;p&gt;一：创建Git</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://example.com/2021/10/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/10/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-10-28T13:21:13.000Z</published>
    <updated>2021-10-28T13:21:45.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程涉及以下几点：</p><ul><li>线程的同步</li><li>线程的生命周期</li><li>线程的通信</li><li>线程的创建（4）</li><li>线程安全与解决（3）</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>程序：</p><p>进程：正在运行的程序，程序执行的一次执行过程</p><ul><li>生命周期：产生，执行消亡的过程。</li></ul><p>线程 ：进程进一步细化。</p><ul><li>进程可以含有多个线程</li><li>多个线程共享一个进程中的方法区和堆</li><li>每个线程各自一个程序计数器和虚拟机栈</li><li>一个进程中的多个线程共享相同的内存单元/内存地址空间</li><li>从同一堆中分配对象，可以访问相同的变量和对象。使得线程间通信更简便、高效。</li><li>多个线程操作共享的系统资源可能就会带来安全的隐患。</li></ul><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p>并行：多个cpu执行多个任务</p><p>并发：一个CPU执行多个任务（时间片）</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><p>  使用了：java.lang.Thread类</p><ul><li>步骤：<ul><li>定义子类继承Thread类。</li><li>子类中重写Thread类中的run方法</li><li>创建Thread子类对象，即创建了线程对象。</li><li>调用线程对象start方法：启动线程，调用run方法</li></ul></li></ul><ul><li><p>start（）：启动当前线程；调用当前的run()方法。</p><p>​                必须使用start开启一个新的线程，不能直接调用run()</p></li><li><p>建立多个线程需要的重新创建线程的对象，不能让已经start的线程start</p></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p><strong>void start():</strong> 启动线程，并执行对象的run()方法</p></li><li><p><strong>run():</strong> 线程在被调度时执行的操作</p></li><li><p><strong>String getName():</strong> 返回线程的名称</p></li><li><p><strong>void setName(String name)</strong>:设置该线程名称</p></li><li><p><strong>static Thread currentThread():</strong> 返回当前线程。在Thread子类中就</p></li></ul><p>是this，通常用于主线程和Runnable实现类</p><ul><li><p>**static void yield()***线程让步</p><p>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程，若队列中没有同优先级的线程，忽略此方法。</p></li><li><p><strong>join()</strong> <strong>：</strong>当某个程序执行流中调用其他线程的 join() 方法时，调用线程将</p><p>被阻塞，直到 join() 方法加入的 join 线程执行完为止低优先级的线程也可以获得执行</p></li><li><p>**static void sleep(long millis)**<strong>：</strong>(指定时间:毫秒) </p><p>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后</p><p>重排队。</p><p>抛出InterruptedException异常</p></li><li><p><strong>stop():</strong> 强制线程生命期结束，不推荐使用</p></li><li><p>**boolean isAlive()**<strong>：</strong>返回boolean，判断线程是否还活着</p></li></ul><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p><strong>抢占式</strong>：高优先级的线程抢占CPU</p><p>等级:<em>MAX_PRIORITY</em>：1~10</p><p>使用方法：</p><ul><li><p><strong>getPriority()</strong> <strong>：</strong>返回线程优先值</p></li><li><p><strong>setPriority(int newPriority)</strong> <strong>：</strong>改变线程的优先级</p></li></ul><p>优先级的设置要在start()之前。</p><h4 id="第二种创建方式："><a href="#第二种创建方式：" class="headerlink" title="第二种创建方式："></a>第二种创建方式：</h4><p> 步骤：</p><ol><li><p>定义子类，实现Runnable接口。</p></li><li><p>子类中重写Runnable接口中的run方法。</p></li><li><p>通过Thread类含参构造器创建线程对象。</p></li><li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p></li><li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>定义在Thread.state中</p><ul><li><strong>新建：</strong> 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建</li></ul><p>状态</p><ul><li><strong>就绪：</strong>处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已</li></ul><p>具备了运行的条件，只是没分配到CPU资源</p><ul><li><strong>运行：</strong>当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线</li></ul><p>程的操作和功能</p><ul><li><strong>阻塞：</strong>在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中</li></ul><p>止自己的执行，进入阻塞状态</p><ul><li><strong>死亡：</strong>线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li></ul><p><img src="https://raw.githubusercontent.com/chen-boran/Picture_bed/main/img/image-20210928163052596.png" alt="image-20210928163052596"></p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><ul><li>操作共享数据，即为需要被同步的代码 会产生线程安全问题</li></ul><p>使用同步方式解决线程安全问题</p><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;p&gt;线程涉及以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的同步&lt;/li&gt;
&lt;li&gt;线程的生命周期&lt;/li&gt;
&lt;li&gt;线程的通信&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://example.com/2021/10/28/SpringMVC/"/>
    <id>http://example.com/2021/10/28/SpringMVC/</id>
    <published>2021-10-28T13:18:52.000Z</published>
    <updated>2021-10-28T13:20:49.522Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h1><h3 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p><h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p><p>SpringMVC 是 Spring 为<strong>表述层</strong>开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p></blockquote><h3 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h3><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>(封装)，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>IDE：idea 2019.2</p><p>构建工具：maven3.5.4</p><p>服务器：tomcat7</p><p>Spring版本：5.3.1</p><h3 id="2、创建maven工程"><a href="#2、创建maven工程" class="headerlink" title="2、创建maven工程"></a>2、创建maven工程</h3><h5 id="a-gt-添加web模块"><a href="#a-gt-添加web模块" class="headerlink" title="a&gt;添加web模块"></a>a&gt;添加web模块</h5><h5 id="b-gt-打包方式：war"><a href="#b-gt-打包方式：war" class="headerlink" title="b&gt;打包方式：war"></a>b&gt;打包方式：war</h5><h5 id="c-gt-引入依赖"><a href="#c-gt-引入依赖" class="headerlink" title="c&gt;引入依赖"></a>c&gt;引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p><p><img src="C:\Users\ASUS\Desktop\img\img001.png" alt="images"></p><h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p><h5 id="a-gt-默认配置方式"><a href="#a-gt-默认配置方式" class="headerlink" title="a&gt;默认配置方式"></a>a&gt;默认配置方式</h5><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">去除掉警示牌请求，其他所有请求交给前端控制器处理</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-扩展配置方式"><a href="#b-gt-扩展配置方式" class="headerlink" title="b&gt;扩展配置方式"></a>b&gt;扩展配置方式</h5><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>&lt;url-pattern&gt;标签中使用/和/*的区别：</p><p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p><p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p><p>/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p></blockquote><h3 id="4、创建请求控制器"><a href="#4、创建请求控制器" class="headerlink" title="4、创建请求控制器"></a>4、创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p><p>请求控制器中每一个处理请求的方法成为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、创建springMVC的配置文件"><a href="#5、创建springMVC的配置文件" class="headerlink" title="5、创建springMVC的配置文件"></a>5、创建springMVC的配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6、测试HelloWorld"><a href="#6、测试HelloWorld" class="headerlink" title="6、测试HelloWorld"></a>6、测试HelloWorld</h3><h5 id="a-gt-实现对首页的访问"><a href="#a-gt-实现对首页的访问" class="headerlink" title="a&gt;实现对首页的访问"></a>a&gt;实现对首页的访问</h5><p>在请求控制器中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-通过超链接跳转到指定页面"><a href="#b-gt-通过超链接跳转到指定页面" class="headerlink" title="b&gt;通过超链接跳转到指定页面"></a>b&gt;通过超链接跳转到指定页面</h5><p>在主页index.html中设置超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在请求控制器中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面(web页面的地址没有改变)</p><h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><h3 id="1、-RequestMapping注解的功能"><a href="#1、-RequestMapping注解的功能" class="headerlink" title="1、@RequestMapping注解的功能"></a>1、@RequestMapping注解的功能</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><h3 id="2、-RequestMapping注解的位置"><a href="#2、-RequestMapping注解的位置" class="headerlink" title="2、@RequestMapping注解的位置"></a>2、@RequestMapping注解的位置</h3><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><p>所以想要访问类里面方法的注解信息，请求的路径中要额外添加类上注解的路径：/text</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、-RequestMapping注解的value属性"><a href="#3、-RequestMapping注解的value属性" class="headerlink" title="3、@RequestMapping注解的value属性"></a>3、@RequestMapping注解的value属性</h3><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p><p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、-RequestMapping注解的method属性"><a href="#4、-RequestMapping注解的method属性" class="headerlink" title="4、@RequestMapping注解的method属性"></a>4、@RequestMapping注解的method属性</h3><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><h3 id="5、-RequestMapping注解的params属性（了解）"><a href="#5、-RequestMapping注解的params属性（了解）" class="headerlink" title="5、@RequestMapping注解的params属性（了解）"></a>5、@RequestMapping注解的params属性（了解）</h3><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p></blockquote><h3 id="6、-RequestMapping注解的headers属性（了解）"><a href="#6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="6、@RequestMapping注解的headers属性（了解）"></a>6、@RequestMapping注解的headers属性（了解）</h3><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p><h3 id="7、SpringMVC支持ant风格的路径"><a href="#7、SpringMVC支持ant风格的路径" class="headerlink" title="7、SpringMVC支持ant风格的路径"></a>7、SpringMVC支持ant风格的路径</h3><p>？：表示任意的<strong>单</strong>个字符(/和？不可以)</p><p>*：表示任意的0个或多个字符</p><p>**：表示任意的一层或多层目录</p><p>注意：在使用**时，只能使用/**/xxx的方式</p><h3 id="8、SpringMVC支持路径中的占位符（重点）"><a href="#8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="8、SpringMVC支持路径中的占位符（重点）"></a>8、SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：/deleteUser?id=1</p><p>rest方式：/deleteUser/1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure><h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h3 id="1、通过ServletAPI获取"><a href="#1、通过ServletAPI获取" class="headerlink" title="1、通过ServletAPI获取"></a>1、通过ServletAPI获取</h3><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">     <span class="comment">//形参对象的request表示当前表单，当前的request自动赋值给形参</span></span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、通过控制器方法的形参获取请求参数"><a href="#2、通过控制器方法的形参获取请求参数" class="headerlink" title="2、通过控制器方法的形参获取请求参数"></a>2、通过控制器方法的形参获取请求参数</h3><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h3 id="3、-RequestParam"><a href="#3、-RequestParam" class="headerlink" title="3、@RequestParam"></a>3、@RequestParam</h3><p>@RequestParam是<strong>将请求参数和控制器方法的形参</strong>创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><p>value：指定为形参赋值的请求参数的参数名</p><p>required：设置是否必须传输此请求参数，默认值为true</p><p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p><h3 id="4、-RequestHeader"><a href="#4、-RequestHeader" class="headerlink" title="4、@RequestHeader"></a>4、@RequestHeader</h3><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="5、-CookieValue"><a href="#5、-CookieValue" class="headerlink" title="5、@CookieValue"></a>5、@CookieValue</h3><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="6、通过POJO获取请求参数"><a href="#6、通过POJO获取请求参数" class="headerlink" title="6、通过POJO获取请求参数"></a>6、通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPOJO</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7、解决获取请求参数的乱码问题"><a href="#7、解决获取请求参数的乱码问题" class="headerlink" title="7、解决获取请求参数的乱码问题"></a>7、解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p></blockquote><h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h3 id="1、使用ServletAPI向request域对象共享数据"><a href="#1、使用ServletAPI向request域对象共享数据" class="headerlink" title="1、使用ServletAPI向request域对象共享数据"></a>1、使用ServletAPI向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用ModelAndView向request域对象共享数据"><a href="#2、使用ModelAndView向request域对象共享数据" class="headerlink" title="2、使用ModelAndView向request域对象共享数据"></a>2、使用ModelAndView向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、使用Model向request域对象共享数据"><a href="#3、使用Model向request域对象共享数据" class="headerlink" title="3、使用Model向request域对象共享数据"></a>3、使用Model向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModel</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、使用map向request域对象共享数据"><a href="#4、使用map向request域对象共享数据" class="headerlink" title="4、使用map向request域对象共享数据"></a>4、使用map向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、使用ModelMap向request域对象共享数据"><a href="#5、使用ModelMap向request域对象共享数据" class="headerlink" title="5、使用ModelMap向request域对象共享数据"></a>5、使用ModelMap向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelMap</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Model、ModelMap、Map的关系"><a href="#6、Model、ModelMap、Map的关系" class="headerlink" title="6、Model、ModelMap、Map的关系"></a>6、Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Model&#123;&#125;</span><br><span class="line">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br><span class="line">public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="7、向session域共享数据"><a href="#7、向session域共享数据" class="headerlink" title="7、向session域共享数据"></a>7、向session域共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSession</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、向application域共享数据"><a href="#8、向application域共享数据" class="headerlink" title="8、向application域共享数据"></a>8、向application域共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testApplication</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">ServletContext application = session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h3 id="1、ThymeleafView"><a href="#1、ThymeleafView" class="headerlink" title="1、ThymeleafView"></a>1、ThymeleafView</h3><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\Desktop\img\img002.png"></p><h3 id="2、转发视图"><a href="#2、转发视图" class="headerlink" title="2、转发视图"></a>2、转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><p>例如”forward:/“，”forward:/employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\Desktop\img\img003.png" alt="image-20210706201316593"></p><h3 id="3、重定向视图"><a href="#3、重定向视图" class="headerlink" title="3、重定向视图"></a>3、重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><p>例如”redirect:/“，”redirect:/employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\Desktop\img\img004.png" alt="image-20210706201602267"></p><blockquote><p>注：</p><p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p><p>转发和重定向的区别：</p><p>转发是一次请求（浏览器），地址栏不变；重定向是两次请求，地址栏发生改变</p><p>转发可以获取请求域中的数据，转发不可以</p><p>转发可以访问web_inf中的文件，重定向不可以</p><p>转发发生在服务器内部，可以访问web_inf等对外部隐藏的文件（只能服务器内部资源 ）</p><p>重定向是浏览器资源，访问浏览器任何资源</p></blockquote><h3 id="4、视图控制器view-controller"><a href="#4、视图控制器view-controller" class="headerlink" title="4、视图控制器view-controller"></a>4、视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p><p>&lt;mvc:annotation-driven /&gt;   //开启注解驱动</p></blockquote><h1 id="七、RESTful"><a href="#七、RESTful" class="headerlink" title="七、RESTful"></a>七、RESTful</h1><h3 id="1、RESTful简介"><a href="#1、RESTful简介" class="headerlink" title="1、RESTful简介"></a>1、RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><p>一种软件架构的风格。</p><h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a&gt;资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b&gt;资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c&gt;状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h3 id="2、RESTful的实现"><a href="#2、RESTful的实现" class="headerlink" title="2、RESTful的实现"></a>2、RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id=1</td><td>user/1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id=1</td><td>user/1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table><h3 id="3、HiddenHttpMethodFilter"><a href="#3、HiddenHttpMethodFilter" class="headerlink" title="3、HiddenHttpMethodFilter"></a>3、HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p><p>a&gt;当前请求的请求方式必须为post</p><p>b&gt;当前请求必须传输请求参数_method</p><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p><p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p></li><li><p>```<br>String paramValue = request.getParameter(this.methodParam);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 八、RESTful案例</span><br><span class="line"></span><br><span class="line">### 1、准备工作</span><br><span class="line"></span><br><span class="line">和传统 CRUD 一样，实现对员工信息的增删改查。</span><br><span class="line"></span><br><span class="line">- 搭建环境</span><br><span class="line"></span><br><span class="line">- 准备实体类</span><br><span class="line"></span><br><span class="line"> &#96;&#96;&#96;java</span><br><span class="line"> package com.atguigu.mvc.bean;</span><br><span class="line"> </span><br><span class="line"> public class Employee &#123;</span><br><span class="line"> </span><br><span class="line">    private Integer id;</span><br><span class="line">    private String lastName;</span><br><span class="line"> </span><br><span class="line">    private String email;</span><br><span class="line">    &#x2F;&#x2F;1 male, 0 female</span><br><span class="line">    private Integer gender;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">       return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">       return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">       this.lastName &#x3D; lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">       return email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">       this.email &#x3D; email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Integer getGender() &#123;</span><br><span class="line">       return gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setGender(Integer gender) &#123;</span><br><span class="line">       this.gender &#x3D; gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee(Integer id, String lastName, String email, Integer gender) &#123;</span><br><span class="line">       super();</span><br><span class="line">       this.id &#x3D; id;</span><br><span class="line">       this.lastName &#x3D; lastName;</span><br><span class="line">       this.email &#x3D; email;</span><br><span class="line">       this.gender &#x3D; gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>准备dao模拟数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mvc.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      employees = <span class="keyword">new</span> HashMap&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">      employees.put(<span class="number">1001</span>, <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1002</span>, <span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1003</span>, <span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1004</span>, <span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1005</span>, <span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Integer initId = <span class="number">1006</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(employee.getId() == <span class="keyword">null</span>)&#123;</span><br><span class="line">         employee.setId(initId++);</span><br><span class="line">      &#125;</span><br><span class="line">      employees.put(employee.getId(), employee);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.values();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.get(id);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      employees.remove(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、功能清单"><a href="#2、功能清单" class="headerlink" title="2、功能清单"></a>2、功能清单</h3><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页√</td><td>/</td><td>GET</td></tr><tr><td>查询全部数据√</td><td>/employee</td><td>GET</td></tr><tr><td>删除√</td><td>/employee/2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面√</td><td>/toAdd</td><td>GET</td></tr><tr><td>执行保存√</td><td>/employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面√</td><td>/employee/2</td><td>GET</td></tr><tr><td>执行更新√</td><td>/employee</td><td>PUT</td></tr></tbody></table><h3 id="3、具体功能：访问首页"><a href="#3、具体功能：访问首页" class="headerlink" title="3、具体功能：访问首页"></a>3、具体功能：访问首页</h3><h5 id="a-gt-配置view-controller"><a href="#a-gt-配置view-controller" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-创建页面"><a href="#b-gt-创建页面" class="headerlink" title="b&gt;创建页面"></a>b&gt;创建页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>访问员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、具体功能：查询所有员工数据"><a href="#4、具体功能：查询所有员工数据" class="headerlink" title="4、具体功能：查询所有员工数据"></a>4、具体功能：查询所有员工数据</h3><h5 id="a-gt-控制器方法"><a href="#a-gt-控制器方法" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeList</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-创建employee-list-html"><a href="#b-gt-创建employee-list-html" class="headerlink" title="b&gt;创建employee_list.html"></a>b&gt;创建employee_list.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options(<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、具体功能：删除"><a href="#5、具体功能：删除" class="headerlink" title="5、具体功能：删除"></a>5、具体功能：删除</h3><h5 id="a-gt-创建处理delete请求方式的表单"><a href="#a-gt-创建处理delete请求方式的表单" class="headerlink" title="a&gt;创建处理delete请求方式的表单"></a>a&gt;创建处理delete请求方式的表单</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delete_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-删除超链接绑定点击事件"><a href="#b-gt-删除超链接绑定点击事件" class="headerlink" title="b&gt;删除超链接绑定点击事件"></a>b&gt;删除超链接绑定点击事件</h5><p>引入vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过vue处理点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//event表示当前事件</span></span></span><br><span class="line"><span class="javascript">            deleteEmployee:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//通过id获取表单标签</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delete_form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;delete_form&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span></span><br><span class="line">                delete_form.action = event.target.href;</span><br><span class="line"><span class="javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line">                delete_form.submit();</span><br><span class="line"><span class="javascript">                <span class="comment">//阻止超链接的默认跳转行为</span></span></span><br><span class="line">                event.preventDefault();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="c-gt-控制器方法"><a href="#c-gt-控制器方法" class="headerlink" title="c&gt;控制器方法"></a>c&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、具体功能：跳转到添加数据页面"><a href="#6、具体功能：跳转到添加数据页面" class="headerlink" title="6、具体功能：跳转到添加数据页面"></a>6、具体功能：跳转到添加数据页面</h3><h5 id="a-gt-配置view-controller-1"><a href="#a-gt-配置view-controller-1" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/toAdd&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;employee_add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-创建employee-add-html"><a href="#b-gt-创建employee-add-html" class="headerlink" title="b&gt;创建employee_add.html"></a>b&gt;创建employee_add.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7、具体功能：执行保存"><a href="#7、具体功能：执行保存" class="headerlink" title="7、具体功能：执行保存"></a>7、具体功能：执行保存</h3><h5 id="a-gt-控制器方法-1"><a href="#a-gt-控制器方法-1" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、具体功能：跳转到更新数据页面"><a href="#8、具体功能：跳转到更新数据页面" class="headerlink" title="8、具体功能：跳转到更新数据页面"></a>8、具体功能：跳转到更新数据页面</h3><h5 id="a-gt-修改超链接"><a href="#a-gt-修改超链接" class="headerlink" title="a&gt;修改超链接"></a>a&gt;修改超链接</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-控制器方法"><a href="#b-gt-控制器方法" class="headerlink" title="b&gt;控制器方法"></a>b&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span></span>&#123;</span><br><span class="line">    Employee employee = employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-创建employee-update-html"><a href="#c-gt-创建employee-update-html" class="headerlink" title="c&gt;创建employee_update.html"></a>c&gt;创建employee_update.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显</span></span><br><span class="line"><span class="comment">        若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9、具体功能：执行更新"><a href="#9、具体功能：执行更新" class="headerlink" title="9、具体功能：执行更新"></a>9、具体功能：执行更新</h3><h5 id="a-gt-控制器方法-2"><a href="#a-gt-控制器方法-2" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、HttpMessageConverter"><a href="#八、HttpMessageConverter" class="headerlink" title="八、HttpMessageConverter"></a>八、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p><p>ResponseEntity</p><h3 id="1、-RequestBody"><a href="#1、-RequestBody" class="headerlink" title="1、@RequestBody"></a>1、@RequestBody</h3><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>requestBody:username=admin&amp;password=123456</p><h3 id="2、RequestEntity"><a href="#2、RequestEntity" class="headerlink" title="2、RequestEntity"></a>2、RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]<br>requestBody:username=admin&amp;password=123</p><h3 id="3、-ResponseBody"><a href="#3、-ResponseBody" class="headerlink" title="3、@ResponseBody"></a>3、@ResponseBody</h3><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：浏览器页面显示success</p><h3 id="4、SpringMVC处理json"><a href="#4、SpringMVC处理json" class="headerlink" title="4、SpringMVC处理json"></a>4、SpringMVC处理json</h3><p>@ResponseBody处理json的步骤：</p><p>a&gt;导入jackson的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p><p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testResponseUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器的页面中展示的结果：</p><p>{“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”}</p><h3 id="5、SpringMVC处理ajax"><a href="#5、SpringMVC处理ajax" class="headerlink" title="5、SpringMVC处理ajax"></a>5、SpringMVC处理ajax</h3><p>a&gt;请求超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b&gt;通过vue和axios处理点击事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            testAjax:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                axios(&#123;</span><br><span class="line"><span class="javascript">                    method:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line">                    url:event.target.href,</span><br><span class="line">                    params:&#123;</span><br><span class="line"><span class="javascript">                        username:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        password:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line">                    alert(response.data);</span><br><span class="line">                &#125;);</span><br><span class="line">                event.preventDefault();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c&gt;控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAjax</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、-RestController注解"><a href="#6、-RestController注解" class="headerlink" title="6、@RestController注解"></a>6、@RestController注解</h3><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h3 id="7、ResponseEntity"><a href="#7、ResponseEntity" class="headerlink" title="7、ResponseEntity"></a>7、ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p><h1 id="九、文件上传和下载"><a href="#九、文件上传和下载" class="headerlink" title="九、文件上传和下载"></a>九、文件上传和下载</h1><h3 id="1、文件下载"><a href="#1、文件下载" class="headerlink" title="1、文件下载"></a>1、文件下载</h3><p>使用ResponseEntity实现下载文件的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    String realPath = servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><p>上传步骤：</p><p>a&gt;添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b&gt;在SpringMVC的配置文件中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c&gt;控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    String hzName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> File(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十、拦截器"><a href="#十、拦截器" class="headerlink" title="十、拦截器"></a>十、拦截器</h1><h3 id="1、拦截器的配置"><a href="#1、拦截器的配置" class="headerlink" title="1、拦截器的配置"></a>1、拦截器的配置</h3><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor</p><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、拦截器的三个抽象方法"><a href="#2、拦截器的三个抽象方法" class="headerlink" title="2、拦截器的三个抽象方法"></a>2、拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p><p>postHandle：控制器方法执行之后执行postHandle()</p><p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p><h3 id="3、多个拦截器的执行顺序"><a href="#3、多个拦截器的执行顺序" class="headerlink" title="3、多个拦截器的执行顺序"></a>3、多个拦截器的执行顺序</h3><p>a&gt;若每个拦截器的preHandle()都返回true</p><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p><p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p><p>b&gt;若某个拦截器的preHandle()返回了false</p><p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p><h1 id="十一、异常处理器"><a href="#十一、异常处理器" class="headerlink" title="十一、异常处理器"></a>十一、异常处理器</h1><h3 id="1、基于配置的异常处理"><a href="#1、基于配置的异常处理" class="headerlink" title="1、基于配置的异常处理"></a>1、基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、基于注解的异常处理"><a href="#2、基于注解的异常处理" class="headerlink" title="2、基于注解的异常处理"></a>2、基于注解的异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十二、注解配置SpringMVC"><a href="#十二、注解配置SpringMVC" class="headerlink" title="十二、注解配置SpringMVC"></a>十二、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h3 id="1、创建初始化类，代替web-xml"><a href="#1、创建初始化类，代替web-xml" class="headerlink" title="1、创建初始化类，代替web.xml"></a>1、创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。<br>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebInit</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter encodingFilter = <span class="keyword">new</span> CharacterEncodingFilter();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="keyword">true</span>);</span><br><span class="line">        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、创建SpringConfig配置类，代替spring的配置文件"><a href="#2、创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="2、创建SpringConfig配置类，代替spring的配置文件"></a>2、创建SpringConfig配置类，代替spring的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#3、创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="3、创建WebConfig配置类，代替SpringMVC的配置文件"></a>3、创建WebConfig配置类，代替SpringMVC的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonsMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        FirstInterceptor firstInterceptor = <span class="keyword">new</span> FirstInterceptor();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        ServletContextTemplateResolver templateResolver = <span class="keyword">new</span> ServletContextTemplateResolver(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> </span>&#123;</span><br><span class="line">        SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class="line">        ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、测试功能"><a href="#4、测试功能" class="headerlink" title="4、测试功能"></a>4、测试功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十三、SpringMVC执行流程"><a href="#十三、SpringMVC执行流程" class="headerlink" title="十三、SpringMVC执行流程"></a>十三、SpringMVC执行流程</h1><h3 id="1、SpringMVC常用组件"><a href="#1、SpringMVC常用组件" class="headerlink" title="1、SpringMVC常用组件"></a>1、SpringMVC常用组件</h3><ul><li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p><ul><li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p><ul><li>Handler：<strong>处理器</strong>，需要工程师开发</li></ul><p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p><ul><li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p><ul><li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p><ul><li>View：<strong>视图</strong></li></ul><p>作用：将模型数据通过页面展示给用户</p><h3 id="2、DispatcherServlet初始化过程"><a href="#2、DispatcherServlet初始化过程" class="headerlink" title="2、DispatcherServlet初始化过程"></a>2、DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p><p><img src="C:\Users\ASUS\Desktop\img\img005.png" alt="images"></p><h5 id="a-gt-初始化WebApplicationContext"><a href="#a-gt-初始化WebApplicationContext" class="headerlink" title="a&gt;初始化WebApplicationContext"></a>a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-创建WebApplicationContext"><a href="#b-gt-创建WebApplicationContext" class="headerlink" title="b&gt;创建WebApplicationContext"></a>b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    String configLocation = getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-DispatcherServlet初始化策略"><a href="#c-gt-DispatcherServlet初始化策略" class="headerlink" title="c&gt;DispatcherServlet初始化策略"></a>c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、DispatcherServlet调用组件处理请求"><a href="#3、DispatcherServlet调用组件处理请求" class="headerlink" title="3、DispatcherServlet调用组件处理请求"></a>3、DispatcherServlet调用组件处理请求</h3><h5 id="a-gt-processRequest"><a href="#a-gt-processRequest" class="headerlink" title="a&gt;processRequest()"></a>a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-doService"><a href="#b-gt-doService" class="headerlink" title="b&gt;doService()"></a>b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestPath requestPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-doDispatch"><a href="#c-gt-doDispatch" class="headerlink" title="c&gt;doDispatch()"></a>c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           <span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d-gt-processDispatchResult"><a href="#d-gt-processDispatchResult" class="headerlink" title="d&gt;processDispatchResult()"></a>d&gt;processDispatchResult()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、SpringMVC的执行流程"><a href="#4、SpringMVC的执行流程" class="headerlink" title="4、SpringMVC的执行流程"></a>4、SpringMVC的执行流程</h3><ol><li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p></li></ol><p>a) 不存在</p><p>i. 再判断是否配置了mvc:default-servlet-handler</p><p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p><img src="C:\Users\ASUS\Desktop\img\img006.png" alt="image-20210709214911404"></p><p><img src="C:\Users\ASUS\Desktop\img\img007.png" alt="image-20210709214947432"></p><p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p><p><img src="C:\Users\ASUS\Desktop\img\img008.png" alt="image-20210709215255693"></p><p><img src="C:\Users\ASUS\Desktop\img\img009.png" alt="image-20210709215336097"></p><p>b) 存在则执行下面的流程</p><ol start="3"><li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p></li><li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p></li></ol><p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p><p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><ol start="7"><li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p></li><li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】。</p></li><li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p></li><li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p></li><li><p>将渲染结果返回给客户端。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、SpringMVC简介&quot;&gt;&lt;a href=&quot;#一、SpringMVC简介&quot; class=&quot;headerlink&quot; title=&quot;一、SpringMVC简介&quot;&gt;&lt;/a&gt;一、SpringMVC简介&lt;/h1&gt;&lt;h3 id=&quot;1、什么是MVC</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://example.com/2021/10/28/redis/"/>
    <id>http://example.com/2021/10/28/redis/</id>
    <published>2021-10-28T13:17:48.000Z</published>
    <updated>2021-10-28T13:52:06.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>1. redis    1. 概念    2. 下载安装    3. 命令操作        1. 数据结构    4. 持久化操作    5. 使用Java客户端操作redis</code></pre><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库（解决性能问题）</code></pre><h3 id="1-1NOSQL"><a href="#1-1NOSQL" class="headerlink" title="1.1NOSQL"></a>1.1NOSQL</h3><ul><li>NoSQL(NoSQL = Not Only SQL)，不仅仅是SQL        </li><li>一项全新的数据库理念，泛指非关系型的数据库。</li><li>不遵循SQL标准；不支持ACID；远超SQL 性能</li><li>使用场景<ul><li>l 对数据高并发的读写</li><li>l 海量数据的读写</li><li>对数据高可扩展性的</li></ul></li><li>不适合场景<ul><li>l 需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</li><li>SQL不使用，或者不行的条件 </li></ul></li><li>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</li></ul><ol><li><p>NOSQL和关系型数据库比较</p><pre><code>优点：          1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。          2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。          3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。          4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</code></pre><p>​        缺点：<br>​        1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。<br>​        2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。<br>​        3）不提供关系型数据库对事务的处理。</p></li><li><p>非关系型数据库的优势：</p><pre><code>1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</code></pre></li><li><p>关系型数据库的优势：</p><pre><code>1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。      2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</code></pre></li><li><p>总结</p><pre><code>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</code></pre></li></ol><h3 id="1-2-常见NOSQL"><a href="#1-2-常见NOSQL" class="headerlink" title="1.2 常见NOSQL"></a>1.2 常见NOSQL</h3><ul><li><p>键值(Key-Value)存储数据库</p><pre><code>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB        典型应用： 内容缓存，主要用于处理大量数据的高访问负载。         数据模型： 一系列键值对        优势： 快速查询        劣势： 存储的数据缺少结构化</code></pre></li><li><p>列存储数据库</p><pre><code>相关产品：Cassandra, HBase, Riak        典型应用：分布式的文件系统        数据模型：以列簇式存储，将同一列数据存在一起        优势：查找速度快，可扩展性强，更容易进行分布式扩展        劣势：功能相对局限</code></pre></li><li><p>文档型数据库</p><pre><code>相关产品：CouchDB、MongoDB        典型应用：Web应用（与Key-Value类似，Value是结构化的）        数据模型： 一系列键值对        优势：数据结构要求不严格        劣势： 查询性能不高，而且缺乏统一的查询语法</code></pre></li><li><p>图形(Graph)数据库</p><pre><code>相关数据库：Neo4J、InfoGrid、Infinite Graph        典型应用：社交网络        数据模型：图结构        优势：利用图结构相关算法。        劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</code></pre></li></ul><h3 id="1-3-Redis"><a href="#1-3-Redis" class="headerlink" title="1.3 Redis"></a>1.3 Redis</h3><ul><li><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库</p></li><li><p>默认端口号：6379</p></li><li><p>提供多种键值数据类型，适应不同场景下的存储需求 </p><p>Redis支持的键值数据类型如下：    </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 字符串类型 string</span><br><span class="line">2) 哈希类型 hash</span><br><span class="line">3) 列表类型 list</span><br><span class="line">4) 集合类型 set</span><br><span class="line">5) 有序集合类型 sorted set</span><br></pre></td></tr></table></figure><ul><li>Redis使用单线程+多路IO复用</li></ul><p><strong>1. 应用场景</strong></p><ul><li><p>高频次，热门访问的数据，降低数据库IO</p></li><li><p>分布式架构，做session共享</p></li><li><p>缓存（数据查询、短连接、新闻内容、商品内容等等）</p></li><li><p>任务队列。（秒杀、抢购、12306等等）</p></li><li><p>应用排行榜网站访问统计</p></li><li><p>数据过期处理（可以精确到毫秒</p></li><li><p>分布式集群架构中的session分离</p></li></ul><p><strong>2.下载安装</strong></p><ol><li>官网：<a href="https://redis.io/">https://redis.io</a></li><li>中文网：<a href="http://www.redis.net.cn/">http://www.redis.net.cn/</a></li><li>首先要有c语言编译环境<ul><li>redis.windows.conf：配置文件</li><li>redis-cli.exe：redis的客户端</li><li>redis-server.exe：redis服务器端</li></ul></li></ol><p><strong>3.命令操作</strong></p><p>常见数据类型操作命令<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><ol><li>redis的数据结构：</li></ol><ul><li><p>redis存储的是：key,value格式的数据，key都是字符串，value有5种不同的数据结构</p><p>value的数据结构：</p><ol><li> 字符串类型 string</li><li> 哈希类型 hash ： map格式  </li><li> 列表类型 list ： linkedlist格式。支持重复元素</li><li> 集合类型 set  ： 不允许重复元素</li><li> 有序集合类型 sortedset：不允许重复元素，且元素有顺序</li></ol></li></ul><ol start="2"><li><p>key值操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">keys *查看当前库所有key   (匹配：keys *1)</span><br><span class="line"></span><br><span class="line">exists key判断某个key是否存在</span><br><span class="line"></span><br><span class="line">type key 查看你的key是什么类型</span><br><span class="line"></span><br><span class="line">del key    删除指定的key数据</span><br><span class="line"></span><br><span class="line">unlink key  根据value选择非阻塞删除</span><br><span class="line"></span><br><span class="line">仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</span><br><span class="line"></span><br><span class="line">expire key 10  10秒钟：为给定的key设置过期时间</span><br><span class="line"></span><br><span class="line">ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">select命令切换数据库</span><br><span class="line"></span><br><span class="line">dbsize查看当前数据库的key的数量</span><br><span class="line"></span><br><span class="line">flushdb清空当前库</span><br><span class="line"></span><br><span class="line">flushall通杀全部库</span><br></pre></td></tr></table></figure></li><li><p>字符串类型 string</p></li></ol><p>  基本的数据类型，是二进制安全的、</p><p>  一个字符串value最多可以是512M</p><pre><code>1. 存储： set key value  127.0.0.1:6379&gt; set username zhangsan  OK2. 获取： get key  127.0.0.1:6379&gt; get username  &quot;zhangsan&quot;3. 删除： del key  127.0.0.1:6379&gt; del age  (integer) 1</code></pre><ol start="4"><li><p>哈希类型 hash</p></li><li><p>存储： hset key field value</p><p> 127.0.0.1:6379&gt; hset myhash username lisi<br> (integer) 1<br> 127.0.0.1:6379&gt; hset myhash password 123<br> (integer) 1</p></li></ol><pre><code>2. 获取：   * hget key field: 获取指定的field对应的值      127.0.0.1:6379&gt; hget myhash username      &quot;lisi&quot;  * hgetall key：获取所有的field和value      127.0.0.1:6379&gt; hgetall myhash      1) &quot;username&quot;      2) &quot;lisi&quot;      3) &quot;password&quot;      4) &quot;123&quot;3. 删除： hdel key field  127.0.0.1:6379&gt; hdel myhash username  (integer) 1</code></pre><ol start="5"><li><p>列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p></li><li><p>添加：</p></li><li><p>lpush key value: 将元素加入列表左表</p></li><li><p>rpush key value：将元素加入列表右边</p><pre><code>127.0.0.1:6379&gt; lpush myList a(integer) 1127.0.0.1:6379&gt; lpush myList b(integer) 2127.0.0.1:6379&gt; rpush myList c(integer) 3</code></pre></li></ol><pre><code>2. 获取：  * lrange key start end ：范围获取      127.0.0.1:6379&gt; lrange myList 0 -1      1) &quot;b&quot;      2) &quot;a&quot;      3) &quot;c&quot;3. 删除：  * lpop key： 删除列表最左边的元素，并将元素返回  * rpop key： 删除列表最右边的元素，并将元素返回</code></pre><ol start="6"><li><p>集合类型 set ： 不允许重复元素</p><pre><code>1. 存储：sadd key value    127.0.0.1:6379&gt; sadd myset a    (integer) 1    127.0.0.1:6379&gt; sadd myset a    (integer) 02. 获取：smembers key:获取set集合中所有元素    127.0.0.1:6379&gt; smembers myset    1) &quot;a&quot;3. 删除：srem key value:删除set集合中的某个元素        127.0.0.1:6379&gt; srem myset a    (integer) 1</code></pre><ol start="6"><li><p>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><ol><li><p>存储：zadd key score value<br>127.0.0.1:6379&gt; zadd mysort 60 zhangsan<br>(integer) 1<br>127.0.0.1:6379&gt; zadd mysort 50 lisi<br>(integer) 1<br>127.0.0.1:6379&gt; zadd mysort 80 wangwu<br>(integer) 1</p></li><li><p>获取：zrange key start end [withscores]<br>127.0.0.1:6379&gt; zrange mysort 0 -1</p><ol><li>“lisi”</li><li>“zhangsan”</li><li>“wangwu”</li></ol><p>127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</p><ol><li>“zhangsan”</li><li>“60”</li><li>“wangwu”</li><li>“80”</li><li>“lisi”</li><li>“500”</li></ol></li><li><p>删除：zrem key value<br>127.0.0.1:6379&gt; zrem mysort lisi<br>(integer) 1</p></li></ol></li><li><p>通用命令</p><ol><li>keys * : 查询所有的键</li><li>type key ： 获取键对应的value的类型</li><li>del key：删除指定的key value </li></ol></li></ol></li></ol><pre><code>4. 持久化    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000                            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf                        2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化5. Java客户端 Jedis    * Jedis: 一款java操作redis数据库的工具.    * 使用步骤：        1. 下载jedis的jar包        2. 使用            //1. 获取连接            Jedis jedis = new Jedis(&quot;localhost&quot;,6379);               //2. 操作               jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //3. 关闭连接            jedis.close();## jedis</code></pre><p>首先要添加jedis所需的jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId &gt;redis.clients&lt;&#x2F; groupId &gt;</span><br><span class="line">&lt;artifactId &gt;jedis&lt;&#x2F; artifactId &gt;</span><br><span class="line">&lt;version &gt;3.2.0&lt;&#x2F; version &gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>​    Jedis操作各种redis中的数据结构<br>​            1) 字符串类型 string<br>​                set<br>​                get<br>​                </p><pre><code>步骤流程：//1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            //存储            jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //获取            String username = jedis.get(&quot;username&quot;);            System.out.println(username);                //可以使用setex()方法存储可以指定过期时间的 key value            jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对                //3. 关闭连接            jedis.close();        2) 哈希类型 hash ： map格式              hset            hget            hgetAll            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // 存储hash            jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);            jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);            jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);                // 获取hash            String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);            System.out.println(name);</code></pre><p>​<br>​                // 获取hash的所有map中的数据<br>​                Map&lt;String, String&gt; user = jedis.hgetAll(“user”);<br>​<br>​                // keyset<br>​                Set<String> keySet = user.keySet();<br>​                for (String key : keySet) {<br>​                    //获取value<br>​                    String value = user.get(key);<br>​                    System.out.println(key + “:” + value);<br>​                }<br>​<br>​                //3. 关闭连接<br>​                jedis.close();</p><pre><code>        3) 列表类型 list ： linkedlist格式。支持重复元素            lpush / rpush            lpop / rpop            lrange start end : 范围获取                         //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // list 存储            jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存            jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存                // list 范围获取            List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist);                        // list 弹出            String element1 = jedis.lpop(&quot;mylist&quot;);//c            System.out.println(element1);                String element2 = jedis.rpop(&quot;mylist&quot;);//c            System.out.println(element2);                // list 范围获取            List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist2);                //3. 关闭连接            jedis.close();        4) 集合类型 set  ： 不允许重复元素            sadd            smembers:获取所有元素            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作</code></pre><p>​<br>​                // set 存储<br>​                jedis.sadd(“myset”,”java”,”php”,”c++”);<br>​<br>​                // set 获取<br>​                Set<String> myset = jedis.smembers(“myset”);<br>​                System.out.println(myset);<br>​<br>​                //3. 关闭连接<br>​                jedis.close();<br>​            5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序<br>​                zadd<br>​                zrange<br>​    </p><pre><code>            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // sortedset 存储            jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);            jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);            jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);                // sortedset 获取            Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);                System.out.println(mysortedset);</code></pre><p>​<br>​                //3. 关闭连接<br>​                jedis.close();</p><p>​<br>​        * jedis连接池： JedisPool<br>​            * 使用：<br>​                1. 创建JedisPool连接池对象<br>​                2. 调用方法 getResource()方法获取Jedis连接<br>​                    //0.创建一个配置对象<br>​                    JedisPoolConfig config = new JedisPoolConfig();<br>​                    config.setMaxTotal(50);<br>​                    config.setMaxIdle(10);<br>​<br>​                    //1.创建Jedis连接池对象<br>​                    JedisPool jedisPool = new JedisPool(config,”localhost”,6379);<br>​<br>​                    //2.获取连接<br>​                    Jedis jedis = jedisPool.getResource();<br>​                    //3. 使用<br>​                    jedis.set(“hehe”,”heihei”);</p><p>​<br>​                    //4. 关闭 归还到连接池中<br>​                    jedis.close();<br>​<br>​            * 连接池工具类<br>​                public class JedisPoolUtils {<br>​<br>​                    private static JedisPool jedisPool;<br>​                </p><pre><code>                static&#123;                    //读取配置文件                    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);                    //创建Properties对象                    Properties pro = new Properties();                    //关联文件                    try &#123;                        pro.load(is);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                    //获取数据，设置到JedisPoolConfig中                    JedisPoolConfig config = new JedisPoolConfig();                    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));                    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));                                //初始化JedisPool                    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</code></pre><p>​<br>​<br>​                    }</p><p>​<br>​                    /**<br>​                     * 获取连接方法<br>​                     */<br>​                    public static Jedis getJedis(){<br>​                        return jedisPool.getResource();<br>​                    }<br>​                }</p><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. redis
    1. 概念
    2. 下载安装
    3. 命令操作
        1. 数据结构
   </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring 5</title>
    <link href="http://example.com/2021/10/13/Spring-5/"/>
    <id>http://example.com/2021/10/13/Spring-5/</id>
    <published>2021-10-13T12:35:05.000Z</published>
    <updated>2021-10-30T13:00:32.217Z</updated>
    
    <content type="html"><![CDATA[<p> 本文作为学习尚硅谷Spring5教程之后的课后笔记，仅供个人学习。 </p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><strong>Spring 是轻量级的开源的 JavaEE 框架。</strong></p><ul><li>独立使用不依赖其他组件</li><li>导入的jar包很少，体积很小</li></ul><p>Spring 可以解决企业应用开发的复杂</p><p>Spring 拥有两个核心部分：IOC 和 Aop</p><p>（1）IOC：控制反转，把创建对象过程交给 Spring 进行管理（不需要new初始化对象）</p><p>（2）Aop：面向切面，不修改源代码的情况下进行功能增强</p><p>Spring的特点 （优势）：</p><p>（1）方便解耦，简化开发</p><p>（2）Aop 编程支持</p><p>（3）方便程序测试</p><p>（4）方便和其他框架进行整合（Mybatis等）</p><p>（5）方便进行事务操作</p><p>（6）降低 API 开发难度（对很多组成进行了封装）</p><p>Spring项目所依赖的jar包如下：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211012095832374.png" alt="image-20211012095832374"></p><h2 id="二、IOC容器"><a href="#二、IOC容器" class="headerlink" title="二、IOC容器"></a>二、IOC容器</h2><h3 id="1-IOC概念和底层原理"><a href="#1-IOC概念和底层原理" class="headerlink" title="1.IOC概念和底层原理"></a>1.IOC概念和底层原理</h3><p>（1）概念：</p><pre><code>                  控制反转，把对象创建和对象的调用过程交给spring进行管理。</code></pre><p>​        目的：降低耦合度。</p><p>（2）IOC底层原理：<strong>xml，反射，工厂模式</strong>（设计模式）</p><p>​            // 工厂模式：目的为了降低耦合 。创建工厂类，new对象，之后调用工厂类的方法即可—————&gt;仍然具有一定的耦合度 —————&gt;IOC:最大限度的   </p><p>​            <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211012104003619.png" alt="image-20211012104003619" style="zoom: 67%;" /></p><p><strong>Spring提供IOC容器两种实现方式（两个接口）</strong></p><ul><li><p>BeanFactory：Spring内部使用的接口，不提倡开发人员使用。特点：加载配置文件时不会创建对象，获取（使用）对象时才会创建对象。</p></li><li><p>ApplicationContext：BeanFactory的子接口，提供了更多更强大的功能，一般由开发人员使用。</p><p>​    特点：加载配置文件时会把配置文件里的对象进行创建。</p><p>哪种方式更好？</p><p>​    耗时耗资源的过程都在启动工程中启动，减少用户调用时的时间，具体工程中ApplicationContext更常用</p></li><li><p>ApplicationContext两个常用实现类：</p><ul><li>FileSystemXmlApplicationContext：绝对路径，从盘符开始算起</li><li>ClassPathXmlApplicationContext：相对路径，从src开始算起</li></ul></li></ul><p>什么是Bean管理？</p><p>​    Bean管理是指两个操作：Spring创建对象 和 Spring注入属性</p><p>​    Bean管理有两种操作方式：</p><ul><li>基于xml配置文件方式实现 </li><li>基于注解方式实现</li></ul><h3 id="2-IOC操作Bean管理（基于xml）"><a href="#2-IOC操作Bean管理（基于xml）" class="headerlink" title="2.IOC操作Bean管理（基于xml）"></a>2.IOC操作Bean管理（基于xml）</h3><p>xml实现Bean管理：<br>（1）基于xml方式创建对象：</p><p>​    在Spring配置文件中使用bean标签，来创建对象，bean标签可以使用很多年属</p><p>性</p><p>常用属性：</p><ul><li><p>id：唯一标识</p></li><li><p>class：目标类的路径，可以使用绝对路径和相对路径</p><p>创建对象时，默认执行无参构造函数</p></li></ul><p>（2）基于xml方式注入属性：</p><ul><li><p>方法一：使用set方法进行注入：</p><p>DI 注入：（IOC的具体实现）依赖注入，即注入属性 </p><p>首先先为类的属性提供set方法：</p><p>创建一个类，定义他们的属性和set方法</p><p>  public class User {<br>  private String userName;<br>  private String userAge;<br>  // set方法注入<br>  public void setUserName(String userName) {</p><pre><code>  this.userName = userName;</code></pre><p>  }</p><p>  public void setUserAge(String userAge) {</p><pre><code>  this.userAge = userAge;</code></pre><p>  }</p><p>  public String getUserName() {</p><pre><code>  return userName;</code></pre><p>  }</p><p>  public String getUserAge() {</p><pre><code>  return userAge;</code></pre><p>  }<br>  }</p></li></ul><p>然后在xml配置文件中通过property标签进行属性注入</p><pre><code> &lt;!--1 配置User对象创建--&gt;    &lt;!--&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring5.User&quot;&gt;&lt;/bean&gt;--&gt;    &lt;!--2 set方法注入属性--&gt;    &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot;&gt;        &lt;!--使用property完成属性注入            name：类里面属性名称            value：向属性注入的值        --&gt;        &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt;</code></pre><p>​<br>​<br>​<br> 然后进行测试</p><pre><code>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);User user = applicationContext.getBean(&quot;user&quot;, User.class);System.out.println(user.getUserName() + &quot; &quot; +user.getUserAge());</code></pre><p>方法二：使用有参构造函数进行注入</p><p>首先提供有参构造方法</p><pre><code>public class User &#123;private String userName;private String userAge;public User(String userName, String userAge)&#123;    this.userName = userName;    this.userAge = userAge;&#125;</code></pre><p>然后再xml配置文件中通过constructor-arg标签进行属性注入</p><pre><code>&lt;!--配置User对象--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.oymn.spring5.User&quot;&gt;    &lt;constructor-arg name=&quot;userName&quot; value=&quot;haha&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;userAge&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>（3）xml注入其他属性</p><p><strong>null值</strong></p><p>在xml文件中设置空值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--null值--&gt;</span><br><span class="line">&lt;!--&lt;property name&#x3D;&quot;address&quot;&gt;</span><br><span class="line">    &lt;null&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;property&gt;--&gt;</span><br></pre></td></tr></table></figure><p><strong>属性值包含特殊符号</strong></p><p>假设现在userName属性需要赋值为 &lt; sdjfs &gt;（ 属性值中含有特殊字符，会报错 ）</p><p> 解决方法：</p><ul><li><p>把特殊字符转义即可</p></li><li><p>通过 <![CDATA[值]]> 来表示</p><p>例如：<value> <strong><![CDATA[**  解析 xml **]]></strong><value></p></li></ul><h4 id="1-注入属性——外部bean"><a href="#1-注入属性——外部bean" class="headerlink" title="1.注入属性——外部bean"></a>1.注入属性——外部bean</h4><p>创建两个类，在一个类中调用另一个类的方法，使用外部bean的形式</p><p>有两个类：UserService和UserDaoImpl，其中UserDaoImpl实现UserDao接口</p><pre><code>public class UserService &#123;private UserDao userDao;public void setUserDao(UserDao userDao)&#123;    this.userDao = userDao;&#125;//创建set方法，之后使用set方法注入public void add()&#123;    System.out.println(&quot;add&quot;);&#125;</code></pre><p>通过 ref 来指定创建userDaoImpl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.oymn.spring5.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;&#x2F;&#x2F;  创建userdao对象，接口不能有对象此处使用其实现类的对象</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.oymn.spring5.UserService&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">​&#x2F;&#x2F;创建userservice对象</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.atguigu.spring5.service.UserService&quot;&gt;    &lt;!--注入userDao对象        name属性：类里面属性名称        ref属性：创建userDao对象bean标签id值（想要引入的userdao对象创建时的ID值）    --&gt;    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h4 id="2-注入属性——内部bean"><a href="#2-注入属性——内部bean" class="headerlink" title="2. 注入属性——内部bean"></a>2. 注入属性——内部bean</h4><p>不通过ref属性，而是通过嵌套一个bean标签实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--内部 bean--&gt;&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;com.atguigu.spring5.bean.Emp&quot;&gt;     &lt;!--设置两个普通属性--&gt;     &lt;property name&#x3D;&quot;ename&quot; value&#x3D;&quot;lucy&quot;&gt;&lt;&#x2F;property&gt;     &lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;女&quot;&gt;&lt;&#x2F;property&gt;     &lt;!--设置对象类型属性--&gt;     &lt;property name&#x3D;&quot;dept&quot;&gt;     &#x2F;&#x2F;不是使用外部bean 得hef引入当前bean外边创建得bean对象,而是在bean内部属性定义时嵌套创建bean         &lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;com.atguigu.spring5.bean.Dept&quot;&gt;         &lt;property name&#x3D;&quot;dname&quot; value&#x3D;&quot;安保部&quot;&gt;&lt;&#x2F;property&gt;         &lt;&#x2F;bean&gt;     &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt; </span><br></pre></td></tr></table></figure><h4 id="3-注入属性——级联赋值"><a href="#3-注入属性——级联赋值" class="headerlink" title="3.注入属性——级联赋值"></a>3.注入属性——级联赋值</h4><p>写法一：外部bean，通过ref属性来获取外部bean</p><p>写法二：</p><p>emp类中有ename和dept两个属性，其中dept有dname属性，</p><p>注意：emp要提供dept属性的get方法。否则方法取不到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--级联赋值--&gt;&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;com.atguigu.spring5.bean.Emp&quot;&gt;    &lt;!--设置两个普通属性--&gt;    &lt;property name&#x3D;&quot;ename&quot; value&#x3D;&quot;lucy&quot;&gt;&lt;&#x2F;property&gt; ​&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;女&quot;&gt;&lt;&#x2F;property&gt;​    &lt;!--写法一--&gt;​&lt;property name&#x3D;&quot;dept&quot; ref&#x3D;&quot;dept&quot;&gt;&lt;&#x2F;property&gt;​    &lt;!--写法二--&gt;​    &lt;property name&#x3D;&quot;dept.dname&quot; value&#x3D;&quot;技术部&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;com.atguigu.spring5.bean.Dept&quot;&gt;​    &lt;pr operty name&#x3D;&quot;dname&quot; value&#x3D;&quot;财务部&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h4 id="4-注入集合属性（数组，List，Map）"><a href="#4-注入集合属性（数组，List，Map）" class="headerlink" title="4. 注入集合属性（数组，List，Map）"></a>4. 注入集合属性（数组，List，Map）</h4><p>共同特征：都包含多个元素</p><p>假设有一个Stu类（学生类）</p><ol><li><p>首先创建类，定义数组、list、map、set、等类型属性，生成对应的set方法</p><p>public class Stu {<br>private String[] courses;<br>private List<String> list;<br>private Map&lt;String,String&gt; map;<br>private Set<String> set;</p><p>//创建set<br>public void setCourses(String[] courses) {</p><pre><code>this.courses = courses;</code></pre><p>}<br>//list集合类型<br>public void setList(List<String> list) {</p><pre><code>this.list = list;</code></pre><p>}<br>//map类型属性<br>public void setMap(Map&lt;String, String&gt; map) {</p><pre><code>this.map = map;</code></pre><p>}<br>//set 集合类型<br>public void setSet(Set<String> set) {</p><pre><code>this.set = set;</code></pre><p>}</p></li></ol><ol start="2"><li><p>在xml配置文件中对这些集合属性进行注入</p><p>这里不使用value，因为一个属性有多个属值，都是集合类型属性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;stu&quot; class&#x3D;&quot;com.oymn.spring5.Stu&quot;&gt;    &lt;!--数组类型属性注入--&gt;    &lt;property name&#x3D;&quot;courses&quot;&gt;        &lt;array&gt;&#x2F;&#x2F; 可以使用&lt;array&gt;或者&lt;list&gt;            &lt;value&gt;java课程&lt;&#x2F;value&gt;            &lt;value&gt;数据库课程&lt;&#x2F;value&gt;        &lt;&#x2F;array&gt;    &lt;&#x2F;property&gt;    &lt;!--List类型属性注入--&gt;    &lt;property name&#x3D;&quot;list&quot;&gt;        &lt;list&gt;            &lt;value&gt;张三&lt;&#x2F;value&gt;            &lt;value&gt;李四&lt;&#x2F;value&gt;        &lt;&#x2F;list&gt;    &lt;&#x2F;property&gt;    &lt;!--Map类型属性注入--&gt;    &lt;property name&#x3D;&quot;map&quot;&gt;        &lt;map&gt;&#x2F;&#x2F;  map属性有键值和标签两个属性            &lt;entry key&#x3D;&quot;JAVA&quot; value&#x3D;&quot;java&quot;&gt;&lt;&#x2F;entry&gt;            &lt;entry key&#x3D;&quot;PHP&quot; value&#x3D;&quot;php&quot;&gt;&lt;&#x2F;entry&gt;        &lt;&#x2F;map&gt;    &lt;&#x2F;property&gt;    &lt;!--Set类型属性注入--&gt;    &lt;property name&#x3D;&quot;set&quot;&gt;        &lt;set&gt;            &lt;value&gt;Mysql&lt;&#x2F;value&gt;            &lt;value&gt;Redis&lt;&#x2F;value&gt;        &lt;&#x2F;set&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p><strong>设置对象类型的值</strong> </p><p>上面的集合值都是字符串（string），以下设置对象类型的值，如下：</p><p>写法： 集合+外部bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建多个 course 对象--&gt;&lt;bean id&#x3D;&quot;course1&quot; class&#x3D;&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;&lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;Spring5 框架&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;course2&quot; class&#x3D;&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;&lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;MyBatis 框架&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!--注入 list 集合类型，但是值是对象--&gt;&lt;property name&#x3D;&quot;courseList&quot;&gt;    &lt;list&gt;        &lt;ref bean&#x3D;&quot;course1&quot;&gt;&lt;&#x2F;ref&gt;        &lt;ref bean&#x3D;&quot;course2&quot;&gt;&lt;&#x2F;ref&gt;&#x2F;&#x2F;    &lt;&#x2F;list&gt;&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p><strong>把集合注入部分提取出来</strong></p><p>使用 util 标签，这样不同的bean都可以使用相同的集合注入部分了。</p><!--将集合注入部分提取出来--><p>引入名称空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1 提取list集合类型属性注入--&gt;&lt;util:list id&#x3D;&quot;bookList&quot;&gt;    &lt;value&gt;易筋经&lt;&#x2F;value&gt;    &lt;value&gt;九阴真经&lt;&#x2F;value&gt;    &lt;value&gt;九阳神功&lt;&#x2F;value&gt;    &#x2F;&#x2F;当然也可以引入对象类型属性，使用ref即可&lt;&#x2F;util:list&gt;&lt;!--2 提取list集合类型属性注入使用--&gt;&lt;bean id&#x3D;&quot;book&quot; class&#x3D;&quot;com.atguigu.spring5.collectiontype.Book&quot; scope&#x3D;&quot;prototype&quot;&gt;    &lt;property name&#x3D;&quot;list&quot; ref&#x3D;&quot;bookList&quot;&gt;&lt;&#x2F;property&gt;    &#x2F;&#x2F;注意此时 name和ref对应util中的id&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>Spring有两种Bean，一种是普通Bean，另一种是工厂Bean（FactoryBean）</p><ul><li><p>普通bean：在配置文件中定义 <strong>bean</strong> <strong>类型就是返回类型</strong></p></li><li><p>工厂bean：<strong>在配置文件定义bean 类型可以和返回类型不一样</strong></p></li></ul><p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建的类实现接口，public class MyBean implements FactoryBean&lt;Course&gt; &#123;&#x2F;&#x2F;适用泛型类，定义返回的类型是Course类型    &#x2F;&#x2F;定义返回bean的类型，可以不是xml文件中定义的Mybean类型     @Override    public Course getObject() throws Exception &#123;        Course course &#x3D; new Course();        course.setCname(&quot;abc&quot;);        return course;    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return null;    &#125;    @Override    public boolean isSingleton() &#123;        return false;    &#125;&#125;&lt;bean id&#x3D;&quot;myBean&quot; class&#x3D;&quot;com.atguigu.spring5.factorybean.MyBean&quot;&gt;&lt;&#x2F;bean&gt;&#x2F;&#x2F;测试用例public void test3() &#123; ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Course course &#x3D; context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course);&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>在Spring中，可以设置bean实例是单实例还是多实例，默认情况下bean是单实例对象。</p><p>执行结果是相同的：</p><p>通过 bean标签的scope属性 来设置单实例还是多实例。<br>Scope属性值：singleton和prototype</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211012163218578.png" alt="image-20211012163218578"></p><p><strong>singleton：</strong>默认值，表示单实例对象。加载配置文件时就会创建单实例对象。<br><strong>prototype</strong>：表示多实例对象。不是在加载配置文件时创建对象，在调用getBean方法时创建多实例对象。</p><p>//两者创建的时机不同</p><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>从对象的创建到销毁的过程</p><p>bean的生命周期（过程）：<br>（1）通过构造器创建 bean 实例（执行无参数构造（默认））</p><p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p><p>（3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</p><p>（4）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p>（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</p><p>（6）bean 可以使用了（对象获取到了）</p><p>（7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p><p> 示例：</p><pre><code>public class Orders &#123;    private String orderName;public Orders() &#123;    System.out.println(&quot;第一步：执行无参构造方法创建bean实例&quot;);&#125;public void setOrderName(String orderName) &#123;    this.orderName = orderName;    System.out.println(&quot;第二步：调用set方法设置属性值&quot;);&#125;//初始化方法public void initMethod()&#123;    System.out.println(&quot;第四步：执行初始化方法&quot;);&#125;//销毁方法public void destroyMethod()&#123;    System.out.println(&quot;第七步：执行销毁方法&quot;);&#125;</code></pre><p>//实现后置处理器，需要实现BeanPostProcessor接口<br>public class MyBeanPost implements BeanPostProcessor {</p><pre><code>@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;    System.out.println(&quot;第三步：将bean实例传递给bean后置处理器的postProcessBeforeInitialization方法&quot;);    return bean;&#125;@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;    System.out.println(&quot;第五步：将bean实例传递给bean后置处理器的postProcessAfterInitialization方法&quot;);    return bean;&#125;&lt;bean id=&quot;orders&quot; class=&quot;com.oymn.spring5.Orders&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;    &lt;property name=&quot;orderName&quot; value=&quot;hahah&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置bean后置处理器，这样配置后整个xml里面的bean用的都是这个后置处理器--&gt;&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.oymn.spring5.MyBeanPost&quot;&gt;&lt;/bean&gt;@Testpublic void testOrders()&#123;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);Orders orders = context.getBean(&quot;orders&quot;, Orders.class);System.out.println(&quot;第六步：获取bean实例对象&quot;);System.out.println(orders);//手动让bean实例销毁context.close();</code></pre><h4 id="xml自动装配"><a href="#xml自动装配" class="headerlink" title="xml自动装配"></a>xml自动装配</h4><ul><li><p>之前的配置使用name，value、ref是手动装配，下面进行自动装配</p></li><li><p>根据指定的装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入</p></li><li><p>要求 emp中属性的名称dept 和 bean标签的id值dept 一样，才能识别</p></li><li><p>要求同一个xml文件中不能有两个相同类型的bean，否则无法识别</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--实现自动装配    bean标签属性autowire，配置自动装配    autowire属性常用两个值：        byName根据属性名称注入 ，注入值bean的id值和类属性名称一样        byType根据属性类型注入--&gt;&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;com.atguigu.spring5.autowire.Emp&quot; autowire&#x3D;&quot;byType&quot;&gt;    &lt;!--&lt;property name&#x3D;&quot;dept&quot; ref&#x3D;&quot;dept&quot;&gt;&lt;&#x2F;property&gt;--&gt;&lt;&#x2F;bean&gt;&lt;property name&#x3D;&quot;dept1&quot; ref&#x3D;&quot;dept&quot;&gt;&lt;&#x2F;property&gt;&#x2F;&#x2F;注意此时同一type有两个bean，此时会发生错误，要使用byName &lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;&#x2F;bean&gt; </span><br></pre></td></tr></table></figure><h4 id="通过外部属性文件来操作bean"><a href="#通过外部属性文件来操作bean" class="headerlink" title="通过外部属性文件来操作bean"></a>通过外部属性文件来操作bean</h4><p>把大量配置的属性信息，存放到外部文件中，方便使用和修改。</p><p>例子：引入数据库 信息配置</p><ul><li><p>导入数据库连接池jar包</p></li><li><p>创建外部属性文件，properties格式文件，写数据库信息(用户名，密码，数据库服务器，路径名称等)</p></li><li><p>引入context名称空间，并通过context标签引入外部属性文件，使用“${}”来获取文件中对应的值 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引入 context 名称空间&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;&lt;!--直接配置连接池--&gt;&#x2F;&#x2F;   初始配置方法 &lt;!--&lt;bean id&#x3D;&quot;dataSource&quot;   class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;userDb&quot;&gt;&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;--&gt;    &lt;!--引入外部属性文件--&gt;    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;    &lt;!--配置连接池--&gt;   &#x2F;&#x2F;通过配置文件进行赋值，使用表达式$&#123;&#125;    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;prop.url&#125;&quot;&gt;&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;prop.password&#125;&quot;&gt;&lt;&#x2F;property&gt;            &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="3-IOC操作Bean管理（基于注解）"><a href="#3-IOC操作Bean管理（基于注解）" class="headerlink" title="3. IOC操作Bean管理（基于注解）"></a>3. IOC操作Bean管理（基于注解）</h3><p>引入：注解：Java代码中的特殊标记，可以使用在方法上、类上、属性上。</p><ul><li><p>格式：@注解名称（属性名=属性值，属性名=属性值，……）</p></li><li><p>注解可以作用在类，属性，方法。</p></li><li><p>目的：简化xml配置，很少或不使用xml</p></li></ul><h4 id="1-基于注解创建对象"><a href="#1-基于注解创建对象" class="headerlink" title="1. 基于注解创建对象"></a>1. 基于注解创建对象</h4><p>spring提供了四种创建对象的注解：</p><p>@Component<br>@Service：一般用于Service层<br>@Controller：一般用于web层<br>@ Repository：一般用于Dao层  //功能都是相同的，因为习惯划分了应用的层</p><p>流程：</p><ul><li><p>首先需要AOP引入依赖：</p></li><li><p>开启组件扫描：</p><p>扫描base-package包下所有有注解的类<strong>并以注解的形式为其创建对象</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.oymn&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure><ul><li>基于注解方式实现对象创建<br>例子：在com.oymn.spring5.Service创建一个stuService类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在注解里面value属性值可以省略不写，默认值是类名称，首字母小写&#x2F;&#x2F;即:UserService -- userService在类的前面添加@Component(value &#x3D; &quot;userService&quot;) &#x2F;&#x2F;相当于&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;..&quot;&#x2F;&gt;@Servicepublic class UserService &#123;    @Value(value &#x3D; &quot;abc&quot;)    private String name;    &#x2F;&#x2F;定义dao类型属性    &#x2F;&#x2F;不需要添加set方法    &#x2F;&#x2F;添加注入属性注解&#x2F;&#x2F;    @Autowired  &#x2F;&#x2F;根据类型进行注入&#x2F;&#x2F;    @Qualifier(value &#x3D; &quot;userDaoImpl1&quot;) &#x2F;&#x2F;根据名称进行注入&#x2F;&#x2F;    private UserDao userDao;    &#x2F;&#x2F;@Resource  &#x2F;&#x2F;根据类型进行注入    @Resource(name &#x3D; &quot;userDaoImpl1&quot;)  &#x2F;&#x2F;根据名称进行注入    private UserDao userDao;    public void add() &#123;        System.out.println(&quot;service add.......&quot;+name);        userDao.add();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>然后可以通过getBean方法来获取stuService对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);StuService stuService &#x3D; context.getBean(&quot;stuService&quot;, StuService.class);System.out.println(stuService);stuService.add();</span><br></pre></td></tr></table></figure><p><strong>注意：开启组件扫描的细节配置：</strong></p><p>use-default-fileters设置使用默认过滤器，可以设置成false,通过include-</p><p>filter来设置只扫描base-packet 下的所有由注解修饰的类(相当于筛选)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.oymn&quot; use-default-filters&#x3D;&quot;false&quot;&gt;&lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>exclude-filter设置哪些注解不被进行扫描，</p><p>例子中为@Controller修饰的类不被扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.oymn&quot;&gt;    &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure><h4 id="2-基于注解进行属性注入"><a href="#2-基于注解进行属性注入" class="headerlink" title="2. 基于注解进行属性注入"></a>2. 基于注解进行属性注入</h4><p>@Autowired：根据属性类型自动装配</p><p>   举例子说明： </p><pre><code>创建StuDao接口和StuDaoImpl实现类，为StuDaoImpl添加创建对象注解public interface StuDao &#123;    public void add();&#125;</code></pre><p>​<br>​    @Repository        //添加注解，获取对象<br>​    public class StuDaoImpl implements StuDao {<br>​        @Override<br>​        </p><pre><code>    public void add() &#123;        System.out.println(&quot;StuDaoImpl&quot;);    &#125;&#125;StuService类中添加StuDao属性，为其添加@Autowire注解，spring会自动为stuDao属性创建StuDaoImpl对象@Component(value=&quot;stuService&quot;)public class StuService &#123;@Autowired    //添加属性，使用@Autowire注解public StuDao stuDao;public void add()&#123;    System.out.println(&quot;addService&quot;);    stuDao.add();&#125;</code></pre><p>@Qualifier：根据属性名称自动装配</p><p>和@Autowire一同使用</p><p>当遇到一个接口有很多实现类时，只通过@Autowire是无法完成自动装配的，所以需要再使用@Qualifier通过名称来锁定某个类 </p><pre><code>@Component(value=&quot;stuService&quot;)public class StuService &#123;@Autowired@Qualifier(value=&quot;stuDaoImpl&quot;)  //这样就能显式指定stuDaoImpl这个实现类public StuDao stuDao;public void add()&#123;    System.out.println(&quot;addService&quot;);    stuDao.add();&#125;</code></pre><p>}</p><p>@Resource：可以根据类型注入，也可以根据名称注入</p><pre><code>@Component(value=&quot;stuService&quot;)public class StuService &#123;//@Resource   //根据类型进行注入@Resource(name=&quot;stuDaoImpl&quot;)  //根据名称进行注入public StuDao stuDao;public void add()&#123;    System.out.println(&quot;addService&quot;);    stuDao.add();&#125;</code></pre><p>@Value：注入普通类型属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Value(value &#x3D; &quot;abc&quot;)private String name;  &#x2F;&#x2F;将name注入为abc</span><br></pre></td></tr></table></figure><p>（3）完全注解开发：</p><ul><li>创建配置类，替代原来xml配置文件中设置的扫 描</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个包，创建一个配置类@Configuration    &#x2F;&#x2F;表明为一个配置类@ComponentScan(basePackages &#x3D; &quot;com.oymn&quot;)   &#x2F;&#x2F;开启组件扫描public class SpringConfig &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>编写测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void testService2() &#123;    &#x2F;&#x2F;加载配置类    ApplicationContext context            &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);    UserService userService &#x3D; context.getBean(&quot;userService&quot;, UserService.class);    System.out.println(userService);    userService.add();</span><br></pre></td></tr></table></figure></li></ul><h2 id="四-AOP"><a href="#四-AOP" class="headerlink" title="四.AOP"></a>四.AOP</h2><p>引入：<br>面向切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。通俗来说就是在不修改代码的情况下添加新的功能。</p><p>最终目的就是降低耦合度</p><h3 id="1-AOP底层原理"><a href="#1-AOP底层原理" class="headerlink" title="1.AOP底层原理"></a>1.AOP底层原理</h3><p>底层通过动态代理来实现：</p><p>第一种：有接口的情况，使用JDK动态代理：创建接口实现类的代理对象。<br>第二种：无接口的情况，使用CGLIB动态代理：创建当前类子类的代理对象。</p><p>JDK动态代理举例：</p><p>通过 java.lang.reflect.Proxy类 调用 newProxyInstance方法 创建代理类。</p><p>newProxyInstance方法：</p><p>方法有三个参数：</p><p>参数一：类加载器</p><p>参数二：所增强方法所在的类，这个类实现的接口，支持多个接口</p><p>参数三：实现InvocationHandle接口，创建代理部分，重写invoke方法来添加新的功能</p><p>代码举例：</p><pre><code>//创建接口UserDaopublic interface UserDao &#123;    public int add(int a, int b);    public int multi(int a, int b);&#125;//定义实现类public class UserDaoImpl implements UserDao &#123;    @Override    public int add(int a, int b) &#123;        return a+b;    &#125;    @Override    public int multi(int a, int b) &#123;    return a*b;&#125;public   class Main &#123;@Testpublic void test1()&#123;    //所需代理的类实现的接口，支持多个接口    Class[] interfaces = &#123;UserDao.class&#125;;        UserDao userDao = new UserDaoImpl();        //调用newProxyInstance方法来创建代理类    UserDao userDaoProxy = (UserDao)        Proxy.newProxyInstance(Main.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));        int result = userDaoProxy.add(1, 2);    System.out.println(result);&#125;</code></pre><p>​<br>​    //参数3<br>​    //创建内部类，实现InvocationHandler接口，增强invoke方法，添加新功能<br>​    class UserDaoProxy implements InvocationHandler {<br>​    </p><pre><code>    Object obj;        //通过有参构造函数将需要创建代理的类传过来    public UserDaoProxy(Object obj)&#123;//Object更加通用        this.obj = obj;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;进入&quot; + method.getName() + &quot;方法，这是新增的代码，参数有&quot; + Arrays.toString(args));                //执行原有的代码        Object invoke = method.invoke(obj, args);                System.out.println(&quot;方法原先的内容执行完了&quot;);                return invoke;    &#125;&#125;&#125;</code></pre><p>基于AspectJ实现AOP操作</p><h3 id="2-AOP相关术语"><a href="#2-AOP相关术语" class="headerlink" title="2.AOP相关术语"></a>2.AOP相关术语</h3><ul><li><p>连接点：类中可以被增强的方法，称为连接点。</p></li><li><p>切入点：实际被增强的方法，称为切入点。</p></li><li><p>通知：增强的那一部分逻辑代码。通知有多种类型：</p><ul><li><p>前置通知：增强部分代码在原代码前面。</p></li><li><p>后置通知：增强部分代码在原代码后面。</p></li><li><p>环绕通知：增强部分代码既有在原代码前面，也有在原代码后面。</p></li><li><p>异常通知：原代码发生异常后才会执行。</p></li><li><p>最终通知：类似与finally那一部分</p></li></ul></li><li><p>切面：指把通知应用到切入点这一个动作。</p></li></ul><h3 id="3-AspectJ"><a href="#3-AspectJ" class="headerlink" title="3. AspectJ"></a>3. AspectJ</h3><ul><li><p>AspectJ是Spring一般用来实现AOP 操作；</p></li><li><p>AspectJ 不是Spring的组成部分，独立于SPRING，一般把两者共同使用</p></li><li><p>需要的相关依赖：<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211012212607877.png" alt="image-20211012212607877"></p></li></ul><p><strong>1.基于AspectJ实现AOP有两种方式：</strong></p><ul><li>基于xml配置文件</li><li>基于注解方法（常用） </li></ul><p><strong>2.切入点表达式</strong>：（明确对哪个类中的那个方法进行增强）</p><p>语法结构：execution（[权限修饰符] [返回类型] [类全路径] [方法名称] [参数列表]）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强execution(* com.auguigu.dao.BookDao.add(..))1举例2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强execution(* com.atguigu.dao.BookDao.*(..))1举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强execution(* com.atguigu.dao.*.* (..))</span><br></pre></td></tr></table></figure><p><strong>3.基于注解方式</strong></p><p>1、创建类，在类里面定义方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123; public void add() &#123; System.out.println(&quot;add.......&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure><p>2、创建增强类（编写增强逻辑）</p><p>（1）在增强类里面，创建方法，让不同方法代表不同通知类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;增强的类*public class UserProxy &#123; public void before() &#123;*&#x2F;&#x2F;前置通知* System.out.println(&quot;before......&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure><p>3、进行通知的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（1）在 spring 配置文件中，开启注解扫描&lt;?xml version&#x3D;****&quot;1.0&quot;** **encoding&#x3D;****&quot;UTF-8&quot;***?&gt;*&lt; beans xmlns&#x3D;****&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;  xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;  xmlns:aop&#x3D;****&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd**  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;* &gt;  &lt;!-- 开启注解扫描 --&gt;  &lt; context :component-scan* base  package&#x3D; &quot;com.atguigu.spring5.aopanno&quot; &gt;&lt;&#x2F; context :component-scan &gt; （2）使用注解创建 User 和 UserProxy 对象（3）在增强类上面添加注解 @Aspect&#x2F;&#x2F;增强的类*@Component@Aspect *&#x2F;&#x2F;生成代理对象public class UserProxy &#123;（4）在 spring 配置文件中开启生成代理对象&lt;!-- 开启 Aspect 生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;&#x2F;aop:aspectj-autoproxy&gt; </span><br></pre></td></tr></table></figure><p>4、配置不同类型的通知</p><p>（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">增强的类@Component@Aspect &#x2F;&#x2F;生成代理对象public class** UserProxy &#123; &#x2F;&#x2F;前置通知 &#x2F;&#x2F;@Before 注解表示作为前置通知 @Before(value &#x3D; **&quot;execution(\* com.atguigu.spring5.aopanno.User.add(..))&quot;**) public void** before() &#123; System.**out**.println(&quot;before.........&quot;); &#125; &#x2F;&#x2F;后置通知（返回通知） @AfterReturning(value &#x3D; &quot;execution(\**com.atguigu.spring5.aopanno.User.add(..))&quot;) **public void** afterReturning() &#123; System.out.println(&quot;afterReturning.........&quot;); &#125; &#x2F;&#x2F;最终通知 @After(value &#x3D; &quot;execution(\com.atguigu.spring5.aopanno.User.add(..))&quot;) public void after() &#123; System.out.println(&quot;after.........&quot;); &#125; &#x2F;&#x2F;异常通知* @AfterThrowing(value &#x3D; &quot;execution(\com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterThrowing() &#123; System.out.println(&quot;afterThrowing.........&quot;); &#125; &#x2F;&#x2F;环绕通知 @Around(value &#x3D; **&quot;execution(\* com.atguigu.spring5.aopanno.User.add(..))&quot;**) public void** around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前.........&quot;); &#x2F;&#x2F;被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后.........&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure><p>5、相同的切入点抽取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;相同切入点抽取@Pointcut(value &#x3D; &quot;execution(\ com.atguigu.spring5.aopanno.User.add(..))&quot;)public void pointdemo() &#123;&#125;&#x2F;&#x2F;前置通知&#x2F;&#x2F;@Before 注解表示作为前置通知@Before(value &#x3D; &quot;pointdemo()&quot;)public void** before() &#123; System.out.println(&quot;before.........&quot;);&#125;</span><br></pre></td></tr></table></figure><p>6、有多个增强类多同一个方法进行增强，设置增强类优先级</p><p>（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Component@Aspect@Order(1)public class PersonProxy</span><br></pre></td></tr></table></figure><p><strong>7、完全使用注解开发</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1）创建配置类，不需要创建 xml 配置文件@Configuration@ComponentScan(basePackages &#x3D; &#123;&quot;com.atguigu&quot;&#125;)@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true)public class ConfigAop &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>4.基于xml方式</strong></p><p>基于配置文件 ，了解即可</p><h2 id="五、JdbcTemplate"><a href="#五、JdbcTemplate" class="headerlink" title="五、JdbcTemplate"></a>五、JdbcTemplate</h2><p>Spring对JDBC进行封装，使用JdbcTemplate方便对数据库的操作。</p><h3 id="1-引用方法"><a href="#1-引用方法" class="headerlink" title="1.引用方法"></a>1.引用方法</h3><p>（1）增删改操作：</p><p>int update(String sql, Object… args);</p><p>（2）查询：返回某个值（例如）</p><p>T queryForObject(String sql,Class<T> requiredType);</p><p>（3）查询：返回某个对象</p><p>T queryForObject(String sql,RowMapper<T> rowMapper,Object … args);</p><p>//三个参数：</p><ul><li><p>第一个参数：sql 语句</p></li><li><p>第二个参数：RowMapper 是一个接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装</p></li><li><p>第三个参数：sql 语句值</p></li></ul><p>（4）查询：返回集合</p><p>List<T> query(String sql,RowMapper<T> rowMapper,Object… args);</p><p>（5）批量增删改：</p><p>int[] batchUpdate(String sql,List&lt;Object[]&gt; batchArgs);//传入多条数据即list集合</p><ul><li><p>第一个参数：sql 语句</p></li><li><p>第二个参数：List 集合，添加多条记录数据</p></li></ul><h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h3><p>引入相关jar包</p><p>所需jar包</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211013181633819.png" alt="image-20211013181633819" style="zoom:80%;" /><p>配置数据库连接池； </p><p>&lt;context:component-scan base-package=”com.oymn”&gt;</context:component-scan></p><!--配置数据库连接池 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;book&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;000000&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>配置JdbcTemplate对象，注入DateSourse  // 使用set方法注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建JdbcTemplate对象--&gt;&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;!--注入数据库连接池--&gt;    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>创建Service类和Dao类，在Dao类中注入JdbcTemplate对象</p><pre><code>public interface BookDao &#123;public void add(Book book);  //添加public void update(Book book);  //修改public void delete(int id);  //删除public int queryCount();   //查询数量public Book queryBookById(int id);  //查询public List&lt;Book&gt; queryBooks();   //查询所有public void batchAddBook(List&lt;Object[]&gt; books);  //批量添加public void batchUpdateBook(List&lt;Object[]&gt; books);  //批量修改public void batchDeleteBook(List&lt;Object[]&gt; args);  //批量删除@Repositorypublic class BookDaoImpl implements BookDao &#123;@Autowiredprivate JdbcTemplate jdbcTemplate;//在BookDaoImpl中定义各种数据库操作方法@Override            //添加操作 public void add(Book book) &#123;    String sql = &quot;insert into t_book set name=?,price=?&quot;;    Object[] args = &#123;book.getBookName(),book.getBookPrice()&#125;;    int update = jdbcTemplate.update(sql, args);    System.out.println(update);&#125;@Override                //更改操作public void update(Book book) &#123;    String sql = &quot;update t_book set name=?,price=? where id=?&quot;;    Object[] args = &#123;book.getBookName(),book.getBookPrice(),book.getBookId()&#125;;    int update = jdbcTemplate.update(sql, args);    System.out.println(update);&#125;@Override            //删除操作public void delete(int id) &#123;    String sql = &quot;delete from t_book where id=?&quot;;    int update = jdbcTemplate.update(sql, id);    System.out.println(update);&#125;@Override            //查询表中的记录条数public int queryCount() &#123;    String sql = &quot;select count(*) from t_book&quot;;    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);    return count;&#125;@Override            //查询返回对象public Book queryBookById(int id) &#123;    String sql = &quot;select id bookId,name bookName,price bookPrice from t_book where id=?&quot;;        Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class), id);    //    return book;&#125;@Override            //查询返回集合public List&lt;Book&gt; queryBooks() &#123;    String sql = &quot;select id bookId,name bookName,price bookPrice from t_book&quot;;    List&lt;Book&gt; bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class));    return bookList;&#125;//批量增删改@Overridepublic void batchAddBook(List&lt;Object[]&gt; books) &#123;    String sql = &quot;insert into t_book set id=?,name=?,price=?&quot;;    int[] ints = jdbcTemplate.batchUpdate(sql, books);    System.out.println(Arryliet.toString(ints));&#125;@Overridepublic void batchUpdateBook(List&lt;Object[]&gt; books) &#123;    String sql = &quot;update t_book set name=?,price=? where id=?&quot;;    int[] ints = jdbcTemplate.batchUpdate(sql, books);    System.out.println(Arryliet.toString(ints));&#125;@Overridepublic void batchDeleteBook(List&lt;Object[]&gt; args) &#123;    String sql = &quot;delete from t_book where id=?&quot;;    int[] ints = jdbcTemplate.batchUpdate(sql, args);    System.out.println(Arryliet.toString(ints));&#125;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Servicepublic class BookService &#123;   &#x2F;&#x2F;在service类中注入BookDao 类型属性，使用注解的方法   @Autowired    private BookDao bookDao &#x3D; new BookDaoImpl();      通多调用bookDAO的方法 定义相关增删改查函数，后续进行测试   &#x2F;&#x2F;添加    public void add(Book book)&#123;        bookDao.add(book);    &#125;    &#x2F;&#x2F;修改    public void update(Book book)&#123;        bookDao.update(book);    &#125;    &#x2F;&#x2F;删除    public void delete(Integer id)&#123;        bookDao.delete(id);    &#125;    &#x2F;&#x2F;查询数量    public int queryCount()&#123;        return bookDao.queryCount();    &#125;    &#x2F;&#x2F;查询图书    public Book queryBookById(Integer id)&#123;        return bookDao.queryBookById(id);    &#125;    &#x2F;&#x2F;查询所有图书    public List&lt;Book&gt; queryBooks()&#123;        return bookDao.queryBooks();    &#125;    &#x2F;&#x2F;批量添加图书    public void batchAddBook(List&lt;Object[]&gt; books)&#123;        bookDao.batchAddBook(books);    &#125;    &#x2F;&#x2F;批量修改图书    public void batchUpdateBook(List&lt;Object[]&gt; books)&#123;        bookDao.batchUpdateBook(books);    &#125;    &#x2F;&#x2F;批量删除图书    public void batchDeleteBook(List&lt;Object[]&gt; args)&#123;        bookDao.batchDeleteBook(args);    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="六、事务管理"><a href="#六、事务管理" class="headerlink" title="六、事务管理"></a>六、事务管理</h2><ul><li><p>事务是数据库操作最基本单位，逻辑上的一组操作，要么都成功，要么都失败。</p><p>典型场景：转账</p></li><li><p>事务四个特性ACID：原子性，一致性，隔离性，持久性。</p></li><li><p>Spring事务管理有两种方式：</p><ul><li>编程式事务管理 </li><li>声明式事务管理         //一般使用声明式事务管理，底层使用AOP原理。</li></ul></li></ul><p><strong>引入</strong>：代码在执行中出现异常，异常之前代码执行完毕，代码之后未被执行，如何处理？</p><p>​    使用事务进行解决：</p><ul><li>开启事务</li><li>进行事务操作</li><li>没有发生异常，提交事务</li><li>发生异常，回滚事务</li></ul><h3 id="1-声明事务管理"><a href="#1-声明事务管理" class="headerlink" title="1.声明事务管理"></a>1.声明事务管理</h3><p>声明式事务管理有两种方式：</p><ul><li><p>基于xml配置方式 </p></li><li><p>基于注解方式          //     一般使用注解方式。</p></li></ul><p><strong>Spring事务管理API:</strong></p><p>Spring事务管理提供了一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。</p><p>对于使用JdbcTemplate进行数据库交互，则使用DataSourceTransactionManager实现类，如果整合Hibernate框架则使用HibernateTransactionManager实现类，具体情况具体使用。</p><p><strong>范例</strong></p><p>下面重点演示 以注解方式实现声明式事务管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 数据库连接池 --&gt;&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;      destroy-method&#x3D;&quot;close&quot;&gt;    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;book&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;000000&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--创建JdbcTemplate对象--&gt;&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;!--注入数据库连接池--&gt;    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!--创建事务管理器--&gt;&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&#x2F;&#x2F;配置数据源​    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--开启事务注解--&gt;&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&gt;&lt;&#x2F;tx:annotation-driven&gt;&lt;!--在service类上面或者service类的方法上面添加事务注解@Transactional--&gt;&#x2F;&#x2F;如果把@Transactional添加在类上面，这个类里面所有方法都添加事务。&#x2F;&#x2F;如果只是添加在方法上面，则只为这个方法添加事务。&#x2F;&#x2F;我们一般在整个类前面添加@Service@Transactionalpublic class UserService &#123;&#125; </span><br></pre></td></tr></table></figure><p> //</p><h3 id="2-声明式事务管理的参数配置："><a href="#2-声明式事务管理的参数配置：" class="headerlink" title="2.声明式事务管理的参数配置："></a>2.声明式事务管理的参数配置：</h3><p>在 service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p><ul><li><p>propagation：事务传播行为</p><p><strong>即：多事务方法直接进行调用，这个过程中事务 是如何进行管理的</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20211030205951405.png" alt="image-20211030205951405"></p><p>记住前两个</p></li><li><p>isolation：事务隔离级别</p><p>解决事务隔离性，并发操作时发生的问题，防止多事务操作产生的互相影响</p><p>可能有三个读问题：脏读，不可重复读，虚读（幻读）。</p><p>设置隔离级别，解决读问题：</p><p>​                                                                脏读            不可重复读            虚读<br>READ UNCOMMITED（读未提交）    有                        有                        有<br>READ COMMITED（读已提交）        无                         有                        有<br>REPEATABLE READ（可重复读）        无                        无                        有<br>SERIALIZABLE（串行化）                        无                    无                         </p></li><li><p>timeout：超时时间</p><p>事务需要在一定时间内进行提交，超过时间后回滚。<br>默认值是-1，设置时间以秒为单位。</p></li><li><p>readOnly：是否只读<br>默认值为false，表示可以查询，也可以增删改。<br>设置为true，只能查询。</p></li><li><p>rollbackFor：回滚，设置出现哪些异常进行事务回滚。</p></li><li><p>noRollbackFor：不回滚，设置出现哪些异常不进行事务回滚。</p><p>下面是类之前@Transactional注释得相关参数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Service@Transactional(propagation &#x3D; Propagation.REQUIRED,isolation &#x3D; Isolation.READ_COMMITTED)public class AccountService &#123;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-完全注解实现声明式事务管理："><a href="#3-完全注解实现声明式事务管理：" class="headerlink" title="3.完全注解实现声明式事务管理："></a>3.完全注解实现声明式事务管理：</h3><p>创建配置类：（代替xml文件）</p><pre><code>@Configuration  //配置类@ComponentScan(basePackages = &quot;com.oymn.spring5&quot;)  //开启组件扫描@EnableTransactionManagement  //开启事务public class Config &#123;//创建数据库连接池@Beanpublic DruidDataSource getDruidDataSource()&#123;    DruidDataSource druidDataSource = new DruidDataSource();    druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);    druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/book&quot;);    druidDataSource.setUsername(&quot;root&quot;);    druidDataSource.setPassword(&quot;000000&quot;);    return druidDataSource;&#125;//创建JdbcTemplate对象@Beanpublic JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123;    //到ioc容器中根据类型注入  找到datesourse    JdbcTemplate jdbcTemplate = new JdbcTemplate();    //注入datesource对象    jdbcTemplate.setDataSource(dataSource);    return jdbcTemplate;&#125;//创建事务管理器@Beanpublic DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123;    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();    transactionManager.setDataSource(dataSource);    return transactionManager;&#125;&#125;</code></pre><p>@Service<br>public class AccountService {</p><pre><code>@Autowiredprivate AccountDao accountDao;@Transactionalpublic void accountMoney()&#123;    accountDao.add();    //int i=1/0;   //用来模拟转账失败    accountDao.reduce();&#125;</code></pre><h3 id="4-xml实现声明式事务管理："><a href="#4-xml实现声明式事务管理：" class="headerlink" title="4. xml实现声明式事务管理："></a>4. xml实现声明式事务管理：</h3><p>大致流程：</p><ul><li>大致创建事务管理器</li><li>配置事务通知</li><li>配置切入点和切面：事务加到哪个类哪个方法上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.oymn&quot;&gt;&lt;&#x2F;context:component-scan&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;      destroy-method&#x3D;&quot;close&quot;&gt;    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;book&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;000000&quot; &#x2F;&gt;    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--创建JdbcTemplate对象--&gt;&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;!--注入数据库连接池--&gt;    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!--创建事务管理器--&gt;&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id&#x3D;&quot;txadvice&quot;&gt;    &lt;!--配置事务参数--&gt;    &lt;tx:attributes&gt;&#x2F;&#x2F;指定哪种规则的方法上添加事务        &lt;tx:method name&#x3D;&quot;accountMoney&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;        &#x2F;&#x2F;name&#x3D;&quot;accountMoney&quot;目标类的名字    &lt;&#x2F;tx:attributes&gt;&lt;&#x2F;tx:advice&gt;&lt;!--配置切入点和切面--&gt;&lt;aop:config&gt;    &lt;!--配置切入点--&gt;&#x2F;&#x2F;切入点表达式    &lt;aop:pointcut id&#x3D;&quot;pt&quot; expression&#x3D;&quot;execution(com.oymn.spring5.Service..(..))&quot;&#x2F;&gt;    &lt;!--配置切面--&gt;    &lt;aop:advisor advice-ref&#x3D;&quot;txadvice&quot; pointcut-ref&#x3D;&quot;pt&quot;&#x2F;&gt;&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure><h2 id="六、Spring5新特性"><a href="#六、Spring5新特性" class="headerlink" title="六、Spring5新特性"></a>六、Spring5新特性</h2><h4 id="自带了日志封装"><a href="#自带了日志封装" class="headerlink" title="自带了日志封装"></a>自带了日志封装</h4><p>Spring5移除了Log4jConfigListener，官方建议使用Log4j2<br>Spring5整合Log4j2：</p><p>第一步：引入jar包</p><p>第二步：创建log4j2.xml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;&lt;configuration status&#x3D;&quot;INFO&quot;&gt;    &lt;!--先定义所有的appender--&gt;    &lt;appenders&gt;        &lt;!--输出日志信息到控制台--&gt;        &lt;console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;            &lt;!--控制日志输出的格式--&gt;            &lt;PatternLayout pattern&#x3D;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;&#x2F;&gt;        &lt;&#x2F;console&gt;    &lt;&#x2F;appenders&gt;    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;    &lt;loggers&gt;        &lt;root level&#x3D;&quot;info&quot;&gt;            &lt;appender-ref ref&#x3D;&quot;Console&quot;&#x2F;&gt;        &lt;&#x2F;root&gt;    &lt;&#x2F;loggers&gt;&lt;&#x2F;configuration&gt; </span><br></pre></td></tr></table></figure><h4 id="Nullable注解"><a href="#Nullable注解" class="headerlink" title="@Nullable注解"></a>@Nullable注解</h4><p>@Nullable注解可以用在方法上，属性上，参数上，表示方法返回值可以为空，属性可以为空，参数可以为空。</p><p>@Nullable     //表示方法返回值可以为空<br>public int getId();</p><p>@Nullable     //表示参数可以为空<br>public void setId(@Nullable int Id);</p><p>@Nullable     //表示属性可以为空<br>public int id;</p><h4 id="支持函数式风格编程"><a href="#支持函数式风格编程" class="headerlink" title="支持函数式风格编程"></a>支持函数式风格编程</h4><p>这是因为java8新增了lamda表达式</p><p>@Test<br>public void test() {<br>    //1 创建 GenericApplicationContext 对象<br>    GenericApplicationContext context = new GenericApplicationContext();<br>    //2 调用 context 的方法对象注册<br>    context.refresh();<br>    context.registerBean(“user1”,User.class,() -&gt; new User());<br>    //3 获取在 spring 注册的对象<br>    // User user = (User)context.getBean(“com.atguigu.spring5.test.User”);<br>    User user = (User)context.getBean(“user1”);<br>    System.out.println(user);<br>}</p><h4 id="支持整合JUnit5"><a href="#支持整合JUnit5" class="headerlink" title="支持整合JUnit5"></a>支持整合JUnit5</h4><p>（1）整合JUnit4：</p><p>第一步：引入jar包</p><p>第二步：创建测试类，使用注解方式完成</p><p>@RunWith(SpringJUnit4ClassRunner.class) //单元测试框架<br>@ContextConfiguration(“classpath:bean4.xml”) //加载配置文件<br>public class JUnitTest {</p><pre><code>@Autowiredpublic User user;@Testpublic void test()&#123;    System.out.println(user);&#125;</code></pre><p>}</p><p>bean4.xml：</p><p>&lt;context:component-scan base-package=”com.oymn”&gt;</context:component-scan><br>1<br>通过使用@ContextConfiguration注解，测试方法中就不用每次都通过context来获取对象了，比较方便。</p><p>ApplicationContext context = new ClassPathXmlApplicationContext(“bean2.xml”);<br>BookService bookService = context.getBean(“bookService”,BookService.class);</p><p>（2）整合JUnit5：</p><h4 id="Webflux"><a href="#Webflux" class="headerlink" title="Webflux"></a>Webflux</h4>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="http://example.com/2021/10/11/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/10/11/%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-11T13:39:04.000Z</published>
    <updated>2021-10-13T12:47:58.866Z</updated>
    
    <content type="html"><![CDATA[<p>爱对方水电费</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;爱对方水电费&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux 文件权限和目录配置</title>
    <link href="http://example.com/2021/10/03/linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2021/10/03/linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</id>
    <published>2021-10-03T01:33:25.000Z</published>
    <updated>2021-10-28T13:14:35.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux-文件权限和目录配置"><a href="#linux-文件权限和目录配置" class="headerlink" title="linux 文件权限和目录配置"></a>linux 文件权限和目录配置</h2><p>涉及命令：</p><ul><li>切换用户：su -用户名      exit退出</li><li>显示文件的所有属性权限：ls - al</li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li><p>Linux的每个文件中,可可分别给予使用者，群组，与其他人三种方式的rwx的权限。</p></li><li><p>root，一般用户的用户相关信息记录在/etc/passwd;个人密码记录在 /etc/shadow/;组名记录在 /etc/group</p></li><li><p>访问文件需要相关的权限，</p></li><li><p>群组最有用的功能之一，就是当你的团队开发资源的时候，每个账户都可以有多个群组支持。</p></li><li><p>利用ls -l显示的文件属性中，第一个字段是文件的权限，共有十位，</p><p>第一位是文件类型，：d:目录，-:文件,I:连接档，b：接口设备。c:串行端口设备。</p><p>接下来三个为一组，分为使用者，群组，其他人权限，权限有rwx三种，：可读 可写 可执行</p></li></ul><p><strong>linux文件权限重要性：</strong> </p><ul><li>系统保护</li><li>文件开发、数据共享</li><li>权限设置避免安全问题</li></ul><p>修改文件属性和群组</p><p><strong>更改文件的群组支持chgrp</strong></p><p>要被改变的组名必须要在/etc/group 文件内存在才 行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] dirname&#x2F;filename</span><br><span class="line">注：[-R] 是递归修改，更改文件目录下的所有文件或者目录的权限</span><br></pre></td></tr></table></figure><p><strong>修改文件的拥有者为chown</strong>，更改一个文件的拥有者与群组，使用什么指令。chown chgrp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将目录中所有文件或目录更改文件拥有者</span><br><span class="line">chown [-R] 帐号名称 文件或目录</span><br><span class="line">chown [-R] 帐号名称：用户组名称 文件或目录</span><br></pre></td></tr></table></figure><p><strong>修改文件的权限用chmod</strong></p><ul><li><p>chmod修改权限的方式：</p><ul><li><p>符号法：u 、g、o、分别代表 user、group、others三种身份</p><p>​        +、-、=分别代表加入、移除、设置三种操作</p><p>例如：增加某个文件的让所有人可写入的权限 ：chmod a+w  文件名</p></li><li><p>数字法：rwx分数 分别为421；各种身份的权限数字进行累加</p><p>例如：当一个文件的修改权限为 -rwx-xr–指令：chmod 754  文件名  或者chmod u=rwx，g=rx，o=r 文件名 </p></li></ul></li></ul><h3 id="权限的意义"><a href="#权限的意义" class="headerlink" title="权限的意义"></a>权限的意义</h3><p>权限对于目录和文件的作用略有不同，下面我们分开概述：</p><ul><li><p>文件</p><ul><li>r，可读此文件的实际内容，如读取文本文件的文字内容等。</li><li>w，可以编辑，新增或者修改该文件的内容（不能删除）</li><li>x，该文件具有可以被系统执行的权利。</li></ul></li><li><p>目录：</p><ul><li>r：read contents in directory    可以查询文件名数据</li><li>w：modify contents directory  可以对文件进行改动，包括 移动、新建、删除、重命名等。</li><li>x：accessdirectory    能够进入该目录作为当前工作目录</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>要开放目录给任何人浏览，应该至少也要给予r及x的权限，但w的权限不可随便给。</li><li>能否读取到某个文件内容，跟该文件所在的目录权限有关系，目录至少需要x的权限</li></ul><h3 id="linux文件种类："><a href="#linux文件种类：" class="headerlink" title="linux文件种类："></a>linux文件种类：</h3><p>常规文件：包括文本文件、二进制文件、数据文件  第一个字符为 -</p><p>目录   director</p><p>链接文件   类似windows的快捷方式</p><p>设备与设备文件 device  包括 区块blocks和字符文件character </p><p>数据接口文件  sockets</p><p>数据接送文件   FIFO pipe</p><ul><li><p>Linux档名的限制，单一文件或目录最大容许的文件名为255个英文字符或者128 个汉字字符。</p></li><li><p>linux一个文件能否执行和文件扩展名没有关系，文件扩展名是用来便于用户是别文件功能，能否执行与 文件权限中的  权限的是个属性有关</p></li><li><p>文件能否执行成功最终要看件的内容</p></li></ul><h3 id="linux目录配置："><a href="#linux目录配置：" class="headerlink" title="linux目录配置："></a>linux目录配置：</h3><ul><li><p>绝对路径文件名为从根目录/开始写起，否则都为相对路径。</p></li><li><p>.  表示当前目录          ..  表示上级目录</p></li></ul><p>常见目录功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;：根目录 ，最重要的目录</span><br><span class="line">&#x2F;etc&#x2F;:几乎系统所有的配置文件案都在这里，尤其是passwd和shaow</span><br><span class="line">&#x2F;boot&#x2F;:开机配置文件。也是预设摆放核心vmlinuz的地方。</span><br><span class="line">&#x2F;usr&#x2F;bin,&#x2F;bin:一般执行档摆放的地方。</span><br><span class="line">&#x2F;var&#x2F;log:摆放系统注册表文件的地方法</span><br><span class="line">&#x2F;dev:摆放所有系统装置文件的目录</span><br><span class="line">&#x2F;use&#x2F;sbin,&#x2F;sbin：系统管理员常用的指令集</span><br><span class="line">&#x2F;run:将经常变动的项目移动到内存暂存</span><br></pre></td></tr></table></figure><p>根目录：</p><p><img src="https://www.hualigs.cn/image/615904e2ddc91.jpg"></p><p><img src="https://www.hualigs.cn/image/615904e3495de.jpg"></p><p>/usr</p><p><img src="https://www.hualigs.cn/image/615904e341b8c.jpg"></p><p>/var</p><p> <img src="https://www.hualigs.cn/image/615904e33db17.jpg"></p><ul><li>文档名有【.】开头表示为隐藏文档，需要使用ls-a这个-a选项才可以显示出隐藏文档的内容，而使用ls -al才能显示出属性。</li></ul>]]></content>
    
    
    <summary type="html">some of my essay</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>summery-of -advanced-SQL</title>
    <link href="http://example.com/2021/10/02/summery-of-advanced-SQL/"/>
    <id>http://example.com/2021/10/02/summery-of-advanced-SQL/</id>
    <published>2021-10-02T02:27:50.000Z</published>
    <updated>2021-10-23T05:00:11.949Z</updated>
    
    <content type="html"><![CDATA[<p>一、概述</p><p>主要涉及：</p><p>索引优化分析<br>查询截取分析<br>MySQL锁机制<br>主从复制</p><p>02_MySQL简介<br>概述</p><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。</p><p>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>MySQL是开源的，所以你不需要支付额外的费用。</p><p>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。MySQL使用标准的SQL数据语言形式。</p><p>MySQL可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Per、PHP、Eifel、Ruby和Tcl等。Mysql对PHP有很好的支持，PHP是目前最流行的Web开发语言。</p><p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。</p><p>高级MySQL</p><p>MySQL内核</p><p>SQL优化攻城狮</p><p>MySQL服务器的优化</p><p>各种参数常量设定</p><p>查询语句优化</p><p>主从复制</p><p>软硬件升级</p><p>容灾备份</p><p>SQL编程</p><p>完整的MySQL优化需要很深的功底，大公司甚至有专门的DBA写上述。</p><p>03_RPM安装<br>MySQL Linux版（CentOS）</p><p>官网下载地址</p><p>检查当前系统是否安装过MySQL</p><p>查询命令：rpm -qa|grep -i mysql<br>删除命令：rpm -e RPM软件包名(该名字是上一个命令查出来的名字)<br>没装过：</p><p>已装过</p><p>安装MySQL服务端（注意提示）</p><p>安装命令：rpm -ivh RPM软件包名</p><p>安装MySQL客户端</p><p>安装命令：rpm -ivh RPM软件包名</p><p>查看MySQL安装时创建的MySQL用户和MySQL组</p><p>cat /etc/passwd |grep mysql<br>cat /etc/group |grep mysql</p><p>或者可以执行mysqladmin –version命令。</p><p>或者ps -ef | grep mysql</p><p>MySQL服务启动与暂停</p><p>service mysql start<br>service mysql stop<br>ps -ef | grep mysql查看<br>04_ROOT密码设置和开机自启动<br>mysql服务启动后，开始连接。</p><p>首次连接成功</p><p>输入命令mysql<br>退出命令exit</p><p>注意这里，因为MySQL默认没有密码，所以这里我们没有输入密码就直接连上了。</p><p>按照安装Server中的提示修改登录密码</p><p>/usr/bin/mysqladmin -u root password 123456</p><p>自启动mysql服务</p><p>05_安装位置<br>在Linux下查看安装目录ps -ef | grep mysql。</p><p>路径    解释    备注<br>/var/lib/mysql    mysql数据库文件的存放路径    如/var/lib/mysql/atguigu.cloud.pid<br>/usr/share/mysql    配置文件目录    mysql.server命令及配置文件<br>/usr/bin    相关命令目录    mysqladmin mysqldump等命令<br>/etc/init.d/mysql    启停相关脚本<br>06_修改字符集<br>修改配置文件</p><p>cp /usr/share/mysql/my-huge.cnf /etc/my.cnf</p><p>为什么mysql会自己读取/etc/my.cnf？</p><p>打开mysql.server你就会发现conf=/etc/my.cnf居然是写死的。</p><p>link</p><p>修改字符集和数据存储路径</p><p>插入中文，未能正确显示：</p><p>查看字符集</p><p>show variables like ‘character%”;<br>show variables like ‘%char%”;</p><p>默认的是客户端和服务器都用了latin1，所以会乱码。</p><p>修改</p><p>vim /etc/my.cnf</p><p>红色字为修改项</p><p>重启数据库</p><p>service mysql start<br>service mysql stop<br>重新连接后重新create databse并使用新建库，然后再重新建表试试</p><p>07_MySQL配置文件<br>主要配置文件</p><p>二进制日志log-bin</p><p>用于主从复制<br>错误日志log-error</p><p>默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等。<br>查询日志log</p><p>默认关闭，记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源<br>数据文件</p><p>两系统</p><p>windows<br>输入mysql后select @@database;<br>linux<br>默认路径：/var/lib/mysql<br>frm文件（form）</p><p>存放表结构<br>myd文件（my data）</p><p>存放表数据<br>myi文件（my index）</p><p>存放表索引<br>如何配置</p><p>Windows - my.ini文件<br>Linux - /etc/my.cnf文件<br>08_MySQL逻辑架构简介<br>总体概览</p><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，</p><p>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p>1.连接层</p><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcplip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2.服务层</p><p>第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3.引擎层</p><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同这样我们可以根据自己的实际需要进行选取，后面介绍MyISAM和InnoDB。</p><p>4.存储层<br>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p><p>09_存储引擎简介<br>查看命令：</p><p>查看mysql以提供什么存储引擎<br>show engines;<br>mysql&gt; show engines;<br>+——————–+———+—————————————————————-+————–+——+————+<br>| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |<br>+——————–+———+—————————————————————-+————–+——+————+<br>| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |<br>| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |<br>| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |<br>| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |<br>| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |<br>| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |<br>| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |<br>| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |<br>| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |<br>+——————–+———+—————————————————————-+————–+——+————+<br>9 rows in set (0.01 sec)</p><p>mysql&gt;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>查看mysql当前默认的存储引擎<br>show variables like ‘%storage_engine%’;<br>mysql&gt; show variables like ‘%storage_engine%’;<br>+———————————-+——–+<br>| Variable_name                    | Value  |<br>+———————————-+——–+<br>| default_storage_engine           | InnoDB |<br>| default_tmp_storage_engine       | InnoDB |<br>| disabled_storage_engines         |        |<br>| internal_tmp_disk_storage_engine | InnoDB |<br>+———————————-+——–+<br>4 rows in set, 1 warning (0.01 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>MyISAM和InnoDB</p><p>对比项    MyISAM    InnoDB<br>主外键    不支持    支持<br>事务    不支持    支持<br>行表锁    表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作    行锁，操作时只锁某一行，不对其他行有影响，适合高并发的操作<br>缓存    只缓存索引，不缓存真实数据    不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响<br>表空间    小    大<br>关注点    性能    事务<br>默认安装    是    是<br>阿里巴巴、淘宝用哪个？</p><p>Percona为MySQL数据库服务器进行了改进，在功能和性能上较MySQL有着很显著的提升。该版本提升了在高负载情况下的InnoDB的性能、为DBA提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</p><p>该公司新建了一款存储引擎叫xtradb完全可以替代innodb,并且在性能和并发上做得更好，</p><p>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</p><p>AliSql+AliRedis</p><p>二、索引优化分析<br>10_SQL性能下降原因<br>1.查询语句写的烂</p><p>2.索引失效</p><p>单值<br>select * from user where name=’’;<br>create index idx_user_name on user(name);<br>1<br>2<br>复合<br>select * from user where name=’’ and email=’’;<br>create index idx_user_name on user(name, email);<br>1<br>2<br>3.关联查询太多join（设计缺陷或不得已的需求）</p><p>4.服务器调优及各个参数设置（缓冲、线程数等）</p><p>11_SQL执行加载顺序<br>手写</p><p>SELECT DISTINCT<br>    <select_list><br>FROM<br>    <left_table> <join_type><br>JOIN<br>    <right_table><br>ON<br>    <join_condition><br>WHERE<br>    <where_condition><br>GROUP BY<br>    <group_by_list><br>HAVING<br>    <having_condition><br>ORDER BY<br>    <order_by_condition><br>LIMIT<br>    <limit_number><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>机读</p><p>1 FROM <left_table><br>2 ON <join_condition><br>3 <join_type> JOIN <right_table><br>4 WHERE <where_condition><br>5 GROUP BY <group_by_list><br>6 HAVING <having_condition><br>7 SELECT<br>8 DISTINCT <select_list><br>9 ORDER BY <order_by_condition><br>10 LIMIT <limit_number><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>总结</p><p>12_七种JOIN理论</p><p>13_七种JOIN的SQL编写<br>准备工作，创建以下表，插入新数据：</p><p>CREATE TABLE tbl_dept(<br>    id INT(11) NOT NULL AUTO_INCREMENT,<br>    deptName VARCHAR(30) DEFAULT NULL,<br>    locAdd VARCHAR(40) DEFAULT NULL,<br>    PRIMARY KEY(id)<br>)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</p><p>CREATE TABLE tbl_emp (<br>    id INT(11) NOT NULL AUTO_INCREMENT,<br>    NAME VARCHAR(20) DEFAULT NULL,<br>    deptId INT(11) DEFAULT NULL,<br>    PRIMARY KEY (id),<br>    KEY fk_dept_Id (deptId)<br>    #CONSTRAINT ‘fk_dept_Id’ foreign key (‘deptId’) references ‘tbl_dept’(‘Id’)<br>)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</p><p>INSERT INTO tbl_dept(deptName,locAdd) VALUES(‘RD’,11);<br>INSERT INTO tbl_dept(deptName,locAdd) VALUES(‘HR’,12);<br>INSERT INTO tbl_dept(deptName,locAdd) VALUES(‘MK’,13);<br>INSERT INTO tbl_dept(deptName,locAdd) VALUES(‘MIS’,14);<br>INSERT INTO tbl_dept(deptName,locAdd) VALUES(‘FD’,15);</p><p>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘z3’,1);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘z4’,1);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘z5’,1);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘w5’,2);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘w6’,2);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘s7’,3);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘s8’,4);<br>INSERT INTO tbl_emp(NAME,deptId) VALUES(‘s9’,51);</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>执行后的结果：</p><p>mysql&gt; select * from tbl_dept;<br>+—-+———-+——–+<br>| id | deptName | locAdd |<br>+—-+———-+——–+<br>|  1 | RD       | 11     |<br>|  2 | HR       | 12     |<br>|  3 | MK       | 13     |<br>|  4 | MIS      | 14     |<br>|  5 | FD       | 15     |<br>+—-+———-+——–+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select * from tbl_emp;<br>+—-+——+——–+<br>| id | NAME | deptId |<br>+—-+——+——–+<br>|  1 | z3   |      1 |<br>|  2 | z4   |      1 |<br>|  3 | z5   |      1 |<br>|  4 | w5   |      2 |<br>|  5 | w6   |      2 |<br>|  6 | s7   |      3 |<br>|  7 | s8   |      4 |<br>|  8 | s9   |     51 |<br>+—-+——+——–+<br>8 rows in set (0.00 sec)</p><p>mysql&gt;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>1.inner join</p><p>mysql&gt; select * from tbl_emp a inner join tbl_dept b on a.deptId = b.id;<br>+—-+——+——–+—-+———-+——–+<br>| id | NAME | deptId | id | deptName | locAdd |<br>+—-+——+——–+—-+———-+——–+<br>|  1 | z3   |      1 |  1 | RD       | 11     |<br>|  2 | z4   |      1 |  1 | RD       | 11     |<br>|  3 | z5   |      1 |  1 | RD       | 11     |<br>|  4 | w5   |      2 |  2 | HR       | 12     |<br>|  5 | w6   |      2 |  2 | HR       | 12     |<br>|  6 | s7   |      3 |  3 | MK       | 13     |<br>|  7 | s8   |      4 |  4 | MIS      | 14     |<br>+—-+——+——–+—-+———-+——–+<br>7 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>2.left join</p><p>mysql&gt; select * from tbl_emp a left join tbl_dept b on a.deptId = b.id;<br>+—-+——+——–+——+———-+——–+<br>| id | NAME | deptId | id   | deptName | locAdd |<br>+—-+——+——–+——+———-+——–+<br>|  1 | z3   |      1 |    1 | RD       | 11     |<br>|  2 | z4   |      1 |    1 | RD       | 11     |<br>|  3 | z5   |      1 |    1 | RD       | 11     |<br>|  4 | w5   |      2 |    2 | HR       | 12     |<br>|  5 | w6   |      2 |    2 | HR       | 12     |<br>|  6 | s7   |      3 |    3 | MK       | 13     |<br>|  7 | s8   |      4 |    4 | MIS      | 14     |<br>|  8 | s9   |     51 | NULL | NULL     | NULL   |<br>+—-+——+——–+——+———-+——–+<br>8 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>3.right join</p><p>mysql&gt; select * from tbl_emp a right join tbl_dept b on a.deptId = b.id;<br>+——+——+——–+—-+———-+——–+<br>| id   | NAME | deptId | id | deptName | locAdd |<br>+——+——+——–+—-+———-+——–+<br>|    1 | z3   |      1 |  1 | RD       | 11     |<br>|    2 | z4   |      1 |  1 | RD       | 11     |<br>|    3 | z5   |      1 |  1 | RD       | 11     |<br>|    4 | w5   |      2 |  2 | HR       | 12     |<br>|    5 | w6   |      2 |  2 | HR       | 12     |<br>|    6 | s7   |      3 |  3 | MK       | 13     |<br>|    7 | s8   |      4 |  4 | MIS      | 14     |<br>| NULL | NULL |   NULL |  5 | FD       | 15     |<br>+——+——+——–+—-+———-+——–+<br>8 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>4.left join 2</p><p>mysql&gt; select * from tbl_emp a left join tbl_dept b on a.deptId = b.id where b.id is null;<br>+—-+——+——–+——+———-+——–+<br>| id | NAME | deptId | id   | deptName | locAdd |<br>+—-+——+——–+——+———-+——–+<br>|  8 | s9   |     51 | NULL | NULL     | NULL   |<br>+—-+——+——–+——+———-+——–+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>5.right join 2</p><p>mysql&gt; select * from tbl_emp a right join tbl_dept b on a.deptId = b.id where a.deptid is null;<br>+——+——+——–+—-+———-+——–+<br>| id   | NAME | deptId | id | deptName | locAdd |<br>+——+——+——–+—-+———-+——–+<br>| NULL | NULL |   NULL |  5 | FD       | 15     |<br>+——+——+——–+—-+———-+——–+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>6.full join</p><p>MySQL不支持full join，不过可以换种方法表示</p><p>mysql&gt; select * from tbl_emp a left join tbl_dept b on a.deptId = b.id<br>    -&gt; union<br>    -&gt; select * from tbl_emp a right join tbl_dept b on a.deptId = b.id;<br>+——+——+——–+——+———-+——–+<br>| id   | NAME | deptId | id   | deptName | locAdd |<br>+——+——+——–+——+———-+——–+<br>|    1 | z3   |      1 |    1 | RD       | 11     |<br>|    2 | z4   |      1 |    1 | RD       | 11     |<br>|    3 | z5   |      1 |    1 | RD       | 11     |<br>|    4 | w5   |      2 |    2 | HR       | 12     |<br>|    5 | w6   |      2 |    2 | HR       | 12     |<br>|    6 | s7   |      3 |    3 | MK       | 13     |<br>|    7 | s8   |      4 |    4 | MIS      | 14     |<br>|    8 | s9   |     51 | NULL | NULL     | NULL   |<br>| NULL | NULL |   NULL |    5 | FD       | 15     |<br>+——+——+——–+——+———-+——–+<br>9 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>7.full join 2</p><p>mysql&gt; select * from tbl_emp a left join tbl_dept b on a.deptId = b.id where b.id is null union select * from tbl_emp a right join tbl_dept b on a.deptId = b.id where a.deptId is null;<br>+——+——+——–+——+———-+——–+<br>| id   | NAME | deptId | id   | deptName | locAdd |<br>+——+——+——–+——+———-+——–+<br>|    8 | s9   |     51 | NULL | NULL     | NULL   |<br>| NULL | NULL |   NULL |    5 | FD       | 15     |<br>+——+——+——–+——+———-+——–+<br>2 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>14_索引是什么<br>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。</p><p>索引的目的在于提高查询效率，可以类比字典。</p><p>如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p><p>如果没有索引，那么你可能需要逐个逐个寻找，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？</p><p>是不是觉得如果没有索引，这个事情根本无法完成？</p><p>你可以简单理解为“排好序的快速查找数据结构”。</p><p>详解</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。</p><p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p><p>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p><p>我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p><p>15_索引优劣势<br>优势</p><p>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本。</p><p>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</p><p>劣势</p><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的（占空间）</p><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。（）</p><p>索引只是提高效率的一个因素，如果你的MysQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询。</p><p>总结</p><p>索引，空间换取时间。</p><p>16_索引分类和建索引命令语句<br>MySQL索引分类：</p><p>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。<br>唯一索引：索引列的值必须唯一，但允许有空值。<br>复合索引：即一个索引包含多个列。<br>基本语法：<br>创建<br>CREATE [UNIQUE] INDEX indexName ON mytable(columnName(length));<br>ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnName(length));<br>删除<br>DROP INDEX [indexName] ON mytable;<br>查看<br>SHOW INDEX FROM tableName;<br>使用alter命令 - 有四种方式来添加数据表的索引<br>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);：该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。<br>ALTER TABLE tbl name ADD UNIQUE index_name (column_list);：这条语句创建索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)。<br>ALTER TABLE tbl_name ADD INDEX index_name (column_list);：添加普通索引，索引值可出现多次。<br>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);：该语句指定了索引为FULLTEXT，用于全文索引。<br>17_索引结构与检索原理<br>MySQL索引结构</p><p>BTree索引<br>Hash索引<br>full-text全文索引<br>R-Tree索引<br>BTree索引检索原理</p><p>初始化介绍</p><p>一颗b+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示),如磁盘块1包含数据项17和35，包含指针P1、P2、P3,<br>P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p><p>真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。</p><p>非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><p>查找过程</p><p>如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO。在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</p><p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><p>18_哪些情况适合建索引<br>主键自动建立唯一索引<br>频繁作为查询条件的字段应该创建索引<br>查询中与其它表关联的字段，外键关系建立索引<br>频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录还会更新索引<br>Where条件里用不到的字段不创建索引<br>单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)<br>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度<br>查询中统计或者分组字段<br>19_哪些情况不适合建索引<br>表记录太少<br>经常增删改的表<br>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。<br>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率天约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p><p>索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</p><p>20_性能分析前提知识<br>MySQL Query Optimizer</p><p>Mysql中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的,这部分最耗费时间）</p><p>当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query 中的 Hint信息(如果有），看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint 或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p><p>MySQL常见瓶颈</p><p>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候<br>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候<br>服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态<br>21_explain使用简介<br>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>官网地址</p><p>能干嘛</p><p>表的读取顺序<br>数据读取操作的操作类型<br>哪些索引可以使用<br>哪些索引被实际使用<br>表之间的引用<br>每张表有多少行被优化器查询<br>怎么玩</p><p>explain + sql语句<br>执行计划包含的信息<br>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |<br>mysql&gt; select * from tbl_dept;<br>+—-+———-+——–+<br>| id | deptName | locAdd |<br>+—-+———-+——–+<br>|  1 | RD       | 11     |<br>|  2 | HR       | 12     |<br>|  3 | MK       | 13     |<br>|  4 | MIS      | 14     |<br>|  5 | FD       | 15     |<br>+—-+———-+——–+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; explain select * from tbl_dept;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+——-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+——-+<br>|  1 | SIMPLE      | tbl_dept | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | NULL  |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>22_explain之id介绍<br>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>三种情况：</p><p>id相同，执行顺序由上至下</p><p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p>id相同不同，同时存在</p><p>id相同，执行顺序由上至下</p><p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p>id相同不同，同时存在</p><p>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行，衍生=DERIVED</p><p>小结</p><p>id越大越先查询</p><p>23_explain之select_type和table介绍<br>select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><p>select_type有哪些？</p><p>SIMPLE - 简单的select查询,查询中不包含子查询或者UNION。<br>PRIMARY - 查询中若包含任何复杂的子部分，最外层查询则被标记为。<br>SUBQUERY - 在SELECT或WHERE列表中包含了子查询。<br>DERIUED - 在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。<br>UNION - 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中外层SELECT将被标记为：DERIVED。<br>UNION RESULT - 从UNION表获取结果的SELECT。<br>table：显示这一行的数据是关于哪张表的。</p><p>24_explain之type介绍<br>访问类型排列</p><p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt;ALL</p><p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p>详细说明</p><p>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。</p><p>const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</p><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。选择本地图片</p><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</p><p>range：只检索给定范围的行,使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p><p>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。</p><p>all：Full Table Scan，将遍历全表以找到匹配的行。</p><p>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p>25_explain之possible_keys和key介绍<br>possible_keys</p><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段火若存在索引，则该索引将被列出，但不一定被查询实际使用。</p><p>key</p><p>实际使用的索引。如果为NULL，则没有使用索引</p><p>查询中若使用了覆盖索引，则该索引仅出现在key列表中</p><p>26_explain之key_len介绍<br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p><p>27_explain之ref介绍<br>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><p>由key_len可知t1表的idx_col1_col2被充分使用，col1匹配t2表的col1，col2匹配了一个常量，即 ‘ac’。</p><p>查询中与其它表关联的字段，外键关系建立索引。</p><p>28_explain之rows介绍<br>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。</p><p>29_explain之Extra介绍<br>包含不适合在其他列中显示但十分重要的额外信息。</p><p>Using filesort</p><p>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为”文件排序”</p><p>Using temporary</p><p>使了用临时表保存中间结果，MysQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</p><p>Using index</p><p>表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！</p><p>如果同时出现using where，表明索引被用来执行索引键值的查找；</p><p>如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p><p>如果同时出现using where，表明索引被用来执行索引键值的查找；</p><p>如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p><p>覆盖索引（Covering Index）,一说为索引覆盖。</p><p>理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。</p><p>理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。</p><p>注意：</p><p>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select*，因为</p><p>如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p><p>What is a Covering Index？</p><p>A covering index is an index that contains all of, and possibly more, the columns you need for your query.</p><p>For instance, this:</p><p>SELECT *<br>FROM tablename<br>WHERE criteria<br>1<br>2<br>3<br>will typically use indexes to speed up the resolution of which rows to retrieve using criteria, but then it will go to the full table to retrieve the rows.</p><p>However, if the index contained the columns column1, column2 and column3, then this sql:</p><p>SELECT column1, column2<br>FROM tablename<br>WHERE criteria<br>1<br>2<br>3<br>and, provided that particular index could be used to speed up the resolution of which rows to retrieve, the index already contains the values of the columns you’re interested in, so it won’t have to go to the table to retrieve the rows, but can produce the results directly from the index.</p><p>This can also be used if you see that a typical query uses 1-2 columns to resolve which rows, and then typically adds another 1-2 columns, it could be beneficial to append those extra columns (if they’re the same all over) to the index, so that the query processor can get everything from the index itself.</p><p>link</p><p>Using where</p><p>表明使用了where过滤。</p><p>Using join buffer</p><p>使用了连接缓存。</p><p>impossible where</p><p>where子句的值总是false，不能用来获取任何元组。</p><p>select tables optimized away</p><p>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p><p>distinct</p><p>优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p><p>30_explain之热身Case</p><p>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name… 】</p><p>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,namefrom t1 where other_column=’’】</p><p>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</p><p>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</p><p>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</p><p>31_索引单表优化案例<br>建表SQL</p><p>CREATE TABLE IF NOT EXISTS article(<br>    id INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,<br>    author_id INT(10) UNSIGNED NOT NULL,<br>    category_id INT(10) UNSIGNED NOT NULL,<br>    views INT(10) UNSIGNED NOT NULL,<br>    comments INT(10) UNSIGNED NOT NULL,<br>    title VARCHAR(255) NOT NULL,<br>    content TEXT NOT NULL<br>);</p><p>INSERT INTO article(author_id,category_id,views,comments,title,content)<br>VALUES<br>(1,1,1,1,’1’,’1’),<br>(2,2,2,2,’2’,’2’),<br>(1,1,3,3,’3’,’3’);</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>mysql&gt; select * from article;<br>+—-+———–+————-+——-+———-+——-+———+<br>| id | author_id | category_id | views | comments | title | content |<br>+—-+———–+————-+——-+———-+——-+———+<br>|  1 |         1 |           1 |     1 |        1 | 1     | 1       |<br>|  2 |         2 |           2 |     2 |        2 | 2     | 2       |<br>|  3 |         1 |           1 |     3 |        3 | 3     | 3       |<br>+—-+———–+————-+——-+———-+——-+———+<br>3 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>案例</p><p>查询category_id为1且comments 大于1的情况下，views最多的article_id。</p><p>mysql&gt; SELECT id, author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;<br>+—-+———–+<br>| id | author_id |<br>+—-+———–+<br>|  3 |         1 |<br>+—-+———–+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; show index from article;<br>+———+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+———+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| article |          0 | PRIMARY  |            1 | id          | A         |           3 |     NULL | NULL   |      | BTREE      |         |               |<br>+———+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; explain SELECT id, author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;<br>+—-+————-+———+————+——+—————+——+———+——+——+———-+—————————–+<br>| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                       |<br>+—-+————-+———+————+——+—————+——+———+——+——+———-+—————————–+<br>|  1 | SIMPLE      | article | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using filesort |<br>+—-+————-+———+————+——+—————+——+———+——+——+———-+—————————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>结论：很显然，type是ALL，即最坏的情况。Extra里还出现了Using filesort，也是最坏的情况。优化是必须的。</p><p>开始优化</p><p>新建索引+删除索引</p><p>mysql&gt; create index idx_article_ccv on article(category_id,comments,views);<br>Query OK, 0 rows affected (0.03 sec)<br>Records: 0  Duplicates: 0  Warnings: 0</p><p>mysql&gt; show index from article;<br>+———+————+—————–+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table   | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+———+————+—————–+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| article |          0 | PRIMARY         |            1 | id          | A         |           3 |     NULL | NULL   |      | BTREE      |         |               |<br>| article |          1 | idx_article_ccv |            1 | category_id | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |<br>| article |          1 | idx_article_ccv |            2 | comments    | A         |           3 |     NULL | NULL   |      | BTREE      |         |               |<br>| article |          1 | idx_article_ccv |            3 | views       | A         |           3 |     NULL | NULL   |      | BTREE      |         |               |<br>+———+————+—————–+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>4 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>或者用下面sql创建索引：</p><p>ALTER TABLE ‘article’ ADD INDEX idx_article_ccv ( ‘category_id , ‘comments’, ‘views’ );<br>1<br>创建后的效果</p><p>mysql&gt; explain SELECT id, author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;<br>+—-+————-+———+————+——-+—————–+—————–+———+——+——+———-+—————————————+<br>| id | select_type | table   | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                                 |<br>+—-+————-+———+————+——-+—————–+—————–+———+——+——+———-+—————————————+<br>|  1 | SIMPLE      | article | NULL       | range | idx_article_ccv | idx_article_ccv | 8       | NULL |    1 |   100.00 | Using index condition; Using filesort |<br>+—-+————-+———+————+——-+—————–+—————–+———+——+——+———-+—————————————+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>Extra里还是出现了Using filesort，创建这索引作用不大。</p><p>如果comments &gt; 1换成comments = 1，可以让Using filesort消失，但不符题目要求。</p><p>mysql&gt; explain SELECT id, author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;<br>+—-+————-+———+————+——+—————–+—————–+———+————-+——+———-+————-+<br>| id | select_type | table   | partitions | type | possible_keys   | key             | key_len | ref         | rows | filtered | Extra       |<br>+—-+————-+———+————+——+—————–+—————–+———+————-+——+———-+————-+<br>|  1 | SIMPLE      | article | NULL       | ref  | idx_article_ccv | idx_article_ccv | 8       | const,const |    1 |   100.00 | Using where |<br>+—-+————-+———+————+——+—————–+—————–+———+————-+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>既然创建这索引作用不大，删了它吧。</p><p>mysql&gt; DROP INDEX idx_article_ccv ON article;<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>缘由</p><p>type变成了range，这是可以忍受的。但是extra里使用Using filesort仍是无法接受的。</p><p>但是我们已经建立了索引，为啥没用呢？</p><p>这是因为按照BTree索引的工作原理，先排序category_id，如果遇到相同的category_id则再排序comments,如果遇到相同的comments 则再排序views。</p><p>当comments字段在联合索引里处于中间位置时，因comments &gt; 1条件是一个范围值(所谓range)，MySQL无法利用索引再对后面的views部分进行检索，即range类型查询字段后面的索引无效。</p><p>改进</p><p>跟上次创建索引相比，这次不为comments字段创建索引。</p><p>mysql&gt; create index idx_article_cv on article(category_id, views);<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>再次explain</p><p>mysql&gt; explain SELECT id, author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;<br>+—-+————-+———+————+——+—————-+—————-+———+——-+——+———-+————-+<br>| id | select_type | table   | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra       |<br>+—-+————-+———+————+——+—————-+—————-+———+——-+——+———-+————-+<br>|  1 | SIMPLE      | article | NULL       | ref  | idx_article_cv | idx_article_cv | 4       | const |    2 |    33.33 | Using where |<br>+—-+————-+———+————+——+—————-+—————-+———+——-+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>可以看到，type变为了ref，Extra中的Using filesort也消失了，结果非常理想。</p><p>32_索引两表优化案例<br>新建SQL</p><p>CREATE TABLE IF NOT EXISTS class(<br>    id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>    card INT(10) UNSIGNED NOT NULL,<br>    PRIMARY KEY(id)<br>);</p><p>CREATE TABLE IF NOT EXISTS book(<br>    bookid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>    card INT(10) UNSIGNED NOT NULL,<br>    PRIMARY KEY(bookid)<br>);</p><p>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</p><p>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>创建后的结果：</p><p>mysql&gt; select * from class;<br>+—-+——+<br>| id | card |<br>+—-+——+<br>|  1 |   17 |<br>|  2 |    2 |<br>|  3 |   18 |<br>|  4 |    4 |<br>|  5 |    4 |<br>|  6 |    8 |<br>|  7 |    9 |<br>|  8 |    1 |<br>|  9 |   18 |<br>| 10 |    6 |<br>| 11 |   15 |<br>| 12 |   15 |<br>| 13 |   12 |<br>| 14 |   15 |<br>| 15 |   18 |<br>| 16 |    2 |<br>| 17 |   18 |<br>| 18 |    5 |<br>| 19 |    7 |<br>| 20 |    1 |<br>| 21 |    2 |<br>+—-+——+<br>21 rows in set (0.00 sec)</p><p>mysql&gt; select * from book;<br>+——–+——+<br>| bookid | card |<br>+——–+——+<br>|      1 |    8 |<br>|      2 |   14 |<br>|      3 |    3 |<br>|      4 |   16 |<br>|      5 |    8 |<br>|      6 |   12 |<br>|      7 |   17 |<br>|      8 |    8 |<br>|      9 |   10 |<br>|     10 |    3 |<br>|     11 |    4 |<br>|     12 |   12 |<br>|     13 |    9 |<br>|     14 |    7 |<br>|     15 |    6 |<br>|     16 |    8 |<br>|     17 |    3 |<br>|     18 |   11 |<br>|     19 |    5 |<br>|     20 |   11 |<br>+——–+——+<br>20 rows in set (0.00 sec)</p><p>mysql&gt;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>开始explain分析</p><p>mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+—————————————————-+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+—————————————————-+<br>|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   21 |   100.00 | NULL                                               |<br>|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+—————————————————-+<br>2 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>type都是all，需要优化。</p><p>为book.card创建索引</p><p>mysql&gt; ALTER TABLE <code>book</code> ADD INDEX Y(<code>card</code>);<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>再次explain分析</p><p>mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br>+—-+————-+——-+————+——+—————+——+———+—————+——+———-+————-+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref           | rows | filtered | Extra       |<br>+—-+————-+——-+————+——+—————+——+———+—————+——+———-+————-+<br>|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL | NULL    | NULL          |   21 |   100.00 | NULL        |<br>|  1 | SIMPLE      | book  | NULL       | ref  | Y             | Y    | 4       | my.class.card |    1 |   100.00 | Using index |<br>+—-+————-+——-+————+——+—————+——+———+—————+——+———-+————-+<br>2 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>可以看到第二行的type变为了ref，rows也变少了，优化比较明显。这是由左连接特性决定的。LEFT JOIN条件用于确定如何从右表搜索行，左边一定都有，所以右边是我们的关键点，一定需要在右表建立索引。</p><p>删除为book.card创建索引</p><p>mysql&gt; drop index y on book;<br>Query OK, 0 rows affected (0.02 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>为class.card创建索引</p><p>mysql&gt; ALTER TABLE <code>class</code> ADD INDEX Y(<code>card</code>);<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>再次explain分析</p><p>mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br>+—-+————-+——-+————+——-+—————+——+———+——+——+———-+—————————————————-+<br>| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |<br>+—-+————-+——-+————+——-+—————+——+———+——+——+———-+—————————————————-+<br>|  1 | SIMPLE      | class | NULL       | index | NULL          | Y    | 4       | NULL |   21 |   100.00 | Using index                                        |<br>|  1 | SIMPLE      | book  | NULL       | ALL   | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |<br>+—-+————-+——-+————+——-+—————+——+———+——+——+———-+—————————————————-+<br>2 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>可见右边是我们的关键点，要想优化需要在右表建立索引。</p><p>然后我们换用右连接RIGHT JOIN查询</p><p>mysql&gt; EXPLAIN SELECT * FROM class right JOIN book ON class.card = book.card;<br>+—-+————-+——-+————+——+—————+——+———+————–+——+———-+————-+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref          | rows | filtered | Extra       |<br>+—-+————-+——-+————+——+—————+——+———+————–+——+———-+————-+<br>|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL         |   20 |   100.00 | NULL        |<br>|  1 | SIMPLE      | class | NULL       | ref  | Y             | Y    | 4       | my.book.card |    1 |   100.00 | Using index |<br>+—-+————-+——-+————+——+—————+——+———+————–+——+———-+————-+<br>2 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>换成左边是我们的关键点，要想优化需要在左表建立索引。</p><p>小结</p><p>索引两表优化，左连接右表建索引，右连接左表建索引。</p><p>33_索引三表优化案例<br>新建SQL</p><p>CREATE TABLE IF NOT EXISTS phone(<br>    phoneid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>    card INT(10) UNSIGNED NOT NULL,<br>    PRIMARY KEY(phoneid)<br>)ENGINE=INNODB;</p><p>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>建后效果</p><p>mysql&gt; select * from phone;<br>+———+——+<br>| phoneid | card |<br>+———+——+<br>|       1 |   10 |<br>|       2 |   13 |<br>|       3 |   17 |<br>|       4 |    5 |<br>|       5 |   12 |<br>|       6 |    7 |<br>|       7 |   15 |<br>|       8 |   17 |<br>|       9 |   17 |<br>|      10 |   14 |<br>|      11 |   19 |<br>|      12 |   13 |<br>|      13 |    5 |<br>|      14 |    8 |<br>|      15 |    2 |<br>|      16 |    8 |<br>|      17 |   11 |<br>|      18 |   14 |<br>|      19 |   13 |<br>|      20 |    5 |<br>+———+——+<br>20 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>复用到上一节book，class两表，移除它们原有的索引。</p><p>mysql&gt; show index from class;<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| class |          0 | PRIMARY  |            1 | id          | A         |          21 |     NULL | NULL   |      | BTREE      |         |               |<br>| class |          1 | Y        |            1 | card        | A         |          12 |     NULL | NULL   |      | BTREE      |         |               |<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>2 rows in set (0.01 sec)</p><p>mysql&gt; drop index y on class;<br>Query OK, 0 rows affected (0.02 sec)<br>Records: 0  Duplicates: 0  Warnings: 0</p><p>mysql&gt; show index from book;<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| book  |          0 | PRIMARY  |            1 | bookid      | A         |          20 |     NULL | NULL   |      | BTREE      |         |               |<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>1 row in set (0.01 sec)</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>为phone.card和book.card创建新的索引。</p><p>mysql&gt; alter table <code>phone</code> add index z(<code>card</code>);<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0</p><p>mysql&gt; alter table <code>book</code> add index y(<code>card</code>);<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>explain三表连接</p><p>mysql&gt; explain SELECT * FROM class LEFT JOIN book ON class.card = book.card LEFT JOIN phone ON book.card = phone.card;<br>+—-+————-+——-+————+——+—————+——+———+—————+——+———-+————-+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref           | rows | filtered | Extra       |<br>+—-+————-+——-+————+——+—————+——+———+—————+——+———-+————-+<br>|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL | NULL    | NULL          |   21 |   100.00 | NULL        |<br>|  1 | SIMPLE      | book  | NULL       | ref  | y             | y    | 4       | my.class.card |    1 |   100.00 | Using index |<br>|  1 | SIMPLE      | phone | NULL       | ref  | z             | z    | 4       | my.book.card  |    1 |   100.00 | Using index |<br>+—-+————-+——-+————+——+—————+——+———+—————+——+———-+————-+<br>3 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>后2行的 type 都是ref且总 rows优化很好，效果不错。因此索引最好设置在需要经常查询的字段中。</p><p>结论</p><p>Join语句的优化</p><p>尽可能减少Join语句中的NestedLoop的循环总次数：“永远用小结果集驱动大的结果集”。</p><p>优先优化NestedLoop的内层循环，保证Join语句中被驱动表上Join条件字段已经被索引。</p><p>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置。</p><p>34_索引失效1-跳过复合索引中间列<br>索引失效（应该避免）</p><p>最佳左前缀法则 - 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过复合索引中间列。<br>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。<br>存储引擎不能使用索引中范围条件右边的列。<br>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *。<br>mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描。<br>is null, is not null 也无法使用索引。<br>like以通配符开头（’%abc…’），mysql索引失效会变成全表扫描的操作。<br>字符串不加单引号索引失效。<br>少用or，用它来连接时会索引失效。<br>全值匹配我最爱</p><p>新建SQL</p><p>CREATE TABLE staffs(<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    <code>name</code> VARCHAR(24) NOT NULL DEFAULT’’ COMMENT’姓名’,<br>    <code>age</code> INT NOT NULL DEFAULT 0 COMMENT’年龄’,<br>    <code>pos</code> VARCHAR(20) NOT NULL DEFAULT’’ COMMENT’职位’,<br>    <code>add_time</code> TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT’入职时间’<br>)CHARSET utf8 COMMENT’员工记录表’;</p><p>INSERT INTO staffs(<code>name</code>,<code>age</code>,<code>pos</code>,<code>add_time</code>) VALUES(‘z3’,22,’manager’,NOW());<br>INSERT INTO staffs(<code>name</code>,<code>age</code>,<code>pos</code>,<code>add_time</code>) VALUES(‘July’,23,’dev’,NOW());<br>INSERT INTO staffs(<code>name</code>,<code>age</code>,<code>pos</code>,<code>add_time</code>) VALUES(‘2000’,23,’dev’,NOW());</p><p>ALTER TABLE staffs ADD INDEX index_staffs_nameAgePos(<code>name</code>,<code>age</code>,<code>pos</code>);</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND age=25;<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref         | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 78      | const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND age=25 AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref               | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 140     | const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>注意下面的explain</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE age=25 AND pos=’dev’;<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE pos=’dev’;<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>上面两个索引失效了</p><p>最佳左前缀法则 - 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+———————–+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |    33.33 | Using index condition |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>35_索引失效2-索引列上做额外操作<br>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE left(NAME,4)=’July’;<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using where |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>36_索引失效3-限定复合索引某列的范围<br>存储引擎不能使用索引中范围条件右边的列（我理解为限定复合索引某字段的范围会时索引失效，也就是&gt;，&lt;，between…and…谨慎用在复合索引某字段）。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND age=25;<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref         | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 78      | const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND age=25 AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref               | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 140     | const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND age&gt;25 AND pos=’dev’;<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys           | key                     | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | staffs | NULL       | range | index_staffs_nameAgePos | index_staffs_nameAgePos | 78      | NULL |    1 |    33.33 | Using index condition |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>由age=25变成age&gt;25后，type从ref变成range。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+———————–+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |    33.33 | Using index condition |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND pos=’dev’ and age &gt; 25;<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys           | key                     | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | staffs | NULL       | range | index_staffs_nameAgePos | index_staffs_nameAgePos | 78      | NULL |    1 |    33.33 | Using index condition |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>37_索引失效4-select *<br>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’ AND age=25 AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref               | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 140     | const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT name,age,pos FROM staffs WHERE NAME=’July’ AND age=25 AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref               | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 140     | const,const,const |    1 |   100.00 | Using index |<br>+—-+————-+——–+————+——+————————-+————————-+———+——————-+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>我们最好按需索取，少用select *</p><p>mysql&gt; EXPLAIN SELECT name,age,pos FROM staffs WHERE NAME=’July’ AND pos=’dev’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+————————–+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra                    |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+————————–+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |    33.33 | Using where; Using index |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT name,age,pos FROM staffs WHERE NAME=’July’ AND age&gt;25 AND pos=’dev’;<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+————————–+<br>| id | select_type | table  | partitions | type  | possible_keys           | key                     | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | staffs | NULL       | range | index_staffs_nameAgePos | index_staffs_nameAgePos | 78      | NULL |    1 |    33.33 | Using where; Using index |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT name FROM staffs WHERE NAME=’July’ AND age=25;<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref         | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 78      | const,const |    1 |   100.00 | Using index |<br>+—-+————-+——–+————+——+————————-+————————-+———+————-+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>38_索引失效5-!=或者&lt;&gt;<br>mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME!=’July’;<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | index_staffs_nameAgePos | NULL | NULL    | NULL |    3 |    66.67 | Using where |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME&lt;&gt;’July’;<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | index_staffs_nameAgePos | NULL | NULL    | NULL |    3 |    66.67 | Using where |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>39_索引失效6-is null或者is not null<br>is null, is not null 也无法使用索引</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME is null;<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——————+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——————+<br>|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——————+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME is not null;<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | index_staffs_nameAgePos | NULL | NULL    | NULL |    3 |    66.67 | Using where |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>Extra打印为Impossible WHERE，是因为我们在创建staffs表，设置name字段的属性为not null。</p><p>下面额外演示Extra为Impossible WHERE情况。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE 1=1;<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE 1!=1;<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——————+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——————+<br>|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——————+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>40_索引失效7-like以通配符%开头字符串<br>like以通配符%开头（’%abc…’），mysql索引失效会变成全表扫描的操作。</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME=’July’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME like ‘%July%’;<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME like ‘%July’;<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |<br>+—-+————-+——–+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM staffs WHERE NAME like ‘July%’;<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys           | key                     | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | staffs | NULL       | range | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | NULL |    1 |   100.00 | Using index condition |<br>+—-+————-+——–+————+——-+————————-+————————-+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>问题：解决like ‘%字符串%’时索引不被使用的方法？</p><p>新建SQL</p><p>CREATE TABLE <code>tbl_user</code>(<br>    <code>id</code> INT(11) NOT NULL AUTO_INCREMENT,<br>    <code>name</code> VARCHAR(20) DEFAULT NULL,<br>    <code>age</code>INT(11) DEFAULT NULL,<br>    <code>email</code> VARCHAR(20) DEFAULT NULL,<br>    PRIMARY KEY(<code>id</code>)<br>)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</p><p>INSERT INTO tbl_user(<code>name</code>,<code>age</code>,<code>email</code>)VALUES(‘1aa1’,21,‘a@163.com’);<br>INSERT INTO tbl_user(<code>name</code>,<code>age</code>,<code>email</code>)VALUES(‘2bb2’,23,‘b@163.com’);<br>INSERT INTO tbl_user(<code>name</code>,<code>age</code>,<code>email</code>)VALUES(‘3cc3’,24,‘c@163.com’);<br>INSERT INTO tbl_user(<code>name</code>,<code>age</code>,<code>email</code>)VALUES(‘4dd4’,26,‘d@163.com’);<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>mysql&gt; select * from tbl_user;<br>+—-+——+——+———–+<br>| id | name | age  | email     |<br>+—-+——+——+———–+<br>|  1 | 1aa1 |   21 | <a href="mailto:&#x61;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a> |<br>|  2 | 2bb2 |   23 | <a href="mailto:&#x62;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;">&#x62;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;</a> |<br>|  3 | 3cc3 |   24 | <a href="mailto:&#x63;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#x63;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;</a> |<br>|  4 | 4dd4 |   26 | <a href="mailto:&#x64;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x64;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a> |<br>+—-+——+——+———–+<br>4 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>创建索引前，先看看以下explain：</p><p>EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;</p><p>EXPLAIN SELECT id FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>EXPLAIN SELECT NAME FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>EXPLAIN SELECT age FROM tbl_user WHERE NAME LIKE ‘%aa%’;</p><p>EXPLAIN SELECT id,NAME FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>EXPLAIN SELECT id,NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;</p><p>EXPLAIN SELECT * FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>EXPLAIN SELECT id,NAME,age,email FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>mysql&gt; EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; EXPLAIN SELECT id FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT NAME FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>mysql&gt; EXPLAIN SELECT id,NAME FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT id,NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>mysql&gt; EXPLAIN SELECT * FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT id,NAME,age,email FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>没有创建索引，都全表查找。</p><p>现在创建索引</p><p>mysql&gt; CREATE INDEX idx_user_nameAge ON tbl_user(NAME,age);<br>Query OK, 0 rows affected (0.02 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>1<br>2<br>3<br>再执行上述一系列explain</p><p>mysql&gt; EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>看得出，用上索引（覆盖索引）</p><p>mysql&gt; EXPLAIN SELECT id FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT NAME FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>看得出，都用上索引（覆盖索引）</p><p>mysql&gt; EXPLAIN SELECT id,NAME FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT id,NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>| id | select_type | table    | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tbl_user | NULL       | index | NULL          | idx_user_nameAge | 68      | NULL |    4 |    25.00 | Using where; Using index |<br>+—-+————-+———-+————+——-+—————+——————+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>看得出，都用上索引（覆盖索引）</p><p>mysql&gt; EXPLAIN SELECT * FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT id,NAME,age,email FROM tbl_user WHERE NAME LIKE ‘%aa%’;<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | tbl_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |<br>+—-+————-+———-+————+——+—————+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>看得出，都没用上索引了，有email字段再，只能全表搜索。</p><p>覆盖索引（Covering Index）,一说为索引覆盖。</p><p>理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。</p><p>理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。</p><p>注意：</p><p>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select*，因为</p><p>如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p><p>小结</p><p>解决like ‘%字符串%’时索引不被使用的方法？复合索引，然后覆盖索引。</p><p>41_索引失效8-数目字符串不加单引号<br>数目字符串不加单引号索引失效。</p><p>mysql&gt; SELECT * FROM staffs WHERE NAME=2000;<br>+—-+——+—–+—–+———————+<br>| id | name | age | pos | add_time            |<br>+—-+——+—–+—–+———————+<br>|  3 | 2000 |  23 | dev | 2021-04-03 14:03:18 |<br>+—-+——+—–+—–+———————+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; SELECT * FROM staffs WHERE NAME=’2000’;<br>+—-+——+—–+—–+———————+<br>| id | name | age | pos | add_time            |<br>+—-+——+—–+—–+———————+<br>|  3 | 2000 |  23 | dev | 2021-04-03 14:03:18 |<br>+—-+——+—–+—–+———————+<br>1 row in set (0.00 sec)</p><p>mysql&gt; explain SELECT * FROM staffs WHERE NAME=2000;<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | index_staffs_nameAgePos | NULL | NULL    | NULL |    3 |    33.33 | Using where |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>1 row in set, 3 warnings (0.00 sec)</p><p>mysql&gt; explain SELECT * FROM staffs WHERE NAME=’2000’;<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys           | key                     | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | staffs | NULL       | ref  | index_staffs_nameAgePos | index_staffs_nameAgePos | 74      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+————————-+————————-+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>42_索引失效9-用关键字OR<br>少用or，用它来连接时会索引失效。</p><p>mysql&gt; explain SELECT * FROM staffs WHERE NAME=’July’ or name=’z3’;<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>| id | select_type | table  | partitions | type | possible_keys           | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | staffs | NULL       | ALL  | index_staffs_nameAgePos | NULL | NULL    | NULL |    3 |    66.67 | Using where |<br>+—-+————-+——–+————+——+————————-+——+———+——+——+———-+————-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; SELECT * FROM staffs WHERE NAME=’July’ or name=’z3’;<br>+—-+——+—–+———+———————+<br>| id | name | age | pos     | add_time            |<br>+—-+——+—–+———+———————+<br>|  1 | z3   |  22 | manager | 2021-04-03 14:03:18 |<br>|  2 | July |  23 | dev     | 2021-04-03 14:03:18 |<br>+—-+——+—–+———+———————+<br>2 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>43_索引失效10-小总结<br>小总结</p><p>假设index(a, b, c)</p><p>where语句    索引是否被使用<br>where a = 3    Y，使用到a<br>where a = 3 and b = 5    Y，使用到a，b<br>where a = 3 and b = 5 and c = 4    Y，使用到a，b，c<br>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4    N<br>where a = 3 and c = 5    使用到a，但是c不可以，b中间断了<br>where a = 3 and b &gt; 4 and c = 5    使用到a和b，c不能用在范围之后，b断了<br>where a = 3 and b like ‘kk%’ and c = 4    Y，使用到a，b，c<br>44_索引面试题分析<br>新建SQL</p><p>create table test03(<br>    id int primary key not null auto_increment,<br>    c1 char(10),<br>    c2 char(10),<br>    c3 char(10),<br>    c4 char(10),<br>    c5 char(10)<br>);</p><p>insert into test03(c1,c2,c3,c4,c5) values (‘a1’,’a2’,’a3’,’a4’,’a5’);<br>insert into test03(c1,c2,c3,c4,c5) values (‘b1’,’b2’,’b3’,’b4’,’b5’);<br>insert into test03(c1,c2,c3,c4,c5) values (‘c1’,’c2’,’c3’,’c4’,’c5’);<br>insert into test03(c1,c2,c3,c4,c5) values (‘d1’,’d2’,’d3’,’d4’,’d5’);<br>insert into test03(c1,c2,c3,c4,c5) values (‘e1’,’e2’,’e3’,’e4’,’e5’);</p><p>create index idx_test03_c1234 on test03(c1,c2,c3,c4);<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>mysql&gt; select * from test03;<br>+—-+——+——+——+——+——+<br>| id | c1   | c2   | c3   | c4   | c5   |<br>+—-+——+——+——+——+——+<br>|  1 | a1   | a2   | a3   | a4   | a5   |<br>|  2 | b1   | b2   | b3   | b4   | b5   |<br>|  3 | c1   | c2   | c3   | c4   | c5   |<br>|  4 | d1   | d2   | d3   | d4   | d5   |<br>|  5 | e1   | e2   | e3   | e4   | e5   |<br>+—-+——+——+——+——+——+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; show index from test03;<br>+——–+————+——————+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table  | Non_unique | Key_name         | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+——–+————+——————+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| test03 |          0 | PRIMARY          |            1 | id          | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |<br>| test03 |          1 | idx_test03_c1234 |            1 | c1          | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |<br>| test03 |          1 | idx_test03_c1234 |            2 | c2          | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |<br>| test03 |          1 | idx_test03_c1234 |            3 | c3          | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |<br>| test03 |          1 | idx_test03_c1234 |            4 | c4          | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |<br>+——–+————+——————+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>5 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>问题：我们创建了复合索引idx_test03_c1234 ，根据以下SQL分析下索引使用情况？</p><p>1<br>explain select * from test03 where c1=’a1’;<br>explain select * from test03 where c1=’a1’ and c2=’a2’;<br>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’;<br>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4=’a4’;<br>1<br>2<br>3<br>4<br>mysql&gt; explain select * from test03 where c1=’a1’;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+——-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’;<br>+—-+————-+——–+————+——+——————+——————+———+——————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref               | rows | filtered | Extra |<br>+—-+————-+——–+————+——+——————+——————+———+——————-+——+———-+——-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 123     | const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+——————+——————+———+——————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4=’a4’;<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref                     | rows | filtered | Extra |<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 164     | const,const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>都用上索引了。</p><p>2<br>换一下条件顺序</p><p>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4=’a4’;<br>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ and c3=’a3’;<br>1<br>2<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4=’a4’;<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref                     | rows | filtered | Extra |<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 164     | const,const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ and c3=’a3’;<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref                     | rows | filtered | Extra |<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 164     | const,const,const,const |    1 |   100.00 | NULL  |<br>+—-+————-+——–+————+——+——————+——————+———+————————-+——+———-+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>都用上索引了。</p><p>3<br>限定范围</p><p>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3&gt;’a3’ and c4=’a4’;<br>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4&gt;’a4’ and c3=’a3’;<br>1<br>2<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c3&gt;’a3’ and c4=’a4’;<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | range | idx_test03_c1234 | idx_test03_c1234 | 123     | NULL |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c4&gt;’a4’ and c3=’a3’;<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | range | idx_test03_c1234 | idx_test03_c1234 | 164     | NULL |    1 |   100.00 | Using index condition |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>4<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ order by c3;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>c3作用在排序而不是查找</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ order by c3;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |   100.00 | Using index condition |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>上面两个explain的相同。</p><p>order by c3换成order by c4</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ order by c4;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+—————————————+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra                                 |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+—————————————+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |   100.00 | Using index condition; Using filesort |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+—————————————+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>用到Using filesort。</p><p>5<br>mysql&gt; explain select * from test03 where c1=’a1’ and c5=’a5’ order by c2,c3;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+————————————+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                              |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+————————————+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition; Using where |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+————————————+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>只用c1一个字段索引，但是c2、c3用于排序，无filesort。</p><p>将order by c2,c3换成order by c3,c2。</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c5=’a5’ order by c3,c2;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+—————————————————-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                                              |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+—————————————————-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition; Using where; Using filesort |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+—————————————————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>出现了filesort，我们建的索引是1234，它没有按照顺序来，3，2颠倒了。</p><p>6<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ order by c2,c3;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |   100.00 | Using index condition |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c5=’a5’ order by c2,c3;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+————————————+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra                              |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+————————————+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |    20.00 | Using index condition; Using where |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+————————————+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>用c1、c2两个字段索引，但是c2、c3用于排序，无filesort</p><p>7<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2=’a2’ and c5=’a5’ order by c3,c2;<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+————————————+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref         | rows | filtered | Extra                              |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+————————————+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 82      | const,const |    1 |    20.00 | Using index condition; Using where |<br>+—-+————-+——–+————+——+——————+——————+———+————-+——+———-+————————————+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c5=’a5’ order by c3,c2;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+—————————————————-+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                                              |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+—————————————————-+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition; Using where; Using filesort |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+—————————————————-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>跳过c2，就用c3，就出翔Using filesort。</p><p>8<br>mysql&gt; explain select * from test03 where c1=’a1’ and c4=’a4’ group by c2,c3;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c4=’a4’ group by c3,c2;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+——————————————————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                                                  |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+——————————————————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition; Using temporary; Using filesort |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+——————————————————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>定值、范围还是排序，一般order by是给个范围</p><p>group by基本上都需要进行排序，会有临时表产生</p><p>一般性建议<br>对于单键索引，尽量选择针对当前query过滤性更好的索引。<br>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。<br>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引。<br>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。<br>45_索引优化答疑补充和总结口诀<br>继续上一章节</p><p>mysql&gt; explain select * from test03 where c1=’a1’ and c2 like ‘kk%’ and c3=’a3’;<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | range | idx_test03_c1234 | idx_test03_c1234 | 123     | NULL |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2 like ‘%kk’ and c3=’a3’;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2 like ‘%kk%’ and c3=’a3’;<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>| id | select_type | table  | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | ref  | idx_test03_c1234 | idx_test03_c1234 | 41      | const |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——+——————+——————+———+——-+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>mysql&gt; explain select * from test03 where c1=’a1’ and c2 like ‘k%kk%’ and c3=’a3’;<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>| id | select_type | table  | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                 |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>|  1 | SIMPLE      | test03 | NULL       | range | idx_test03_c1234 | idx_test03_c1234 | 123     | NULL |    1 |    20.00 | Using index condition |<br>+—-+————-+——–+————+——-+——————+——————+———+——+——+———-+———————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>小总结</p><p>假设index(a, b, c)</p><p>where语句    索引是否被使用<br>where a = 3 and b like ‘kk%’ and c = 4    Y，使用到a，b，c<br>where a = 3 and b like ‘%kk’ and c = 4    Y，使用到a<br>where a = 3 and b like ‘%kk%’ and c = 4    Y，使用到a<br>where a= 3 and b like ‘k%kk%’ and c = 4    Y，使用到a，b，c<br>优化总结口诀</p><p>全值匹配我最爱， 最左前缀要遵守；</p><p>带头大哥不能死， 中间兄弟不能断；</p><p>索引列上少计算， 范围之后全失效；</p><p>LIKE 百分写最右， 覆盖索引不写 *；</p><p>不等空值还有 OR， 索引影响要注意；</p><p>VAR 引号不可丢， SQL 优化有诀窍。</p><p>三、查询截取分析<br>46_小表驱动大表<br>通常SQL调优过程：</p><p>观察，至少跑1天，看看生产的慢SQL情况。<br>开启慢查询日志，设置阙值，比如超过5秒钟的就是慢SQL，并将它抓取出来。<br>explain + 慢SQL分析。<br>show profile。<br>运维经理 or DBA，进行SQL数据库服务器的参数调优。<br>总结：</p><p>慢查询的开启并捕获<br>explain + 慢SQL分析<br>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况<br>SQL数据库服务器的参数调优。<br>优化原则：小表驱动大表，即小的数据集驱动大的数据集。</p><p>RBO原理</p><p>select * from A where id in (select id from B)<br>等价于:<br>for select id from B<br>for select * from A where A.id = B.id<br>1<br>2<br>3<br>4<br>当B表的数据集必须小于A表的数据集时，用in优于exists。</p><p>select * from A where exists (select 1 from B where B.id = A.id)<br>等价于：<br>for select * from A<br>for select * from B where B.id = A.id<br>1<br>2<br>3<br>4<br>当A表的数据集系小于B表的数据集时，用exists优于in。</p><p>注意：A表与B表的ID字段应建立索引。</p><p>EXISTS关键字</p><p>SELECT …FROM table WHERE EXISTS (subquery)<br>1<br>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE）来决定主查询的数据结果是否得以保留。</p><p>提示</p><p>EXSTS(subquey)只返回TRUE或FALSE，因此子查询中的SELECT * 也可以是 SELECT 1 或select ‘X’，官方说法是实际执行时会忽略SELECT清单，因此没有区别。<br>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。<br>EXISTS子查询往往也可以用条件表达式，其他子查询或者JOIN来替代，何种最优需要具体问题具体分析<br>47_in和exists<br>示例表：</p><p>mysql&gt; select * from tbl_emp;<br>+—-+——+——–+<br>| id | NAME | deptId |<br>+—-+——+——–+<br>|  1 | z3   |      1 |<br>|  2 | z4   |      1 |<br>|  3 | z5   |      1 |<br>|  4 | w5   |      2 |<br>|  5 | w6   |      2 |<br>|  6 | s7   |      3 |<br>|  7 | s8   |      4 |<br>|  8 | s9   |     51 |<br>+—-+——+——–+<br>8 rows in set (0.02 sec)</p><p>mysql&gt; select * from tbl_dept;<br>+—-+———-+——–+<br>| id | deptName | locAdd |<br>+—-+———-+——–+<br>|  1 | RD       | 11     |<br>|  2 | HR       | 12     |<br>|  3 | MK       | 13     |<br>|  4 | MIS      | 14     |<br>|  5 | FD       | 15     |<br>+—-+———-+——–+<br>5 rows in set (0.01 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>in和exists用法</p><p>mysql&gt; select * from tbl_emp e where e.deptId in (select id from tbl_dept d);<br>+—-+——+——–+<br>| id | NAME | deptId |<br>+—-+——+——–+<br>|  1 | z3   |      1 |<br>|  2 | z4   |      1 |<br>|  3 | z5   |      1 |<br>|  4 | w5   |      2 |<br>|  5 | w6   |      2 |<br>|  6 | s7   |      3 |<br>|  7 | s8   |      4 |<br>+—-+——+——–+<br>7 rows in set (0.00 sec)</p><p>mysql&gt; select * from tbl_emp e where exists (select 1 from tbl_dept d where d.id = e.deptId);<br>+—-+——+——–+<br>| id | NAME | deptId |<br>+—-+——+——–+<br>|  1 | z3   |      1 |<br>|  2 | z4   |      1 |<br>|  3 | z5   |      1 |<br>|  4 | w5   |      2 |<br>|  5 | w6   |      2 |<br>|  6 | s7   |      3 |<br>|  7 | s8   |      4 |<br>+—-+——+——–+<br>7 rows in set (0.00 sec)</p><p>mysql&gt; select * from tbl_emp e where exists (select ‘X’ from tbl_dept d where d.id = e.deptId);<br>+—-+——+——–+<br>| id | NAME | deptId |<br>+—-+——+——–+<br>|  1 | z3   |      1 |<br>|  2 | z4   |      1 |<br>|  3 | z5   |      1 |<br>|  4 | w5   |      2 |<br>|  5 | w6   |      2 |<br>|  6 | s7   |      3 |<br>|  7 | s8   |      4 |<br>+—-+——+——–+<br>7 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>48_为排序使用索引OrderBy优化<br>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。</p><p>新建SQL</p><p>create table tblA(<br>    #id int primary key not null auto_increment,<br>    age int,<br>    birth timestamp not null<br>);</p><p>insert into tblA(age, birth) values(22, now());<br>insert into tblA(age, birth) values(23, now());<br>insert into tblA(age, birth) values(24, now());</p><p>create index idx_A_ageBirth on tblA(age, birth);</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>mysql&gt; select * from tblA;<br>+——+———————+<br>| age  | birth               |<br>+——+———————+<br>|   22 | 2021-04-04 19:31:45 |<br>|   23 | 2021-04-04 19:31:45 |<br>|   24 | 2021-04-04 19:31:45 |<br>+——+———————+<br>3 rows in set (0.00 sec)</p><p>mysql&gt; show index from tblA;<br>+——-+————+—————-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+——-+————+—————-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| tbla  |          1 | idx_A_ageBirth |            1 | age         | A         |           3 |     NULL | NULL   | YES  | BTREE      |         |               |<br>| tbla  |          1 | idx_A_ageBirth |            2 | birth       | A         |           3 |     NULL | NULL   |      | BTREE      |         |               |<br>+——-+————+—————-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>2 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>mysql&gt; EXPLAIN SELECT * FROM tblA where age &gt; 20 order by age;<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+————————–+<br>| id | select_type | table | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tblA  | NULL       | index | idx_A_ageBirth | idx_A_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM tblA where age&gt;20 order by age,birth;<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+————————–+<br>| id | select_type | table | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tblA  | NULL       | index | idx_A_ageBirth | idx_A_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM tblA where age&gt;20 order by birth;<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+——————————————+<br>| id | select_type | table | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                                    |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+——————————————+<br>|  1 | SIMPLE      | tblA  | NULL       | index | idx_A_ageBirth | idx_A_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index; Using filesort |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+——————————————+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM tblA where age&gt;20 order by birth,age;<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+——————————————+<br>| id | select_type | table | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                                    |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+——————————————+<br>|  1 | SIMPLE      | tblA  | NULL       | index | idx_A_ageBirth | idx_A_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index; Using filesort |<br>+—-+————-+——-+————+——-+—————-+—————-+———+——+——+———-+——————————————+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>mysql&gt; EXPLAIN SELECT * FROM tblA order by birth;<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+—————————–+<br>| id | select_type | table | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra                       |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+—————————–+<br>|  1 | SIMPLE      | tblA  | NULL       | index | NULL          | idx_A_ageBirth | 9       | NULL |    3 |   100.00 | Using index; Using filesort |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+—————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM tblA WHERE birth &gt; ‘2016-01-28 00:00:00’ order by birth;<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+——————————————+<br>| id | select_type | table | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra                                    |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+——————————————+<br>|  1 | SIMPLE      | tblA  | NULL       | index | NULL          | idx_A_ageBirth | 9       | NULL |    3 |    33.33 | Using where; Using index; Using filesort |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+——————————————+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM tblA WHERE birth &gt; ‘2016-01-28 00:00:00’ order by age;<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+————————–+<br>| id | select_type | table | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra                    |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+————————–+<br>|  1 | SIMPLE      | tblA  | NULL       | index | NULL          | idx_A_ageBirth | 9       | NULL |    3 |    33.33 | Using where; Using index |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+————————–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; EXPLAIN SELECT * FROM tblA order by age, birth desc;<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+—————————–+<br>| id | select_type | table | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra                       |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+—————————–+<br>|  1 | SIMPLE      | tblA  | NULL       | index | NULL          | idx_A_ageBirth | 9       | NULL |    3 |   100.00 | Using index; Using filesort |<br>+—-+————-+——-+————+——-+—————+—————-+———+——+——+———-+—————————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>MySQL支持二种方式的排序，FileSort和lIndex，Index效率高，它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p><p>ORDER BY满足两情况，会使用Index方式排序：</p><p>ORDER BY语句使用索引最左前列。<br>使用where子句与Order BY子句条件列组合满足索引最左前列。<br>如果不在索引列上，mysql的filesort有两种算法：</p><p>双路排序<br>单路排序<br>双路排序</p><p>MySQL4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和OrderBy列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读对应的数据输出。</p><p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p><p>取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p><p>单路排序</p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序压的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p><p>结论及引申出的问题</p><p>由于单路是后出的，总体而言好过双路</p><p>但是用单路有问题</p><p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取取<br>sort_buffer容量大小，再排……从而多次I/O。</p><p>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><p>优化策略</p><p>增大sort_buffer_size参数的设置<br>增大max_length_for_sort_data参数的设置<br>为什么设置sort_buffer_size、max_length_for_sort_data参数能优化排序？</p><p>提高Order By的速度</p><p>Order by时select * 是一个大忌只Query需要的字段，这点非常重要。在这里的影响是;<br>当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。<br>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer__size。<br>尝试提高sort_buffer_size，不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。<br>尝试提高max_length_for_sort_data，提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。<br>小结<br>为排序使用索引</p><p>MySql两种排序方式∶文件排序 或 扫描有序索引排序<br>MySql能为 排序 与 查询 使用相同的索引<br>创建复合索引 a_b_c (a, b, c)</p><p>order by能使用索引最左前缀</p><p>ORDER BY a<br>ORDER BY a, b<br>ORDER BY a, b, c<br>ORDER BY a DESC, b DESC, c DESC<br>如果WHERE使用素引的最左前缀定义为常量，则order by能使用索引</p><p>WHERE a = const ORDER BY b,c<br>WHERE a = const AND b = const ORDER BY c<br>WHERE a = const ORDER BY b, c<br>WHERE a = const AND b &gt; const ORDER BY b, c<br>不能使用索引进行排序</p><p>ORDER BY a ASC, b DESC, c DESC //排序不—致<br>WHERE g = const ORDER BY b, c //产丢失a索引<br>WHERE a = const ORDER BY c //产丢失b索引<br>WHERE a = const ORDER BY a, d //d不是素引的一部分<br>WHERE a in (…) ORDER BY b, c //对于排序来说,多个相等条件也是范围查询<br>49_GroupBy优化与慢查询日志<br>GroupBy优化</p><p>group by实质是先排序后进行分组，遵照索引建的最佳左前缀。<br>当无法使用索引列，增大max_length_for_sort_data参数的设置 + 增大sort_buffer_size参数的设置。<br>where高于having，能写在where限定的条件就不要去having限定了。<br>慢查询日志<br>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。<br>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。<br>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。<br>如何操作<br>默认情况下，MySQL数据库没有开启慢查询日速，需要我们手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><p>查看是否开启及如何开启</p><p>默认 - SHOW VARIABLES LIKE ‘%slow_query_log%’;<br>开启 - set global slow_query_log=1;，只对当前数据库生效，如果MySQL重启后则会失效。<br>mysql&gt; SHOW VARIABLES LIKE ‘%slow_query_log%’;<br>+———————+————————–+<br>| Variable_name       | Value                    |<br>+———————+————————–+<br>| slow_query_log      | OFF                      |<br>| slow_query_log_file | DESKTOP-LNJQ0VF-slow.log |<br>+———————+————————–+<br>2 rows in set, 1 warning (0.00 sec)</p><p>mysql&gt; set global slow_query_log=1;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; SHOW VARIABLES LIKE ‘%slow_query_log%’;<br>+———————+————————–+<br>| Variable_name       | Value                    |<br>+———————+————————–+<br>| slow_query_log      | ON                       |<br>| slow_query_log_file | DESKTOP-LNJQ0VF-slow.log |<br>+———————+————————–+<br>2 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>如果要永久生效，就必须修改配置文件my.cnf(其它系统变量也是如此)</p><p>修改my.cnf文件，[mysqld]下增加或修改参数slow_query_log和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件</p><p>slow_query_log =1<br>slow_query_log_file=/var/lib/mysqatguigu-slow.log<br>1<br>2<br>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log（如果没有指定参数slow_query_log_file的话）</p><p>开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？</p><p>这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，命令：SHOW VARIABLES LIKE ‘long_query_time%’;</p><p>mysql&gt; SHOW VARIABLES LIKE ‘long_query_time%’;<br>+—————–+———–+<br>| Variable_name   | Value     |<br>+—————–+———–+<br>| long_query_time | 10.000000 |<br>+—————–+———–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>可以使用命令修改，也可以在my.cnf参数里面修改。</p><p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。</p><p>设置慢SQL阈值时间：set global long_query_time=3;</p><p>mysql&gt; SHOW VARIABLES LIKE ‘long_query_time%’;<br>+—————–+———–+<br>| Variable_name   | Value     |<br>+—————–+———–+<br>| long_query_time | 10.000000 |<br>+—————–+———–+<br>1 row in set, 1 warning (0.00 sec)</p><p>mysql&gt; set global long_query_time=3;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; SHOW VARIABLES LIKE ‘long_query_time%’;<br>+—————–+———–+<br>| Variable_name   | Value     |<br>+—————–+———–+<br>| long_query_time | 10.000000 |<br>+—————–+———–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>为什么设置后看不出变化？</p><p>需要重新连接或新开一个会话才能看到修改值。</p><p>记录慢SQL并后续分析</p><p>假设我们成功设置慢SQL阈值时间为3秒（set global long_query_time=3;）。</p><p>模拟超时SQL：</p><p>mysql&gt; SELECT sleep(4);<br>+———-+<br>| sleep(4) |<br>+———-+<br>|        0 |<br>+———-+<br>1 row in set (4.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>日志记录：</p><p>查询当前系统中有多少条慢查询记录</p><p>mysql&gt; show global status like ‘%Slow_queries%’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| Slow_queries  | 1     |<br>+—————+——-+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>在配置文件中设置慢SQL阈值时间</p><p>#[mysqld]下配置:<br>slow_query_log=1;<br>slow_query_log_file=/var/lib/mysql/atguigu-slow.log<br>long_query_time=3;<br>log_output=FILE;<br>1<br>2<br>3<br>4<br>5<br>日志分析工具mysqldumpslow<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p><p>查看mysqldumpslow的帮助信息，mysqldumpslow –help。</p><p>s：是表示按照何种方式排序<br>c：访问次数<br>l：锁定时间<br>r：返回记录<br>t：查询时间<br>al：平均锁定时间<br>ar：平均返回记录数<br>at：平均查询时间<br>t：即为返回前面多少条的数据<br>g：后边搭配一个正则匹配模式，大小写不敏感的<br>工作常用参考</p><p>得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log<br>得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log<br>得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g “left join” /var/lib/mysql/atguigu-slow.log<br>另外建议在使用这些命令时结合│和more 使用，否则有可能出现爆屏情况<br>mysqldumpslow -s r-t 10 /ar/lib/mysql/atguigu-slow.log | more<br>50_批量插入数据脚本<br>创建SQL</p><p>create database bigData;<br>use bigData;</p><p>CREATE TABLE dept(<br>    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,<br>    deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,<br>    dname VARCHAR(20)NOT NULL DEFAULT “”,<br>    loc VARCHAR(13) NOT NULL DEFAULT “”<br>)ENGINE=INNODB DEFAULT CHARSET=utf8;</p><p>CREATE TABLE emp(<br>    id int unsigned primary key auto_increment,<br>    empno mediumint unsigned not null default 0,<br>    ename varchar(20) not null default “”,<br>    job varchar(9) not null default “”,<br>    mgr mediumint unsigned not null default 0,<br>    hiredate date not null,<br>    sal decimal(7,2) not null,<br>    comm decimal(7,2) not null,<br>    deptno mediumint unsigned not null default 0<br>)ENGINE=INNODB DEFAULT CHARSET=utf8;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>设置参数log_bin_trust_function_creators</p><p>创建函数，假如报错：This function has none of DETERMINISTIC…</p><p>由于开启过慢查询日志，因为我们开启了bin-log，我们就必须为我们的function指定一个参数。</p><p>show variables like ‘log_bin_trust_function_creators’;<br>set global log_bin_trust_function_creators=1;<br>1<br>2<br>这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法：</p><p>windows下my.ini[mysqld]加上log_bin_trust_function_creators=1</p><p>linux下/etc/my.cnf 下my.cnf[mysqld]加上log_bin_trust_function_creators=1</p><p>创建函数，保证每条数据都不同</p><p>随机产生字符串</p><p>delimiter $$ # 两个 $$ 表示结束<br>create function rand_string(n int) returns varchar(255)<br>begin<br>    declare chars_str varchar(100) default ‘abcdefghijklmnopqrstuvwxyz’;<br>    declare return_str varchar(255) default ‘’;<br>    declare i int default 0;<br>    while i &lt; n do<br>        set return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));<br>        set i=i+1;<br>    end while;<br>    return return_str;<br>end $$<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>随机产生部门编号</p><p>delimiter $$<br>create function rand_num() returns int(5)<br>begin<br>    declare i int default 0;<br>    set i=floor(100+rand()*10);<br>    return i;<br>end $$<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>运行结果</p><p>mysql&gt; delimiter $$ # 两个 $$ 表示结束<br>mysql&gt; create function rand_string(n int) returns varchar(255)<br>    -&gt; begin<br>    -&gt;     declare chars_str varchar(100) default ‘abcdefghijklmnopqrstuvwxyz’;<br>    -&gt;     declare return_str varchar(255) default ‘’;<br>    -&gt;     declare i int default 0;<br>    -&gt;     while i &lt; n do<br>    -&gt;         set return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));<br>    -&gt;         set i=i+1;<br>    -&gt;     end while;<br>    -&gt;     return return_str;<br>    -&gt; end $$<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select rand_string(2);<br>    -&gt; ;<br>    -&gt; $$<br>+—————-+<br>| rand_string(2) |<br>+—————-+<br>| af             |<br>+—————-+<br>1 row in set (0.00 sec)</p><p>mysql&gt; delimiter $$<br>mysql&gt; create function rand_num() returns int(5)<br>    -&gt; begin<br>    -&gt;     declare i int default 0;<br>    -&gt;     set i=floor(100+rand()*10);<br>    -&gt;     return i;<br>    -&gt; end $$<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select rand_num()$$<br>+————+<br>| rand_num() |<br>+————+<br>|        105 |<br>+————+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>创建存储过程</p><p>创建往emp表中插入数据的存储过程</p><p>delimiter $$<br>create procedure insert_emp(in start int(10),in max_num int(10))<br>begin<br>    declare i int default 0;<br>    set autocommit = 0;<br>    repeat<br>        set i = i+1;<br>        insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),rand_string(6),’salesman’,0001,curdate(),2000,400,rand_num());<br>        until i=max_num<br>        end repeat;<br>    commit;<br>end $$<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>创建往dept表中插入数据的存储过程</p><p>delimiter $$<br>create procedure insert_dept(in start int(10),in max_num int(10))<br>begin<br>    declare i int default 0;<br>    set autocommit = 0;<br>    repeat<br>        set i = i+1;<br>        insert into dept(deptno,dname,loc) values((start+i),rand_string(10),rand_string(8));<br>        until i=max_num<br>        end repeat;<br>    commit;<br>end $$</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>调用存储过程</p><p>往dept表中插入数据</p><p>mysql&gt; DELIMITER ;<br>mysql&gt; CALL insert_dept(100, 10);<br>Query OK, 0 rows affected (0.01 sec)<br>1<br>2<br>3<br>往emp表中插入50万数据</p><p>mysql&gt; DELIMITER ;<br>mysql&gt; CALL insert_emp(100001, 500000);<br>Query OK, 0 rows affected (27.00 sec)<br>1<br>2<br>3<br>运行结果</p><p>mysql&gt; select * from dept;<br>+—-+——–+———+——–+<br>| id | deptno | dname   | loc    |<br>+—-+——–+———+——–+<br>|  1 |    101 | mqgfy   | ck     |<br>|  2 |    102 | wgighsr | kbq    |<br>|  3 |    103 | gjgdyj  | brb    |<br>|  4 |    104 | gzfug   | p      |<br>|  5 |    105 | keitu   | cib    |<br>|  6 |    106 | nndvuv  | csue   |<br>|  7 |    107 | cdudl   | tw     |<br>|  8 |    108 | aafyea  | aqq    |<br>|  9 |    109 | zuqezjx | dpqoyo |<br>| 10 |    110 | pam     | cses   |<br>+—-+——–+———+——–+<br>10 rows in set (0.00 sec)</p><p>mysql&gt; select * from emp limit 20;<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>| id | empno  | ename | job      | mgr | hiredate   | sal     | comm   | deptno |<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>|  1 | 100002 | xmbva | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>|  2 | 100003 | aeq   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    109 |<br>|  3 | 100004 | cnjfz | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    105 |<br>|  4 | 100005 | wwhd  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    100 |<br>|  5 | 100006 | e     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>|  6 | 100007 | yjfr  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>|  7 | 100008 | xlp   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>|  8 | 100009 | mp    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>|  9 | 100010 | tcdl  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>| 10 | 100011 | akw   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    106 |<br>| 11 | 100012 | re    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>| 12 | 100013 | qip   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    105 |<br>| 13 | 100014 | bvaf  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>| 14 | 100015 | g     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    106 |<br>| 15 | 100016 | qt    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>| 16 | 100017 | bzy   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    109 |<br>| 17 | 100018 | gf    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>| 18 | 100019 | r     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>| 19 | 100020 | ydokg | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    100 |<br>| 20 | 100021 | ee    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>20 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>51_用Show Profile进行sql分析<br>Show Profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。</p><p>官方文档</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><p>分析步骤</p><p>1.是否支持，看看当前的mysql版本是否支持。</p><p>mysql&gt; show variables like ‘profiling’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| profiling     | OFF   |<br>+—————+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>默认是关闭，使用前需要开启。</p><p>2.开启功能，默认是关闭，使用前需要开启。</p><p>mysql&gt; set profiling=on;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)</p><p>mysql&gt; show variables like ‘profiling’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| profiling     | ON    |<br>+—————+——-+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>3.运行SQL</p><p>mysql&gt; select * from emp group by id%10 limit 150000;<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>| id | empno  | ename | job      | mgr | hiredate   | sal     | comm   | deptno |<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>| 10 | 100011 | akw   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    106 |<br>|  1 | 100002 | xmbva | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>|  2 | 100003 | aeq   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    109 |<br>|  3 | 100004 | cnjfz | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    105 |<br>|  4 | 100005 | wwhd  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    100 |<br>|  5 | 100006 | e     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>|  6 | 100007 | yjfr  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>|  7 | 100008 | xlp   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>|  8 | 100009 | mp    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>|  9 | 100010 | tcdl  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>10 rows in set (0.55 sec)</p><p>mysql&gt; select * from emp group by id%20 order by 5;<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>| id | empno  | ename | job      | mgr | hiredate   | sal     | comm   | deptno |<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>|  1 | 100002 | xmbva | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>|  3 | 100004 | cnjfz | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    105 |<br>|  5 | 100006 | e     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>|  7 | 100008 | xlp   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>|  9 | 100010 | tcdl  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>| 11 | 100012 | re    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>| 13 | 100014 | bvaf  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>| 15 | 100016 | qt    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>| 17 | 100018 | gf    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>| 19 | 100020 | ydokg | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    100 |<br>|  2 | 100003 | aeq   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    109 |<br>|  4 | 100005 | wwhd  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    100 |<br>|  6 | 100007 | yjfr  | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>|  8 | 100009 | mp    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    102 |<br>| 10 | 100011 | akw   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    106 |<br>| 12 | 100013 | qip   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    105 |<br>| 14 | 100015 | g     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    106 |<br>| 16 | 100017 | bzy   | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    109 |<br>| 18 | 100019 | r     | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    108 |<br>| 20 | 100021 | ee    | salesman |   1 | 2021-04-05 | 2000.00 | 400.00 |    107 |<br>+—-+——–+——-+———-+—–+————+———+——–+——–+<br>20 rows in set (0.57 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>4.查看结果，show profiles;</p><p>mysql&gt; show profiles;<br>+———-+————+———————————————–+<br>| Query_ID | Duration   | Query                                         |<br>+———-+————+———————————————–+<br>|        1 | 0.00204000 | show variables like ‘profiling’               |<br>|        2 | 0.55134250 | select * from emp group by id%10 limit 150000 |<br>|        3 | 0.56902000 | select * from emp group by id%20 order by 5   |<br>+———-+————+———————————————–+<br>3 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>5.诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL数字号码;</p><p>mysql&gt; show profile cpu,block io for query 3;<br>+———————-+———-+———-+————+————–+—————+<br>| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |<br>+———————-+———-+———-+————+————–+—————+<br>| starting             | 0.000049 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| checking permissions | 0.000005 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| Opening tables       | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| init                 | 0.000021 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| System lock          | 0.000009 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| optimizing           | 0.000003 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| statistics           | 0.000017 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| preparing            | 0.000008 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| Creating tmp table   | 0.000045 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| Sorting result       | 0.000004 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| executing            | 0.000002 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| Sending data         | 0.568704 | 0.546875 |   0.046875 |         NULL |          NULL |<br>| Creating sort index  | 0.000048 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| end                  | 0.000003 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| query end            | 0.000005 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| removing tmp table   | 0.000006 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| query end            | 0.000003 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| closing tables       | 0.000004 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| freeing items        | 0.000061 | 0.000000 |   0.000000 |         NULL |          NULL |<br>| cleaning up          | 0.000015 | 0.000000 |   0.000000 |         NULL |          NULL |<br>+———————-+———-+———-+————+————–+—————+<br>20 rows in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>参数备注</p><p>ALL：显示所有的开销信息。<br>BLOCK IO：显示块lO相关开销。<br>CONTEXT SWITCHES ：上下文切换相关开销。<br>CPU：显示CPU相关开销信息。<br>IPC：显示发送和接收相关开销信息。<br>MEMORY：显示内存相关开销信息。<br>PAGE FAULTS：显示页面错误相关开销信息。<br>SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。<br>SWAPS：显示交换次数相关开销的信息。<br>6.日常开发需要注意的结论</p><p>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。<br>Creating tmp table 创建临时表，拷贝数据到临时表，用完再删除<br>Copying to tmp table on disk 把内存中临时表复制到磁盘，危险!<br>locked<br>52_全局查询日志<br>永远不要在生产环境开启这个功能。</p><p>配置文件启用。在mysql的my.cnf中，设置如下：</p><p>#开启<br>general_log=1<br>#记录日志文件的路径<br>general_log_file=/path/logfile<br>#输出格式<br>log_output=FILE<br>1<br>2<br>3<br>4<br>5<br>6<br>编码启用。命令如下：</p><p>set global general_log=1;</p><p>set global log_output=’TABLE’;</p><p>mysql&gt; set global general_log=1;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; set global log_output=’TABLE’;<br>Query OK, 0 rows affected (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>此后，你所编写的sql语句，将会记录到mysql库里的geneial_log表，可以用下面的命令查看：</p><p>mysql&gt; select * from mysql.general_log;<br>+—————————-+——————————+———–+———–+————–+———————————+<br>| event_time                 | user_host                    | thread_id | server_id | command_type | argument                        |<br>+—————————-+——————————+———–+———–+————–+———————————+<br>| 2021-04-05 19:57:28.182473 | root[root] @ localhost [::1] |         5 |         1 | Query        | select * from mysql.general_log |<br>+—————————-+——————————+———–+———–+————–+———————————+<br>1 row in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>四、MySQL锁机制<br>53_数据库锁理论概述<br>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>类比：网上购物</p><p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？</p><p>这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p><p>锁的分类</p><p>从对数据操作的类型（读\写）分</p><p>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。<br>从对数据操作的粒度分</p><p>表锁<br>行锁<br>54_读锁案例讲解<br>表锁（偏读）</p><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p>案例分析</p><p>建表SQL</p><p>create table mylock (<br>    id int not null primary key auto_increment,<br>    name varchar(20) default ‘’<br>) engine myisam;</p><p>insert into mylock(name) values(‘a’);<br>insert into mylock(name) values(‘b’);<br>insert into mylock(name) values(‘c’);<br>insert into mylock(name) values(‘d’);<br>insert into mylock(name) values(‘e’);</p><p>select * from mylock;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>运行结果</p><p>mysql&gt; create table mylock (<br>    -&gt;     id int not null primary key auto_increment,<br>    -&gt;     name varchar(20) default ‘’<br>    -&gt; ) engine myisam;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt;<br>mysql&gt; insert into mylock(name) values(‘a’);<br>Query OK, 1 row affected (0.00 sec)</p><p>mysql&gt; insert into mylock(name) values(‘b’);<br>Query OK, 1 row affected (0.00 sec)</p><p>mysql&gt; insert into mylock(name) values(‘c’);<br>Query OK, 1 row affected (0.00 sec)</p><p>mysql&gt; insert into mylock(name) values(‘d’);<br>Query OK, 1 row affected (0.00 sec)</p><p>mysql&gt; insert into mylock(name) values(‘e’);<br>Query OK, 1 row affected (0.00 sec)</p><p>mysql&gt;<br>mysql&gt; select * from mylock;<br>+—-+——+<br>| id | name |<br>+—-+——+<br>|  1 | a    |<br>|  2 | b    |<br>|  3 | c    |<br>|  4 | d    |<br>|  5 | e    |<br>+—-+——+<br>5 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>手动增加表锁</p><p>lock table 表名字 read(write), 表名字2 read(write), 其他;</p><p>mysql&gt; lock table mylock read;<br>Query OK, 0 rows affected (0.00 sec)<br>1<br>2<br>查看表上加过的锁</p><p>mysql&gt; show open tables;<br>+——————–+——————————————————+——–+————-+<br>| Database           | Table                                                | In_use | Name_locked |<br>+——————–+——————————————————+——–+————-+<br>| performance_schema | events_waits_summary_by_user_by_event_name           |      0 |           0 |<br>| performance_schema | events_waits_summary_global_by_event_name            |      0 |           0 |<br>| performance_schema | events_transactions_summary_global_by_event_name     |      0 |           0 |<br>| performance_schema | replication_connection_status                        |      0 |           0 |<br>| mysql              | time_zone_leap_second                                |      0 |           0 |<br>| mysql              | columns_priv                                         |      0 |           0 |<br>| my                 | test03                                               |      0 |           0 |<br>| bigdata            | mylock                                               |      1 |           0 |<br>…<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>释放锁</p><p>mysql&gt; unlock tables;<br>Query OK, 0 rows affected (0.00 sec)<br>1<br>2<br>加读锁——为mylock表加read锁（读阻塞写例子）</p><p>55_读锁案例讲解2<br>为mylock表加write锁（MylSAM存储引擎的写阻塞读例子）</p><p>案例结论</p><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p><p>MySQL的表级锁有两种模式：</p><p>表共享读锁(Table Read Lock)<br>表独占写锁(Table Write Lock)<br>锁类型    可否兼容    读锁    写锁<br>读锁    是    是    否<br>写锁    是    否    否<br>结合上表，所以对MyISAM表进行操作，会有以下情况：</p><p>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</p><p>对MyISAM表的写操作〈加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</p><p>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。</p><p>表锁分析</p><p>看看哪些表被加锁了</p><p>mysql&gt; show open tables;<br>1<br>如何分析表锁定</p><p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定。</p><p>mysql&gt;  show status like ‘table_locks%’;<br>+———————–+——-+<br>| Variable_name         | Value |<br>+———————–+——-+<br>| Table_locks_immediate | 170   |<br>| Table_locks_waited    | 0     |<br>+———————–+——-+<br>2 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><p>Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1 ;<br>Table_locks_waited：出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况；<br>此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><p>56_行锁理论<br>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务(TRANSACTION)；二是采用了行级锁。</p><p>由于行锁支持事务，复习老知识</p><p>事务(Transaction）及其ACID属性<br>并发事务处理带来的问题<br>事务隔离级别<br>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性：</p><p>原子性(Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。<br>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时，所有的内部数据结构〈如B树索引或双向链表）也都必须是正确的。<br>隔离性（lsolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。<br>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。<br>并发事务处理带来的问题</p><p>更新丢失(Lost Update)<br>脏读(Dirty Reads)<br>不可重复读(Non-Repeatable Reads)<br>幻读(Phantom Reads)<br>更新丢失(Lost Update)</p><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题――最后的更新覆盖了由其他事务所做的更新。</p><p>例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。</p><p>如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</p><p>脏读(Dirty Reads)</p><p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。</p><p>一句话：事务A读取到了事务B已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p><p>不可重复读(Non-Repeatable Reads)</p><p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做“不可重复读”。</p><p>一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性。</p><p>幻读(Phantom Reads)</p><p>一个事务接相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读“。</p><p>一句话:事务A读取到了事务B体提交的新增数据，不符合隔离性。</p><p>多说一句：幻读和脏读有点类似，</p><p>脏读是事务B里面修改了数据，</p><p>幻读是事务B里面新增了数据。</p><p>事务隔离级别</p><p>”脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p><p>读数据—致性及允许的并发副作用（隔离级别）    读数据一致性    脏读    不可重复读    幻读<br>未提交读（Read Uncommitted）    最低级别，只能保证不读取物理上损坏的数据    是    是    是<br>已提交读（Read committed）    语句级    否    是    是<br>可重复读（Repeatable read）    事务级    否    否    是<br>可序列化（serializable）    最高级别，事务级    否    否    否<br>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><p>常看当前数据库的事务隔离级别：show variables like ‘tx_isolation’;</p><p>mysql&gt; show variables like ‘tx_isolation’;<br>+—————+—————–+<br>| Variable_name | Value           |<br>+—————+—————–+<br>| tx_isolation  | REPEATABLE-READ |<br>+—————+—————–+<br>1 row in set, 1 warning (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>57_行锁案例讲解<br>新建SQL</p><p>CREATE TABLE test_innodb_lock (a INT(11),b VARCHAR(16))ENGINE=INNODB;</p><p>INSERT INTO test_innodb_lock VALUES(1,’b2’);<br>INSERT INTO test_innodb_lock VALUES(3,’3’);<br>INSERT INTO test_innodb_lock VALUES(4, ‘4000’);<br>INSERT INTO test_innodb_lock VALUES(5,’5000’);<br>INSERT INTO test_innodb_lock VALUES(6, ‘6000’);<br>INSERT INTO test_innodb_lock VALUES(7,’7000’);<br>INSERT INTO test_innodb_lock VALUES(8, ‘8000’);<br>INSERT INTO test_innodb_lock VALUES(9,’9000’);<br>INSERT INTO test_innodb_lock VALUES(1,’b1’);</p><p>CREATE INDEX test_innodb_a_ind ON test_innodb_lock(a);<br>CREATE INDEX test_innodb_lock_b_ind ON test_innodb_lock(b);</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>运行结果</p><p>mysql&gt; select * from test_innodb_lock;<br>+——+——+<br>| a    | b    |<br>+——+——+<br>|    1 | b2   |<br>|    3 | 3    |<br>|    4 | 4000 |<br>|    5 | 5000 |<br>|    6 | 6000 |<br>|    7 | 7000 |<br>|    8 | 8000 |<br>|    9 | 9000 |<br>|    1 | b1   |<br>+——+——+<br>9 rows in set (0.00 sec)</p><p>mysql&gt; show index from test_innodb_lock;<br>+——————+————+————————+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table            | Non_unique | Key_name               | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+——————+————+————————+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| test_innodb_lock |          1 | test_innodb_a_ind      |            1 | a           | A         |           8 |     NULL | NULL   | YES  | BTREE      |         |               |<br>| test_innodb_lock |          1 | test_innodb_lock_b_ind |            1 | b           | A         |           9 |     NULL | NULL   | YES  | BTREE      |         |               |<br>+——————+————+————————+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>2 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>行锁定基本演示（两个客户端更新同一行记录）</p><p>58_行锁演示答疑补充</p><p>59_索引失效行锁变表锁<br>无索引行锁升级为表锁</p><p>60_间隙锁危害</p><p>什么是间隙锁</p><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。</p><p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>危害</p><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</p><p>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><p>61_如何锁定一行<br>面试：如何锁定一行？begin…commit</p><p>62_行锁总结与页锁<br>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MylISAM相比就会有比较明显的优势了。</p><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><p>行锁分析</p><p>如何分析行锁定<br>通过检查lnnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>mysql&gt; show status like ‘innodb_row_lock%’;<br>+——————————-+——-+<br>| Variable_name                 | Value |<br>+——————————-+——-+<br>| Innodb_row_lock_current_waits | 0     |<br>| Innodb_row_lock_time          | 0     |<br>| Innodb_row_lock_time_avg      | 0     |<br>| Innodb_row_lock_time_max      | 0     |<br>| Innodb_row_lock_waits         | 0     |<br>+——————————-+——-+<br>5 rows in set (0.00 sec)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>对各个状态量的说明如下:</p><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；<br>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；<br>Innodb_row_lock_time_avg：每次等待所花平均时间；<br>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；<br>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；<br>对于这5个状态变量，比较重要的主要是</p><p>Innodb_row_lock_time_avg（等待平均时长）<br>lnnodb_row_lock_waits（等待总次数）<br>lnnodb_row_lock_time（等待总时长）这三项。<br>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p>优化建议</p><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。<br>合理设计索引，尽量缩小锁的范围<br>尽可能较少检索条件，避免间隙锁<br>尽量控制事务大小，减少锁定资源量和时间长度<br>尽可能低级别事务隔离<br>页锁</p><p>开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。（了解一下即可）</p><p>五、主从复制<br>63_主从复制<br>复制的基本原理</p><p>slave会从master读取binlog来进行数据同步</p><p>三步骤+原理图</p><p>MySQL复制过程分成三步</p><p>master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events;<br>slave将master的binary log events拷贝到它的中继日志(relay log) ;<br>slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的<br>复制的基本原则</p><p>每个slave只有一个master<br>每个slave只能有一个唯一的服务器ID<br>每个master可以有多个salve<br>复制的最大问题是延迟。</p><p>一主一从常见配置<br>mysql版本一致且后台以服务运行</p><p>主从都配置在[mysqld]结点下，都是小写</p><p>主机修改my.ini配置文件</p><p>[必须]主服务器唯一ID</p><p>server-id=1<br>[必须]启用二进制日志</p><p>log-bin=自己本地的路径/mysqlbin<br>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin<br>[可选]启用错误日志</p><p>log-err=自己本地的路径/mysqlerr<br>log-err=D:/devSoft/MySQLServer5.5/data/mysqlerr<br>[可选]根目录</p><p>basedir=“自己本地路径”<br>basedir=“D:/devSoft/MySQLServer5.5/”<br>[可选]临时目录</p><p>tmpdir=“自己本地路径”<br>tmpdir=“D:/devSoft/MySQLServer5.5/”<br>[可选]数据目录</p><p>datadir=“自己本地路径/Data/”<br>datadir=“D:/devSoft/MySQLServer5.5/Data/”<br>主机，读写都可以</p><p>read-only=O<br>[可选]设置不要复制的数据库</p><p>binlog-ignore-db=mysql<br>[可选]设置需要复制的数据库</p><p>binlog-do-db=需要复制的主数据库名字<br>从机修改my.cnf配置文件</p><p>[必须]从服务器唯一ID<br>[可选]启用二进制日志<br>配置文件，请主机+从机都重启后台mysql服务</p><p>service mysql stop<br>service mysql start<br>主机从机都关闭防火墙</p><p>windows手动关闭</p><p>关闭虚拟机linux防火墙 service iptables stop</p><p>在Windows主机上建立帐户并授权slave</p><p>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘zhangsan’@‘从机器数据库IP’ IDENTIFIED BY ‘123456’;<br>flush privileges;//刷新<br>查询master的状态<br>show master status;<br>记录下File和Position的值</p><p>执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化<br>在Linux从机上配置需要复制的主机</p><p>CHANGE MASTER TO MASTER_HOST=’主机<br>IP’, MASTER_USER=‘zhangsan’, MASTER_PASSWORD=’123456’, MASTER_LOG_FILE=’File名字’, MASTER_LOG_POS=Position数字;</p><p>启动从服务器复制功能</p><p>start slave;<br>show slave status\G</p><p>下面两个参数都是Yes，则说明主从配置成功!<br>Slave_IO_Running：Yes<br>Slave_SQL_Running：Yes<br>主机新建库、新建表、insert记录，从机复制</p><p>如何停止从服务复制功能</p><p>stop slave;</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>尚硅谷_宋红康_JDBC</title>
    <link href="http://example.com/2021/08/02/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-JDBC-1/"/>
    <id>http://example.com/2021/08/02/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-JDBC-1/</id>
    <published>2021-08-02T02:17:49.000Z</published>
    <updated>2021-10-02T02:19:48.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><hr><h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul><li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p></li><li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566741430592.png" alt="1566741430592"> </p></li></ul><h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul><li><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p>JDO (Java Data Object )技术</p></li><li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p></li></ul></li><li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p></li></ul><h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul><li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555575760234.png" alt="1555575760234"></p><hr><ul><li>有了JDBC，Java程序访问数据库时是这样的：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555575981203.png" alt="1555575981203"></p><hr><ul><li>总结如下：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566741692804.png" alt="1566741692804"></p><h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p></blockquote><h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1565969323908.png" alt="1565969323908"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li><li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li></ul></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576157618.png" alt="1555576157618"></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576170074.png" alt="1555576170074"></p><ul><li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li></ul><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566134718955.png" alt="1566134718955"></p><p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566134781682.png" alt="1566134781682"></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566135290460.png" alt="1566135290460"></p><h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li></ul></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566136831283.png" alt="1566136831283"></p></li></ul></li></ul><h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><ul><li><strong>jdbc:子协议:子名称</strong></li><li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li><li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li><li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li></ul></li><li><p>举例：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576477107.png" alt="1555576477107"></p></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/atguigu</li><li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p></li><li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p></li></ul></li></ul></li></ul><h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul><li>user,password可以用“属性名=属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul><li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p></li><li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566573842140.png" alt="1566573842140"></p></li></ul><h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">String userName = scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">User user = get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line">String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566569819744.png" alt="1566569819744"></p><h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul><li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p></li><li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul><li><p>代码的可读性和可维护性。</p></li><li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li></ul></li><li><p>PreparedStatement 可以防止 SQL 注入 </p></li></ul><h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY  ,    VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123;Connection conn = null;PreparedStatement ps = null;try &#123;//1.获取数据库的连接conn = JDBCUtils.getConnection();//2.获取PreparedStatement的实例 (或：预编译sql语句)ps = conn.prepareStatement(sql);//3.填充占位符for(int i = 0;i &lt; args.length;i++)&#123;ps.setObject(i + 1, args[i]);&#125;//4.执行sql语句ps.execute();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;finally&#123;//5.关闭资源JDBCUtils.closeResource(conn, ps);&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;try &#123;// 1.获取数据库连接conn = JDBCUtils.getConnection();// 2.预编译sql语句，得到PreparedStatement对象ps = conn.prepareStatement(sql);// 3.填充占位符for (int i = 0; i &lt; args.length; i++) &#123;ps.setObject(i + 1, args[i]);&#125;// 4.执行executeQuery(),得到结果集：ResultSetrs = ps.executeQuery();// 5.得到结果集的元数据：ResultSetMetaDataResultSetMetaData rsmd = rs.getMetaData();// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值int columnCount = rsmd.getColumnCount();if (rs.next()) &#123;T t = clazz.newInstance();for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列// 获取列值Object columnVal = rs.getObject(i + 1);// 获取列的别名:列的别名，使用类的属性名充当String columnLabel = rsmd.getColumnLabel(i + 1);// 6.2使用反射，给对象的相应属性赋值Field field = clazz.getDeclaredField(columnLabel);field.setAccessible(true);field.set(t, columnVal);&#125;return t;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;// 7.关闭资源JDBCUtils.closeResource(conn, ps, rs);&#125;return null;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li><p>boolean next()</p></li><li><p>getString()</p></li><li><p>…</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580152530.png" alt="1555580152530"></p></li></ul><h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta = rs.getMetaData();</p><ul><li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p></li><li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p></li><li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p></li><li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p></li><li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p></li><li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p></li><li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p></li></ul></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555579494691.png" alt="1555579494691"></p><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li><li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555579816884.png" alt="1555579816884"></p><h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul><li><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。</p></blockquote></li><li><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><hr><h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580275036.png" alt="1555580275036"></p><p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580735377.png" alt="1555580735377"></p><p>向数据表中添加如下数据：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580763636.png" alt="1555580763636"></p><p><strong>代码实现1：插入一个新的student 信息</strong></p><p>请输入考生的详细信息</p><p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p><p>信息录入成功!</p><p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580937490.png" alt="1555580937490"></p><p><strong>代码实现3：完成学生信息的删除功能</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580965019.png" alt="1555580965019"></p><hr><h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555581069798.png" alt="1555581069798"></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接Connection conn = JDBCUtils.getConnection();String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="comment">// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;conn = getConnection();ps = conn.prepareStatement(sql);ps.setInt(<span class="number">1</span>, <span class="number">8</span>);rs = ps.executeQuery();<span class="keyword">if</span>(rs.next())&#123;Integer id = rs.getInt(<span class="number">1</span>);    String name = rs.getString(<span class="number">2</span>);String email = rs.getString(<span class="number">3</span>);    Date birth = rs.getDate(<span class="number">4</span>);Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);    System.out.println(cust);     <span class="comment">//读取Blob类型的字段Blob photo = rs.getBlob(5);InputStream is = photo.getBinaryStream();OutputStream os = new FileOutputStream(&quot;c.jpg&quot;);byte [] buffer = new byte[1024];int len = 0;while((len = is.read(buffer)) != -1)&#123;os.write(buffer, 0, len);&#125;    JDBCUtils.closeResource(conn, ps, rs);if(is != null)&#123;is.close();&#125;if(os !=  null)&#123;os.close();&#125;    &#125;</span></span><br></pre></td></tr></table></figure><h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li><li><strong>executeBatch()：执行批量处理语句；</strong></li><li><strong>clearBatch():清空缓存的数据</strong></li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li>数据库中提供一个goods表。创建如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,NAME <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;st.executeUpdate(sql);&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);ps.executeUpdate();&#125;<span class="keyword">long</span> end = System.currentTimeMillis();System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 *  ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar *  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);<span class="comment">//1.“攒”sqlps.addBatch();if(i % 500 == 0)&#123;//2.执行ps.executeBatch();//3.清空ps.clearBatch();&#125;&#125;long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625                                                                         //1000000条:14733  JDBCUtils.closeResource(conn, ps);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false)  /  commit()*/</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();<span class="comment">//1.设置为不自动提交数据conn.setAutoCommit(false);String sql = &quot;insert into goods(name)values(?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);for(int i = 1;i &lt;= 1000000;i++)&#123;ps.setString(1, &quot;name_&quot; + i);//1.“攒”sqlps.addBatch();if(i % 500 == 0)&#123;//2.执行ps.executeBatch();//3.清空ps.clearBatch();&#125;&#125;//2.提交数据conn.commit();long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p></li><li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p></li><li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p></li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p><ul><li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li><li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;Connection conn = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;<span class="comment">// 1.获取数据库连接conn = JDBCUtils.getConnection();// 2.开启事务conn.setAutoCommit(false);// 3.进行数据库操作String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;update(conn, sql1, &quot;AA&quot;);// 模拟网络异常//System.out.println(10 / 0);String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;update(conn, sql2, &quot;BB&quot;);// 4.若没有异常，则提交事务conn.commit();&#125; catch (Exception e) &#123;e.printStackTrace();// 5.若有异常，则回滚事务try &#123;conn.rollback();&#125; catch (SQLException e1) &#123;e1.printStackTrace();&#125;    &#125; finally &#123;        try &#123;//6.恢复每次DML操作的自动提交功能conn.setAutoCommit(true);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125;        //7.关闭连接JDBCUtils.closeResource(conn, null, null);     &#125;  &#125;</span></span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123;PreparedStatement ps = null;try &#123;// 1.获取PreparedStatement的实例 (或：预编译sql语句)ps = conn.prepareStatement(sql);// 2.填充占位符for (int i = 0; i &lt; args.length; i++) &#123;ps.setObject(i + 1, args[i]);&#125;// 3.执行sql语句ps.execute();&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;// 4.关闭资源JDBCUtils.closeResource(null, ps);&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol><li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul><li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p></li><li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p></li></ul><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul><li><p>数据库提供的4种事务隔离级别：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555586275271.png" alt="1555586275271"></p></li><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li></ul><ul><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li><li><p>设置当前 mySQL 连接的隔离级别:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;;  #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566726681515.png" alt="1566726681515"></p><ul><li>层次结构：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566745811244.png" alt="1566745811244"></p><h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.lang.reflect.ParameterizedType;<span class="keyword">import</span> java.lang.reflect.Type;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;<span class="comment">/** * 定义一个用来被继承的对数据库进行基本操作的Dao *  * <span class="doctag">@author</span> HanYanBing * * <span class="doctag">@param</span> &lt;T&gt; */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();<span class="comment">// 定义一个变量来接收泛型的类型private Class&lt;T&gt; type;// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定public BaseDao() &#123;// 获取子类的类型Class clazz = this.getClass();// 获取父类的类型// getGenericSuperclass()用来获取当前类的父类的类型// ParameterizedType表示的是带泛型的类型ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型// 这个方法会返回一个Type的数组Type[] types = parameterizedType.getActualTypeArguments();// 获取具体的泛型的类型·this.type = (Class&lt;T&gt;) types[0];&#125;/** * 通用的增删改操作 *  * @param sql * @param params * @return */public int update(Connection conn,String sql, Object... params) &#123;int count = 0;try &#123;count = queryRunner.update(conn, sql, params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return count;&#125;/** * 获取一个对象 *  * @param sql * @param params * @return */public T getBean(Connection conn,String sql, Object... params) &#123;T t = null;try &#123;t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return t;&#125;/** * 获取所有对象 *  * @param sql * @param params * @return */public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123;List&lt;T&gt; list = null;try &#123;list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return list;&#125;/** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 *  * @param sql * @param params * @return */public Object getValue(Connection conn,String sql, Object... params) &#123;Object count = null;try &#123;// 调用queryRunner的query方法获取一个单一的值count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return count;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> com.atguigu.bookstore.beans.Book;<span class="keyword">import</span> com.atguigu.bookstore.beans.Page;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;<span class="comment">/** * 从数据库中查询出所有的记录 *  * <span class="doctag">@return</span> */</span><span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;<span class="comment">/** * 向数据库中插入一条记录 *  * <span class="doctag">@param</span> book */</span><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;<span class="comment">/** * 从数据库中根据图书的id删除一条记录 *  * <span class="doctag">@param</span> bookId */</span><span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;<span class="comment">/** * 根据图书的id从数据库中查询出一条记录 *  * <span class="doctag">@param</span> bookId * <span class="doctag">@return</span> */</span><span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;<span class="comment">/** * 根据图书的id从数据库中更新一条记录 *  * <span class="doctag">@param</span> book */</span><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;<span class="comment">/** * 获取带分页的图书信息 *  * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象 */</span><span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;<span class="comment">/** * 获取带分页和价格范围的图书信息 *  * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象 */</span><span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> com.atguigu.bookstore.beans.User;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;<span class="comment">/** * 根据User对象中的用户名和密码从数据库中获取一条记录 *  * <span class="doctag">@param</span> user * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录 */</span><span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;<span class="comment">/** * 根据User对象中的用户名从数据库中获取一条记录 *  * <span class="doctag">@param</span> user * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录 */</span><span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;<span class="comment">/** * 向数据库中插入User对象 *  * <span class="doctag">@param</span> user */</span><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> com.atguigu.bookstore.beans.Book;<span class="keyword">import</span> com.atguigu.bookstore.beans.Page;<span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;<span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;<span class="comment">// 调用BaseDao中得到一个List的方法List&lt;Book&gt; beanList = null;// 写sql语句String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;;beanList = getBeanList(conn,sql);return beanList;&#125;@Overridepublic void saveBook(Connection conn,Book book) &#123;// 写sql语句String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;// 调用BaseDao中通用的增删改的方法update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());&#125;@Overridepublic void deleteBookById(Connection conn,String bookId) &#123;// 写sql语句String sql = &quot;DELETE FROM books WHERE id = ?&quot;;// 调用BaseDao中通用增删改的方法update(conn,sql, bookId);&#125;@Overridepublic Book getBookById(Connection conn,String bookId) &#123;// 调用BaseDao中获取一个对象的方法Book book = null;// 写sql语句String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;book = getBean(conn,sql, bookId);return book;&#125;@Overridepublic void updateBook(Connection conn,Book book) &#123;// 写sql语句String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;;// 调用BaseDao中通用的增删改的方法update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());&#125;@Overridepublic Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123;// 获取数据库中图书的总记录数String sql = &quot;select count(*) from books&quot;;// 调用BaseDao中获取一个单一值的方法long totalRecord = (long) getValue(conn,sql);// 将总记录数设置都page对象中page.setTotalRecord((int) totalRecord);// 获取当前页中的记录存放的ListString sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;;// 调用BaseDao中获取一个集合的方法List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);// 将这个List设置到page对象中page.setList(beanList);return page;&#125;@Overridepublic Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123;// 获取数据库中图书的总记录数String sql = &quot;select count(*) from books where price between ? and ?&quot;;// 调用BaseDao中获取一个单一值的方法long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);// 将总记录数设置都page对象中page.setTotalRecord((int) totalRecord);// 获取当前页中的记录存放的ListString sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;;// 调用BaseDao中获取一个集合的方法List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);// 将这个List设置到page对象中page.setList(beanList);return page;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> com.atguigu.bookstore.beans.User;<span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;<span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;<span class="comment">// 调用BaseDao中获取一个对象的方法User bean = null;// 写sql语句String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;;bean = getBean(conn,sql, user.getUsername(), user.getPassword());return bean;&#125;@Overridepublic boolean checkUsername(Connection conn,User user) &#123;// 调用BaseDao中获取一个对象的方法User bean = null;// 写sql语句String sql = &quot;select id,username,password,email from users where username = ?&quot;;bean = getBean(conn,sql, user.getUsername());return bean != null;&#125;@Overridepublic void saveUser(Connection conn,User user) &#123;//写sql语句String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;//调用BaseDao中通用的增删改的方法update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="comment">/** * 图书类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;<span class="keyword">private</span> Integer id;<span class="keyword">private</span> String title; <span class="comment">// 书名private String author; // 作者private double price; // 价格private Integer sales; // 销量private Integer stock; // 库存private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径//构造器，get()，set()，toString()方法略&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="keyword">import</span> java.util.List;<span class="comment">/** * 页码类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合public static final int PAGE_SIZE = 4; // 每页显示的记录数private int pageNo; // 当前页//private int totalPageNo; // 总页数，通过计算得到private int totalRecord; // 总记录数，通过查询数据库得到</span></span><br></pre></td></tr></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="comment">/** * 用户类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;<span class="keyword">private</span> Integer id;<span class="keyword">private</span> String username;<span class="keyword">private</span> String password;<span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p><ul><li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li><li><strong>进行sql操作</strong></li><li><strong>断开数据库连接</strong></li></ul></li><li><p>这种模式开发，存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li><li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p></li><li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p></li><li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p></li><li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555593464033.png" alt="1555593464033"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555593598606.png" alt="1555593598606"></p><ul><li><p><strong>数据库连接池技术的优点</strong></p><p><strong>1. 资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2. 更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><p><strong>3. 新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p><p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul><li>获取连接方式一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123;ComboPooledDataSource cpds = new ComboPooledDataSource();cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);cpds.setUser(&quot;root&quot;);cpds.setPassword(&quot;abc123&quot;);//cpds.setMaxPoolSize(100);Connection conn = cpds.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>获取连接方式二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123;Connection conn = cpds.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;BasicDataSource source = <span class="keyword">new</span> BasicDataSource();source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);source.setUsername(<span class="string">&quot;root&quot;</span>);source.setPassword(<span class="string">&quot;abc123&quot;</span>);<span class="comment">//source.setInitialSize(10);Connection conn = source.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123;try &#123;Properties pros = new Properties();InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);pros.load(is);//根据提供的BasicDataSourceFactory创建对应的DataSource对象source = BasicDataSourceFactory.createDataSource(pros);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;public static Connection getConnection4() throws Exception &#123;Connection conn = source.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【dbcp.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#...</span></span><br></pre></td></tr></table></figure><h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> javax.sql.DataSource;<span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;Properties pro = <span class="keyword">new</span> Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));DataSource ds = DruidDataSourceFactory.createDataSource(pro);Connection conn = ds.getConnection();System.out.println(conn);&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=123456driverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall</span></span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th><strong>配置</strong></th><th><strong>缺省</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils   </li></ul></li><li><p>API包说明：</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555595163263.png" alt="1555595163263"></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555595198644.png" alt="1555595198644"></p><h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p><ul><li><strong>更新</strong><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul></li><li><strong>插入</strong><ul><li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li><li>….</li></ul></li><li><strong>批处理</strong><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>…..</li></ul></li><li><strong>查询</strong><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…… </li></ul></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加@Testpublic void testInsert() throws Exception &#123;QueryRunner runner = new QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;);System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除@Testpublic void testDelete() throws Exception &#123;QueryRunner runner = new QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = &quot;delete from customers where id &lt; ?&quot;;int count = runner.update(conn, sql,3);System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p></li><li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p></li><li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p></li><li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p></li><li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p></li><li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p></li><li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p></li><li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p></li><li><p><strong>ScalarHandler：</strong>查询单个值对象</p></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 测试查询:查询一条记录 *  * 使用ResultSetHandler的实现类：BeanHandler */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;<span class="comment">//BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class);Customer customer = runner.query(conn, sql, handler, 23);System.out.println(customer);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 测试查询:查询多条记录构成的集合 *  * 使用ResultSetHandler的实现类：BeanListHandler */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;<span class="comment">//BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class);List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23);list.forEach(System.out::println);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 自定义ResultSetHandler的实现类 */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;System.out.println(<span class="string">&quot;handle&quot;</span>);<span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));if(rs.next())&#123;int id = rs.getInt(&quot;id&quot;);String name = rs.getString(&quot;name&quot;);String email = rs.getString(&quot;email&quot;);Date birth = rs.getDate(&quot;birth&quot;);return new Customer(id, name, email, birth);&#125;return null;&#125;&#125;;Customer customer = runner.query(conn, sql, handler, 23);System.out.println(customer);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler *  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();<span class="comment">//测试一：//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;//ScalarHandler handler = new ScalarHandler();//long count = (long) runner.query(conn, sql, handler, 20);//System.out.println(count);//测试二：String sql = &quot;select max(birth) from customers&quot;;ScalarHandler handler = new ScalarHandler();Date birth = (Date) runner.query(conn, sql, handler);System.out.println(birth);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结<span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;Connection conn = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;<span class="comment">//1.获取连接的操作（//① 手写的连接：JDBCUtils.getConnection();//② 使用数据库连接池：C3P0;DBCP;Druid//2.对数据表进行一系列CRUD操作//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;//② 使用dbutils提供的jar包中提供的QueryRunner类//提交数据conn.commit();&#125; catch (Exception e) &#123;e.printStackTrace();try &#123;//回滚数据conn.rollback();&#125; catch (SQLException e1) &#123;e1.printStackTrace();&#125;&#125;finally&#123;//3.关闭连接等操作//① JDBCUtils.closeResource();//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Jdbc</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/17/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/07/17/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-17T15:49:31.952Z</published>
    <updated>2021-10-13T23:53:09.209Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">title: java常见问题</span><br><span class="line">date: 2021-09-20 20:04:28</span><br><span class="line">tags: thinks</span><br><span class="line">categories: thinks</span><br><span class="line">keywords:</span><br><span class="line">description: some of my thinks</span><br><span class="line">top_img: </span><br><span class="line">comments: </span><br><span class="line">cover: https:&#x2F;&#x2F;ae01.alicdn.com&#x2F;kf&#x2F;Ue5889eaf11594a4aabca090c5d5060798.jpg</span><br><span class="line">toc:  </span><br><span class="line">toc_number:</span><br><span class="line">copyright:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br></pre></td></tr></table></figure><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><h3 id="何为编程"><a href="#何为编程" class="headerlink" title="何为编程"></a>何为编程</h3><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</p><p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p><h3 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h3><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="jdk1.5之后的三大版本"></a>jdk1.5之后的三大版本</h3><ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li><li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li><li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h3 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h3><p>JVM</p><p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p><p>JRE</p><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p><p>JDK</p><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p><p>JVM&amp;JRE&amp;JDK关系图</p><h3 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p><p>面向对象（封装，继承，多态）</p><p>平台无关性（Java虚拟机实现平台无关性）</p><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p><p>安全性</p><h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h3><p>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><h4 id="采用字节码的好处："><a href="#采用字节码的好处：" class="headerlink" title="采用字节码的好处："></a>采用字节码的好处：</h4><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h4 id="先看下java中的编译器和解释器："><a href="#先看下java中的编译器和解释器：" class="headerlink" title="先看下java中的编译器和解释器："></a>先看下java中的编译器和解释器：</h4><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure><h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><h3 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><h4 id="Java基本数据类型图"><a href="#Java基本数据类型图" class="headerlink" title="Java基本数据类型图"></a>Java基本数据类型图</h4><h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h4 id="什么Java注释"><a href="#什么Java注释" class="headerlink" title="什么Java注释"></a>什么Java注释</h4><p>定义：用于解释说明程序的文字</p><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>单行注释<br>格式： // 注释文字</li><li>多行注释<br>格式： / <em>注释文字</em> /</li><li>文档注释<br>格式：/** 注释文字* /</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p><p>注意事项：多行和文档注释都不能嵌套使用。</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><p>定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p><p>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p><p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p><p>public : 对所有类可见。使用对象：类、接口、变量、方法</p><h4 id="访问修饰符图"><a href="#访问修饰符图" class="headerlink" title="访问修饰符图"></a>访问修饰符图</h4><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h4 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h4><p>用于修饰类、属性和方法；</p><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表<br>示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块<br>中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调<br>用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的<br>最后判断。</li></ul><h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p>this的用法在java中大体可以分为3种：</p><p>1.普通的直接引用，this相当于是指向当前对象本身。</p><p>2.形参与成员名字重名，用this来区分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.引用本类的构造函数</p><p>class Person{ private String name; private int age; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> { }  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> {     <span class="hljs-built_in">this</span>.name = name; } <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, int age</span>)</span> {     <span class="hljs-built_in">this</span>(name);     <span class="hljs-built_in">this</span>.age = age; }</p><p><code>&#125;</code></p><h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super也有三种用法：</p><p>1.普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><p>class Person{ protected String name; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> {     <span class="hljs-built_in">this</span>.name = name; }  } class Student extends Person{ private String name; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> name1</span>)</span> {     <span class="hljs-built_in">super</span>(name);     <span class="hljs-built_in">this</span>.name = name1; }  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span>{     System.out.println(<span class="hljs-built_in">this</span>.name);      <span class="hljs-comment">//Child</span>     System.out.println(<span class="hljs-built_in">super</span>.name);     <span class="hljs-comment">//Father</span> }  } public class Test { public static void main(String[] args) { Student s1 = new Student(“Father”,”Child”); s1.getInfo(); }</p><p><code>&#125;</code></p><p>3.引用父类构造函数</p><p>3、引用父类构造函数</p><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul><h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul><li>super:它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h4><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。 <strong>以致于即使没有创建对象，也能使用属性和调用方法</strong> ！</p><p>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong> 。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法 <strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong> 。</p><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p><p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p><p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果 某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量 。</p><p>因此比较常见的static应用场景有：</p><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p><h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><p><code>public static void main(String[] args) &#123; ok: for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j); if (j == 5) &#123; break ok; &#125;    &#125; &#125; </code></p><p><code>&#125;</code></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h4><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p><p>缺点：没有面向对象易维护、易复用、易扩展</p><h4 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h4><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><h4 id="面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。"><a href="#面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。" class="headerlink" title="面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。"></a>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</h4><h4 id="面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。"><a href="#面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。" class="headerlink" title="面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。"></a>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</h4><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><h4 id="面向对象的特征主要有以下几个方面："><a href="#面向对象的特征主要有以下几个方面：" class="headerlink" title="面向对象的特征主要有以下几个方面："></a>面向对象的特征主要有以下几个方面：</h4><p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p>封装</p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p>继承</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p>多态</p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>其中Java 面向对象编程三大特性：封装 继承 多态</p><p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p><h4 id="关于继承如下-3-点请记住："><a href="#关于继承如下-3-点请记住：" class="headerlink" title="关于继承如下 3 点请记住："></a>关于继承如下 3 点请记住：</h4><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><p>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul><h4 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p>继承：在多态中必须存在有继承关系的子类和父类。</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ul><li>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p><p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p><p>成员变量：方法外部，类内部定义的变量</p><p>局部变量：类的方法中的变量。</p><p>成员变量和局部变量的区别</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>成员变量：针对整个类有效。</p><p>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><h4 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h4><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</p><p>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p><p>局部变量：当方法调用完，或者语句结束后，就自动释放。</p><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>成员变量：有默认初始值。</p><p>局部变量：没有默认初始值，使用前必须赋值。</p><p>使用原则</p><p>在使用变量时需要遵循的原则为：就近原则</p><p>首先在局部范围找，有就使用；接着在成员位置找。</p><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>帮助子类做初始化工作。</p><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><p>名字与类名相同；</p><p>没有返回值，但不能用void声明构造函数；</p><p>生成类的对象时自动执行，无需调用。</p><h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p><h4 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p>静态方法和实例方法的区别主要体现在两个方面：</p><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h4 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是 <strong>内部类</strong> 。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><h4 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h4><p>内部类可以分为四种： <strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong> 。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义在类内部的静态类，就是静态内部类。</p><p>public class Outer { <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> radius = <span class="hljs-number">1</span>;  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInner</span> </span>{     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>{         System.out.println(<span class="hljs-string">“visit outer static  variable:”</span> + radius);     } }</p><p><code>&#125;</code></p><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式， <code>new 外部类.静态内部类()</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner &#x3D; new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><p>public class Outer { <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span> radius = <span class="hljs-number">1</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> =<span class="hljs-number">2</span>;   <span class="hljs-keyword">class</span> Inner {     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> visit() {         System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">“visit outer static  variable:”</span> + radius);         System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">“visit outer   variable:”</span> + <span class="hljs-keyword">count</span>);     } }</p><p><code>&#125;</code></p><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式 <code>外部类实例.new 内部类()</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner inner &#x3D; outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的内部类，就是局部内部类。</p><p>public class Outer { private  <span class="hljs-type">int</span> out_a = <span class="hljs-number">1</span>; private static <span class="hljs-type">int</span> STATIC_b = <span class="hljs-number">2</span>;  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testFunctionClass(){     <span class="hljs-type">int</span> inner_c =<span class="hljs-number">3</span>;     <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> {         private <span class="hljs-type">void</span> fun(){             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(out_a);             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(STATIC_b);             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(inner_c);         }     }     <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();     <span class="hljs-keyword">inner</span>.fun(); } <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> testStaticFunctionClass(){     <span class="hljs-type">int</span> d =<span class="hljs-number">3</span>;     <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> {         private <span class="hljs-type">void</span> fun(){             // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(STATIC_b);             <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(d);         }     }     <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();     <span class="hljs-keyword">inner</span>.fun(); }</p><p><code>&#125;</code></p><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内， <code>new 内部类()</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void testStaticFunctionClass()&#123;</span><br><span class="line">class Inner &#123;</span><br><span class="line">&#125;</span><br><span class="line">Inner  inner &#x3D; new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><p>public class Outer { <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>{     <span class="hljs-keyword">new</span> Service() {         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>{             <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {                 System.out.println(<span class="hljs-string">“匿名内部类”</span> );             }         }     }.method(); }</p><p><code>&#125; //匿名内部类必须继承或实现一个已有的接口  interface Service&#123; void method(); &#125;</code></p><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><p>匿名内部类创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类&#x2F;接口&#123;</span><br><span class="line">&#x2F;&#x2F;匿名内部类实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h4><p>我们为什么要使用内部类呢？因为它有以下优点：</p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h4 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h4><ol><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ol><h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</p><p>先看这段代码：</p><p>public class Outer { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outMethod</span><span class="hljs-params">()</span></span>{     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a =<span class="hljs-number">10</span>;     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerMethod</span><span class="hljs-params">()</span></span>{             System.out.println(a);         }      } }</p><p><code>&#125;</code></p><p>以上例子，为什么要加final呢？是因为 <strong>生命周期不一致</strong> ， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><h4 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h4><p>public class Outer { private int age = 12; <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> {     private <span class="hljs-type">int</span> age = <span class="hljs-number">13</span>;     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> print() {         <span class="hljs-type">int</span> age = <span class="hljs-number">14</span>;         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“局部变量：” + age);         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“内部类变量：” + this.age);         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“外部类变量：” + <span class="hljs-keyword">Outer</span>.this.age);     } }  <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) {     <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">in</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();     <span class="hljs-keyword">in</span>.print(); }</p><p><code>&#125;</code></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：14</span><br><span class="line">内部类变量：13</span><br><span class="line">外部类变量：12</span><br></pre></td></tr></table></figure><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p><h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="== 和 equals 的区别是什么"></a>== 和 equals 的区别是什么</h4><p>: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p><p>equals(): 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“”比较这两个对象。</p><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; a 为一个引用</span><br><span class="line">String b &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; b为另一个引用,对象的内容一样</span><br><span class="line">String aa &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 放在常量池中</span><br><span class="line">String bb &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 从常量池中查找</span><br><span class="line">if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true</span><br><span class="line">System.out.println(&quot;aabb&quot;);</span><br><span class="line">if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象</span><br><span class="line">System.out.println(&quot;ab&quot;);</span><br><span class="line">if (a.equals(b)) &#x2F;&#x2F; true</span><br><span class="line">System.out.println(&quot;aEQb&quot;);</span><br><span class="line">if (42 &#x3D;&#x3D; 42.0) &#123; &#x2F;&#x2F; true</span><br><span class="line">System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h4><p>HashSet如何检查重复</p><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p><p>hashCode和equals方法的关系</p><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><h4 id="我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode："><a href="#我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode：" class="headerlink" title="我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode："></a>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</h4><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h4 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h4><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><h4 id="因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖"><a href="#因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖" class="headerlink" title="因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖"></a>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</h4><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。 按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><h4 id="Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。"><a href="#Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。" class="headerlink" title="Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。"></a>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</h4><h4 id="下面通过-3-个例子来给大家说明"><a href="#下面通过-3-个例子来给大家说明" class="headerlink" title="下面通过 3 个例子来给大家说明"></a>下面通过 3 个例子来给大家说明</h4><p>example 1</p><p>public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2);  <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“num1 = “ + num1); <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“num2 = “ + num2);  } public static void swap(int a, int b) { int temp = a; a = b; b = temp; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“a = “ + a); <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“b = “ + b);</p><p><code>&#125;</code></p><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><h4 id="通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看-example2"><a href="#通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看-example2" class="headerlink" title="通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2."></a>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</h4><p>example 2</p><p>public class Test { <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) {     // TODO Auto-<span class="hljs-keyword">generated</span> <span class="hljs-keyword">method</span> stub     Student s1 = <span class="hljs-built_in">new</span> Student(“小张”);     Student s2 = <span class="hljs-built_in">new</span> Student(“小李”);     Test.swap(s1, s2);     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“s1:” + s1.getName());     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“s2:” + s2.getName()); }  <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(Student x, Student y) {     Student <span class="hljs-keyword">temp</span> = x;     x = y;     y = <span class="hljs-keyword">temp</span>;     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“x:” + x.getName());     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“y:” + y.getName()); }</p><p><code>&#125;</code></p><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><p>交换之前：</p><p>交换之后：</p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p><p>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h4 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h4><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p>按操作对象分类结构图：</p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><p>简答</p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><p>详细回答</p><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>静态编译和动态编译</p><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul><h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p><h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private int id;</span><br><span class="line">String name;</span><br><span class="line">protected boolean sex;</span><br><span class="line">public float score;</span><br><span class="line">&#125;</span><br><span class="line">public class Get &#123;</span><br><span class="line">&#x2F;&#x2F;获取反射机制三种方式</span><br><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">&#x2F;&#x2F;方式一(通过建立对象)</span><br><span class="line">Student stu &#x3D; new Student();</span><br><span class="line">Class classobj1 &#x3D; stu.getClass();</span><br><span class="line">System.out.println(classobj1.getName());</span><br><span class="line">&#x2F;&#x2F;方式二（所在通过路径-相对路径）</span><br><span class="line">Class classobj2 &#x3D; Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">System.out.println(classobj2.getName());</span><br><span class="line">&#x2F;&#x2F;方式三（通过类名）</span><br><span class="line">Class classobj3 &#x3D; Student.class;</span><br><span class="line">System.out.println(classobj3.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ol><h4 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><h4 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h4><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><h4 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h4><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h4 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final char value[];</span><br></pre></td></tr></table></figure><h4 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p><h4 id="1-String不可变但不代表引用不可以变"><a href="#1-String不可变但不代表引用不可以变" class="headerlink" title="1) String不可变但不代表引用不可以变"></a>1) String不可变但不代表引用不可以变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;Hello&quot;;</span><br><span class="line">str &#x3D; str + &quot; World&quot;;</span><br><span class="line">System.out.println(&quot;str&#x3D;&quot; + str);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str&#x3D;Hello World</span><br></pre></td></tr></table></figure><p>解析：</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><h4 id="2-通过反射是可以修改所谓的“不可变”对象"><a href="#2-通过反射是可以修改所谓的“不可变”对象" class="headerlink" title="2) 通过反射是可以修改所谓的“不可变”对象"></a>2) 通过反射是可以修改所谓的“不可变”对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建字符串&quot;Hello World&quot;， 并赋给引用s</span><br><span class="line">String s &#x3D; &quot;Hello World&quot;;</span><br><span class="line">System.out.println(&quot;s &#x3D; &quot; + s); &#x2F;&#x2F; Hello World</span><br><span class="line">&#x2F;&#x2F; 获取String类中的value字段</span><br><span class="line">Field valueFieldOfString &#x3D; String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line">&#x2F;&#x2F; 改变value属性的访问权限</span><br><span class="line">valueFieldOfString.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F; 获取s对象上的value属性的值</span><br><span class="line">char[] value &#x3D; (char[]) valueFieldOfString.get(s);</span><br><span class="line">&#x2F;&#x2F; 改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] &#x3D; &#39;_&#39;;</span><br><span class="line">System.out.println(&quot;s &#x3D; &quot; + s); &#x2F;&#x2F; Hello_World</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; Hello World</span><br><span class="line">s &#x3D; Hello_World</span><br></pre></td></tr></table></figure><p>解析：</p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><h4 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h4><p>String 类是 final 类，不可以被继承。</p><h4 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;hello&quot;; &#x2F;&#x2F;str1指向静态区</span><br><span class="line">String str2 &#x3D; new String(&quot;hello&quot;);  &#x2F;&#x2F;str2指向堆上的对象</span><br><span class="line">String str3 &#x3D; &quot;hello&quot;;</span><br><span class="line">String str4 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">System.out.println(str1.equals(str2)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str2.equals(str4)); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; str4); &#x2F;&#x2F;false</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;false</span><br><span class="line">str2 &#x3D; str1;</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; &quot;hello&quot;); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba</span><br><span class="line">&#x2F;&#x2F; StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba</span><br></pre></td></tr></table></figure><h4 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h4><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p><h4 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><h4 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>String类中使用字符数组保存字符串，privatefinalcharvalue[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h4 id="对于三者使用的总结"><a href="#对于三者使用的总结" class="headerlink" title="对于三者使用的总结"></a>对于三者使用的总结</h4><p>如果要操作少量的数据用 = String</p><p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p><p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p><h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="Integer a= 127 与 Integer b = 127相等吗"></a>Integer a= 127 与 Integer b = 127相等吗</h4><p>对于对象引用类型：比较的是对象的内存地址。</p><p>对于基本数据类型：比较的是值。</p><p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p><p>public static void main(String[] args) { Integer a = new Integer(3); Integer b = 3;  // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true <span class="hljs-type">Integer</span> a1 = <span class="hljs-number">128</span>; <span class="hljs-type">Integer</span> b1 = <span class="hljs-number">128</span>; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a1 == b1); // <span class="hljs-keyword">false</span>  <span class="hljs-type">Integer</span> a2 = <span class="hljs-number">127</span>; <span class="hljs-type">Integer</span> b2 = <span class="hljs-number">127</span>; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a2 == b2);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Wireshark 学习心得</title>
    <link href="http://example.com/2021/07/11/Wireshark-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>http://example.com/2021/07/11/Wireshark-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</id>
    <published>2021-07-11T04:50:01.000Z</published>
    <updated>2021-07-11T06:17:38.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>首先介绍软件基本页面布局和功能</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711135223797.png" alt="image-20210711135223797"></p><p>如图：</p><p>包括最上方的选向窗口和下面的工具栏</p><table><thead><tr><th>名称</th><th>功能</th><th>补充</th></tr></thead><tbody><tr><td>文件</td><td>包括文件存储</td><td></td></tr><tr><td>编辑</td><td></td><td></td></tr><tr><td>视图</td><td></td><td></td></tr><tr><td>跳转</td><td></td><td></td></tr><tr><td>捕获</td><td></td><td></td></tr><tr><td>分析</td><td>捕获信息的分析</td><td></td></tr><tr><td>统计</td><td>对于所捕获信息的统计</td><td></td></tr><tr><td>电话</td><td></td><td></td></tr><tr><td>无线</td><td></td><td></td></tr></tbody></table><h1 id="2-过滤"><a href="#2-过滤" class="headerlink" title="2.过滤"></a>2.过滤</h1><p>接着重点是Wirshark的过滤功能，通过过滤器可以筛选许多不必要的信息，（设置 Caputure Filter 之前一定要三思而后行，避免筛除有用的包）</p><p>过滤是wireshark最难，最有趣的地方，值得深入学习。</p><p>wireshark还设置了查找功能，如果对于过滤命令不够熟悉，可是使用查找功能进行筛选，效果是一样的。具体操作：</p><ul><li>点击感兴趣的一条内容–&gt;右键 Prepare a filter–&gt;select–》自动生成过滤表达式</li></ul><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711135015254.png" alt="image-20210711135015254" style="zoom:80%;" /><p>以下是常用的筛选命令：来自 <a href="https://www.wireshark.org/">Wireshark官网</a> ,过多信息在此不做赘述，具体参见    Wireshark User’s Guide&amp;&amp;<a href="https://www.wireshark.org/docs/dfref/">参考标准</a></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>在过滤器中输入IP.之后会有相应的显示，和java的方法类似</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711130532533.png" alt="image-20210711130532533"></p><p>常见的IP筛选如下:</p><table><thead><tr><th>FIELD NAME</th><th>DESCRIPTION</th><th>TYPE</th></tr></thead><tbody><tr><td>ip.addr</td><td>Source or Destination Address</td><td>IPv4 address</td></tr><tr><td>ip.dst</td><td>Destination Address</td><td>IPv4 address</td></tr><tr><td>ip.id</td><td>Identification</td><td>Unsigned integer, 2 bytes</td></tr><tr><td>ip.len</td><td>Total Length</td><td>Unsigned integer, 2 bytes</td></tr><tr><td>ip.flags</td><td>Flags</td><td>Unsigned integer, 1 byte</td></tr><tr><td>ip.opt.mtu</td><td>MTU</td><td>Unsigned integer, 2 bytes</td></tr><tr><td>ip.src</td><td>Source Address</td><td>IPv4 address</td></tr><tr><td>ip.src_host</td><td>Source Host</td><td>Character string</td></tr><tr><td>ip.ttl</td><td>Time to Live</td><td>Unsigned integer, 1 byte</td></tr><tr><td>ip.version</td><td>Version</td><td>Unsigned integer, 1 byte</td></tr></tbody></table><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Capture only traffic to or from IP address 172.18.5.4:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host 172.18.5.4</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic to or from a range of IP addresses:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure></li></ul><p>or</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net 192.168.0.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic from a range of IP addresses:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure></li></ul><p>or</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src net 192.168.0.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic to a range of IP addresses:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure></li></ul><p>or</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst net 192.168.0.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure></li></ul><p>Capture only DNS (port 53) traffic:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 53</span><br></pre></td></tr></table></figure></li></ul><p>Capture non-HTTP and non-SMTP traffic on your server (both are equivalent):</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host www.example.com and not (port 80 or port 25)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host www.example.com and not port 80 and not port 25</span><br></pre></td></tr></table></figure></li></ul><p>Capture except all ARP and DNS traffic:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port not 53 and not arp</span><br></pre></td></tr></table></figure></li></ul><p>Capture traffic within a range of ports</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tcp[0:2] &gt; 1500 and tcp[0:2] &lt; 1550) or (tcp[2:2] &gt; 1500 and tcp[2:2] &lt; 1550)</span><br></pre></td></tr></table></figure></li></ul><p>or, with newer versions of libpcap (0.9.1 and later):</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp portrange 1501-1549</span><br></pre></td></tr></table></figure></li></ul><p>Capture only Ethernet type EAPOL:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ether proto 0x888e</span><br></pre></td></tr></table></figure></li></ul><p>Reject ethernet frames towards the Link Layer Discovery Protocol Multicast group:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not ether dst 01:80:c2:00:00:0e</span><br></pre></td></tr></table></figure></li></ul><p>Capture only IPv4 traffic - the shortest filter, but sometimes very useful to get rid of lower layer protocols like ARP and STP:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip</span><br></pre></td></tr></table></figure></li></ul><p>Capture only unicast traffic - useful to get rid of noise on the network if you only want to see traffic to and from your machine, not, for example, broadcast and multicast announcements:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not broadcast and not multicast</span><br></pre></td></tr></table></figure></li></ul><p>Capture IPv6 “all nodes” (router and neighbor advertisement) traffic. Can be used to find rogue RAs:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst host ff02::1</span><br></pre></td></tr></table></figure></li></ul><p>Capture HTTP GET requests. This looks for the bytes ‘G’, ‘E’, ‘T’, and ‘ ‘ (hex values 47, 45, 54, and 20) just after the TCP header. “tcp[12:1] &amp; 0xf0) &gt;&gt; 2” figures out the TCP header length. From Jefferson Ogata via the <a href="http://seclists.org/tcpdump/2004/q4/95">tcpdump-workers mailing list</a>.</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 80 and tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] &#x3D; 0x47455420</span><br></pre></td></tr></table></figure></li></ul><h2 id="Useful-Filters"><a href="#Useful-Filters" class="headerlink" title="Useful Filters"></a>Useful Filters</h2><p>Blaster and Welchia are RPC worms. (Does anyone have better links, i.e. ones that describe or show the actual payload?)</p><p><a href="http://www.sans.org/security-resources/malwarefaq/w32_blasterworm.php">Blaster worm</a>:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst port 135 and tcp port 135 and ip[2:2]&#x3D;&#x3D;48</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://securityresponse.symantec.com/avcenter/venc/data/detecting.traffic.due.to.rpc.worms.html">Welchia worm</a>:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icmp[icmptype]&#x3D;&#x3D;icmp-echo and ip[2:2]&#x3D;&#x3D;92 and icmp[8:4]&#x3D;&#x3D;0xAAAAAAAA</span><br></pre></td></tr></table></figure><p>The filter looks for an icmp echo request that is 92 bytes long and has an icmp payload that begins with 4 bytes of A’s (hex). It is the signature of the welchia worm just before it tries to compromise a system.</p></li></ul><p>Many worms try to spread by contacting other hosts on ports 135, 445, or 1433. This filter is independent of the specific worm instead it looks for SYN packets originating from a local network on those specific ports. Please change the network filter to reflect your own network.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst port 135 or dst port 445 or dst port 1433  and tcp[tcpflags] &amp; (tcp-syn) !&#x3D; 0 and tcp[tcpflags] &amp; (tcp-ack) &#x3D; 0 and src net 192.168.0.0&#x2F;24</span><br></pre></td></tr></table></figure><p><a href="https://web.archive.org/web/20140419183909/http://www.riverbed.com/blogs/Retroactively-detecting-a-prior-Heartbleed-exploitation-from-stored-packets-using-a-BPF-expression.html">Heartbleed Exploit</a>:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp src port 443 and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) * 4] &#x3D; 0x18) and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) * 4 + 1] &#x3D; 0x03) and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) * 4 + 2] &lt; 0x04) and ((ip[2:2] - 4 * (ip[0] &amp; 0x0F)  - 4 * ((tcp[12] &amp; 0xF0) &gt;&gt; 4) &gt; 69))</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-常见功能"><a href="#3-常见功能" class="headerlink" title="3.常见功能"></a>3.常见功能</h1><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h3><p>在wireshark中的分析选项中</p><ul><li><p>Analyze–&gt;Export info Composite</p></li><li><p>statistics–&gt;service response time–&gt;选定相关协议响应（<strong>时间统计表</strong>）———-衡量服务器性能</p></li><li><p>statistic–&gt;TCP Stream Graph   (<strong>信息统计图</strong>)</p></li></ul><h3 id="2-搜索功能"><a href="#2-搜索功能" class="headerlink" title="2.搜索功能"></a>2.搜索功能</h3><ul><li><p>快捷键：ctrl+f</p></li><li><p>效果图：</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210711140444529.png" alt="image-20210711140444529" style="zoom:200%;" /></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.基本介绍&quot;&gt;&lt;/a&gt;1.基本介绍&lt;/h1&gt;&lt;p&gt;首先介绍软件基本页面布局和功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\ASUS\AppData</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初步理解JAVA 虚拟机（黑马）</title>
    <link href="http://example.com/2021/06/20/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E9%BB%91%E9%A9%AC%EF%BC%89/"/>
    <id>http://example.com/2021/06/20/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E9%BB%91%E9%A9%AC%EF%BC%89/</id>
    <published>2021-06-20T12:12:56.000Z</published>
    <updated>2021-06-20T12:36:49.468Z</updated>
    
    <content type="html"><![CDATA[<p> 定义：java Virtural Machine  （java二进制代码<strong>运行环境</strong>）</p><p>优点：</p><ul><li><p>一次编写，到处运行</p></li><li><p>自动内存管理，垃圾回收机制</p></li><li><p>数组下标越界检查</p></li><li><p>多态机制</p></li></ul><p>JVM屏蔽java和底层操作系统的差异：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618122158873.png" alt="image-20210618122158873"></p><p>常见JVM：</p><p>学习路线：<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618122633191.png" alt="image-20210618122633191"></p><h1 id="一-内存结构"><a href="#一-内存结构" class="headerlink" title="一.内存结构"></a>一.内存结构</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps1.png" alt="img"></p><p>\1. 程序计数器</p><p>\2. 虚拟机栈</p><p>\3. 本地方法栈</p><p>\4. 堆</p><p>\5. 方法区</p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器     "></a>1. 程序计数器    <a href="af://n31/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps2.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps3.png" alt="img"> </p><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><ul><li><p>特点：</p><p>Program Counter Register 程序计数器（寄存器</p><ul><li><p>作用：记住下一条jvm指令的执行地址</p></li><li><p>是线程私有的</p></li><li><p><strong>不会存在内存溢出</strong> </p></li></ul></li></ul><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><p> 线程私有的，每个线程都有自身计数器</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618131139123.png" alt="image-20210618131139123">  </p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li><p>（虚拟机）栈：每个线程运行时所需要的内存   </p></li><li><p>每个栈由多个栈帧（Frame）组成</p></li><li><p>栈帧（Frame）：一个方法运行时需要的内存</p></li><li><p>每个线程只能有一个活动栈帧（正在执行的方法）</p></li></ul><p><strong>问题辨析</strong></p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>-栈内存自动清除，垃圾是对堆得数据进行回收 </p></li><li><p>栈内存分配越大越好吗？</p><p>栈内存越大，可同时运行的线程会减少，一般不建议增大内存</p></li><li><p>方法内的局部变量是否线程安全？</p><p>取决于使用的局部变量是否共享</p></li></ol><ul><li><p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围（return 返回），需要考虑线程安全 </p></li></ul><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p>报错显示 <strong>java.lang.StackOverflowError</strong></p><ul><li><p>栈帧过多导致栈内存溢出</p><p>例：方法递归调用</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618133324333.png" alt="image-20210618133324333" style="zoom:25%;" /></li><li><p>栈帧过大导致栈内存溢出</p> <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618133359416.png" alt="image-20210618133359416" style="zoom:25%;" /></li></ul><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><p>案例1： cpu 占用过多定位</p><p>用top定位哪个进程对cpu的占用过高</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps10.png" alt="img">ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） jstack 进程id</p><p>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>案例2：程序运行很长时间没有结果</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps11.png" alt="img"></p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps12.png" alt="img"></p><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存特点</li></ul><p>它是线程共享的，堆中对象都需要考虑线程安全的问题  </p><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><ol><li>jps 工具</li></ol><ul><li> 查看当前系统中有哪些 java 进程</li></ul><ol start="2"><li><p>jmap 工具 <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps16.png" alt="img"> 查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具</p><p>图形界面的，多功能的监测工具，可以连续监测</p></li></ol><p>案例 ： 垃圾回收后，内存占用仍然很高</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps19.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps20.png" alt="img"> </p><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">J</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">VM</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">规范</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">-</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">方法区定义</a></p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成     "></a>5.2 组成    <a href="af://n248/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps21.png" alt="img"></p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出     "></a>5.3 方法区内存溢出    <a href="af://n265/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps22.png" alt="img">    1.8 以前会导致永久代内存溢出</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps23.png" alt="img"></p><p> 场景</p><p>​    mybatis</p><p>​    spring </p><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池     "></a>5.4 运行时常量池    <a href="af://n325/"> </a></h3><ul><li><p>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p></li><li><p>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p></li></ul><h3 id="5-5-StringTable-先看几道面试题："><a href="#5-5-StringTable-先看几道面试题：" class="headerlink" title="5.5 StringTable     先看几道面试题："></a>5.5 StringTable    <a href="af://n350/"> </a>先看几道面试题：</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps26.png" alt="img"></p><h3 id="5-5-StringTable-特性"><a href="#5-5-StringTable-特性" class="headerlink" title="5.5 StringTable 特性     "></a>5.5 StringTable 特性    <a href="af://n353/"> </a></h3><p>常量池中的字符串仅是符号，第一次用到时才变为对象利用串池的机制，来避免重复创建字符串对象</p><ul><li><p>字符串变量拼接的原理是 StringBuilder （1.8)字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用 <strong>intern</strong> 方法，主动将串池中还没有的字符串对象放入串池</p></li></ul><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</p><p>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回</p><h3 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置     "></a>5.6 StringTable 位置    <a href="af://n375/"> </a></h3><h3 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收     "></a>5.7 StringTable 垃圾回收    <a href="af://n388/"> </a></h3><h3 id="5-8-StringTable-性能调优"><a href="#5-8-StringTable-性能调优" class="headerlink" title="5.8 StringTable 性能调优     "></a>5.8 StringTable 性能调优    <a href="af://n401/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps28.png" alt="img"> 调整 -XX:StringTableSize=桶个数</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps29.png" alt="img"> 考虑将字符串对象是否入池</p><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h2 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义     "></a>6.1 定义    <a href="af://n432/"> </a></h2><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区分配回收成本较高，但读写性能高不受 JVM 内存回收管理</li></ul><h3 id="6-2-分配和回收原理"><a href="#6-2-分配和回收原理" class="headerlink" title="6.2 分配和回收原理     "></a>6.2 分配和回收原理    <a href="af://n452/"> </a></h3><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，</li><li>使用了 Cleaner （虚引用)来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><h1 id="二-垃圾回收"><a href="#二-垃圾回收" class="headerlink" title="二.垃圾回收"></a>二.垃圾回收</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps33.png" alt="img"></p><ol><li><p> 如何判断对象可以回收</p></li><li><p> 垃圾回收算法</p></li><li><p> 分代垃圾回收</p></li><li><p> 垃圾回收器</p></li><li><p> 垃圾回收调优</p></li></ol><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps34.png" alt="img"> </p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><ol><li><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收</p></li><li><p>哪些对象可以作为 GC Root ?</p></li></ol><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><ol><li> 强引用</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps38.png" alt="img"> 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><ol start="2"><li><p>软引用（SoftReference）</p><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</p></li></ol><p>可以配合引用队列来释放软引用自身</p><ol start="3"><li><p>弱引用（WeakReference）</p><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象可以配合引用队列来释放弱引用自身</p></li><li><p>虚引用（PhantomReference）</p><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li><li><p>终结器引用（FinalReference）</p><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p></li></ol><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1标记回收"><a href="#2-1标记回收" class="headerlink" title="2.1标记回收"></a>2.1标记回收</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps43.png" alt="img"></p><ol><li>标记可回收垃圾</li><li>回收垃圾</li></ol><ul><li>优点：速度快效率高</li><li>缺点：造成内存碎片（内存空间不连续）</li></ul><h2 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理     "></a>2.2 标记整理    <a href="af://n170/"> </a></h2><p>定义：Mark Compact <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps44.png" alt="img"> 速度慢</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps45.png" alt="img"></p><ol><li>标记可回收垃圾（存活多）</li><li>回收垃圾（内存空间向前移动）</li></ol><ul><li>优点：速度较慢（设计地址的变化等操作）</li><li>缺点：不会造成内存碎片 </li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制     "></a>2.3 复制    <a href="af://n188/"> </a></h3><p>定义：Copy</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps46.png" alt="img"></p><p>把可以保存的对象复制到另一份内存空间，并交换from和to</p><ul><li><p>优点：没有内存碎片</p></li><li><p>占用双倍的内存空间 </p></li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收     "></a>3. 分代垃圾回收    <a href="af://n207/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps47.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps48.png" alt="img"> </p><ol><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中（其他对象空间 被回收），存活的对象年龄加 1并且交换 from to</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215049838.png" alt="image-20210619215049838"></p></li><li><p>minor gc 会引发 stop the world（避免线程混乱，涉及地质改变），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215117828.png" alt="image-20210619215117828"></p></li><li><p>当老年代空间不足，会先尝试触发 minor gc（初级垃圾清除），如果之后空间仍不足，那么触发 full gc，STW的时间更长</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215139218.png" alt="image-20210619215139218"></p></li></ol><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数     "></a>3.1 相关 VM 参数    <a href="af://n224/"> </a></h3><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><p> <strong>大对象直接送到老年代机制</strong></p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器    @@@@@"></a>4. 垃圾回收器    @@@@@</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps50.png" alt="img"></p><ol><li><p>串行</p><ul><li>底层是单线程，- </li><li>适用于堆内存较小，适合个人电脑</li></ul></li><li><p>吞吐量优先</p><ul><li>多线程</li><li>适用于堆内存较大，多核 cpu </li><li>让<strong>单位时间</strong>内，STW 的时间最短 0.2 0.2 = 4，垃圾回收时间占比最低，这样就称吞吐量高</li></ul></li><li><p>响应时间优先</p><ul><li><p>多线程</p></li><li><p>适用于堆内存较大，</p></li><li><p>多核 cpu</p></li><li><p>尽可能让单次 STW 的单次时间最短     0.1 0.1 0.1 0.1 0.1 = 0.5</p></li></ul></li></ol><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行     "></a>4.1 串行    <a href="af://n311/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps54.png" alt="img"></p><ol><li>空间不足</li><li>在安全点暂停（阻塞）——-》开启单个垃圾回收线程</li><li>垃圾回收完成————》线程继续</li></ol><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><p>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps56.png" alt="img"></p><ol><li> 内存空间不足</li><li> 在安全点暂停（阻塞）——-》开启多个垃圾回收线程（）</li><li> 垃圾回收完成————》线程继续</li></ol><h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先     "></a>4.3 响应时间优先    <a href="af://n341/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps57.png" alt="img"></p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1     "></a>4.4 G1    <a href="af://n363/"> </a></h3><p>定义：Garbage First</p><ul><li><p>2004 论文发布</p></li><li><p>2009 JDK 6u14 体验</p></li><li><p>2012 JDK 7u4 官方支持 </p></li><li><p>2017 JDK 9 默认成为垃圾回收器</p></li></ul><p>适用场景</p><ul><li><p>同时注重吞吐量（Throughput）和低延迟（Low latency)，默认的暂停目标是 200 ms</p></li><li><p>超大堆内存，会将堆划分为多个大小相等的 Region </p></li><li><p>整体上是<strong>标记+整理算法</strong>，两个区域之间是<strong>复制算法</strong></p></li><li><p>相关 JVM 参数</p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize=size</p><p>-XX:MaxGCPauseMillis=time</p></li></ul><h4 id="1-G1-垃圾回收阶段"><a href="#1-G1-垃圾回收阶段" class="headerlink" title="1) G1 垃圾回收阶段"></a>1) G1 垃圾回收阶段</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps63.png" alt="img"> </p><h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection     "></a>2) Young Collection    <a href="af://n406/"> </a></h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps64.png" alt="img"> 会 STW</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps65.png" alt="img"> </p><p> S:幸存区</p><p>O:老年代</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps66.png" alt="img"> </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps67.png" alt="img"> </p><h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM     "></a>3) Young Collection + CM    <a href="af://n436/"> </a></h4><ul><li><p>在 Young GC 时会进行 GC Root 的初始标记</p></li><li><p>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定 </p></li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps69.png" alt="img"></p><h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>混合收集阶段</p><ul><li>会对 E、S、O 进行全面垃圾回收最终标记（Remark）会 STW </li><li>拷贝存活（Evacuation）会 STW </li><li>不是所有老年代都被回收，优先回收垃圾最多的标记，</li></ul><p>-XX:MaxGCPauseMillis=ms</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps71.png" alt="img"> </p><h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC     "></a>5) Full GC    <a href="af://n459/"> </a></h4><ul><li><p>SerialGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p></li><li><p>ParallelGC </p><p>新生代内存不足发生的垃圾收集 - minor gc </p><p>老年代内存不足发生的垃圾收集- </p></li><li><p>full gc</p><p>新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足</p><p>新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足</p></li></ul><h4 id="6）Young-Collection跨代引用"><a href="#6）Young-Collection跨代引用" class="headerlink" title="6）Young Collection跨代引用"></a>6）Young Collection跨代引用</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps73.png" alt="img"></p><p> 老年代引用了新生代被标记成脏卡区</p><p> 垃圾回收时，对脏卡去进行查找，加快垃圾回收速度</p><ul><li><p>卡表与 Remembered Set</p></li><li><p>在引用变更时通过 <strong>post-write barrier</strong> （标记脏卡）+ dirty card queue </p></li><li><p>concurrent refinement threads 更新 Remembered Set</p></li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps75.png" alt="img"> </p><h4 id="7-Remark"><a href="#7-Remark" class="headerlink" title="7) Remark     "></a>7) Remark    <a href="af://n530/"> </a></h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps76.png" alt="img"></p><p> 注：黑色处理完；    灰色正在处理；    白色尚未处理</p><p>并发标记阶段，如果回收期间引用关系发生了改变：</p><ol><li><p>C被A 引用（A是根引用）</p></li><li><p>C就会被添加<strong>写屏障</strong>，进入队列中，被<strong>重新标记</strong>成灰色</p></li><li><p>并发标记结束，进入重新标记阶段（remark），其他线程结束</p></li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620100531126.png" alt="image-20210620100531126"></p><h4 id="8-JDK-8u20-字符串去重"><a href="#8-JDK-8u20-字符串去重" class="headerlink" title="8) JDK 8u20 字符串去重"></a>8) JDK 8u20 字符串去重</h4><p>优点：节省大量内存</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps77.png" alt="img">优点：节省大量内存</p><h4 id="9-JDK-8u40-并发标记类卸载"><a href="#9-JDK-8u40-并发标记类卸载" class="headerlink" title="9) JDK 8u40 并发标记类卸载"></a>9) JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4 id="10-JDK-8u60-回收巨型对象"><a href="#10-JDK-8u60-回收巨型对象" class="headerlink" title="10) JDK 8u60 回收巨型对象     "></a>10) JDK 8u60 回收巨型对象    <a href="af://n587/"> </a></h4><ul><li><p>一个对象大于 region 的一半时，称之为巨型对象 </p></li><li><p>G1 不会对巨型对象进行拷贝</p></li><li><p>回收时被优先考虑</p></li><li><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉(回收得越早越好)</p></li></ul><h4 id="11-JDK-9-并发标记起始时间的调整"><a href="#11-JDK-9-并发标记起始时间的调整" class="headerlink" title="11) JDK 9 并发标记起始时间的调整     "></a>11) JDK 9 并发标记起始时间的调整    <a href="af://n614/"> </a></h4><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p><ul><li><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent（默认45%)</p></li><li><p>JDK 9 可以动态调整</p></li><li><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p></li><li><p>进行数据采样并动态调整</p></li><li><p>总会添加一个安全的空档空间</p></li><li></li></ul><h4 id="12-JDK-9-更高效的回收"><a href="#12-JDK-9-更高效的回收" class="headerlink" title="12) JDK 9 更高效的回收     "></a>12) JDK 9 更高效的回收    <a href="af://n645/"> </a></h4><p>250+增强</p><p>180+bug修复</p><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">j</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">ava/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">j</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">avase/12/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">g</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">ctunin</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">g</a></p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优     "></a>5. 垃圾回收调优    <a href="af://n670/"> </a></h2><p>预备知识</p><ul><li><p>掌握 GC 相关的 VM 参数，会基本的空间调整掌握相关工具</p></li><li><p>知识点：调优跟应用、环境有关，没有放之四海而皆准的法则</p></li></ul><h3 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps85.png" alt="img">内存锁竞争</p><p>cpu 占用 io</p><h3 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h3><p>【低延迟】还是【高吞吐量】，选择合适的回收器</p><p>CMS，G1，ZGC</p><p>ParallelGC</p><h3 id="5-3-最快的-GC"><a href="#5-3-最快的-GC" class="headerlink" title="5.3 最快的 GC     "></a>5.3 最快的 GC    <a href="af://n742/"> </a></h3><p>答案是不发生 GC 查看 FullGC 前后的内存占用，考虑下面几个问题</p><p>数据是不是太多？</p><p>resultSet = statement.executeQuery(“select * from 大表 limit n”) 数据表示是否太臃肿？</p><p>对象图</p><p>对象大小 16 Integer 24 int 4 是否存在内存泄漏？</p><p>static Map map =</p><p>软弱第三方缓存实现</p><h3 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优     "></a>5.4 新生代调优    <a href="af://n798/"> </a></h3><p>新生代的特点所有的 new 操作的内存分配非常廉价</p><p>TLAB thread-local allocation buffer 死亡对象的回收代价是零大部分对象用过即死</p><p>Minor GC 的时间远远低于 Full GC</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps89.png" alt="img"> 越大越好吗？</p><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps90.png" alt="img">新生代能容纳所有【并发量 * (请求-响应)】的数据幸存区大到能保留【当前活跃对象+需要晋升对象】</p><h3 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优     "></a>5.5 老年代调优    <a href="af://n860/"> </a></h3><p>以 CMS 为例</p><p>CMS 的老年代内存越大越好</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps91.png" alt="img">先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</p><p>-XX:CMSInitiatingOccupancyFraction=percent</p><h3 id="5-6-案例"><a href="#5-6-案例" class="headerlink" title="5.6 案例     "></a>5.6 案例    <a href="af://n882/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps92.png" alt="img">案例1 Full GC 和 Minor GC频繁</p><p>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</p><h1 id="三-类加载与字节码技术"><a href="#三-类加载与字节码技术" class="headerlink" title="三. 类加载与字节码技术"></a>三. 类加载与字节码技术</h1><p> 类加载与字节码技术     </p><ol><li>类文件结构 </li><li>字节码指令 </li><li>编译期处理</li><li>类加载阶</li><li>类加载器</li><li>运行期优化</li></ol><h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h2><p>一个简单的 HelloWorld.java</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620123640244.png" alt="image-20210620123640244"></p><p>编译为 HelloWorld.class 后是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# od -t xC HelloWorld.class </span><br><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00</span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00</span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><p>根据 JVM 规范，类文件结构如下：<br> <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620123750334.png" alt="image-20210620123750334"></p><p>下面分别进行解释：</p><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><p>表示文件类型</p><p>0~3 字节，表示它是否是【class】类型的文件<br>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h3 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h3><p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8<br>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池     @@@@"></a>1.3 常量池     @@@@</h3><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td>CONSTANT_Class</td><td>7</td></tr><tr><td>CONSTANT_Fieldref</td><td>9</td></tr><tr><td>CONSTANT_Methodref</td><td>10</td></tr><tr><td>CONSTANT_InterfaceMethodref</td><td>11</td></tr><tr><td>CONSTANT_String</td><td>8</td></tr><tr><td>CONSTANT_Integer</td><td>3</td></tr><tr><td>CONSTANT_Float</td><td>4</td></tr><tr><td>CONSTANT_Long</td><td>5</td></tr><tr><td>CONSTANT_Double</td><td>6</td></tr><tr><td>CONSTANT_NameAndType</td><td>12</td></tr><tr><td>CONSTANT_Utf8</td><td>1</td></tr><tr><td>CONSTANT_MethodHandle</td><td>15</td></tr><tr><td>CONSTANT_MethodType</td><td>16</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>8<del>9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1</del>#34项，注意 #0 项不计入，也没有值<br>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09##</li></ul><p>第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p><p>第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26 项来获得这个方法的【所属类】和【方法名】<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07<br>第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【<init>】<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e<br>0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</p><p>第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】<br>0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63<br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</p><p>第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】<br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01<br>0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</p><p>第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】<br>0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63<br>0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p><p>第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p><p>第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16<br>0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p><p>第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p><p>第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e<br>67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</p><p>第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】<br>0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61<br>0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</p><p>第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】<br>0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46<br>0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</p><p>第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】<br>0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e<br>第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e<br>0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】<br>0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74<br>0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c<br>0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</p><p>第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】<br>0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61<br>0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</p><p>第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】<br>0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</p><p>第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f<br>0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p><p>第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】<br>0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72<br>0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76<br>第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】<br>0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76<br>0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</p><p>第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】<br>0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</p><p>第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】<br>0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a<br>0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h3 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h3><p>21 表示该 class 是一个类，公共的<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>05表示根据常量池中 #5 找到本类全限定名<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>06表示根据常量池中 #6 找到父类全限定名<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>表示接口的数量，本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>Flag Name    Value    Interpretation<br>ACC_PUBLIC    0x0001    Declared public ; may be accessed from outside its package.<br>ACC_FINAL    0x0010    Declared final ; no subclasses allowed.<br>ACC_SUPER    0x0020    Treat superclass methods specially when invoked by the invokespecial instruction.<br>ACC_INTERFACE    0x0200    Is an interface, not a class.<br>ACC_ABSTRACT    0x0400    Declared abstract ; must not be instantiated.<br>ACC_SYNTHETIC    0x1000    Declared synthetic; not present in the source code.<br>ACC_ANNOTATION    0x2000    Declared as an annotation type.<br>ACC_ENUM    0x4000    Declared as an enum type.</p><h3 id="1-5-Field-信息"><a href="#1-5-Field-信息" class="headerlink" title="1.5 Field 信息"></a>1.5 Field 信息</h3><p>表示成员变量数量，本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><table><thead><tr><th>FieldType</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L ClassName</td><td>reference</td><td>an instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><h3 id="1-6-Method-信息"><a href="#1-6-Method-信息" class="headerlink" title="1.6 Method 信息"></a>1.6 Method 信息</h3><p>表示方法数量，本类为 2<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><ul><li><p>一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成<br>红色代表访问修饰符（本类中是 public）<br>蓝色代表引用了常量池 #07 项作为方法名称<br>绿色代表引用了常量池 #08 项作为方法参数描述黄色代表方法属性数量，本方法是 1 红色代表方法属性<br>00 09 表示引用了常量池 #09 项，发现是【Code】属性<br>00 00 00 2f 表示此属性的长度是 47<br>00 01 表示【操作数栈】 大深度<br>00 01 表示【局部变量表】 大槽（slot）数<br>00 00 00 05 表示字节码长度，本例是 5</p></li><li><p>2a b7 00 01 b1 是字节码指令</p></li><li><p>00 00 00 02 表示方法细节属性数量，本例是 2</p></li><li><p>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<br>00 00 00 06 表示此属性的总长度，本例是 6<br>00 01 表示【LineNumberTable】长度<br>00 00 表示【字节码】行号 00 04 表示【java 源码】行号</p></li><li><p>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<br>00 00 00 0c 表示此属性的总长度，本例是 12<br>00 01 表示【LocalVariableTable】长度<br>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<br>00 05 表示局部变量覆盖的范围长度<br>00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】<br>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是<br>【Lcn/itcast/jvm/t5/HelloWorld;】<br>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</p></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line"></span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br></pre></td></tr></table></figure><p>红色代表访问修饰符（本类中是 public static）蓝色代表引用了常量池 #14 项作为方法名称绿色代表引用了常量池 #15 项作为方法参数描述黄色代表方法属性数量，本方法是 2 红色代表方法属性（属性1）<br>00 09 表示引用了常量池 #09 项，发现是【Code】属性<br>00 00 00 37 表示此属性的长度是 55<br>00 02 表示【操作数栈】 大深度<br>00 01 表示【局部变量表】 大槽（slot）数 00 00 00 05 表示字节码长度，本例是 9<br>b2 00 02 12 03 b6 00 04 b1 是字节码指令<br>00 00 00 02 表示方法细节属性数量，本例是 2<br>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<br>00 00 00 0a 表示此属性的总长度，本例是 10<br>00 02 表示【LineNumberTable】长度<br>00 00 表示【字节码】行号 00 06 表示【java 源码】行号<br>00 08 表示【字节码】行号 00 07 表示【java 源码】行号<br>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<br>00 00 00 0c 表示此属性的总长度，本例是 12<br>00 01 表示【LocalVariableTable】长度<br>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<br>00 09 表示局部变量覆盖的范围长度<br>00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】<br>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】<br>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</p><p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00<br>0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00<br>0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a<br>0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b<br>0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</p><p>红色代表方法属性（属性2）<br>00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性<br>0000 00 05 表示此属性的总长度，本例是 5<br>01参数数量<br>00 10 表示引用了常量池 #16 项，是【args】<br>00 00 访问修饰符<br>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00<br>0001120 00 00 02 00 14<br>1.7 附加属性<br>00 01 表示附加属性数量<br>00 13 表示引用了常量池 #19 项，即【SourceFile】<br>00 00 00 02 表示此属性的长度<br>00 14 表示引用了常量池 #20 项，即【HelloWorld.java】<br>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00<br>0001120 00 00 02 00 14</p><p>参考文献<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2.字节码指令"></a>2.字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是<br>public cn.itcast.jvm.t5.HelloWorld(); 构造方法的字节码指令</p><p>1.2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数<br>2.b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</p><ol start="3"><li>00 01 引用常量池中 #1 项，即【Method java/lang/Object.”<init>“:()V】</li><li>b1 表示返回</li></ol><p>1.b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？<br>2.00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】<br>3.12 =&gt; ldc 加载参数，哪个参数呢？<br>4.03 引用常量池中 #3 项，即 【String hello world】<br>5.b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？<br>6.00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】<br>7.b1 表示返回</p><p>请参考<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件<br>[root@localhost ~]# javap -v HelloWorld.class<br>Classfile /root/HelloWorld.class<br>  Last modified Jul 7, 2019; size 597 bytes<br>  MD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbc   Compiled from “HelloWorld.java” public class cn.itcast.jvm.t5.HelloWorld   minor version: 0   major version: 52   flags: ACC_PUBLIC, ACC_SUPER Constant pool:<br>   #1 = Methodref          #6.#21         // java/lang/Object.”<init>“:()V<br>   #2 = Fieldref           #22.#23        // java/lang/System.out:Ljava/io/PrintStream;    #3 = String             #24            // hello world    #4 = Methodref          #25.#26        // java/io/PrintStream.println:<br>(Ljava/lang/String;)V<br>   #5 = Class              #27            // cn/itcast/jvm/t5/HelloWorld<br>   #6 = Class              #28            // java/lang/Object<br>   #7 = Utf8               <init><br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               LocalVariableTable<br>  #12 = Utf8               this<br>  #13 = Utf8               Lcn/itcast/jvm/t5/HelloWorld;</p><p>  #14 = Utf8               main   #15 = Utf8               ([Ljava/lang/String;)V<br>  #16 = Utf8               args<br>  #17 = Utf8               [Ljava/lang/String;<br>  #18 = Utf8               MethodParameters<br>  #19 = Utf8               SourceFile<br>  #20 = Utf8               HelloWorld.java<br>  #21 = NameAndType        #7:#8          // “<init>“:()V<br>  #22 = Class              #29            // java/lang/System<br>  #23 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;<br>  #24 = Utf8               hello world<br>  #25 = Class              #32            // java/io/PrintStream<br>  #26 = NameAndType        #33:#34        // println:(Ljava/lang/String;)V<br>  #27 = Utf8               cn/itcast/jvm/t5/HelloWorld<br>  #28 = Utf8               java/lang/Object<br>  #29 = Utf8               java/lang/System<br>  #30 = Utf8               out<br>  #31 = Utf8               Ljava/io/PrintStream;<br>  #32 = Utf8               java/io/PrintStream<br>  #33 = Utf8               println   #34 = Utf8               (Ljava/lang/String;)V<br>{   public cn.itcast.jvm.t5.HelloWorld();     descriptor: ()V<br>    flags: ACC_PUBLIC     Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0          1: invokespecial #1                  // Method java/lang/Object.”<br><init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 4: 0       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature             0       5     0  this   Lcn/itcast/jvm/t5/HelloWorld;<br>  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=2, locals=1, args_size=1<br>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;          3: ldc           #3                  // String hello world<br>         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V          8: return<br>      LineNumberTable:<br>        line 6: 0<br>        line 7: 8       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       9     0  args   [Ljava/lang/String;     MethodParameters:       Name                           Flags<br>      args<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090</p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><p> 1）原始 java 代码     </p><p>2）编译后的字节码文件<br>[root@localhost ~]# javap -v Demo3_1.class Classfile /root/Demo3_1.class<br>  Last modified Jul 7, 2019; size 665 bytes<br>  MD5 checksum a2c29a22421e218d4924d31e6990cfc5   Compiled from “Demo3_1.java” public class cn.itcast.jvm.t3.bytecode.Demo3_1   minor version: 0   major version: 52   flags: ACC_PUBLIC, ACC_SUPER Constant pool:<br>   #1 = Methodref          #7.#26         // java/lang/Object.”<init>“:()V    #2 = Class              #27            // java/lang/Short<br>   #3 = Integer            32768<br>   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;    #5 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V<br>   #6 = Class              #32            // cn/itcast/jvm/t3/bytecode/Demo3_1<br>   #7 = Class              #33            // java/lang/Object<br>   #8 = Utf8               <init><br>   #9 = Utf8               ()V<br>  #10 = Utf8               Code<br>  #11 = Utf8               LineNumberTable<br>  #12 = Utf8               LocalVariableTable<br>  #13 = Utf8               this   #14 = Utf8               Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>  #15 = Utf8               main   #16 = Utf8               ([Ljava/lang/String;)V<br>  #17 = Utf8               args   #18 = Utf8               [Ljava/lang/String;<br>  #19 = Utf8               a</p><p>  #20 = Utf8               I<br>  #21 = Utf8               b<br>  #22 = Utf8               c<br>  #23 = Utf8               MethodParameters<br>  #24 = Utf8               SourceFile<br>  #25 = Utf8               Demo3_1.java<br>  #26 = NameAndType        #8:#9          // “<init>“:()V<br>  #27 = Utf8               java/lang/Short<br>  #28 = Class              #34            // java/lang/System<br>  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;<br>  #30 = Class              #37            // java/io/PrintStream<br>  #31 = NameAndType        #38:#39        // println:(I)V   #32 = Utf8               cn/itcast/jvm/t3/bytecode/Demo3_1<br>  #33 = Utf8               java/lang/Object<br>  #34 = Utf8               java/lang/System<br>  #35 = Utf8               out<br>  #36 = Utf8               Ljava/io/PrintStream;<br>  #37 = Utf8               java/io/PrintStream<br>  #38 = Utf8               println<br>  #39 = Utf8               (I)V {   public cn.itcast.jvm.t3.bytecode.Demo3_1();     descriptor: ()V<br>    flags: ACC_PUBLIC     Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0          1: invokespecial #1                  // Method java/lang/Object.”<br><init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 6: 0       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature             0       5     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=2, locals=4, args_size=1<br>         0: bipush        10<br>         2: istore_1<br>         3: ldc           #3                  // int 32768<br>         5: istore_2<br>         6: iload_1<br>         7: iload_2<br>         8: iadd<br>         9: istore_3<br>        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;         13: iload_3<br>        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br>        17: return<br>      LineNumberTable:<br>        line 8: 0<br>        line 9: 3</p><p>3）常量池载入运行时常量池     </p><p>4）方法字节码载入方法区     </p><p>5）main 线程开始运行，分配栈帧内存<br>（stack=2，locals=4）</p><p>6）执行引擎开始执行字节码     </p><p>bipush 10<br>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） ldc 将一个 int 压入操作数栈 ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）<br>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><p>istore_1      将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p>istore_2     </p><p>iload_1     </p><p>iload_2     </p><p>iadd     </p><p>istore_3     </p><p>getstatic #4     </p><p>iload_3     </p><p>invokevirtual #5<br>va/io/PrintStream.println:(I)V 方法<br>生成新的栈帧（分配 locals、stack等）<br>传递参数，执行新栈帧中的字节码</p><p>完成 main 方法调用，弹出 main 栈帧程序结束</p><h3 id="2-4-练习-分析-i"><a href="#2-4-练习-分析-i" class="headerlink" title="2.4 练习 - 分析 i++"></a>2.4 练习 - 分析 i++</h3><p>目的：从字节码角度分析 a++ 相关题目源码：</p><p>字节码：</p><p>分析：</p><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p>指令    助记符    含义<br>0x99    ifeq    判断是否 == 0<br>0x9a    ifne    判断是否 != 0<br>0x9b    iflt    判断是否 &lt; 0<br>0x9c    ifge    判断是否 &gt;= 0<br>0x9d    ifgt    判断是否 &gt; 0<br>0x9e    ifle    判断是否 &lt;= 0<br>0x9f    if_icmpeq    两个int是否 ==<br>0xa0    if_icmpne    两个int是否 !=<br>0xa1    if_icmplt    两个int是否 &lt;<br>0xa2    if_icmpge    两个int是否 &gt;=<br>0xa3    if_icmpgt    两个int是否 &gt;<br>0xa4    if_icmple    两个int是否 &lt;=<br>0xa5    if_acmpeq    两个引用是否 ==<br>0xa6    if_acmpne    两个引用是否 !=<br>0xc6    ifnull    判断是否 == null<br>0xc7    ifnonnull    判断是否 != null<br>几点说明：<br>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节 goto 用来进行跳转到指定行号的字节码源码：</p><p>字节码：</p><h3 id="2-6-循环控制指令-其实循环控制还是前面介绍的那些指令，例如-while-循环："><a href="#2-6-循环控制指令-其实循环控制还是前面介绍的那些指令，例如-while-循环：" class="headerlink" title="2.6 循环控制指令     其实循环控制还是前面介绍的那些指令，例如 while 循环："></a>2.6 循环控制指令     其实循环控制还是前面介绍的那些指令，例如 while 循环：</h3><p>字节码是：</p><p>再比如 do while 循环：</p><p>字节码是：<br>0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return<br>后再看看 for 循环：</p><p>字节码是：</p><h3 id="2-7-练习-判断结果"><a href="#2-7-练习-判断结果" class="headerlink" title="2.7 练习 - 判断结果"></a>2.7 练习 - 判断结果</h3><p>请从字节码角度分析，下列代码运行的结果：</p><h3 id="2-8-构造方法"><a href="#2-8-构造方法" class="headerlink" title="2.8 构造方法"></a>2.8 构造方法</h3><p>1）<cinit>()V     </p><p>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方</p><p>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在 后<br>public cn.itcast.jvm.t3.bytecode.Demo3_8_2(java.lang.String, int);<br>    descriptor: (Ljava/lang/String;I)V<br>    flags: ACC_PUBLIC     Code:<br>      stack=2, locals=3, args_size=3<br>         0: aload_0<br>         1: invokespecial #1    // super.<init>()V<br>         4: aload_0<br>         5: ldc           #2    // &lt;- “s1”<br>         7: putfield      #3    // -&gt; this.a<br>        10: aload_0<br>        11: bipush        20    // &lt;- 20<br>        13: putfield      #4    // -&gt; this.b<br>        16: aload_0<br>        17: bipush        10    // &lt;- 10<br>        19: putfield      #4    // -&gt; this.b<br>        22: aload_0<br>        23: ldc           #5    // &lt;- “s2”<br>        25: putfield      #3    // -&gt; this.a<br>        28: aload_0             // ——————————<br>        29: aload_1             // &lt;- slot 1(a) “s3”            |         30: putfield      #3    // -&gt; this.a                    |         33: aload_0                                             |         34: iload_2             // &lt;- slot 2(b) 30              |         35: putfield      #4    // -&gt; this.b ——————–<br>        38: return<br>      LineNumberTable: …<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0      39     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_8_2;<br>            0      39     1     a   Ljava/lang/String;<br>            0      39     2     b   I     MethodParameters: …</p><h3 id="2-9-方法调用"><a href="#2-9-方法调用" class="headerlink" title="2.9 方法调用"></a>2.9 方法调用</h3><p>看一下几种不同的方法调用对应的字节码指令</p><p>字节码：<br>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈<br>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “<init>“:()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量<br>终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定<br>普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态<br>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了还有一个执行 invokespecial 的情况是通过 super 调用父类方法</p><h3 id="2-10-多态的原理"><a href="#2-10-多态的原理" class="headerlink" title="2.10 多态的原理"></a>2.10 多态的原理</h3><p>1）运行代码<br>停在 System.in.read() 方法上，这时运行 jps 获取进程 id<br>2）运行 HSDB 工具<br>进入 JDK 安装目录，执行</p><p>进入图形界面 attach 进程 id<br>3）查找某个对象     </p><p>4）查看对象内存结构<br>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br>MarkWord，后 8 字节就是对象的 Class 指针但目前看不到它的实际地址</p><p>5）查看对象 Class 的内存地址<br>可以通过 Windows -&gt; Console 进入命令行模式，执行</p><p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p><p>6）查看类的 vtable<br> 方法1：Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面</p><p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态相关的，final，static 不会列入）<br>那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到：</p><p>通过 Windows -&gt; Console 进入命令行模式，执行</p><p>就得到了 6 个虚方法的入口地址<br>7）验证方法地址<br>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知<br>Dog - public void eat() @0x000000001b7d3fa8<br>Animal - public java.lang.String toString() @0x000000001b7d35e8;<br>Object - protected void finalize() @0x000000001b3d1b10;<br>Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;<br>Object - public native int hashCode() @0x000000001b3d1540; Object - protected native java.lang.Object clone() @0x000000001b3d1678;<br>对号入座，发现<br>    eat() 方法是 Dog 类自己的<br>toString() 方法是继承 String 类的<br>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的<br>8）小结<br>当执行 invokevirtual 指令时，<br>1.先通过栈帧中的对象引用找到对象<br>2.分析对象头，找到对象的实际 Class<br>3.Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了<br>4.查表得到方法的具体地址<br>5.执行方法的字节码</p><h3 id="2-11-异常处理-try-catch"><a href="#2-11-异常处理-try-catch" class="headerlink" title="2.11 异常处理     try-catch"></a>2.11 异常处理     try-catch</h3><pre><code>    11: istore_1    12: return  Exception table:     from    to  target type         2     5     8   Class java/lang/Exception  LineNumberTable: ...              LocalVariableTable:    Start  Length  Slot  Name   Signature        9       3     2     e   Ljava/lang/Exception;        0      13     0  args   [Ljava/lang/String;        2      11     1     i   I       StackMapTable: ...MethodParameters: ...</code></pre><p>}<br>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号<br>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置</p><p>多个 single-catch 块的情况     </p><p>multi-catch 的情况     </p><p>finally     </p><p>public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=1, locals=4, args_size=1<br>         0: iconst_0<br>1istore_1            // 0 -&gt; i<br>2bipush        10    // try ————————————-         4 istore_1            // 10 -&gt; i                                  |          5 bipush        30    // finally                                  |          7 istore_1            // 30 -&gt; i                                  |<br>         8 goto          27    // return ———————————-11 astore_2            // catch Exceptin -&gt; e ———————-</p><pre><code>    12: bipush        20    //                                          |         14: istore_1            // 20 -&gt; i                                  |         15: bipush        30    // finally                                  |         17: istore_1            // 30 -&gt; i                                  |         18: goto          27    // return ----------------------------------        21: astore_3            // catch any -&gt; slot 3 ---------------------        22: bipush        30    // finally                                  |         24: istore_1            // 30 -&gt; i                                  |    25: aload_3             // &lt;- slot 3                                |    26: athrow              // throw ------------------------------------    27: return  Exception table:     from    to  target type         2     5    11   Class java/lang/Exception         2     5    21   any    // 剩余的异常类型，比如 Error</code></pre><p>1115    21   any    // 剩余的异常类型，比如 Error       LineNumberTable: …<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>123     2     e   Ljava/lang/Exception;<br>            0      28     0  args   [Ljava/lang/String;<br>            2      26     1     i   I       StackMapTable: …<br>    MethodParameters: …<br>可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</p><h3 id="2-12-练习-finally-面试题"><a href="#2-12-练习-finally-面试题" class="headerlink" title="2.12 练习 - finally 面试题"></a>2.12 练习 - finally 面试题</h3><p>finally 出现了 return<br>先问问自己，下面的题目输出什么？</p><pre><code>     2: istore_0            // 10 -&gt; slot 0 (从栈顶移除了)     3: bipush        20    // &lt;- 20 放入栈顶     5: ireturn             // 返回栈顶 int(20)     6: astore_1            // catch any -&gt; slot 1     7: bipush        20    // &lt;- 20 放入栈顶          9: ireturn             // 返回栈顶 int(20)       Exception table:     from    to  target type              0     3     6   any       LineNumberTable: ...  StackMapTable: ...</code></pre><p>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子<br>跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常 ，可以试一下下面的代码</p><p>finally 对返回值影响<br>同样问问自己，下面的题目输出什么？</p><h3 id="2-13-synchronized"><a href="#2-13-synchronized" class="headerlink" title="2.13 synchronized"></a>2.13 synchronized</h3><h2 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3. 编译期处理"></a>3. 编译期处理</h2><p>所谓的 语法糖，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）<br>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h3><p>编译成class后的代码：</p><h3 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h3><p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 代码片段1 都会在编译阶段被转换为 代码片段2</p><h3 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：<br>public class Candy3 {<br>    public static void main(String[] args) {<br>        List<Integer> list = new ArrayList&lt;&gt;();<br>        list.add(10); // 实际调用的是 List.add(Object e)<br>        Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);<br>    }<br>}<br>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><p>如果前面的 x 变量类型修改为 int 基本类型那么 终生成的字节码是：</p><p>还好这些麻烦事都不用自己做。</p><p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p><p>使用反射，仍然能够获得这些信息：</p><p>输出</p><h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><h3 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 foreach 循环</h3><p>会被编译器转换为：</p><p>而集合的循环：</p><p>实际被编译器转换为对迭代器的调用：</p><h3 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 switch 字符串</h3><p>可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。</p><p>会被编译器转换为：</p><h3 id="3-7-switch-枚举-switch-枚举的例子，原始代码："><a href="#3-7-switch-枚举-switch-枚举的例子，原始代码：" class="headerlink" title="3.7 switch 枚举     switch 枚举的例子，原始代码："></a>3.7 switch 枚举     switch 枚举的例子，原始代码：</h3><p>转换后代码：</p><h3 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h3><h3 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h3><p>息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：</p><p>输出：</p><p>如以上代码所示，两个异常信息都不会丢。</p><h3 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：父子类的返回值完全一致</p><p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证：</p><p>会输出：</p><h3 id="3-11-匿名内部类-源代码："><a href="#3-11-匿名内部类-源代码：" class="headerlink" title="3.11 匿名内部类     源代码："></a>3.11 匿名内部类     源代码：</h3><p>转换后代码：</p><p>引用局部变量的匿名内部类，源代码：</p><p>转换后代码：</p><h2 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4 . 类加载阶段"></a>4 . 类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><p>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有：<br>_java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴露给 java 使用 _super 即父类<br>_fields 即成员变量<br>_methods 即方法<br>_constants 即常量池<br>_class_loader 即类加载器<br>_vtable 虚方法表<br>_itable 接口方法表<br>如果这个类还有父类没有加载，先加载父类加载和链接可能是交替运行的<br>instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中可以通过前面介绍的 HSDB 工具查看</p><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>验证<br>验证类是否符合 JVM规范，安全性检查<br>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行<br>E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld<br>Error: A JNI error has occurred, please check your installation and try again<br>Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value<br>3405691578 in class file cn/itcast/jvm/t5/HelloWorld<br>        at java.lang.ClassLoader.defineClass1(Native Method)<br>        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)<br>        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)         at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)<br>        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)<br>        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)<br>        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)<br>        at java.security.AccessController.doPrivileged(Native Method)<br>        at java.net.URLClassLoader.findClass(URLClassLoader.java:361)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)<br>        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)         at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)<br>准备<br>为 static 变量分配空间，设置默认值<br>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成<br>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成</p><p>解析     将常量池中的符号引用解析为直接引用</p><h3 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h3><p><cinit>()V 方法<br>初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全<br>发生的时机<br>概括得说，类初始化是【懒惰的】<br>main 方法所在的类，总会被首先初始化首次访问这个类的静态变量或静态方法时子类初始化，如果父类还没初始化，会引发子类访问父类的静态变量，只会触发父类的初始化<br>Class.forName<br>new 会导致初始化不会导致类初始化的情况<br>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化<br>类对象.class 不会触发初始化<br>创建该类的数组不会触发初始化<br>类加载器的 loadClass 方法<br>Class.forName 的参数 2 为 false 时</p><p>实验</p><p>验证（实验时请先全部注释，每次只执行其中一个）</p><h3 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p><p>典型应用 - 完成懒惰初始化单例模式</p><p>以上的实现特点是：懒惰实例化<br>初始化时的线程安全是有保障的</p><h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h2><p>以 JDK 8 为例：<br>名称    加载哪的类    说明<br>Bootstrap ClassLoader    JAVA_HOME/jre/lib    无法直接访问<br>Extension ClassLoader    JAVA_HOME/jre/lib/ext    上级为 Bootstrap，显示为 null<br>Application ClassLoader    classpath    上级为 Extension<br>自定义类加载器    自定义    上级为 Application</p><h3 id="5-1-启动类加载器-用-Bootstrap-类加载器加载类："><a href="#5-1-启动类加载器-用-Bootstrap-类加载器加载类：" class="headerlink" title="5.1 启动类加载器     用 Bootstrap 类加载器加载类："></a>5.1 启动类加载器     用 Bootstrap 类加载器加载类：</h3><p>执行</p><p>输出</p><h3 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h3><p>执行</p><p>输出</p><p>写一个同名的类</p><p>打个 jar 包<br>E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class 已添加清单<br>正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%) 将 jar 包拷贝到 JAVA_HOME/jre/lib/ext 重新执行 Load5_2 输出</p><h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则<br> 注意</p><p>执行流程为：</p><ol><li>sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有<br>2.sun.misc.Launcher$AppClassLoader // 2 处，委派上级 sun.misc.Launcher$ExtClassLoader.loadClass()<br>3.sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有<br>4.sun.misc.Launcher$ExtClassLoader // 3 处，没有上级了，则委派 BootstrapClassLoader 查找<br>5.BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有</li><li>sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在<br>JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader</li><li>到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在 classpath 下查找，找到了</li></ol><h3 id="5-4-线程上下文类加载器"><a href="#5-4-线程上下文类加载器" class="headerlink" title="5.4 线程上下文类加载器"></a>5.4 线程上下文类加载器</h3><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p><p>让我们追踪一下源码：</p><p>先不看别的，看看 DriverManager 的类加载器：</p><p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但<br>JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？继续看 loadInitialDrivers() 方法：</p><p>先看 2）发现它 后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载<br>再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI）<br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称</p><p>这样就可以使用</p><p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：<br>JDBC<br>Servlet 初始化器<br>Spring 容器<br>Dubbo（对 SPI 进行了扩展）接着看 ServiceLoader.load 方法：</p><p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类<br>LazyIterator 中：</p><h3 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h3><p>问问自己，什么时候需要自定义类加载器<br>1）想加载非 classpath 随意路径中的类文件<br>2）都是通过接口来使用实现，希望解耦时，常用在框架设计<br>3）这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</p><p>步骤：<br>1.继承 ClassLoader 父类<br>2.要遵从双亲委派机制，重写 findClass 方法<br> 注意不是重写 loadClass 方法，否则不会走双亲委派机制<br>3.读取类文件的字节码<br>4.调用父类的 defineClass 方法来加载类<br>5.使用者调用该类加载器的 loadClass 方法示例：<br>准备好两个类文件放入 E:\myclasspath，它实现了 java.util.Map 接口，可以先反编译看一下：</p><h2 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6. 运行期优化"></a>6. 运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><p>分层编译<br>（TieredCompilation）<br>先来个例子</p><p>2357173<br>2450346<br>2552906<br>2650346<br>2747786<br>2849920<br>2964000<br>3049067<br>3163574<br>3263147<br>3356746<br>3449494<br>3564853<br>36107520<br>3746933<br>3851627<br>3945653<br>40103680<br>4151626<br>4260160<br>4349067<br>4445653<br>4549493<br>4651626<br>4749066<br>4847360<br>4950774<br>5070827<br>5164000<br>5272107<br>5349066<br>5446080<br>5544800<br>5646507<br>5773813<br>5861013<br>5957600<br>6083200<br>617024204<br>6249493<br>6320907<br>6420907<br>6520053<br>6620906<br>6720907<br>6821333<br>6922187<br>7020480<br>7121760<br>7219200<br>7315360<br>7418347<br>7519627<br>7617067<br>7734134<br>7819200<br>7918347<br>8017493</p><p>8115360<br>8218774<br>8317067<br>8421760<br>8523467<br>8617920<br>8717920<br>8818774<br>8918773<br>9019200<br>9120053<br>9218347<br>9322187<br>9417920<br>9518774<br>9619626<br>9733280<br>9820480<br>9920480<br>10018773<br>10147786<br>10217493<br>10322614<br>10464427<br>10518347<br>10619200<br>10726027<br>10821333<br>10920480<br>11024747<br>11132426<br>11221333<br>11317920<br>11417920<br>11519200<br>11618346<br>11715360<br>11824320<br>11919200<br>12020053<br>12117920<br>12218773<br>12320053<br>12418347<br>12518347<br>12622613<br>12718773<br>12819627<br>12920053<br>13020480<br>13119627<br>13220053<br>13315360<br>134136533<br>13543093<br>136853<br>137853<br>138853</p><p>139853<br>140854<br>141853<br>142853<br>143853<br>144853<br>145853<br>146853<br>147854<br>148853<br>149853<br>150854<br>151853<br>152853<br>153853<br>1541280<br>155853<br>156853<br>157854<br>158853<br>159853<br>160854<br>161854<br>162853<br>163854<br>164854<br>165854<br>166854<br>167853<br>168853<br>169854<br>170853<br>171853<br>172853<br>1731280 174 853<br>1751280<br>176853<br>177854<br>178854<br>179427<br>180853<br>181854<br>182854<br>183854<br>184853<br>185853<br>186854<br>187853<br>188853<br>189854<br>1901280<br>191853<br>192853<br>193853<br>194853<br>195854<br>196853</p><p>原因是什么呢？<br>JVM 将执行状态分成了 5 个层次：<br>0层，解释执行（Interpreter）<br>1层，使用 C1 即时编译器编译执行（不带 profiling）<br>2层，使用 C1 即时编译器编译执行（带基本的 profiling）<br>3层，使用 C1 即时编译器编译执行（带完全的 profiling）<br>4层，使用 C2 即时编译器编译执行<br>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等<br>即时编译器（JIT）与解释器的区别<br>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释<br>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译<br>解释器是将字节码解释为针对所有平台都通用的机器码<br>JIT 会根据平台类型，生成平台特定的机器码<br>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），优化之</p><p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:-<br>DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p><p>参考资料：<a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</a> 方法内联<br>（Inlining）</p><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p><p>还能够进行常量折叠（constant folding）的优化</p><p>实验：</p><p>字段优化<br>JMH 基准测试请参考：<a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a> 创建 maven 工程，添加依赖如下</p><p>编写基准测试代码：</p><p>import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder;<br>import java.util.Random; import java.util.concurrent.ThreadLocalRandom;<br>@Warmup(iterations = 2, time = 1)<br>@Measurement(iterations = 5, time = 1)<br>@State(Scope.Benchmark) public class Benchmark1 {<br>    int[] elements = randomInts(1_000);<br>    private static int[] randomInts(int size) {<br>        Random random = ThreadLocalRandom.current();<br>        int[] values = new int[size];<br>        for (int i = 0; i &lt; size; i++) {<br>            values[i] = random.nextInt();<br>        }<br>        return values;<br>    }<br>    @Benchmark<br>    public void test1() {<br>        for (int i = 0; i &lt; elements.length; i++) {<br>            doSum(elements[i]);<br>        }<br>    }<br>    @Benchmark<br>    public void test2() {<br>        int[] local = this.elements;<br>        for (int i = 0; i &lt; local.length; i++) {<br>            doSum(local[i]);<br>        }<br>    }<br>    @Benchmark<br>    public void test3() {<br>        for (int element : elements) {<br>            doSum(element);<br>        }<br>    }<br>    static int sum = 0;<br>    @CompilerControl(CompilerControl.Mode.INLINE)<br>    static void doSum(int x) {<br>        sum += x;<br>    }<br>    public static void main(String[] args) throws RunnerException {<br>        Options opt = new OptionsBuilder()<br>                .include(Benchmark1.class.getSimpleName())<br>                .forks(1)                 .build();<br>        new Runner(opt).run();<br>北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090</p><p>首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：<br>Benchmark              Mode  Samples        Score  Score error  Units t.Benchmark1.test1    thrpt        5  2420286.539   390747.467  ops/s<br>t.Benchmark1.test2    thrpt        5  2544313.594    91304.136  ops/s<br>t.Benchmark1.test3    thrpt        5  2469176.697   450570.647  ops/s<br>接下来禁用 doSum 方法内联</p><p>测试结果如下：<br>Benchmark              Mode  Samples       Score  Score error  Units t.Benchmark1.test1    thrpt        5  296141.478    63649.220  ops/s<br>t.Benchmark1.test2    thrpt        5  371262.351    83890.984  ops/s<br>t.Benchmark1.test3    thrpt        5  368960.847    60163.391  ops/s<br>分析：<br>在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化：如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：</p><p>可以节省 1999 次 Field 读取操作<br>但如果 doSum 方法没有内联，则不会进行上面的优化</p><p>练习：在内联情况下将 elements 添加 volatile 修饰符，观察测试结果</p><h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉 初的实现，可以通过 debug 得到类名为 sun.reflect.GeneratedMethodAccessor1 可以使用阿里的 arthas 工具：</p><p>选择 1 回车表示分析该进程</p><p>1 [INFO] arthas home: /root/.arthas/lib/3.1.1/arthas<br>[INFO] Try to attach process 13065 [INFO] Attach process 13065 success.<br>[INFO] arthas-client connect 127.0.0.1 3658<br>  ,—.  ,——. ,——–.,–.  ,–.  ,—.   ,—.                            /  O  \ |  .–. ‘’–.  .–’|  ‘–’  | /  O  \ ‘   .-‘<br>|  .-.  ||  ‘–’.’   |  |   |  .–.  ||  .-.  |<code>.  </code>-.                          |  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-‘    |                         <code>--&#39; </code>–’<code>--&#39; &#39;--&#39;   </code>–’   <code>--&#39;  </code>–’<code>--&#39; </code>–’`—–’<br>wiki      <a href="https://alibaba.github.io/arthas">https://alibaba.github.io/arthas</a>                                      tutorials <a href="https://alibaba.github.io/arthas/arthas-tutorials">https://alibaba.github.io/arthas/arthas-tutorials</a>                     version   3.1.1                                                                 pid       13065                                                                 time      2019-06-10 12:23:54<br>再输入【jad + 类名】来进行反编译<br>$ jad sun.reflect.GeneratedMethodAccessor1<br>ClassLoader:<br>+-sun.reflect.DelegatingClassLoader@15db9742                                     </p><p>  +-sun.misc.Launcher$AppClassLoader@4e0e2f2a<br>    +-sun.misc.Launcher$ExtClassLoader@2fdb006e<br>Location:                                                                       </p><p>/*<br>*Decompiled with CFR 0_132.</p><ul><li>*Could not load the following classes:<br>*cn.itcast.jvm.t3.reflect.Reflect1<br> <em>/<br>package sun.reflect;<br>import cn.itcast.jvm.t3.reflect.Reflect1; import java.lang.reflect.InvocationTargetException; import sun.reflect.MethodAccessorImpl;<br>public class GeneratedMethodAccessor1 extends MethodAccessorImpl {<br> /</em><br>*Loose catch block<br>*Enabled aggressive block sorting<br>*Enabled unnecessary exception pruning<br>*Enabled aggressive exception aggregation<br>*Lifted jumps to return sites<br>  */</li></ul><h1 id="四-内存模型"><a href="#四-内存模型" class="headerlink" title="四.内存模型"></a>四.内存模型</h1><h2 id="1-java-内存模型"><a href="#1-java-内存模型" class="headerlink" title="1. java 内存模型"></a>1. java 内存模型</h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p><p><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b">关于它的权威解释，请参考</a></p><p>简单的说，JMM 定义了一套在<strong>多线程读写</strong>共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性     "></a>1.1 原子性    <a href="af://n13/"> </a></h3><p>原子性在学习线程时讲过，下面来个例子简单回顾一下：</p><p>问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><h3 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps95.png" alt="img"></p><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps96.png" alt="img"> </p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps97.png" alt="img"></p><p>但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps98.png" alt="img"></p><p>出现正数的情况：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps99.png" alt="img"></p><h3 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法     "></a>1.3 解决方法    <a href="af://n29/"> </a></h3><p>synchronized（同步关键字)</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps101.png" alt="img"></p><p>如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。</p><ol><li><p>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。</p></li><li><p>这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。</p></li><li><p>当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count– 代码。</p></li></ol><p>注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps104.png" alt="img"></p><p>为什么呢？ </p><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps105.png" alt="img"> </p><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps106.png" alt="img"> </p><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps107.png" alt="img"> </p><h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h3><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以*<!--避免线程从自己的工作缓存中查找变量的值-->*，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620131455851.png" alt="image-20210620131455851" style="zoom:80%;" /><h3 id="2-3-可见性"><a href="#2-3-可见性" class="headerlink" title="2.3 可见性     "></a>2.3 可见性    <strong><a href="af://n71/"> </a></strong></h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， <u><em>不能保证原子性</em></u>，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true</span><br><span class="line"></span><br><span class="line">putstatic   run  &#x2F;&#x2F;  线程 main 修改 run 为 false， 仅此一次 getstatic   run  &#x2F;&#x2F; 线程 t 获取 run false</span><br></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到 新值，不能解决指令交错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设i的初始值为0 getstatic   i  </span><br><span class="line">&#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;0 getstatic   i  </span><br><span class="line">&#x2F;&#x2F; 线程2-获取静态变量i的值 线程内i&#x3D;0 iconst_1     </span><br><span class="line">&#x2F;&#x2F; 线程1-准备常量1 iadd       </span><br><span class="line">&#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 putstatic   i </span><br><span class="line">&#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1 iconst_1     </span><br><span class="line">&#x2F;&#x2F; 线程2-准备常量1 isub       </span><br><span class="line">&#x2F;&#x2F; 线程2-自减 线程内i&#x3D;-1</span><br><span class="line"></span><br><span class="line">putstatic   i  &#x2F;&#x2F; 线程2-将修改后的值存入静态变量i 静态变量i&#x3D;-1</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><p>​    <u>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性</u>。但缺点是synchronized是属于重量级操作，性能相对更低</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性     "></a>3. 有序性    <a href="af://n81/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps110.png" alt="img"></p><h3 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3.1 诡异的结果     "></a>3.1 诡异的结果    <a href="af://n82/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps111.png" alt="img"></p><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？有同学这么分析</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>但我告诉你，结果还有可能是 0 ，信不信吧！</p><p>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2</p><p>相信很多人已经晕了 </p><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p><p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.open</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">dk</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">.j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">ava.net/displa</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">y</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">/CodeTools/</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">cstress</a></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps112.png" alt="img">mvn archetype:generate  -DinteractiveMode=false DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-testarchetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0</p><p>创建 maven 项目，提供如下测试类</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps113.png" alt="img"></p><p>执行</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps114.png" alt="img"></p><p>会输出我们感兴趣的结果，摘录其中一次结果：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps115.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0   1,729  ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">1   42,617,915        ACCEPTABLE  ok</span><br><span class="line">4   5,146,627        ACCEPTABLE  ok</span><br><span class="line">[OK] test.ConcurrencyTest</span><br><span class="line"></span><br><span class="line">(JVM args: [])</span><br><span class="line"> Observed state  Occurrences        Expectation  Interpretation         0     1,652  ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line"></span><br><span class="line">​        1   46,460,657        ACCEPTABLE  ok</span><br><span class="line"></span><br><span class="line">​        4   4,571,072        ACCEPTABLE  ok</span><br></pre></td></tr></table></figure><p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法     "></a>3.2 解决方法    <a href="af://n104/"> </a></h3><p>volatile 修饰的变量，可以禁用指令重排</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps117.png" alt="img"></p><p>结果为：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps118.png" alt="img"></p><h3 id="3-3-有序性理解"><a href="#3-3-有序性理解" class="headerlink" title="3.3 有序性理解     "></a>3.3 有序性理解    <a href="af://n111/"> </a></h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps119.png" alt="img"></p><p>可以看到，至于是先执行 i 还是 先执行 j ，对 终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps120.png" alt="img"></p><p>也可以是</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps121.png" alt="img"></p><p>这种特性称之为<strong>『指令重排』</strong>，</p><p> 单线程不会产生问题；多线程下『指令重排』会影响正确性。</p><p>例如著名的 double-checked locking 模式实现单例</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps122.png" alt="img"></p><p>以上的实现特点是：</p><ul><li><p>懒惰实例化</p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p><p>但在多线程环境下，上面的代码是有问题的，INSTANCE = new Singleton() 对应的字节码为：</p></li></ul><p>0: new      #2          // class cn/itcast/jvm/t4/Singleton</p><p>3: dup</p><p>4: invokespecial #3          // Method “<init>“:()V</p><p>7: putstatic   #4          // Field </p><p>INSTANCE:Lcn/itcast/jvm/t4/Singleton;</p><p>其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1，t2 按如下时间序列执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间1  t1 线程执行到 INSTANCE &#x3D; new Singleton(); 时间2  t1 线程分配空间，为Singleton对象生成了引用地址（0 处）时间3  t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE !&#x3D; null（7 处）时间4  t2 线程进入getInstance() 方法，发现 INSTANCE !&#x3D; null（synchronized块外），直接返回 INSTANCE时间5  t1 线程执行Singleton的构造方法（4 处）</span><br></pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 <strong>JDK 5 以上</strong>的版本的 volatile 才会真正有效</p><h3 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3.4 happens-before     "></a>3.4 happens-before    <a href="af://n133/"> </a></h3><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，</p><p>抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps126.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps127.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps128.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps129.png" alt="img"> 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps130.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps131.png" alt="img"> 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps132.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps133.png" alt="img"></p><ul><li><p>对变量默认值（0，false，null)的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z 变量都是指成员变量或静态成员变量参考： 第17页</p></li></ul><h2 id="4-CAS-与-原子类"><a href="#4-CAS-与-原子类" class="headerlink" title="4. CAS 与 原子类     "></a>4. CAS 与 原子类    <a href="af://n168/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps135.png" alt="img"></p><h3 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4.1 CAS     "></a>4.1 CAS    <a href="af://n169/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps136.png" alt="img"></p><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps137.png" alt="img">因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps138.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(() -&gt; &#123;      for (int i &#x3D; 0; i &lt; count; i++) &#123;     dc.increase();      &#125;    &#125;);          t1.start();    t1.join();    System.out.println(dc.getData());  &#125; &#125;class DataContainer &#123;  private volatile int data;  static final Unsafe unsafe; static final long DATA_OFFSET;  static &#123;   try &#123;      &#x2F;&#x2F; Unsafe 对象不能直接调用，只能通过反射获得      Field theUnsafe &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);      theUnsafe.setAccessible(true);      unsafe &#x3D; (Unsafe) theUnsafe.get(null);    &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;      throw new Error(e);    &#125;    try &#123;      &#x2F;&#x2F; data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性      DATA_OFFSET &#x3D; unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(&quot;data&quot;));    &#125; catch (NoSuchFieldException e) &#123;      throw new Error(e);    &#125;  &#125;  </span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620141319373.png" alt="image-20210620141319373"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps139.png" alt="img"></p><h3 id="4-2-乐观锁与悲观锁"><a href="#4-2-乐观锁与悲观锁" class="headerlink" title="4.2 乐观锁与悲观锁     "></a>4.2 乐观锁与悲观锁    <a href="af://n180/"> </a></h3><p>CAS 是基于乐观锁的思想： 乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p><p>synchronized 是基于悲观锁的思想： 悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p><h3 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4.3 原子操作类     "></a>4.3 原子操作类    <a href="af://n201/"> </a></h3><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，</p><p>例如：AtomicInteger、AtomicBoolean等，</p><p>它们底层就是采用 CAS 技术 + volatile 来实现的。</p><p>可以使用 AtomicInteger 改写之前的例子：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps141.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps142.png" alt="img"></p><h2 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5. synchronized 优化     "></a>5. synchronized 优化    <a href="af://n220/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps143.png" alt="img"></p><ul><li>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word)。Mark Word 平时存储这个对象的 哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为 标记位、线程锁记录指针、重量级锁指针、线程ID 等内容</li></ul><h3 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁     "></a>5.1 轻量级锁    <a href="af://n233/"> </a></h3><p>*<!--如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化-->*。</p><p>这就好比：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即升级为重量级锁(锁膨胀)，进入重量级锁的流程。而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁</span><br></pre></td></tr></table></figure><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps146.png" alt="img"></p><p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p><table><thead><tr><th>线程 1</th><th>对象 Mark Word</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块 A，把 Mark 复制到线程 1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 A</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>访问同步块 B，把 Mark 复制到线程 1 的锁记录</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>失败（发现是自己的锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>锁重入</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 B</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 B 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 A 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>-</td></tr><tr><td>-</td><td>01（无锁）</td><td>访问同步块 A，把 Mark 复制到线程 2 的锁记录</td></tr><tr><td>-</td><td>01（无锁）</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>-</td><td>00（轻量锁）线程 2 锁记录地址</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5.2 锁膨胀     "></a>5.2 锁膨胀    <a href="af://n310/"> </a></h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps147.png" alt="img"></p><table><thead><tr><th>线程 1</th><th>对象 Mark</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块，把 Mark 复制到线程1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>访问同步块，把 Mark 复制到线程 2</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>失败（发现别人已经占了锁）</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>失败（解锁）</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争</td><td>01（无锁）</td><td>阻塞中</td></tr><tr><td>-</td><td>10（重量锁）</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10（重量锁）</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5.3 重量锁     "></a>5.3 重量锁    <a href="af://n378/"> </a></h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><ul><li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p></li><li><p><strong>自旋会占用 CPU 时间</strong>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p><p>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）</p></li><li><p>Java 7 之后不能控制是否开启自旋功能 </p></li></ul><p>自旋重试成功的情况</p><table><thead><tr><th>线程 1 （cpu 1 上）</th><th>对象 Mark</th><th>线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况</p><table><thead><tr><th>线程 1（cpu 1 上）</th><th>对象 Mark</th><th>线程 2（cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-4-偏向锁"><a href="#5-4-偏向锁" class="headerlink" title="5.4 偏向锁"></a>5.4 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</p><ul><li><p>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW)</p></li><li><p>访问对象的 hashCode 也会撤销偏向锁</p></li><li><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p></li><li><p>撤销偏向和重偏向都是批量进行的，以类为单位</p></li><li><p>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</p></li><li><p>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</p></li></ul><p><a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">可以参考这篇论文：</a></p><p>假设有两个方法同步块，利用同一个对象加锁</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps150.png" alt="img"></p><table><thead><tr><th>线程 1</th><th>对象 Mark</th></tr></thead><tbody><tr><td>访问同步块 A，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）</td></tr><tr><td>尝试加偏向锁</td><td>101（无锁可偏向）对象 hashCode</td></tr><tr><td>成功</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 A</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>访问同步块 B，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>是自己的线程 ID，锁是自己的，无需做更多操作</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 B</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行完毕</td><td>101（无锁可偏向）对象 hashCode</td></tr></tbody></table><h3 id="5-5-其它优化"><a href="#5-5-其它优化" class="headerlink" title="5.5 其它优化"></a>5.5 其它优化</h3><ol><li>减少上锁时间    </li></ol><p>同步代码块中尽量短</p><ol start="2"><li><p>减少锁的粒度    </p><p>将一个锁拆分为多个锁提高并发度，例如：</p></li></ol><ul><li><p>ConcurrentHashMap</p></li><li><p>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改， 后将数组中每个 cell 累加，再加上 base 就是 终的值</p></li><li><p>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</p></li></ul><ol start="3"><li>锁粗化    <a href="af://n542/"> </a></li></ol><p>多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps153.png" alt="img"></p><ol start="4"><li>锁消除    </li></ol><p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p><ol start="5"><li>读写分离    </li></ol><p>CopyOnWriteArrayList ConyOnWriteSet</p><p>参考：</p><p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.open</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">j</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">dk</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">.j</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">ava.net/displa</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">y</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">/HotSpot/S</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">y</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">nchronization </a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luo</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">j</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">inpin</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">g</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">.com/2015/07/09/</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">j</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">ava</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">锁优化</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">/ </a><a href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">j</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">ava-se-16-s</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">y</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">nchronized </a><a href="https://www.jianshu.com/p/9932047a89be">https://www</a><a href="https://www.jianshu.com/p/9932047a89be">.j</a><a href="https://www.jianshu.com/p/9932047a89be">ianshu.com/p/9932047a89be </a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblo</a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">g</a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">s.com/sheeva/p/6366782.html</a></p><p><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-</a><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">j</a><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">ava-ever-rebias-an-individual-lock</a></p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Markdown格式解析</title>
    <link href="http://example.com/2021/06/20/Markdown%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/20/Markdown%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-20T12:05:48.000Z</published>
    <updated>2021-06-20T12:36:31.211Z</updated>
    
    <content type="html"><![CDATA[<p>————-正文开始———————–</p><p>==（1）标题==</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>==（2）字体==</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><em><strong>斜体加粗</strong></em></p><p><del>删除线</del></p><p>==高亮==</p><p>我是^上标^</p><p>我是<del>下标</del></p><p>==（3）列表==</p><ul><li><p>一二三四五</p><ul><li><p>上山打老虎</p><ul><li><p>老虎没打到</p><ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><ol><li><p>一二三四五</p></li><li><p>上山打老虎</p></li><li><p>老虎没打到</p></li><li><p>打到小松鼠</p></li></ol><p>==（4）表格==</p><table><thead><tr><th>Mon</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>——</th><th>——</th><th>——</th><th>——</th><th>——</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>上山</th><th>上山</th><th>上山</th><th>上山</th><th>上山</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>打老虎</th><th>打老虎</th><th>打老虎</th><th>打老虎</th><th>打老虎</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>==（5）引用 ==</p><blockquote><p>一二三四五</p></blockquote><blockquote><blockquote><p>上山打老虎</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>老虎没打到</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>打到小松鼠</p></blockquote></blockquote></blockquote></blockquote><p>==（6）分割线==</p><hr><p>==（7）代码==</p><p><code>我是代码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是代码框</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Maven尚硅谷复习总结</title>
    <link href="http://example.com/2021/06/20/Maven%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/06/20/Maven%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-20T12:04:56.000Z</published>
    <updated>2021-06-20T12:36:38.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven尚硅谷复习总结"><a href="#Maven尚硅谷复习总结" class="headerlink" title="Maven尚硅谷复习总结"></a>Maven尚硅谷复习总结</h1><p>导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。 </p><p>1 Why? </p><p>1.1 真的需要吗？ </p><p>Maven 是干什么用的？这是很多同学在刚开始接触 Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用 Maven 我们仍然可以进行 B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用 Maven 我们一样可以开发项目啊？ </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps1.jpg" alt="img"> </p><p>这里给大家纠正一个误区，Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。 </p><p>1.2 究竟为什么？ </p><p>为什么要使用 Maven？它能帮助我们解决什么问题？ </p><p>①添加第三方 jar 包 </p><p>在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。 </p><p>而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。 </p><p>  ②jar 包之间的依赖关系 </p><p>jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。 </p><p>那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar 包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。 </p><p>而引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.3.jar 后，commons-io-2.0.1.jar 会被自动导入，程序员不必了解这个依赖关系。 </p><p>下图是 Spring 所需 jar 包的部分依赖关系 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps2.png" alt="img"> </p><p>③获取第三方 jar 包 </p><p>JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。 </p><p>使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载，并同时下载这个 jar 包所依赖的其他 jar 包 ——规范、完整、准确！一次性解决所有问题！ </p><p>Tips：在这里我们顺便说一下，统一的规范几乎可以说成是程序员的最高信仰。如果没有统一的规范，就意味着每个具体的技术都各自为政，需要以诸多不同的特殊的方式加入到项目中；好不容易加入进来还会和其他技术格格不入，最终受苦的是我们。而任何一个领域的统一规范都能够极大的降低程序员的工作难度，减少工作量。例如：USB 接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备对应的接口，无疑是非常繁琐的。 </p><p>④将项目拆分成多个工程模块 </p><p>随着 JavaEE 项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 JavaEE 项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 Java 工程，有的是 Web 工程。 </p><p>那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。大家请看我们的 Survey 调查项目拆分的情况： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps3.png" alt="img"> 上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。 </p><p>2 What? </p><p>2.1 Maven 简介 </p><p>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps4.jpg" alt="img"> </p><p>2.2 什么是构建 </p><p>构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看： </p><p>①纯 Java 代码 </p><p>大家都知道，我们 Java 是一门编译型语言，.java 扩展名的源文件需要编译成.class 扩展名的字节码文件才能够执行。所以编写任何 Java 代码想要执行的话就必须经过编译得到对应的.class 文件。 </p><p>②Web 工程 </p><p>当我们需要通过浏览器访问 Java 程序时就必须将包含 Java 程序的 Web 工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。 </p><p>我们可以将未编译的 Web 工程比喻为一只生的鸡，编译好的 Web 工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。 </p><p>Web 工程和其编译结果的目录结构对比见下图： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps5.png" alt="img"> </p><p>③实际项目 </p><p>在实际项目中整合第三方框架，Web 工程中除了 Java 程序和 JSP 页面、图片等静态资源之外，还包括第三方框架的 jar 包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。 </p><p>所以综上所述：构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 </p><p>那么项目构建的全过程中都包含哪些环节呢？ </p><p>2.3 构建过程的几个主要环节 </p><p>①清理：删除以前的编译结果，为重新编译做好准备。 </p><p>②编译：将 Java 源程序编译为字节码文件。 </p><p>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 </p><p>④报告：在每一次测试后以标准的格式记录和展示测试结果。 </p><p>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 </p><p>⑥安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 </p><p>⑦部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 </p><p>2.4 自动化构建 </p><p>其实上述环节我们在 Eclipse 中都可以找到对应的操作，只是不太标准。那么既然 IDE 已经可以进行构建了我们为什么还要使用 Maven 这样的构建工具呢？我们来看一个小故事：这是阳光明媚的一天。托马斯向往常一样早早的来到了公司，冲好一杯咖啡，进入了自己的邮箱——很不幸，QA 小组发来了一封邮件，报告了他昨天提交的模块的测试结果——有 BUG。“好吧，反正也不是第一次”，托马斯摇摇头，进入 IDE，运行自己的程序，编译、打包、部署到服务器上，然后按照邮件中的操作路径进行测试。“嗯，没错，这个地方确实有问题”，托马斯说道。于是托马斯开始尝试修复这个 BUG，当他差不多有眉目的时候已经到了午饭时间。 </p><p>下午继续工作。BUG 很快被修正了，接着托马斯对模块重新进行了编译、打包、部署，测试之后确认没有问题了，回复了 QA 小组的邮件。 </p><p>一天就这样过去了，明媚的阳光化作了美丽的晚霞，托马斯却觉得生活并不像晚霞那样美好啊。 </p><p>让我们来梳理一下托马斯这一天中的工作内容 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps6.jpg" alt="img"> </p><p>从中我们发现，托马斯的很大一部分时间花在了“编译、打包、部署、测试”这些程式化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps7.jpg" alt="img"> 能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps8.jpg" alt="img"> </p><p>此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps9.png" alt="img"> </p><p>2.5 Maven 核心概念 </p><p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，看看 Maven 是如何实现自动化构建的 </p><p>①POM </p><p>②约定的目录结构 </p><p>③坐标 </p><p>④依赖管理 </p><p>⑤仓库管理 </p><p>⑥生命周期 </p><p>⑦插件和目标 </p><p>⑧继承 </p><p>⑨聚合 </p><p>3 How? </p><p>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是</p><p>Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 </p><p>下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。 </p><p>如果不能联网可以使用我们提供的 RepMaven.zip 解压得到。具体操作参见“Maven 操作指南.txt”。 </p><p>4 约定的目录结构 </p><p>约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。 </p><p>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式： </p><p>①通过配置的形式明确告诉它 </p><p>②基于第三方工具或框架的约定 </p><p>Maven 对工程目录结构的要求就属于后面的一种。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps10.jpg" alt="img"> </p><p>现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。 </p><p>5 POM </p><p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。 Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。 </p><p>6 坐标 </p><p>6.1 几何中的坐标 </p><p>[1]在一个平面中使用 x、y 两个向量可以唯一的确定平面中的一个点。 </p><p>[2]在空间中使用 x、y、z 三个向量可以唯一的确定空间中的一个点。 </p><p>6.2 Maven 的坐标 </p><p>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。 </p><p>[1]groupid：公司或组织的域名倒序+当前项目名称 </p><p>[2]artifactId：当前项目的模块名称 </p><p>[3]version：当前模块的版本 </p><p> &lt;****g****roupId&gt;com.atguigu.maven</groupId> </p><p> &lt;****a****rtifactId&gt;Hello</artifactId> </p><p> &lt;****v****ersion&gt;0.0.1-SNAPSHOT</version> </p><p>6.3 如何通过坐标到仓库中查找 jar 包？ </p><p>[1]将 gav 三个向量连起来 </p><p>com.atguigu.maven+Hello+0.0.1-SNAPSHOT </p><p>[2]以连起来的字符串作为目录结构到仓库中查找 </p><p>com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar </p><p>※注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install </p><p>7 依赖 </p><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决一下几个问题： </p><p>①依赖的目的是什么 </p><p>当A jar包用到了B jar包中的某些类时，A就对B产生了依赖，这是概念上的描述。那么如何在项目</p><p>中以依赖的方式引入一个我们需要的jar包呢？答案非常简单，就是使用dependency标签指定被依赖jar包的坐标就可以了。 </p><dependency> <p> <groupId>com.atguigu.maven</groupId> </p><p> <artifactId>Hello</artifactId> </p><p> <version>0.0.1-SNAPSHOT</version> </p><p> <scope>compile</scope> </dependency> </p><p>②依赖的范围大家注意到上面的依赖信息中除了目标jar包的坐标还有一个scope设置，这是依赖的范围。依赖的范围有几个可选值，我们用得到的是：compile、test、provided三个。 </p><p>[1]从项目结构角度理解compile和test的区别 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps11.jpg" alt="img"> </p><p>结合具体例子：对于HelloFriend来说，Hello就是服务于主程序的，junit是服务于测试程序的。 </p><p>HelloFriend 主程序需要 Hello 是非常明显的，测试程序由于要调用主程序所以也需要 Hello，所以 compile范围依赖对主程序和测试程序都应该有效。 </p><p>HelloFriend的测试程序部分需要junit也是非常明显的，而主程序是不需要的，所以test范围依赖仅仅对于主程序有效。 </p><p>[2]从开发和运行这两个不同阶段理解compile和provided的区别 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps12.jpg" alt="img"> </p><p>[3]有效性总结 </p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th></tr></thead><tbody><tr><td>主程序</td><td>√</td><td>×</td><td>√</td></tr><tr><td>测试程序</td><td>√</td><td>√</td><td>√</td></tr><tr><td>参与部署</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><p>③依赖的传递性 </p><p>A依赖B，B依赖C，A能否使用C呢？那要看B依赖C的范围是不是compile，如果是则可用，否则不可用。 </p><table><thead><tr><th>Maven 工程</th><th></th><th>依赖范围</th><th>对 A 的可见性</th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>compile</td><td>√</td></tr><tr><td>D</td><td>test</td><td>×</td><td></td><td></td></tr><tr><td>E</td><td>provided</td><td>×</td><td></td><td></td></tr></tbody></table><p>④依赖的排除 </p><p>如果我们在当前工程中引入了一个依赖是A，而A又依赖了B，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。 </p><p>[1]情景举例 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps13.png" alt="img"> </p><p>[2]配置方式 </p><dependency> <p>   <groupId>com.atguigu.maven</groupId> </p><p>   <artifactId>HelloFriend</artifactId> </p><p>   <version>0.0.1-SNAPSHOT</version> </p><p>   <type>jar</type> </p><p>   <scope>compile</scope> </p>   <exclusions> <p>​     <exclusion> </p><p>​       <groupId>commons-logging</groupId> </p><p>​       <artifactId>commons-logging</artifactId> </p><p>​     </exclusion> </p>   </exclusions> </dependency> <p>[3]排除后的效果 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps14.png" alt="img"> </p><p>⑤统一管理所依赖jar包的版本 </p><p>对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将jar包的版本信息统一提</p><p>取出来 </p><p>[1]统一声明版本号 </p><properties> <p>   &lt;atguigu.spring.version&gt;4.1.1.RELEASE&lt;/atguigu.spring.version&gt; </p></properties> <p>其中atguigu.spring.version部分是自定义标签。 </p><p>[2]引用前面声明的版本号 </p><dependencies>    <dependency> <p>​     <groupId>org.springframework</groupId> </p><p>​     <artifactId>spring-core</artifactId> </p><p>​     <version>${atguigu.spring.version}</version> </p>   </dependency> <p>…… </p></dependencies> <p>[3]其他用法 </p><properties> <p>   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; </p></properties> <p>⑥依赖的原则：解决 jar 包冲突 </p><p>[1]路径最短者优先 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps15.png" alt="img"> </p><p>[2]路径相同时先声明者优先 </p><p>  <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps16.png" alt="img"> 这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 </p><p>8 仓库 </p><p>8.1 分类 </p><p>[1]本地仓库：为当前本机电脑上的所有 Maven 工程服务。 </p><p>[2]远程仓库 </p><p>(1)私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps17.png" alt="img"> </p><p>(2)中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。 </p><p>(3)中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 </p><p>8.2 仓库中的文件 </p><p>[1]Maven 的插件 </p><p>[2]我们自己开发的项目的模块 </p><p>[3]第三方框架或工具的 jar 包 </p><p>※不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。 </p><p>9 生命周期 </p><p>9.1 什么是 Maven 的生命周期？ </p><p>●Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 </p><p>●Maven 有三套相互独立的生命周期，分别是： </p><p>①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 </p><p>②Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 </p><p>③Site Lifecycle 生成项目报告，站点，发布站点。 </p><p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 </p><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 </p><p>9.2 Clean 生命周期 </p><p>Clean 生命周期一共包含了三个阶段： </p><p>①pre-clean 执行一些需要在 clean 之前完成的工作 </p><p>②clean 移除所有上一次构建生成的文件 </p><p>③post-clean 执行一些需要在 clean 之后立刻完成的工作 </p><p>9.3 Site 生命周期 </p><p>①pre-site 执行一些需要在生成站点文档之前完成的工作 </p><p>②site 生成项目的站点文档 </p><p>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 </p><p>④site-deploy 将生成的站点文档部署到特定的服务器上 </p><p>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 </p><p>9.4 Default 生命周期 </p><p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources </p><p>generate-resources </p><p>process-resources 复制并处理资源文件，至目标目录，准备打包。 </p><p>compile 编译项目的源代码。 </p><p>process-classes generate-test-sources process-test-sources </p><p>generate-test-resources </p><p>process-test-resources 复制并处理资源文件，至目标测试目录。 </p><p>test-compile 编译测试源代码。 </p><p>process-test-classes </p><p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 </p><p>prepare-package </p><p>package 接受编译好的代码，打包成可发布的格式，如 JAR。 </p><p>pre-integration-test integration-test post-integration-test verify </p><p>install 将包安装至本地仓库，以让其它项目依赖。 </p><p>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 </p><p>9.5 生命周期与自动化构建 </p><p>运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。 </p><p>10 插件和目标 </p><p>●Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。 </p><p>●每个插件都能实现多个功能，每个功能就是一个插件目标。 </p><p>●Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。 </p><p>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 </p><p>11 继承 </p><p>11.1 为什么需要继承机制？由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如： </p><table><thead><tr><th>Hello</th><th><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version> <scope>test</scope> </dependency></th></tr></thead><tbody><tr><td>HelloFriend</td><td><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version></td></tr><tr><td></td><td><scope>test</scope> </dependency></td></tr><tr><td>MakeFriend</td><td><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version> <scope>test</scope> </dependency></td></tr></tbody></table><p>此时如果项目需要将各个模块的junit版本统一为 4.9，那么到各个工程中手动修改无疑是非常不可取的。</p><p>使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。 </p><p>11.2 创建父工程创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是：打包方式处要设置为 pom。 </p><p>11.3 在子工程中引用父工程 </p><parent> <p>​     <!-- 父工程坐标 --> </p><p><groupId>…</groupId> </p><p>​     <artifactId>…</artifactId> </p><p>​     <version>…</version> </p><p>​     <relativePath>从当前目录到父项目的 pom.xml 文件的相对路径</relativePath> </p></parent> <parent> <p> <groupId>com.atguigu.maven</groupId> </p><p> <artifactId>Parent</artifactId> </p><h1 id="0-0-1-SNAPSHOT"><a href="#0-0-1-SNAPSHOT" class="headerlink" title="0.0.1-SNAPSHOT"></a><version>0.0.1-SNAPSHOT</version></h1> <!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --> <p> <relativePath>../Parent/pom.xml</relativePath> </p></parent> <p> 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 </p><p>11.4 在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来 </p><dependencyManagement>  <dependencies>  <dependency> <p>  <groupId>junit</groupId> </p><p>  <artifactId>junit</artifactId> </p><p>  <version>4.9</version> </p><p>  <scope>test</scope> </p> </dependency>  </dependencies> </dependencyManagement> <p>在子项目中重新指定需要的依赖，删除范围和版本号 </p><dependencies>  <dependency> <p> <groupId>junit</groupId> </p><p> <artifactId>junit</artifactId> </p> </dependency> </dependencies> <p>12 聚合 </p><p>12.1 为什么要使用聚合？ </p><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 </p><p>12.2 如何配置聚合？在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 </p><modules> <p> <module>../Hello</module> </p><h1 id="HelloFriend-MakeFriends"><a href="#HelloFriend-MakeFriends" class="headerlink" title="../HelloFriend ../MakeFriends"></a><module>../HelloFriend</module> <module>../MakeFriends</module></h1></modules> <p>13 Maven 酷站我们可以到 <a href="http://mvnrepository.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84">http://mvnrepository.com/搜索需要的</a> jar 包的依赖信息。 </p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>javaweb Summery</title>
    <link href="http://example.com/2021/06/20/javaweb-Summery/"/>
    <id>http://example.com/2021/06/20/javaweb-Summery/</id>
    <published>2021-06-20T12:03:20.000Z</published>
    <updated>2021-06-20T12:36:01.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;                    &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;                        &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;                        &lt;/body&gt;            &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例        * 案例：公司简介            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;ch&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;黑马程序员简介&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                        &lt;h1&gt;                公司简介            &lt;/h1&gt;            &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;p&gt;            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。            &lt;/p&gt;                        &lt;p&gt;            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。            &lt;/p&gt;                        &lt;p&gt;                        黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。            &lt;/p&gt;                        &lt;p&gt;                        一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。            &lt;/p&gt;                        &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                &lt;center&gt;                    江苏传智播客教育科技股份有限公司&lt;br&gt;                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                &lt;/center&gt;            &lt;/font&gt;</code></pre><p>​<br>​                </p><pre><code>            &lt;/body&gt;            &lt;/html&gt;    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;4. 代码实现    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;黑马旅游网&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            &lt;!--采用table来完成布局--&gt;        &lt;!--最外层的table，用于整个页面的布局--&gt;        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;           &lt;!-- 第1行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第2行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第3行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;                            &lt;td&gt;                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第4行 轮播图 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第5行 黑马精选--&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;                    黑马精选                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第6行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第7行 国内游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;                    国内游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第8行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第9行 境外游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;                    境外游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第10行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第11行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第12行 --&gt;            &lt;tr&gt;                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    江苏传智播客教育科技股份有限公司                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                    &lt;/font&gt;                &lt;/td&gt;            &lt;/tr&gt;                    &lt;/table&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><pre><code>1. HTML标签：表单标签2. CSS：</code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性</code></pre><p>​        </p><pre><code>    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;注册页面&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0px;            padding: 0px;            box-sizing: border-box;        &#125;        body&#123;            background: url(&quot;img/register_bg.png&quot;) no-repeat center;            padding-top: 25px;        &#125;            .rg_layout&#123;            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;            background-color: white;            /*让div水平居中*/            margin: auto;        &#125;            .rg_left&#123;            /*border: 1px solid red;*/            float: left;            margin: 15px;        &#125;        .rg_left &gt; p:first-child&#123;            color:#FFD026;            font-size: 20px;        &#125;            .rg_left &gt; p:last-child&#123;            color:#A6A6A6;            font-size: 20px;            &#125;</code></pre><p>​        </p><pre><code>        .rg_center&#123;            float: left;           /* border: 1px solid red;*/            &#125;            .rg_right&#123;            /*border: 1px solid red;*/            float: right;            margin: 15px;        &#125;            .rg_right &gt; p:first-child&#123;            font-size: 15px;            &#125;        .rg_right p a &#123;            color:pink;        &#125;            .td_left&#123;            width: 100px;            text-align: right;            height: 45px;        &#125;        .td_right&#123;            padding-left: 50px ;        &#125;            #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        &#125;        #checkcode&#123;            width: 110px;        &#125;            #img_check&#123;            height: 32px;            vertical-align: middle;        &#125;            #btn_sub&#123;            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        &#125;        &lt;/style&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;</code></pre><p>​        </p><pre><code>                        &lt;tr&gt;                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/form&gt;</code></pre><p>​        </p><pre><code>            &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>GIT 常用命令</title>
    <link href="http://example.com/2021/06/20/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/06/20/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-06-20T12:02:39.000Z</published>
    <updated>2021-10-28T13:14:13.035Z</updated>
    
    <content type="html"><![CDATA[<p>前言：学习一个门技术或者一个知识点，最终目标是学以致用。大谈理论大可不必。GIT就是这样一个工具，重点掌握如何使用方便日常代码管理。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>Git    everything is local</p></li><li><p>免费、开源的<strong>分布式</strong>版本控制工具</p></li><li><p>用于版本控制（个人开发–&gt;团队协作）</p></li><li><p>官网：<a href="https://git-scm.com/">https://git-scm.com</a></p></li><li><p>基本工作流程（存储到本地库历史版本最终应该上传到远程代码托管中心）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018154954412.png" alt="image-20211018154954412"></p></li></ul><p>安装过程在此不做介绍，网上有很多安装教程</p><p>下面详细介绍：GIT 命令、GIT 分支、github、idea整合Gitgitlab（基于局域网）</p><h2 id="GIT常用命令"><a href="#GIT常用命令" class="headerlink" title="GIT常用命令"></a>GIT常用命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr><tr><td></td><td></td></tr></tbody></table><p>用户签名可以在本机的用户目录中.gitconfig中查看</p><ul><li><p>Git中命令行命令和linux相同，我们使用vim编辑器编辑信息。</p></li><li><p>查看本地库的状态：git status  </p><p>//包括目录中未提交到缓存区、已经提交到缓存区、已经发布为历史版本等类型的文件，并用不同颜色显示</p><p>删除暂存区文件： “git rm –cached <file>…” </p></li><li><p><strong>提交本地库</strong>：<strong>git</strong> <strong>commit</strong>   -m “日志信息  文件名</p></li><li><p><strong>git reflog</strong> <strong>查看版本信息</strong>（简略信息）</p><p><strong>git log</strong> 查看版本详细信息(包括文件的版本信息、提交的用户、完整的版本号等信息)</p></li><li><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018162821693.png"></p></li><li><p>版本穿梭：文件更改之后，最终commit到本地库中</p><ul><li><p>本地库只显示最新的版本文件，并且按行管理版本，新增一个版本就会删除之前的版本行，添加新的行进去。</p></li><li><p>Git 支持穿越版本，通过指针更改，变换版本信息，对应相关版本的文件（前后穿越都可）</p><p>使用命令：<strong>git reset –hard</strong> <strong>版本号</strong></p></li></ul><p>​                </p></li></ul><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>Git branch -v</td><td>查看当前分支</td></tr><tr><td>Git branch hot-fix</td><td>添加热分支（紧急修复）</td></tr><tr><td>Git checkout  分支名</td><td>切换当前分支</td></tr><tr><td>Git merge  分支名</td><td>合并分支（没有产生合并冲突）</td></tr><tr><td>手动更改合文件 vim</td><td>合并分支（产生合并冲突）</td></tr><tr><td></td><td></td></tr></tbody></table><ul><li><p>分支可以在不影响主分支的前提下，并行得推进功能添加，单独进行开发，提高了开发效率，并且各个分支之间互相并不影响。</p></li><li><p>查看分支</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018164349203.png" alt="image-20211018164349203"></p><p>明显看到当前只有一个分支master</p></li><li><p>增加分支      Git branch 分支名</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018164549438.png" alt="image-20211018164549438"></p><p>此时已经有了两个分支(hot-fi 是主分支master的副本)</p></li><li><p>切换分支   Git checkout  分支名</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018165122993.png" alt="image-20211018165122993"></p></li><li><p>合并分支：  Git merge  分支名</p><ul><li><p>分支对文件进行了修改等操作，此时主分支和副分支内容不同，可以在主分支的角度上进行合并分支操作：Git merge hot-fi</p></li><li><p>假设在hot-fi中修改了内容，主分支不变，之后就会对主分支内容添加hot-fi分支添加的内容</p></li></ul><p>​       合并前后对比如下：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018165918020.png" alt="image-20211018165918020"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">特定情况下合并分支时，会产生冲突</span><br><span class="line"></span><br><span class="line">冲突产生的原因：</span><br><span class="line"></span><br><span class="line">合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git 无法替</span><br><span class="line"></span><br><span class="line">我们决定使用哪一个。必须人为决定新代码内容</span><br><span class="line"></span><br><span class="line">需要手动合并 </span><br><span class="line">1）编辑有冲突的文件，删除特殊符号，决定要使用的内容</span><br><span class="line">2）添加到暂存区</span><br><span class="line">3）执行提交（注意：此时使用 git commit 命令时不能带文件名）</span><br></pre></td></tr></table></figure><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li>官网：<a href="https://github.com/">https://github.com/</a></li><li>重点熟悉github页面了解使用流程<ul><li>创建远程仓库<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211018192017858.png" alt="image-20211018192017858"></li></ul></li><li>常见操作</li></ul><table><thead><tr><th><strong>命令名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><p>相关操作和本机操作类似：</p><ul><li>克隆远程仓库到本地                 Git clone 远程地址</li><li>推送本地分支到远程仓库        Git push 别名 分支</li><li>拉取远程库内容：                    git pull 远程库地址别名 远程分支名</li></ul>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer Network summery  网络层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-06-20T12:01:53.000Z</published>
    <updated>2021-07-04T07:51:18.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-network-summery-网络层"><a href="#Computer-network-summery-网络层" class="headerlink" title="Computer network summery :网络层"></a>Computer network summery :网络层</h1><h2 id="一、功能和服务"><a href="#一、功能和服务" class="headerlink" title="一、功能和服务"></a>一、功能和服务</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><ul><li><p>路由器不运行应用层和运输层协议</p></li><li><p>功能：转发和路由选择</p></li><li><p> 网络层只向上提供简单灵活的，无连接的，尽力而为的<strong>数据报服务</strong></p></li><li><p>路由选择：网络层决定分组所采用的路径或路由；计算方法是<strong>路由选择算法</strong>( routing algorithm)</p></li><li><p>路由器都具有一张<strong>转发表</strong> (fOlwarding tahle) </p></li><li><p>某些网络体系结构也要求在数据报在路径中流动之前建立连接</p><p>​    例如：ATM 、帧中继、 MPLS</p></li></ul><h3 id="1-2-交换机"><a href="#1-2-交换机" class="headerlink" title="1.2 交换机"></a>1.2 交换机</h3><p>某些分组交换机称为</p><p>链路层交换机(link-Iayer switches) </p><p>其他分组交换机称为路由器( router) </p><h3 id="1-3-服务模型"><a href="#1-3-服务模型" class="headerlink" title="1.3 服务模型"></a>1.3 服务模型</h3><p>定义了分组在发送与接收端系统之间的端到端运输特性</p><ul><li>网络层提供的特定服务<ul><li>确保支付</li><li>具有时延上界的确 保交付</li><li>有序分组支付</li><li>确保最小带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li><li>网络层提供尽力而为服务</li></ul><h3 id="1-4虚电路和数据报网络"><a href="#1-4虚电路和数据报网络" class="headerlink" title="1.4虚电路和数据报网络"></a>1.4虚电路和数据报网络</h3><ul><li>与运输层类似，网络层也能够在两台主机之间提供无连接服务或连接服务</li></ul><ol><li><p><strong>虚电路网络</strong>:仅在网络层提供连接服务的计算机网络</p></li><li><p><strong>数据报网络</strong>:仅在网络层提供无连接服务的计算机网络</p></li><li><p>几乎所有主要计算机网络体系中都不<strong>同时</strong>提供两种服务</p></li><li><p>与运输层的<strong>区别</strong>：运输层服务在端系统中实现，网络层连接服务在端系统中，也在位于网络核心的路由器中实现</p></li><li><p>虚电路网络和数据报网络是计算机网络的两种基本类型 作出转发时，使用了非常不同的信息。</p></li></ol><ul><li><p>虚电路网络</p></li><li><p>数据报网络</p><ul><li><p>端系统要发送分组—&gt;就为该分组加上目的端系统的地</p><p>址，—&gt;将分组推进网络中  </p><p>无需建立任何虚电路，路由器不维护任何虚电路的状态信息</p></li></ul></li></ul><h2 id="二、路由转发"><a href="#二、路由转发" class="headerlink" title="二、路由转发"></a>二、路由转发</h2><h3 id="1、路由器："><a href="#1、路由器：" class="headerlink" title="1、路由器："></a>1、路由器：</h3><ul><li><p>结构</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528204542791.png" alt="image-20210528204542791"></p><ul><li>输入端口：与物理链路相连</li><li>交换结构：网络路由器中的网络</li><li>输出端口：存储和传输交换结构传出的分组</li><li>路由选择处理器：执行路由选择协议</li></ul></li></ul><h3 id="2、输入端口"><a href="#2、输入端口" class="headerlink" title="2、输入端口"></a>2、输入端口</h3><ul><li>输入端口的处理<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205032133.png" alt="image-20210528205032133"></li><li>从链路接收分组，对分组进行处理，通过路由表查找某分组的输出端口，发送到交换结构。</li><li>阻塞的分组在输入端口进行排队</li></ul></li></ul><h3 id="3、交换结构"><a href="#3、交换结构" class="headerlink" title="3、交换结构"></a>3、交换结构</h3><ul><li><p>交换结构：核心部位</p><ul><li><p>三种交换技术：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205614574.png" alt="image-20210528205614574"></p><ul><li><p>内存交换</p></li><li><p>总线交换</p></li><li><p>互联网络交换</p><p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p></li></ul></li></ul></li></ul><h3 id="4、输出端口"><a href="#4、输出端口" class="headerlink" title="4、输出端口"></a>4、输出端口</h3><ul><li>输出端口<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205817371.png" alt="image-20210528205817371"></li><li>选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能</li></ul></li><li>排队（拥塞）<ul><li>输入线路速率，比输出速率大，路由器空间耗尽，后到达的分组会丢包</li></ul></li></ul><h2 id="三、网际协议-IP"><a href="#三、网际协议-IP" class="headerlink" title="三、网际协议 IP"></a>三、网际协议 IP</h2><ul><li><p>TCP/IP 体系中最重要的协议之一</p></li><li><p>与IP配套使用的相关协议由IGMP、ARP、ICMP等</p></li><li><p>通过IP协议使不同的网络在逻辑层面互相连接（虚拟连接）</p></li><li><p>通过IP区分不同的网络，一个网络可以由多种异构网络构成</p></li><li></li></ul><p>因特网中的转发和编址</p><ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211114845.png" alt="image-20210528211114845"></li></ul><h3 id="1、数据报格式"><a href="#1、数据报格式" class="headerlink" title="1、数据报格式"></a>1、数据报格式</h3><p>（IPv4）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211224903.png" alt="image-20210528211224903"></p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本号</td><td align="center">IPv4/IPv6</td></tr><tr><td align="center">首部长度</td><td align="center">一般20字节</td></tr><tr><td align="center">服务类型</td><td align="center">服务类型</td></tr><tr><td align="center">数据报长度</td><td align="center">IP数据报总长度</td></tr><tr><td align="center">标识、标志、片偏移</td><td align="center">与ip分片有关的标示量</td></tr><tr><td align="center">寿命</td><td align="center">寿命 (Time-To- Live TTL)；避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源和目的IP</td><td align="center">转发的地址</td></tr><tr><td align="center">选项</td><td align="center">选项字段 首部扩展（超过20字节）</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table><h3 id="2、数据报分片"><a href="#2、数据报分片" class="headerlink" title="2、数据报分片"></a>2、数据报分片</h3><ul><li><p>数据报不能超过链路层所能承受的最大网络层分组</p></li><li><p>数据报过大时，进行分组，分成的较小数据报叫做片</p></li><li><p>片在目的地端系统进行重新组装，而不是路由器（简便网络内核）</p></li><li><p>发送方为它发送的每个数据报的标识号加1；也就是同一数据报，不同的片 标志相同</p></li><li><p>分片之后转发的片中，最后一个片的标志比特被设为0 ，而所有其他片的标志比特被设为1，</p></li><li><p>偏移字段指定该片应放在初始 数据报的哪个位置</p></li></ul><h3 id="3、IP编址"><a href="#3、IP编址" class="headerlink" title="3、IP编址"></a>3、IP编址</h3><ul><li>网络IP编制涉及以下几个问题：<ul><li>子网划分</li><li>分类的IP地址</li><li>子网掩码</li></ul></li></ul><p><strong>3.1 IP地址分类</strong>：</p><ul><li><p>a类地址：1~126<br>127被lookupback（回环地址）占用–》测试tcp/ip协议的是否正常，任何一台计算机上都有这个地址，这个地址代表本机（127.0.0.1）<br>网络+主机+主机+主机<br>1.0.0.0/8 –》google –》2^24 = 16777216<br>1.0.0.1 1.0.0.2<br>2.0.0.0/8 –&gt;Harvard<br>3.0.0.0/8 –&gt;ibm<br>4.0.0.0/8 –&gt;microsoft</p></li><li><p>b类地址：128~191<br>网络+网络+主机+主机<br>网络的个数：2^14 = 16384<br>每个网络里可以容纳的主机数=2^16 -2<br>129.1.0.0/16</p></li><li><p>c类地址：192~223<br>网络+网络+网络+主机<br>网络的个数：2^21 = 2097152<br>每个网络里可以容纳的主机数=2^8 - 2 =254<br>主机部分全为0代表网段<br>主机部分全为1代表这个网段的广播地址</p></li><li><p>d类：224~239拥有组播通信</p></li><li><p>E类：240~255 保留给科学研究使用</p><!--公网上使用的ip地址是A,B,C类--></li><li><p>私有地址</p><ul><li>满足企业用户在内部网络中使用的需求</li><li>私有地址不能在Internet上使用</li><li>私有地址包括3组<br>A类：10.0.0.0<del>10.255.255.255<br>B类：172.16.0.0</del>172.31.255.255<br>C类：192.168.0.0~192.168.255.255</li></ul></li></ul><p> <strong>具体详解：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">1. A类IP地址</span><br><span class="line">   1.1 网络号——占1个字节</span><br><span class="line">   A类地址的网络号字段占1个字节，但前面的1位(0)已经固定，只剩下7位可以进行分配。即可指派的网络号是126个(即2^7-2)。</span><br><span class="line">   网络号字段为全0的IP地址是个保留地址，意思是“本网络”。</span><br><span class="line">   网络号为127(即01111111)保留作为本地软件环回测试(loopback test)本主机的进程之间的通信只用。</span><br><span class="line">   若主机发送一个目的地址为环回地址(例如 127.0.0.1)的IP数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。</span><br><span class="line">   目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。。</span><br><span class="line">   1.2 主机号——占3个字节</span><br><span class="line">   A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是2^24-2，即16777214。</span><br><span class="line">   全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为5.6.7.8，则该主机所在的网络地址就是5.0.0.0)。</span><br><span class="line">   全1的主机号字段表示该IP地址是“所有的”，即该网络上的所有主机。</span><br><span class="line">   注：IP地址空间共有2^32(即4294967296)个地址。整个A类地址空间共有2^31个地址，占有整个IP地址空间的50%。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. B类IP地址</span><br><span class="line">   2.1 网络号——占2个字节</span><br><span class="line">   B类地址的网络号字段占2个字节，但前面的2位(1 0)已经固定，只剩下14位可以进行分配。</span><br><span class="line">   B类网络地址128.0.0.0是不指派的，而可以指派的B类最小网络地址是128.1.0.0。因此B类地址可指派的网络数是2^14-1，即16383。</span><br><span class="line">   2.2 主机号——占2个字节</span><br><span class="line">   B类地址的每一个网络上的最大主机数是2^16-2，即65534，这里需要减2是因为要扣除全0和全1的主机号。</span><br><span class="line">   注：整个B类地址空间共约2^30个地址，占有整个IP地址空间的25%。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. C类IP地址</span><br><span class="line">   3.1 网络号——占3个字节</span><br><span class="line">   C类地址的网络号字段占3个字节，但前面的3位(1 1 0)已经固定，只剩下21位可以进行分配。</span><br><span class="line"></span><br><span class="line">   C类网络地址192.0.0.0是不指派的，而可以指派的C类最小网络地址是192.0.1.0。因此B类地址可指派的网络数是2^21-1，即2097151。</span><br><span class="line"></span><br><span class="line">   3.2 主机号——占1个字节</span><br><span class="line">   C类地址的每一个网络上的最大主机数是2^8-2，即254，这里需要减2是因为要扣除全0和全1的主机号。</span><br><span class="line">   注：整个C类地址空间共约2^29个地址，占有整个IP地址空间的12.5%。</span><br><span class="line"></span><br><span class="line">一些特殊的网络地址：</span><br><span class="line">一、0.0.0.0</span><br><span class="line">严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。</span><br><span class="line">二、255.255.255.255</span><br><span class="line">限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。</span><br><span class="line">三、127.0.0.1</span><br><span class="line">本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。</span><br><span class="line">四、224.0.0.1</span><br><span class="line">组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP(Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。</span><br><span class="line">五、169.254.X.X</span><br><span class="line">如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</span><br><span class="line">六、10.X.X.X、172.16.X.X～172.31.X.X、192.168.X.X</span><br><span class="line">私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。</span><br><span class="line">七，广播地址(Broadcast Address)</span><br><span class="line">是专门用于同时向网络中（通常指同一子网）所有工作站进行发送的一个地址。在使用TCP&#x2F;IP 协议的网络中，主机标识段host ID（简称主机 ID） 为全 1 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为 2 进制的 11111111 ），当发出一个目的地址为10.1.1.255 的数据包时，它将被分发给该网段上的所有计算机。广播地址应用于网络内的所有主机。</span><br><span class="line">八，网络地址</span><br><span class="line">指的是互联网上的节点在网络中具有的逻辑地址，可对节点进行寻址。主机地址指的是IP地址右边部分用来标识主机本身的部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个 IP地址的网络部分被称为网络号或者网络地址,主机可以与具有相同的网络号的设备直接通讯，在没有连接设备的情况下，即使共享相同的物理网段，网络号不同则无法进行通讯，IP 地址的网络地址使路由器可以将分组置于正确的网段上 。</span><br></pre></td></tr></table></figure><p><strong>2.子网掩码：</strong><br>16 表示网络部分的长度 –》子网掩码也是32位<br>作用：标识ip地址里网络部分的长度<br>用来确定IP的网络地址<br>11111111.11111111.00000000.00000000</p><p>32个二进制位<br>对应IP地址的网络部分用1表示<br>对应IP地址的主机部分用0表示<br>IP地址和子网掩码作逻辑“与”运算得到网络地址</p><p>0和任何数相与都等于0<br>1和任何数相与都等于任何数本身</p><p>网段：就是网络部分的内容<br>192.168.0.4/24 –&gt;192.168.0.0</p><p>A、B、C三类地址的默认子网掩码<br>A类：255.0.0.0<br>B类：255.255.0.0<br>C类：255.255.255.0</p><p><strong>3.子网划分：</strong></p><p>将一个大网络划分为许多的小网络（网络位向主机位借位）<br>子网划分的原因：</p><ul><li>满足不同网络对IP地址的需求</li><li>实现网络的层次性</li></ul><h3 id="4、互联网控制报文协议-ICMP"><a href="#4、互联网控制报文协议-ICMP" class="headerlink" title="4、互联网控制报文协议 (ICMP)"></a>4、互联网控制报文协议 (ICMP)</h3><ul><li><p>主机和路由器用来彼此沟通网络层的信息，用来进行差错报告。</p></li><li><p>ICMP报文是承载在ip 分组中，但是也被看做ip的一部分</p></li><li><p>ICMP协议的功能主要是：</p><ul><li><ol><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ol></li></ul></li><li><p>ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6</p></li><li><p><strong>ICMP的报文格式</strong><br>ICMP报文包含在IP数据报中 。</p><p>​    一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）    和ICMP报文（属于ICMP报文的数据部分）<strong>。当IP报头中的协议字段值    为1时，就说明这是一个ICMP报文。</strong>ICMP报头如下图所示。<br> <img src="https://img-blog.csdn.net/201805301801365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>字段说明：</p><ul><li>类型    一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</li><li>代码    占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</li><li>校验和    这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与在我们介绍IP报头中的校验和计算方法是一样的） </li></ul></li><li></li><li><p>ICMP报文分类：</p><ul><li><p>一类是通知出错原因 （差错报告报文）；</p></li><li><p>一类是用于诊断查询（询问报文）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210704145410714.png" alt="image-20210704145410714"></p></li></ul></li><li><p>众所周知的 ping 程序发送一个 ICMP 类型 编码 的报文到指定主机</p></li></ul><h3 id="5、IGMP网际组管理协议"><a href="#5、IGMP网际组管理协议" class="headerlink" title="5、IGMP网际组管理协议"></a>5、IGMP网际组管理协议</h3><h3 id="6、arp地址解析协议"><a href="#6、arp地址解析协议" class="headerlink" title="6、arp地址解析协议"></a>6、arp地址解析协议</h3><ul><li>逆地址解析协议RARP（现在几乎已经不使用了）</li><li>具体功能是：由IP地址解析得到硬件地址（MAC）</li></ul><p>1.要点</p><ul><li>在主机的高速缓存ARP 缓存中存放一个IP到硬件地址的动态映射表<ul><li>通过响应分组和请求分组动态获取想要发送的IP的未知硬件地址</li><li>响应分组是单播；请求分组是广播</li><li>每一个地址映射信息都有生存时间</li></ul></li></ul><h3 id="7、ipv6"><a href="#7、ipv6" class="headerlink" title="7、ipv6"></a>7、ipv6</h3><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528213948939.png" alt="image-20210528213948939"></p><p><strong>概述</strong></p><ul><li><p>解决ipv4地址不足的问题</p></li><li><p>报文结构</p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本</td><td align="center">IPv4/IPv6                         4比特</td></tr><tr><td align="center">流标签</td><td align="center">于标识一条数据报的流    20比特</td></tr><tr><td align="center">流量类型</td><td align="center">与TOS 字段的含义相似   8比特</td></tr><tr><td align="center">有效负载长度</td><td align="center">IP首部后数据字节数量  16比特</td></tr><tr><td align="center">下一个首部</td><td align="center">标识数据包交付对象（TCP/UDP ）</td></tr><tr><td align="center">跳限制</td><td align="center">与TTL类似  避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源地址</td><td align="center">128比特</td></tr><tr><td align="center">目的地址</td><td align="center">128比特</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table></li><li><p>IPv6首部40字节</p></li></ul><p><strong>相对ipv4特点（不同）：</strong></p><ul><li>不允许在中间路由器上进行分片与重新组装，只能在源与目的地上执行———-没有了分片标志</li><li>没有首部检验和字段，检验在运输层和数据链路层中完成</li><li>没有选项字段，删除选项字段使得 IP 首部成为定长的 40 字节</li><li>地址容量扩大了</li><li>拥有流标签和优先级</li></ul><h2 id="四、路由选择算法"><a href="#四、路由选择算法" class="headerlink" title="四、路由选择算法"></a>四、路由选择算法</h2><p>主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器 (default router) , 又称为该主机的第一跳路由器 (first- hop router）</p><p>源主机的默认路由器称作源路由器( source 川出r) ，把目的主机的默认路由器称作目的路由器 (destination router)</p><p>一个分组从源主机到目的主机的路由选择的较好 方法即路由选择算法</p><p>在两个路由之间根据链路开销，存在一条或者多条最低开销路径。</p><p>最低开销路径也就是最短路径———————最短路径算法SPF；</p><p><strong>路由控制</strong></p><ul><li><p>每路由控制。</p><p>每台路由器中运行一种路由选择算法的情况，每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。这种每路由器控制的方法在因特网中已经使用了几十年。</p><p>OSPF和BGP协议都是基于这种每路由器的方法进行控制的。</p></li><li><p>逻辑集中式控制。</p><p>逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况。通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能(负载共享、防火墙功能、NAT)的丰富集合，而这些功能先前是在单独的中间盒中实现的。</p><p>SDN采用了逻辑集中控制器的概念，而这种方法在生产部署中得到了越来越多的应用。</p></li></ul><h4 id="1-路由选择算法"><a href="#1-路由选择算法" class="headerlink" title="1.路由选择算法"></a>1.路由选择算法</h4><p><strong>分类：</strong></p><ul><li><p><code>全局式路由选择算法</code> (globaJ routing aJgorithm) </p><p>：用完整的、全局性的网络知识计算从源到目的地之间的最低开销路径，即 以所有结点之间的连通</p><p>性及所有链路的费用为输入</p><p>例：链路状态算法  LS  </p><p>​       适应每路由和逻辑集中控制：路由计算可以在集中式路由选择器 开门中，也可以在每台路由器的路优选择组件</p></li></ul><p>​        <code>分散式路由选择算法**</code> (dece t.ralized routing aJgorithm)</p><p>​                以迭代、分布式的方式计算最低开销路径 ，没有结点拥有关于所有网络链路费用的完整信息，                而每个结点仅有与其直接相连链路的费用知识即可开始工作</p><p>​        例：距离向量算法 DV   </p><p>​                天然适应逻辑集中式控制</p><ul><li><p><code>静态路由选择算法</code> (SlaLÌc rouling aJgorithm)：**手工配置、路由更新慢、优先级高</p><p>简单，开销小，但不能及时适应网络状态的变化，适用于小型网络。</p><p><code>动态路由选择算法</code>(dynamic rouling aJ gorithm)**：路由更新快（定期更新、及时响应链路费用或网络拓扑变化）</p><p>能较好地适应网络状态的变化，实现较为复杂，适用于大型网络。</p><p>容易受到路优选择循环、路由震荡的影响</p></li><li><p><code>负载敏感算法</code> load-sensiLÌve aJ gorithm)</p><p>：链路开销动态变化，反映当前链路底层链路的拥塞水平</p><p><code>负载迟钝算法</code>(load-insensitive) </p><p>当今的路由选择算法都是负载迟钝的。</p></li></ul><p><strong>常见算法：</strong></p><ul><li><p>电路交换路由选择算 (circuiL- swiLched routing algorith m)</p></li><li><p>距离向量(Distance- Vector, DV) 算法</p><ul><li>路由器周期性地向其相邻路由器广播自己知道的路由信息，用以通知相邻路由器自己可以到达的网络以及到达该网络的距离。相邻路由器可以根据收到的路由信息修改和刷新自己的路由表。</li><li>优点：算法简单、易于实现。</li><li>缺点：慢收敛问题，路由器的路径变化需要像波浪一样从相邻路由器传播出去，过程缓慢。</li></ul></li><li><p>链路状态广播 (link state broadcast) 算法 </p><ul><li>也叫最短路径优先(shortest path first SPF)算法，它的主要做法如下：<ul><li>首先由路由器向相邻路由器发送查询报文，测试和它相邻路由器的链路状态。如果可以收到相邻路由器发回的响应，则说明该相邻路由器和这个路由器之间可以正常通信；</li><li>在收到该路由器和其他相邻路由器的链路状态后，还向系统中所有参加最短路径优先算法的路由器发送链路状态报文；</li><li>各路由器收到其他路由器发来的链路状态报文后，根据报文中的数据刷新本路由器所保存的网络拓扑结构图。如果链路发生变化，路由器将启用Dijkstra算法生成新的最短路径优先数，并刷新本地路由表；</li></ul></li></ul></li></ul><p><em><strong>分层次的路由选择协议：</strong></em></p><p>因特网采用的路由选择协议主要是<strong>自适应的、动态的、分布式的、分层次的</strong>路由选择协议。</p><p><em><strong>自治系统（autonomous system,AS）</strong></em></p><p> 就是几个路由器组成了一个小团体，小团体内部使用专用的协议进行通信，而小团体和小团体之间也使用专用的协议进行通信。</p><p>目前的因特网中，ISP就是一个自治系统。</p><h2 id="五、路由选择协议"><a href="#五、路由选择协议" class="headerlink" title="五、路由选择协议"></a>五、路由选择协议</h2><p>计算出用于在网络中转发分组的转发表</p><p>两种 AS 内部路由选择协议 (RIP/OSPF) 和一种 AS 间路由选择协议 (BGP)</p><h3 id="1、AS-内部路由选择协议"><a href="#1、AS-内部路由选择协议" class="headerlink" title="1、AS 内部路由选择协议"></a>1、AS 内部路由选择协议</h3><h4 id="1-1-路由信息协议-RIP"><a href="#1-1-路由信息协议-RIP" class="headerlink" title="1.1 路由信息协议 RIP"></a>1.1 路由信息协议 RIP</h4><p> (Routing Information Protocol)</p><p>✅ 它是一种分布式的、基于距离向量的路由选择协议。<br>✅ 它要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。<br><strong>关于距离的定义：</strong></p><p>从一个路由器到直接连接的网络的距离定义为 1。<br>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。<br>“距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。<br>这里的“距离”实际上指的是“最短距离”。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p><p>RIP 允许一条路径最多只能包含 15 个路由器。</p><p>这意味着 RIP 只会选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p><p><strong>RIP 协议的三个特点:</strong></p><ul><li><p>仅和相邻路由器交换信息。</p></li><li><p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</p></li><li><p>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p><p><strong>AS（自治系统）之内的路由器如何建立路由表？</strong></p></li></ul><p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。它的路由表是空的。以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。<br>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。<br>RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</p><p> <strong>RIP2的报文格式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414151233228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>RIP2 报文由首部和路由部分组成。</p><ul><li>RIP2 报文中的路由部分由若干个路由信息组成。</li><li>地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</li><li>路由标记填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。</li><li>再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。</li></ul><p>一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4 + 20 × 25 = 504 4+20\times25=5044+20×25=504字节。如超过，必须再用一个 RIP 报文来传送。</p><h4 id="1-2-开放最短路径优先-OSPF"><a href="#1-2-开放最短路径优先-OSPF" class="headerlink" title="1.2 开放最短路径优先 OSPF"></a>1.2 开放最短路径优先 OSPF</h4><ul><li><p>OSPF (Open Shortest Path First) 是为克服 RIP 的缺点在<code>1989</code>年开发出来的。</p></li><li><p>使用了 Dijkstra 提出的最短路径算法 SPF</p></li></ul><p><strong>区域</strong></p><p>OSPF 将一个自治系统再划分为若干个更小的范围，叫作<code>区域</code>。</p><p>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</p><p><img src="https://img-blog.csdnimg.cn/20200414174248189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>OSPF 使用 IP 数据报传送：</strong></p><ul><li>✅ OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>✅ OSPF 构成的数据报很短。好处是可以不必将长的数据报分片传送。</li><li>✅ 支持可变长度的子网划分和无分类编址 CIDR。</li></ul><p><strong>OSPF 分组</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414174524743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>五种分组类型</p><p>1️⃣ 类型1：问候 (Hello) 分组。<br>2️⃣ 类型2：数据库描述 (Database Description) 分组。<br>3️⃣ 类型3：链路状态请求 (Link State Request) 分组。<br>4️⃣ 类型4：链路状态更新 (Link State Update) 分组，用洪泛法对全网更新链路状态。<br>5️⃣ 类型5：链路状态确认 (Link State Acknowledgment) 分组。</p><h3 id="2、AS-间路由选择协议"><a href="#2、AS-间路由选择协议" class="headerlink" title="2、AS 间路由选择协议"></a>2、AS 间路由选择协议</h3><p> <strong>(边界网关协议 BGP）</strong></p><ul><li><p>BGP 是不同自治系统的路由器之间交换路由信息的协议</p></li><li><p>要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200414174933546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>BGP-4 共使用四种报文</strong> </p><ol><li> 打开 (OPEN) 报文：用来与相邻的另一个BGP发言人建立关系。</li><li> 更新 (UPDATE) 报文：用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li> 保活 (KEEPALIVE) 报文：用来确认打开报文和周期性地证实邻站关系。</li><li> 通知 (NOTIFICATION) 报文：用来发送检测到的差错。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200414175219726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="六、简单网络管理协议（SNMP）"><a href="#六、简单网络管理协议（SNMP）" class="headerlink" title="六、简单网络管理协议（SNMP）"></a>六、简单网络管理协议（SNMP）</h2><p>基于T C P / I P的网络管理包含两个部分：网络管理站（也叫管理进程， m a n a g e r）和被管的网络单元（也叫被管设备）。被管设备端和管理相关的软件叫做代理程序( a g e n t )或代理进程。</p><p>管理进程和代理进程之间的通信可以有两种方式。一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的 I C M P端口？）。另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生。</p><p>基于T C P / I P的网络管理包含3个组成部分：</p><ol><li><p> 一个管理信息库M I B（Management Information Base）。管理信息库包含所有代理进程的所有可被查询和修改的参数。</p></li><li><p> 关于M I B的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。</p></li><li><p> 管理进程和代理进程之间的通信协议，叫做简单网络管理协议 S N M P（Simple Network Management Protocol）。</p></li></ol><p>协议<br>关于管理进程和代理进程之间的交互信息， S N M P定义了5种报文：</p><ol><li><p> get - r e q u e s t操作：从代理进程处提取一个或多个参数值。</p></li><li><p> get - n e x t - r e q u e s t操作：从代理进程处提取一个或多个参数的下一个参数值</p></li><li><p> set - r e q u e s t操作：设置代理进程的一个或多个参数值。</p></li><li><p> get - r e s p o n s e操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</p></li><li><p>t r a p 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</p></li></ol><p>前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的。</p><p>管理信息结构<br>SNMP中，数据类型不多，只有INTEGER，OCTER STRING，IPAddress等</p><p>对象标识符<br>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</p><p>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于 D N S或U n i x的文件系统</p><p> 管理信息库介绍<br>所谓管理信息库，或者M I B，就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p><p>M I B组：s y s t e m（系统标识）、i f（接口）、a t（地址转换）、i p、i c m p和t c p。</p><p>s y s t e m组非常简单，它包含7个简单变量</p><p>interface组只定义了一个简单变量，那就是系统的接口数量</p><p>i p组定义了很多简单变量和3个表格变量</p><p>i c m p组包含4个普通计数器变量（ I C M P报文的输出和输入数量以及 I C M P差错报文的输入和输出数量）和2 2个其他I C M P报文数量的计数器：11个是输出计数器，另外11个是输入计数器。</p><p>t c p组中的简单变量几乎都和T C P状态有关。</p><h2 id="七、SDN-控制平面"><a href="#七、SDN-控制平面" class="headerlink" title="七、SDN 控制平面"></a>七、SDN 控制平面</h2>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
</feed>
