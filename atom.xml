<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-03T08:37:30.308Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-设计原则</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-02T08:20:42.000Z</published>
    <updated>2022-03-03T08:37:30.308Z</updated>
    
    <content type="html"><![CDATA[<p>下面了解一些经典的设计原则，包括，SOLID、KISS、YAGNI、DRY、LOD 等。</p><p>就SOLID原则来说，SOLID 原则并非单纯的 1 个原则，而是由 5个设计原则组成的，它们分别是：<strong>单一职责原则、开闭原则、里式替换原则、接口隔离原则</strong>和<strong>依赖反转原则</strong>。</p><h3 id="单一职责原则SRP"><a href="#单一职责原则SRP" class="headerlink" title="单一职责原则SRP"></a>单一职责原则SRP</h3><p>描述起来就是：一个类或者一个模块只完成一个功能（职责）</p><p>也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，</p><p>一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该</p><p>将它拆分成多个功能更加单一、粒度更细的类。</p><p>​    需要注意的是，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否</p><p>单一的判定，可能都是不一样的。具体场景具体分析，并没有一个明确的，一成不变的标准。</p><p>​    不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展</p><p>性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以</p><p>此作为最终的考量标准。</p><p>​    总结几个情况可能说明这类的设计不满足单一职责原则：</p><p>1、类中的代码行数、函数或者属性过多；</p><p>2、类依赖的其他类过多，或者依赖类的其他类过多；</p><p>3、私有方法过多；</p><p>4、比较难给类起一个合适的名字；</p><p>5、类中大量的方法都是集中操作类中的某几个属性。</p><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>上面介绍了单一职责原则，下面来看一下   第二个原则：开闭原则</p><p>大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设</p><p>计原则就是开闭原则。</p><p>开闭原则的英文全称是 Open Closed Principle，他所描述的原则是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><h3 id="里式替换原则LSP"><a href="#里式替换原则LSP" class="headerlink" title="里式替换原则LSP"></a><strong>里式替换原则</strong>LSP</h3><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。</p><p>原则的描述大致是：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”</p><p>原则描述为：<strong>客户端不应该强迫依赖它不需要的接口</strong>。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面了解一些经典的设计原则，包括，SOLID、KISS、YAGNI、DRY、LOD 等。&lt;/p&gt;
&lt;p&gt;就SOLID原则来说，SOLID 原则并非单纯的 1 个原则，而是由 5个设计原则组成的，它们分别是：&lt;strong&gt;单一职责原则、开闭原则、里式替换原则、接口隔离原则&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-面向对象</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-02T08:19:59.000Z</published>
    <updated>2022-03-03T04:29:52.544Z</updated>
    
    <content type="html"><![CDATA[<p>为了保证知识的全面性，在此讨论面向对象的设计思想，为之后的设计模式做铺垫。</p><h3 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h3><p>首先耳熟能详的面向对象的四大特性：封装、继承、抽象、多态。</p><p><strong>面向对象编程和面向对象编程语言？</strong></p><p>面向对象的两个重要概念：类和对象。</p><ul><li>面向对象编程可以理解成以面向对象四大特性为代码设计基础，以类和对象作为代码基本组织单元的一种编程范式。</li><li>面向对象编程语言：狭义上来说是实现面向对象特性，并且支持类和对象为主体的语法机制的编程语言。</li></ul><p><strong>面向对象分析和面向对象设计？</strong></p><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶</p><p>段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等。</p><h3 id="二、面向对象四大特性"><a href="#二、面向对象四大特性" class="headerlink" title="二、面向对象四大特性"></a>二、面向对象四大特性</h3><p>下面详细分析以下面向对象四大特性</p><p><strong>1. 关于封装特性</strong></p><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类</p><p>提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如</p><p>Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据</p><p>不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用</p><p>性。</p><p><strong>2. 关于抽象特性</strong></p><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只</p><p>需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或</p><p>者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代</p><p>码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也</p><p>是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p><strong>3. 关于继承特性</strong>继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子</p><p>类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程</p><p>语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p><strong>4. 关于多态特性</strong></p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特</p><p>性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可</p><p>以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h3 id="三、面向对象编程相比面向过程编程有什么优点？"><a href="#三、面向对象编程相比面向过程编程有什么优点？" class="headerlink" title="三、面向对象编程相比面向过程编程有什么优点？"></a>三、<strong>面向对象编程相比面向过程编程有什么优点？</strong></h3><p>面向过程编程适用于简单程序开发，程序流程有一条主线，分步骤顺序执行，对于简单的执行流程的程序来说比较适合。</p><p>面向对象编程是用于大规模程序开发，对于整体程序流程错综复杂。以类为思考对象。经过面向对象设计，将需求翻译成类。建立类之间的相互关系，最终组装成程序。</p><p>面向对象的设计模式提供了更清晰、模块化的代码组织方式。</p><p>面向对象编程的代码更易复用、易于维护和复用。（面向对象编程，具有更丰富的特性）</p><h3 id="四、接口和抽象类的区别？"><a href="#四、接口和抽象类的区别？" class="headerlink" title="四、接口和抽象类的区别？"></a>四、接口和抽象类的区别？</h3><p>java即支持抽象类也支持接口。</p><p>1、抽象类</p><p>​    抽象类不能被实例化，只能被继承。</p><p>​    抽象类中可以包含属性和方法，方法可以包含抽象方法（无代码具体实现）和非抽象方法。</p><p>​    子类继承抽象类，必须实现抽象类中的所有<strong>抽象</strong>方法。</p><p>抽象类是一种特殊的不能被实例化类，。</p><p>2、接口 </p><p>​    接口不能包含属性（成员变量）</p><p>​    接口只能还包含抽象方法（无具体实现 ）</p><p>​    实现类实现接口时，必须实现接口中的所有方法。</p><p>3、抽象类和接口的应用场景区别**</p><p>如果要表示一种is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示 has-a关系，并且解决抽象而不是代码复用的问题，那么就可以使用接口。</p><h3 id="五、基于接口编程？"><a href="#五、基于接口编程？" class="headerlink" title="五、基于接口编程？"></a>五、基于接口编程？</h3><p>一个和接口有关的原则：基于接口编程而非实现编程。</p><p>​    从本质上来说，接口可以理解成一组“协议”，“约定”，上述原则可以表述成：基于抽象编程而非实现编程：抽象是提高代码可扩展性、灵活行性、可维护性的有效手段之一</p><p> 定义接口要注意：</p><p>1、函数的命名不能暴露任何实现细节。 </p><p>2、 封装具体的实现细节。 </p><p>3、为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能</p><h3 id="六、多用组合少用继承"><a href="#六、多用组合少用继承" class="headerlink" title="六、多用组合少用继承"></a>六、多用组合少用继承</h3><p>有这么一条设计原则：组合优于继承</p><p><strong>1. 为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>2. 组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>3. 如何判断该用组合还是继承？</strong></p><p> 组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="七、贫血模型-VS-充血模型"><a href="#七、贫血模型-VS-充血模型" class="headerlink" title="七、贫血模型 VS 充血模型"></a>七、<strong>贫血模型</strong> <strong>VS</strong> <strong>充血模型</strong></h3><p>我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构， 相对于新兴的基于充血模型的</p><p>DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了保证知识的全面性，在此讨论面向对象的设计思想，为之后的设计模式做铺垫。&lt;/p&gt;
&lt;h3 id=&quot;一、面向对象&quot;&gt;&lt;a href=&quot;#一、面向对象&quot; class=&quot;headerlink&quot; title=&quot;一、面向对象&quot;&gt;&lt;/a&gt;一、面向对象&lt;/h3&gt;&lt;p&gt;首先耳熟能详的面向</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:33:00.000Z</published>
    <updated>2022-03-02T04:33:00.328Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:32:49.000Z</published>
    <updated>2022-03-02T04:32:49.573Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:31:58.000Z</published>
    <updated>2022-03-02T04:31:58.146Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:31:15.000Z</published>
    <updated>2022-03-02T08:07:33.400Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA并发-结构化并发应用程序</title>
    <link href="http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-02-13T08:35:30.000Z</published>
    <updated>2022-02-13T08:35:30.801Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA并发实战-基础知识</title>
    <link href="http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-02-13T08:27:27.000Z</published>
    <updated>2022-02-13T08:27:27.133Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-表</title>
    <link href="http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E8%A1%A8/"/>
    <id>http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E8%A1%A8/</id>
    <published>2022-02-12T05:57:23.000Z</published>
    <updated>2022-02-12T05:58:59.210Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnDB存储引擎与文件</title>
    <link href="http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8E%E6%96%87%E4%BB%B6/</id>
    <published>2022-02-12T05:57:10.000Z</published>
    <updated>2022-02-13T07:51:45.013Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-事务</title>
    <link href="http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-02-12T05:56:18.000Z</published>
    <updated>2022-02-13T07:18:27.125Z</updated>
    
    <content type="html"><![CDATA[<p>事务是数据库区别与文件系统的重要特征之一。</p><p>InnoDB存储引擎的事务完全符合ACID特性：</p><p>即：原子性（atomicity）</p><p>一致性（consistency）</p><p>持久性（isolation）</p><p>隔离性（durability）</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-锁</title>
    <link href="http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E9%94%81/"/>
    <id>http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E9%94%81/</id>
    <published>2022-02-12T05:56:09.000Z</published>
    <updated>2022-02-12T05:59:22.786Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-索引与算法</title>
    <link href="http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-12T05:55:54.000Z</published>
    <updated>2022-02-12T06:07:37.572Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Redis常见问题</title>
    <link href="http://example.com/2022/02/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/02/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-11T12:51:40.000Z</published>
    <updated>2022-02-11T12:53:08.571Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>- - 如何解决缓存雪崩？  - 如何解决缓存穿透？  - 如何保证缓存与数据库双写时一致的问题？- # 一、缓存雪崩- ## 1.1什么是缓存雪崩？- 回顾一下我们为什么要用缓存(Redis)：- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112044559.webp)为什么要缓存- 现在有个问题，**如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了**。- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112045056.webp)如果缓存挂掉了，全部请求跑去数据库了- 在前面学习我们都知道Redis不可能把所有的数据都缓存起来(**内存昂贵且有限**)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。[Redis对过期键的策略+持久化](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484386&amp;idx=1&amp;sn=323ddc84dc851a975530090fcd6e2326&amp;chksm=ebd742e3dca0cbf52bc65d430447e639d81cc13e0ac34613edf464dae3950b10e2e1df74dcc5&amp;token=1834317504&amp;lang=zh_CN&amp;scene=21#wechat_redirect)- 如果缓存数据**设置的过期时间是相同**的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存**同时失效**，全部请求到数据库中。- **这就是缓存雪崩**：- - Redis挂掉了，请求全部走数据库。  - 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。- 缓存雪崩如果发生了，很可能就把我们的数据库**搞垮**，导致整个服务瘫痪！- ## 1.2如何解决缓存雪崩？- 对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：- - 解决方法：在缓存的时候给过期时间加上一个**随机值**，这样就会大幅度的**减少缓存在同一时间过期**。- 对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：- - 事发前：实现Redis的**高可用**(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。  - 事发中：万一Redis真的挂了，我们可以设置**本地缓存(ehcache)+限流(hystrix)**，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)  - 事发后：redis持久化，重启后自动从磁盘上加载数据，**快速恢复缓存数据**。- # 二、缓存穿透- ## 2.1什么是缓存穿透- 比如，我们有一张数据库表，ID都是从1开始的(**正数**)：- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112046859.webp)随便找了一张数据库表- 但是可能有黑客想把我的数据库搞垮，每次请求的ID都是**负数**。这会导致我的缓存就没用了，请求全部都找数据库去了，但数据库也没有这个值啊，所以每次都返回空出去。- &gt; 缓存穿透是指查询一个一定**不存在的数据**。由于缓存不命中，并且出于容错考虑，如果从**数据库查不到数据则不写入缓存**，这将导致这个不存在的数据**每次请求都要到数据库去查询**，失去了缓存的意义。- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112046860.webp)缓存穿透- **这就是缓存穿透**：- - 请求的数据在缓存大量不命中，导致请求走数据库。- 缓存穿透如果发生了，也可能把我们的数据库**搞垮**，导致整个服务瘫痪！- ## 2.1如何解决缓存穿透？- 解决缓存穿透也有两种方案：- - 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter**提前拦截**，不合法就不让这个请求到数据库层！  - 当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。下次再请求的时候，就可以从缓存里边获取了。  - - 这种情况我们一般会将空对象设置一个**较短的过期时间**。- 参考资料：- - 缓存系列文章--5.缓存穿透问题  - - https://carlosfu.iteye.com/blog/2248185- # 三、缓存与数据库双写一致- ## 3.1对于读操作，流程是这样的- 上面讲缓存穿透的时候也提到了：如果从数据库查不到数据则不写入缓存。- 一般我们对**读操作**的时候有这么一个**固定的套路**：- - 如果我们的数据在缓存里边有，那么就直接取缓存的。  - 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后**将数据库查出来的数据写到缓存中**。  - 最后将数据返回给请求- ## 3.2什么是缓存与数据库双写一致问题？- 如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要**更新**时候呢？各种情况很可能就**造成数据库和缓存的数据不一致**了。- - 这里不一致指的是：**数据库的数据跟缓存的数据不一致**- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112046180.webp)数据库和缓存的数据不一致- 从理论上说，只要我们设置了**键的过期时间**，我们就能保证缓存和数据库的数据**最终是一致**的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。- 除了设置过期时间，我们还需要做更多的措施来**尽量避免**数据库与缓存处于不一致的情况发生。- ## 3.3对于更新操作- 一般来说，执行更新操作时，我们会有两种选择：- - 先操作数据库，再操作缓存  - 先操作缓存，再操作数据库- 首先，要明确的是，无论我们选择哪个，我们都希望这**两个操作要么同时成功，要么同时失败**。所以，这会演变成一个**分布式事务**的问题。- 所以，**如果原子性被破坏了**，可能会有以下的情况：- - **操作数据库成功了，操作缓存失败了**。  - **操作缓存成功了，操作数据库失败了**。- &gt; 如果第一步已经失败了，我们直接返回Exception出去就好了，第二步根本不会执行。- 下面我们具体来分析一下吧。- ### 3.3.1操作缓存- 操作缓存也有两种方案：- - 更新缓存  - 删除缓存- 一般我们都是采取**删除缓存**缓存策略的，原因如下：- 1. 高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就**更加容易**导致数据库与缓存数据不一致问题。(删除缓存**直接和简单**很多)  2. 如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现**懒加载**)- 基于这两点，对于缓存在更新时而言，都是建议执行**删除**操作！- ### 3.3.2先更新数据库，再删除缓存- 正常的情况是这样的：- - 先操作数据库，成功；  - 再删除缓存，也成功；- 如果原子性被破坏了：- - 第一步成功(操作数据库)，第二步失败(删除缓存)，会导致**数据库里是新数据，而缓存里是旧数据**。  - 如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。- 如果在高并发的场景下，出现数据库与缓存数据不一致的**概率特别低**，也不是没有：- - 缓存**刚好**失效  - 线程A查询数据库，得一个旧值  - 线程B将新值写入数据库  - 线程B删除缓存  - 线程A将查到的旧值写入缓存- 要达成上述情况，还是说一句**概率特别低**：- &gt; 因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，**而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存**，所有的这些条件都具备的概率基本并不大。- 对于这种策略，其实是一种设计模式：`Cache Aside Pattern`- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112044375.webp)先修改数据库，再删除缓存- **删除缓存失败的解决思路**：- - 将需要删除的key发送到消息队列中  - 自己消费消息，获得需要删除的key  - **不断重试删除操作，直到成功**- ### 3.3.3先删除缓存，再更新数据库- 正常情况是这样的：- - 先删除缓存，成功；  - 再更新数据库，也成功；- 如果原子性被破坏了：- - 第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。  - 如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。- 看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：- - 线程A删除了缓存  - 线程B查询，发现缓存已不存在  - 线程B去数据库查询得到旧值  - 线程B将旧值写入缓存  - 线程A将新值写入数据库- 所以也会导致数据库和缓存不一致的问题。- **并发下解决数据库与缓存不一致的思路**：- - 将删除缓存、修改数据库、读取缓存等的操作积压到**队列**里边，实现**串行化**。- ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112044508.webp)将操作积压到队列中- ## 3.4对比两种策略- 我们可以发现，两种策略各自有优缺点：- - 先删除缓存，再更新数据库  - - 在高并发下表现不如意，在原子性被破坏时表现优异  - 先更新数据库，再删除缓存(`Cache Aside Pattern`设计模式)  - - 在高并发下表现优异，在原子性被破坏时表现不如意</code></pre><h2 id="3-5其他保障数据一致的方案与资料"><a href="#3-5其他保障数据一致的方案与资料" class="headerlink" title="3.5其他保障数据一致的方案与资料"></a>3.5其他保障数据一致的方案与资料</h2><p>可以用<strong>databus</strong>或者阿里的<strong>canal监听binlog</strong>进行更新。</p><p>参考资料：</p><ul><li><p>缓存更新的套路</p></li><li><ul><li><a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></li></ul></li><li><p>如何保证缓存与数据库双写时的数据一致性？</p></li><li><ul><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md</a></li></ul></li><li><p>分布式之数据库和缓存双写一致性方案解析</p></li><li><ul><li><a href="https://zhuanlan.zhihu.com/p/48334686">https://zhuanlan.zhihu.com/p/48334686</a></li></ul></li><li><p>Cache Aside Pattern</p></li><li><ul><li><a href="https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/81008933">https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/81008933</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">some of my notes</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>mysql全文本搜索</title>
    <link href="http://example.com/2021/11/25/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2021/11/25/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</id>
    <published>2021-11-25T03:10:14.000Z</published>
    <updated>2021-11-25T03:15:37.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-之全文索引"><a href="#MySQL-之全文索引" class="headerlink" title="MySQL 之全文索引"></a>MySQL 之全文索引</h1><p> 本文转载自：<a href="https://zhuanlan.zhihu.com/p/35675553">https://zhuanlan.zhihu.com/p/35675553</a></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p><p>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p><p>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</p><h2 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h2><p>开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况</p><ol><li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</li><li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</li><li>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</li></ol><p>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p><h2 id="操作全文索引"><a href="#操作全文索引" class="headerlink" title="操作全文索引"></a>操作全文索引</h2><p>索引的操作随便一搜都是，这里还是再啰嗦一遍。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>1.创建表时创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> fulltext_test (</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    content text <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    tag <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    FULLTEXT KEY content_tag_fulltext(content,tag)  <span class="operator">/</span><span class="operator">/</span> 创建联合全文索引列</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>2.在已存在的表上创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltext index content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test(content,tag);</span><br></pre></td></tr></table></figure><p>3.通过 SQL 语句 ALTER TABLE 创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">add</span> fulltext index content_tag_fulltext(content,tag);</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>修改个 O，直接删掉重建。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>1.直接使用 DROP INDEX 删除全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test;</span><br></pre></td></tr></table></figure><p>2.通过 SQL 语句 ALTER TABLE 删除全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">drop</span> index content_tag_fulltext;</span><br></pre></td></tr></table></figure><h2 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h2><p>和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> fulltext_test </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">match</span>(content,tag) against(<span class="string">&#x27;xxx xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。</p><h2 id="测试全文索引"><a href="#测试全文索引" class="headerlink" title="测试全文索引"></a>测试全文索引</h2><h2 id="添加测试数据"><a href="#添加测试数据" class="headerlink" title="添加测试数据"></a>添加测试数据</h2><p>有了上面的知识，就可以测试一下全文索引了。</p><p>首先创建测试表，插入测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test (</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    content text <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id),</span><br><span class="line">    fulltext key content_index(content)</span><br><span class="line">) engine<span class="operator">=</span>MyISAM <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (content) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>),(<span class="string">&#x27;b&#x27;</span>),(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (content) <span class="keyword">values</span> (<span class="string">&#x27;aa&#x27;</span>),(<span class="string">&#x27;bb&#x27;</span>),(<span class="string">&#x27;cc&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (content) <span class="keyword">values</span> (<span class="string">&#x27;aaa&#x27;</span>),(<span class="string">&#x27;bbb&#x27;</span>),(<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (content) <span class="keyword">values</span> (<span class="string">&#x27;aaaa&#x27;</span>),(<span class="string">&#x27;bbbb&#x27;</span>),(<span class="string">&#x27;cccc&#x27;</span>);</span><br></pre></td></tr></table></figure><p>按照全文索引的使用语法执行下面查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;aa&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure><p>根据我们的惯性思维，应该会显示 4 条记录才对，然而结果是 1 条记录也没有，只有在执行下面的查询时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;aaaa&#x27;</span>);</span><br></pre></td></tr></table></figure><p>才会搜到 <em>aaaa</em> 这 1 条记录。</p><p>为什么？这个问题有很多原因，其中最常见的就是 <strong>最小搜索长度</strong> 导致的。另外插一句，使用全文索引时，测试表里至少要有 4 条以上的记录，否则，会出现意想不到的结果。</p><p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。</p><p>这两个的默认值可以使用以下命令查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%ft%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看到这两个变量在 MyISAM 和 InnoDB 两种存储引擎下的变量名和默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> MyISAM</span><br><span class="line">ft_min_word_len <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">ft_max_word_len <span class="operator">=</span> <span class="number">84</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> InnoDB</span><br><span class="line">innodb_ft_min_token_size <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">innodb_ft_max_token_size <span class="operator">=</span> <span class="number">84</span>;</span><br></pre></td></tr></table></figure><p>可以看到最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引，而刚刚搜索的只有 <em>aaaa</em> 的长度大于等于 4。</p><h2 id="配置最小搜索长度"><a href="#配置最小搜索长度" class="headerlink" title="配置最小搜索长度"></a>配置最小搜索长度</h2><p>全文索引的相关参数都无法进行动态修改，必须通过修改 MySQL 的配置文件来完成。修改最小搜索长度的值为 1，首先打开 MySQL 的配置文件 /etc/my.cnf，在 [mysqld] 的下面追加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_ft_min_token_size = 1</span><br><span class="line">ft_min_word_len = 1</span><br></pre></td></tr></table></figure><p>然后重启 MySQL 服务器，并修复全文索引。注意，修改完参数以后，一定要修复下索引，不然参数不会生效。</p><p>两种修复方式，可以使用下面的命令修复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repair <span class="keyword">table</span> test quick;</span><br></pre></td></tr></table></figure><p>或者直接删掉重新建立索引，再次执行上面的查询，<em>a、aa、aaa</em> 就都可以查出来了。</p><p>但是，这里还有一个问题，搜索关键字 <em>a</em> 时，为什么 <em>aa、aaa、aaaa</em> 没有出现结果中，讲这个问题之前，先说说两种全文索引。</p><h2 id="两种全文索引"><a href="#两种全文索引" class="headerlink" title="两种全文索引"></a>两种全文索引</h2><h2 id="自然语言的全文索引"><a href="#自然语言的全文索引" class="headerlink" title="自然语言的全文索引"></a>自然语言的全文索引</h2><p>默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行自然语言搜索，上面的例子都是自然语言的全文索引。</p><p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。上面提到的，测试表中必须有 4 条以上的记录，就是这个原因。</p><p>这个机制也比较好理解，比如说，一个数据表存储的是一篇篇的文章，文章中的常见词、语气词等等，出现的肯定比较多，搜索这些词语就没什么意义了，需要搜索的是那些文章中有特殊意义的词，这样才能把文章区分开。</p><h2 id="布尔全文索引"><a href="#布尔全文索引" class="headerlink" title="布尔全文索引"></a>布尔全文索引</h2><p>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。</p><p>MySQL 内置的修饰符，上面查询最小搜索长度时，搜索结果 ft_boolean*_*syntax 变量的值就是内置的修饰符，下面简单解释几个，更多修饰符的作用可以查手册</p><ul><li><strong>+</strong> 必须包含该词</li><li><strong>-</strong> 必须不包含该词</li><li><strong>&gt;</strong> 提高该词的相关性，查询的结果靠前</li><li><strong>&lt;</strong> 降低该词的相关性，查询的结果靠后</li><li><strong>(*)星号</strong> 通配符，只能接在词后面</li></ul><p>对于上面提到的问题，可以使用布尔全文索引查询来解决，使用下面的命令，<em>a、aa、aaa、aaaa</em> 就都被查询出来了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> test <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;a*&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，差不多写完了，又到了总结的时候。</p><p>MySQL 的全文索引最开始仅支持英语，因为英语的词与词之间有空格，使用空格作为分词的分隔符是很方便的。亚洲文字，比如汉语、日语、汉语等，是没有空格的，这就造成了一定的限制。不过 MySQL 5.7.6 开始，引入了一个 ngram 全文分析器来解决这个问题，并且对 MyISAM 和 InnoDB 引擎都有效。</p><p>事实上，MyISAM 存储引擎对全文索引的支持有很多的限制，例如表级别锁对性能的影响、数据文件的崩溃、崩溃后的恢复等，这使得 MyISAM 的全文索引对于很多的应用场景并不适合。所以，多数情况下的建议是使用别的解决方案，例如 Sphinx、Lucene 等等第三方的插件，亦或是使用 InnoDB 存储引擎的全文索引。</p><h2 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h2><ol><li>使用全文索引前，搞清楚版本支持情况；</li><li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引；</li><li>对于中文，可以使用 MySQL 5.7.6 之后的版本，或者第三方插件。</li></ol><p><strong>参考文章</strong></p><p><a href="https://link.zhihu.com/?target=http://blog.51cto.com/imysqldba/1618465">mysql全文索引__简介</a></p><p><a href="https://link.zhihu.com/?target=https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html">MySQL 官方参考手册</a><br>高性能 MySQL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-之全文索引&quot;&gt;&lt;a href=&quot;#MySQL-之全文索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL 之全文索引&quot;&gt;&lt;/a&gt;MySQL 之全文索引&lt;/h1&gt;&lt;p&gt; 本文转载自：&lt;a href=&quot;https://zhuanlan.z</summary>
      
    
    
    
    <category term="技术转载学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E8%BD%AC%E8%BD%BD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>JUC常见问题</title>
    <link href="http://example.com/2021/11/25/JUC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/11/25/JUC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-25T03:04:56.000Z</published>
    <updated>2021-11-25T03:27:20.005Z</updated>
    
    <content type="html"><![CDATA[<p>以下是学习多线程遗留的一些问题和相关简要的解答，参考了许多博客和网站（文末）。</p><h3 id="1-什么是JUC"><a href="#1-什么是JUC" class="headerlink" title="1.什么是JUC"></a>1.什么是JUC</h3><p>是 java.util .concurrent 工具包的简称，用来处理线程，从jdk.5引入</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111251109513.png" alt="202111242325350"></p><h3 id="2-线程和进程的区别"><a href="#2-线程和进程的区别" class="headerlink" title="2.线程和进程的区别"></a>2.线程和进程的区别</h3><p>进程(Process) 是计算机中的程序关于某数据集合上的一次运行活动,是系<br>统进行资源分配和调度的基本单位,是操作系统结构的基础。  </p><ul><li>计算机中的程序关于某数据集合上的一次运行活动</li><li>系统进行资源分配和调度的基本单位,是操作系统结构的基础。</li><li>进程是程序的实体（程序是指令、数据及其组织形式的描述,）</li><li>看作在系统中运行的一个应用程序</li></ul><p>线程(thread) 是操作系统能够进行运算调度的最小单位。</p><ul><li><p>包含在进程之中</p></li><li><p>系统分配处理器时间的最小单元</p></li><li><p>进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流。</p></li><li><p>每条线程并行执行不同的任务。</p></li></ul><p>两者之间的关系：</p><p>进程是线程的容器，一个进程可以并发多个线程，进程是线程的容器</p><h3 id="3-sleep和wait的区别"><a href="#3-sleep和wait的区别" class="headerlink" title="3.sleep和wait的区别"></a>3.sleep和wait的区别</h3><ul><li>sleep 是 Thread 的静态方法, 是线程用来 控制自身流程的。sleep 不会释放锁,它也不需要占用锁（不涉及线程通信）。</li><li>wait 是 Object 的方法,任何对象实例都能调用，wait 会释放锁,但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)，主要用来不同线程之间的调度的。</li><li>它们都可以被 interrupted 方法中断。</li></ul><p>注：两个方法都需要抛出异常</p><h3 id="4-并发和并行的区别"><a href="#4-并发和并行的区别" class="headerlink" title="4.并发和并行的区别"></a>4.并发和并行的区别</h3><p>首先了解串行模式和并行模式：</p><ul><li>串行：所有任务都按照先后顺序执行（一次取得一个任务，并执行）</li><li>并行：和串行不同，并行一次取得多个任务。（依赖于多线程，以及硬件的多核Cpu）</li></ul><p>并发：并发(concurrent)指的是多个程序可以同时运行的现象,更细化的是多进程可以同时运行或者多指令可以同时运行，描述的是多线程同时运行的现象</p><p>并发和并行的区别：</p><p>首先：“并发”指的是程序的结构，“并行”指的是程序运行时的状态</p><h3 id="为什么要使用多线程-以及可能带来的问题？"><a href="#为什么要使用多线程-以及可能带来的问题？" class="headerlink" title="为什么要使用多线程?以及可能带来的问题？"></a>为什么要使用多线程?以及可能带来的问题？</h3><p><strong>线程花销更小，切换更快：</strong></p><p>创建进程的时候系统都要分配大量资源（建立数据表，分派地址空间等），线程之间共享大部分资源，使用相同地址空间，开销很小。</p><p><strong>线程之间通信更方便</strong>：线程通信十分方便 (通过在线程之间共享对象)，线程的数据可以直接为其它线程所共享（同时也会带来隐患）</p><p><strong>提高应用程序响应</strong>：这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，避免了程序进行长时间等待。</p><p><strong>使多CPU系统更加有效</strong>：操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p><p>——&gt;多线程同时也有缺点</p><p>​            可能带来：内存泄漏、死锁、线程安全等问题</p><!--内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果--><h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111251108669.jpg" alt="232002051747387"></p><p>线程整个生命周期，要经过以下几种状态：</p><ul><li><p>NEW,(新建)；</p></li><li><p>RUNNABLE,(准备就绪)；</p></li><li><p>BLOCKED,(阻塞)；</p></li><li><p>WAITING,(不见不散)</p></li><li><p>TIMED_WAITING,(过时不候)；</p></li><li><p>TERMINATED;(终结)；</p></li></ul><p>一个不可能一直”霸占”着CPU独自 运行，CPU会在多条线程之间切换，因此线程状态也会多次在运行、阻塞之间切换 。</p><h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><p>首先需要了解：线程的执行首先要持有管程对象,然后才能执行方法,当方法完成之后会释放管程,方<br>法在执行时候会持有管程,其他线程无法再获取同一个管程；JVM 中同步是基于进入和退出管程(monitor)对象实现的,每个对象都会有一个管程(monitor)对象,管程(monitor)会随着 java 对象一同创建和销毁</p><p>用户线程:平时用到的普通线程,自定义线程</p><p>守护线程:<strong>运行在后台</strong>,是一种特殊的线程,比如垃圾回收GC</p><p>说明：只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</p><p>主线程结束后,用户线程还在运行,JVM 存活<br>如果没有用户线程,都是守护线程,JVM 结束</p><h3 id="创建多线程的多种方法"><a href="#创建多线程的多种方法" class="headerlink" title="创建多线程的多种方法"></a>创建多线程的多种方法</h3><p>创建线程主要有四种方法：</p><p>创建Thread类</p><p>实现Runnable接口</p><p>实现Callable接口</p><p>使用线程池</p><h3 id="多线程的实现步骤"><a href="#多线程的实现步骤" class="headerlink" title="多线程的实现步骤"></a>多线程的实现步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111251107446.png" alt="202111250024218"></p><h3 id="Lock和Synchonized的区别"><a href="#Lock和Synchonized的区别" class="headerlink" title="Lock和Synchonized的区别"></a>Lock和Synchonized的区别</h3><p>1️⃣  <strong>lock 是一个接口，而 synchronized 是 Java 的一个关键字，synchronized 是内置的语言实现。</strong></p><p>2️⃣  <strong>异常是否释放锁：synchronized 在发生异常时候会自动释放占有的锁，因此不会出现死锁；而 lock 发生异常时候，不会主动释放占有的锁，必须手动 unlock 来释放锁，可能引起死锁的发生。(所以最好将同步代码块用 <a href="https://www.jianshu.com/p/384d2ec90c41">try catch</a> 包起来，finally 中写入 unlock，避免死锁的发生。)</strong></p><p>3️⃣   <strong>是否响应中断</strong></p><p><strong>lock 等待锁过程中可以用 interrupt 来中断等待，而 synchronized 只能等待锁的释放，不能响应中断。</strong></p><p><strong>4️⃣   是否知道获取锁：Lock 可以通过 trylock 来知道有没有获取锁，而 synchronized 不能。</strong></p><p><strong>5️⃣   Lock 可以提高多个线程进行读操作的效率。(可以通过 <a href="https://www.jianshu.com/p/377ac92ac10c">ReadWriteLock </a>实现读写分离)</strong></p><p>6️⃣   在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时(即有大量线程同时竞争)，此时 Lock 的性能要远远优于 synchronized。所以说，在具体使用时要根据适当情况选择。</p><p>7️⃣   synchronized 使用 <a href="https://www.jianshu.com/p/aeb8430fe799">Object</a> 对象本身的 wait 、notify、notifyAll 调度机制，而 Lock 可以使用 Condition 进行线程之间的调度。</p><p>注：</p><p><strong>new Thread创建的线程是否立即创建？</strong></p><p>不一定，底层调用了native  即：交给操作系统实现。具体由操作系统决定何时创建</p><h3 id="集合的线程安全？解决方法？"><a href="#集合的线程安全？解决方法？" class="headerlink" title="集合的线程安全？解决方法？"></a>集合的线程安全？解决方法？</h3><p>多个线程同时对集合进行修改，会发并发修改异常</p><p>异常内容java.util.ConcurrentModificationException</p><p>那么如何解决？</p><p>Vector： 矢量队列,  JDK1.0 版本添加的类。继承于 AbstractList,实现<br>了 List, RandomAccess, Cloneable 这些接口。  它是一个队列,支持相关的添加、删除、修改、遍历等功<br>能。<br>  ——&gt;  ArrayList 不同,Vector 中的操作是线程安全的。</p><p>Vector 因此可以被用来解决arrylist线程不安全的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class NotSafeDemo &#123;</span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">多个线程同时对集合进行修改</span><br><span class="line"></span><br><span class="line">@param args</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List list = new Vector();</span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">new Thread(() -&gt;&#123;</span><br><span class="line">list.add(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;, &quot;线程&quot; + i).start();</span><br><span class="line">此时不会出现并发异常</span><br></pre></td></tr></table></figure><p>Java 中常见的集合类型都是不安全的, 比如说ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap </p><p>Java5 之后, 在java.util.concurrent新增了大量的支持高并发的集合接口和实现类</p><p>线程安全的集合类： </p><ul><li> ConcurrentHashMap, ConcurrentLinkedQueue, ConcurrentSkipListSet </li><li> CopyOnWriteArrayList, CopyOnWriteArraySet</li></ul><p>解决线程安全问题，使用相关的类替代线程不安全的集合类即可 </p><h3 id="锁的几种情况，常见的锁？"><a href="#锁的几种情况，常见的锁？" class="headerlink" title="锁的几种情况，常见的锁？"></a>锁的几种情况，常见的锁？</h3><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111251108698.png" alt="image-20211125003853921"></p><p><strong>公平锁与非公平锁</strong>：线程获取锁资源是否是公平的</p><p><strong>乐观锁和悲观锁</strong>：</p><ul><li>乐观锁： 对于并发间操作产生的线程安全问题持乐观状态，乐观锁<strong>认为竞争不总是会发生</strong>，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</li><li>悲观锁： 对于并发间操作产生的线程安全问题持悲观状态，悲观锁<strong>认为竞争总是会发生</strong>，因此每次对某资源进行操作时，都会持有一个独占的锁，和synchronized类似。</li></ul><p><img src="" alt="image-20211125002555353"></p><p><strong>死锁</strong></p><p><strong>可重入锁</strong>：ReentrantLockk 是唯一实现了 Lock 接口的类，提供了很多方法</p><p><strong>读锁和写锁</strong></p><ul><li>读锁，进行‘‘读操作’’时添加的锁。共享锁，会发生死锁。</li><li>写锁，进行‘‘写操作’’时添加的锁。独占锁，会发生死锁。</li></ul><p>注： 如果有一个线程已经占用了读锁,则此时其他线程如果要申请写锁,则申请写<br>        锁的线程会一直等待释放读锁。<br>        如果有一个线程已经占用了写锁,则此时其他线程如果申请写锁或者读锁,则<br>        申请的线程会一直等待释放写锁。</p><p>明确一点，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>因此，诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><h3 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a>Runnable接口和Callable接口的区别</h3><p>返回值不同：使用Runnable时，缺少了一种功能，当线程结束时，无法使线程返回结果，callable支持返回结果</p><h3 id="ThreadLocal？内存泄露问题？"><a href="#ThreadLocal？内存泄露问题？" class="headerlink" title="ThreadLocal？内存泄露问题？"></a>ThreadLocal？内存泄露问题？</h3><p>为什么要用线程池？<code>ThreadPoolExecutor</code> 类的重要参数了解吗？<code>ThreadPoolExecutor</code> 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用<code>FixedThreadPool</code>？如何设置线程池的大小？</p><ol><li><code>synchronized</code> 关键字、volatile 关键字</li></ol><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：<br>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据<br>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率<br>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><ol><li><p>AQS 了解么？原理？AQS 常用组件：<code>Semaphore</code> (信号量)、<code>CountDownLatch</code> （倒计时器） <code>CyclicBarrier</code>(循环栅栏)</p></li><li><p><code>ReentrantLock</code> 、 <code>ReentrantReadWriteLock</code> 、<code>StampedLock</code>（JDK8）</p></li><li><p>CAS 了解么？原理？</p></li><li><p>Atomic 原子类</p></li><li><p>并发容器：<code>ConcurrentHashMap</code> 、 <code>CopyOnWriteArrayList</code> 、 <code>ConcurrentLinkedQueue</code> <code>BlockingQueue</code> 、<code>ConcurrentSkipListMap</code></p></li><li><p><code>Future</code> 和 <code>CompletableFuture</code></p><p>12.1 CompletableFuture 简介<br>CompletableFuture 在 Java 里面被用于异步编程,异步通常意味着非阻塞,<br>可以使得我们的任务单独运行在与主线程分离的其他线程中,并且通过回调可<br>以在主线程中得到异步任务的执行状态,是否完成,和是否异常等信息。<br>CompletableFuture 实现了 Future, CompletionStage 接口,实现了 Future<br>接口就可以兼容现在有线程池框架,而 CompletionStage 接口才是异步编程<br>的接口抽象,里面定义多种异步方法,通过这两者集合,从而打造出了强大的<br>CompletableFuture 类。<br>12.2 Future 与 CompletableFuture<br>Futrue 在 Java 里面,通常用来表示一个异步任务的引用,比如我们将任务提<br>交到线程池里面,然后我们会得到一个 Futrue,在 Future 里面有 isDone 方<br>法来 判断任务是否处理结束,还有 get 方法可以一直阻塞直到任务结束然后获<br>取结果,但整体来说这种方式,还是同步的,因为需要客户端不断阻塞等待或<br>者不断轮询才能知道任务是否完成。<br>Future 的主要缺点如下:<br>(1)不支持手动完成<br>我提交了一个任务,但是执行太慢了,我通过其他路径已经获取到了任务结果,<br>现在没法把这个任务结果通知到正在执行的线程,所以必须主动取消或者一直<br>等待它执行完成<br>(2)不支持进一步的非阻塞调用<br>通过 Future 的 get 方法会一直阻塞到任务完成,但是想在获取任务之后执行<br>额外的任务,因为 Future 不支持回调函数,所以无法实现这个功能<br>(3)不支持链式调用<br>对于 Future 的执行结果,我们想继续传到下一个 Future 处理使用,从而形成<br>一个链式的 pipline 调用,这在 Future 中是没法实现的。<br>(4)不支持多个 Future 合并<br>比如我们有 10 个 Future 并行执行,我们想在所有的 Future 运行完毕之后,<br>执行某些函数,是没法通过 Future 实现的。<br>(5)不支持异常处理<br>Future 的 API 没有任何的异常处理的 api,所以在异步运行时,如果出了问题<br>是不好定位的。</p></li></ol><p>参考:</p><p><strong>还在疑惑并发和并行？</strong><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p><p><a href="https://xie.infoq.cn/article/4e370ded27e4419d2a94a44b3">Synchronized 和 lock 区别</a></p><p><a href="https://mp.weixin.qq.com/s/4mlj5HvVE8Q3Z3G0xlADyQ">Java多线程问题总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是学习多线程遗留的一些问题和相关简要的解答，参考了许多博客和网站（文末）。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是JUC&quot;&gt;&lt;a href=&quot;#1-什么是JUC&quot; class=&quot;headerlink&quot; title=&quot;1.什么是JUC&quot;&gt;&lt;/a&gt;1.什么是JUC&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="http://example.com/2021/11/17/Redis-Sentinel/"/>
    <id>http://example.com/2021/11/17/Redis-Sentinel/</id>
    <published>2021-11-17T13:19:49.000Z</published>
    <updated>2021-11-19T13:41:35.828Z</updated>
    
    <content type="html"><![CDATA[<p>Sentinel（哨岗、哨兵）是Redis的高可用性（highavailability）解决方案</p><p> 首先哨兵主要实现了以下功能： </p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>Sentinel系统监视任意多的主服务器和从服务器，自动升级下线主服务器的从属服务器为主服务器，代理执行原主机的相关工作</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111182216003.png" alt="image-20211118221623916" style="zoom:67%;" /><p>故障转移：解决主服务器下线时长超过设定限度，进行故障的解决的过程</p><p>步骤（以上图为例）：</p><ul><li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li><li>  向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li> Sentinel 继续监视 server1，在它重新上线时，将它设置为新的主服务器的从服务器。</li></ul><p><strong>重点知识脉络</strong>： Sentinel初始化过程；Sentinel和一般Redis服务器的区别；Sentinel监视服务器的方法和原理；Sentinel判断服务器是否在线方法；故障转移详细过程。</p><h2 id="1-启动并初始化Sentinel"><a href="#1-启动并初始化Sentinel" class="headerlink" title="1. 启动并初始化Sentinel"></a>1. 启动并初始化Sentinel</h2><p>启动Sentinel可以使用：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111182345373.png" alt="image-20211118234503273"></p><p>或者：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111182345559.png" alt="image-20211118234559449"></p><p>Sentinel启动大致要经过以下<strong>步骤</strong>：</p><p>​        1）初始化服务器。</p><p>​        2）将普通Redis服务器使用的代码替换成Sentinel专用代码。</p><p>​        3）初始化Sentinel状态。</p><p>​        4）根据给定的配置文件，初始化Sentinel的监视主服务器列表。</p><p>​        5）创建连向主服务器的网络连接。</p><p><strong>说明</strong>：</p><p><strong>Sentinel和一般Redis服务器的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sentinel本质上是运行在特殊环境上的Redis服务器</span><br><span class="line"></span><br><span class="line">​普通Redis服务器使用redis.h/REDIS_SERVERPORT常量的值作为服务器端口 ；</span><br><span class="line"></span><br><span class="line">​Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口 ；</span><br><span class="line"></span><br><span class="line">​在服务器的命令表上存在差别，普通Redis服务器使用redis.c/redisCommandTable S    entinel则使用sentinel.c/sentinelcmds</span><br><span class="line"></span><br><span class="line">​在Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令(未载入)</span><br><span class="line"></span><br><span class="line">​Sentinel可以执行的命令： (PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE)</span><br></pre></td></tr></table></figure><p><strong>创建连向主服务器的网络连接</strong></p><p> 每个被 监视的主服务器，都会与Sentinel创建两个异步网络连接：</p><p>❑ 命令连接： 专门用于向主服务器发送命令，并接收命令回复。</p><p>❑ 订阅连接：专门用于订阅主服务器的__sentinel__:hello频道。</p><p>为什么是异步网络连接？：Sentinel需要与多个实例创建多个网络连接</p><p>链接示例图：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190000569.png" alt="image-20211119000053403" style="zoom:67%;" /><h2 id="2-获取主服务器信息"><a href="#2-获取主服务器信息" class="headerlink" title="2.获取主服务器信息"></a>2.获取主服务器信息</h2><p>Sentinel已经创建成功，连接建立完毕，接着就是哨兵如何对主服务器进行监听。</p><p>Sentinel默认以每十秒一次的频率，向被监视的主服务器发送INFO命令（命令连接），分析INFO命令的回复来获取主服务器的当前信息。</p><p>获取信息通常有以下两方面：</p><ul><li><p>关于主服务器本身的信息，run_id域记录的服务器运行ID，role域记录的服务器角色；</p></li><li><p>关于主服务器属下所有从服务器的信息（根据从服务器Slave字段）</p><p>ip=域记录了从服务器的IP地址，</p><p>port=域则记录了从服务器的端口号。根据IP地址和端口号，Sentinel自动发现从服务器。</p></li></ul><p>主服务器回复信息示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190006659.png" alt="image-20211119000657543"></p><p>根据返回信息，Sentinel对主服务器实例结构进行更新，并由主服务器更新其实例结构字典（记录slave的从服务器信息）</p><h2 id="3-获取从服务器信息"><a href="#3-获取从服务器信息" class="headerlink" title="3.获取从服务器信息"></a>3.获取从服务器信息</h2><p>Sentinel发现主服务器有新的从服务器出现时，Sentinel会为这个新的从服务器创建相应的实例结构之外， 还会创建连接到从服务器的命令连接和订阅连接</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190012033.png" alt="image-20211119001225887"></p><p>和主服务器相同Sentinel每十秒一次发送INFO命令，获取信息</p><p>举例如下：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190013205.png" alt="image-20211119001352120" style="zoom:67%;" /><p>注：图中包含以下信息</p><p>​        ❑从服务器的运行ID run_id。</p><p>​        ❑从服务器的角色role。</p><p>​        ❑主服务器的IP地址master_host，以及主服务器的端口号master_port。</p><p>​        ❑主从服务器的连接状态master_link_status。</p><p>​        ❑从服务器的优先级slave_priority。</p><p>​        ❑从服务器的复制偏移量slave_repl_offset。</p><p>根据这些信息，Sentinel 对从服务器的实例结构进行更新</p><h2 id="4-向主服务器和从服务器发送信息"><a href="#4-向主服务器和从服务器发送信息" class="headerlink" title="4 向主服务器和从服务器发送信息"></a>4 向主服务器和从服务器发送信息</h2><p>Sentinel系统，通过命令连接向主从服务器发送消息，来进行信息交换，控制等效果</p><p>命令中通常包含以下内容：</p><ul><li><p>和Sentinel相关的参数</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111192040224.png" alt="image-20211119203756108"></p></li><li><p>和主服务器有关的参数</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111192040631.png" alt="image-20211119203820574"></p></li></ul><h2 id="5-接收来自主服务器和从服务器的频道信息"><a href="#5-接收来自主服务器和从服务器的频道信息" class="headerlink" title="5.接收来自主服务器和从服务器的频道信息"></a>5.接收来自主服务器和从服务器的频道信息</h2><p>Sentinel与一个主服务器或者从服务器建立起订阅连接之后，就会通过订阅连接发送以下命令</p><p>Sentinel对 频道的订阅会一直持续到Sentinel与服务器的连接断开为止</p><ul><li> 对每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息</li><li>监视一个服务器的多个Sentinel之间信息都是共享的，用来更新各自对于服务器和其他Sentinel的认知</li></ul><p><strong>更新sentinels字典</strong></p><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料</p><p>举个例子：一个Sentinel接受来自来自其他Sentinel的信息之后，会提取其主要信息（与Sentinel和服务器有关的参数），根据主服务器参数在自己的master字典中找到相应服务器的实例结构并更新</p><p>（如果发送信息的Sentinel之前不存在，就新创建）</p><p><strong>连向其他Sentinel的命令连接</strong></p><p>Sentinel发现新的Sentinel时，会在sentinel字典中创建相关实例，并且创建与其连接的命令连接</p><p>因此，监视同一服务器的Sentinel之间会形成互通的网络，可以互相发送命令请求来进行信息交换。</p><p>注：Sentinel之间不会创建订阅连接</p><h2 id="6-检测主观下线状态"><a href="#6-检测主观下线状态" class="headerlink" title="6.检测主观下线状态"></a>6.检测主观下线状态</h2><p>Sentinel与服务器之间连接创建成功，Sentinel会连续不断的监视服务器的状态</p><p>默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从</p><p>服务器、其他Sentinel在内）发送PING命令，通过返回的回复判断实例是否在线</p><p><strong>回复的种类</strong></p><p>​    ❑有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种。</p><p>​    ❑无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者</p><p>在指定时限内没有返回任何回复。</p><p>如果一个实例在down-after-milliseconds设定的时间（毫秒）内，都向Sentinel返回无效回复，Sentinel就会确定该主机处于下线状态修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识。</p><p>注：多个Sentinel设置的主观下线时长可能不同</p><h2 id="7-检查客观下线状态"><a href="#7-检查客观下线状态" class="headerlink" title="7 检查客观下线状态"></a>7 检查客观下线状态</h2><p>判断主观下线之后，需要进一步进行确定，排除其他不必要的原因，进行客观下线状态检查</p><p> 通过向同样监视这一主服务器的其他Sentinel进行询问， 看是否有满足一定数量的其他Sentinel也认为该主服务器进入下线状态。满足条件 Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p><ul><li><p>一般通过  is-master-down-by-addr命令在各个Sentinel之间确定主观下线状态</p></li><li><p>不同Sentinel判断客观下线的条件可能不同（满足一定数量的Sentinel都认为主服务器已经处于下线状态）</p></li></ul><h2 id="8-选举领头Sentinel"><a href="#8-选举领头Sentinel" class="headerlink" title="8 选举领头Sentinel"></a>8 选举领头Sentinel</h2><p>当主服务器最终被确定已经客观下线，监视他的Sentinel们就要选举出一个新的领头Sentinel，由领头Sentinel对其他从服务器进行故障转移</p><p><strong>规则</strong></p><p>规则较多，举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❑所有在线的Sentinel都有被选为领头Sentinel的资格， </span><br><span class="line"></span><br><span class="line">❑每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configurationepoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。</span><br><span class="line"></span><br><span class="line"> ❑每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</span><br><span class="line"></span><br><span class="line">❑当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</span><br><span class="line"></span><br><span class="line">❑Sentinel设置局部领头Sentinel的规则是先到先得： </span><br><span class="line"></span><br><span class="line">❑领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentine </span><br><span class="line"></span><br><span class="line">在一个配置纪元里面，只会出现一个领头Sentinel。 </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="9-故障的转移"><a href="#9-故障的转移" class="headerlink" title="9.故障的转移"></a>9.故障的转移</h2><blockquote><p>新的主库选择出来后，就可以开始进行故障的转移了。</p></blockquote><p>（我们假设：判断主库客观下线了，同时选出<code>sentinel 3</code>是哨兵leader）</p><p><strong>故障转移流程如下</strong>：</p><p><img src="https://www.pdai.tech/_images/db/redis/db-redis-sen-4.png" alt="img"></p><ul><li>将slave-1脱离原从节点（PS: 5.0 中应该是<code>replicaof no one</code>)，升级主节点，</li><li>将从节点slave-2指向新的主节点</li><li>通知客户端主节点已更换</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点</li></ul><p><strong>转移之后</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111192131841.png" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>总的来说就是进行了以下步骤：</p><p>1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</p><p>2）让已下线主服务器属下的所有从服务器改为复制新的主服务器。</p><p>3）将已下线主服务器设置为新的主服务器的从服务器，当 旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</p><p><strong>新主服务器选举</strong></p><p>在所有的从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将其变成主服务器。</p><p>发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升</p><p>级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，直到其状态变成master</p><p><strong>修改从服务器的复制目标</strong></p><p>所有从服务器去复制新的主服务器，通过领头Sentinel向剩下的所有从服务器发送Slaveof命令来实现。</p><p><strong>旧的主服务器变为从服务器</strong></p><p>已下线的主服务器设置为新的主服务器的从服务器，这种设置保存在旧主服务器对应的实例结构中。并且由Sentine控制执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Sentinel（哨岗、哨兵）是Redis的高可用性（highavailability）解决方案&lt;/p&gt;
&lt;p&gt; 首先哨兵主要实现了以下功能： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：哨兵会不断地检查主节点和从节点是否运作</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>String StringBuilder StringBuffer</title>
    <link href="http://example.com/2021/11/16/String-StringBuilder-StringBuffer/"/>
    <id>http://example.com/2021/11/16/String-StringBuilder-StringBuffer/</id>
    <published>2021-11-15T16:12:22.000Z</published>
    <updated>2021-11-15T16:22:33.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自： <a href="https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q">https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q?</a></p><h1 id="探秘Java中String、StringBuilder以及StringBuffer"><a href="#探秘Java中String、StringBuilder以及StringBuffer" class="headerlink" title="探秘Java中String、StringBuilder以及StringBuffer"></a>探秘Java中String、StringBuilder以及StringBuffer</h1><p>​    相信String这个类是Java中使用得最频繁的类之一，并且又是各大公司面试喜欢问到的地方，今天就来和大家一起学习一下String、StringBuilder和StringBuffer这几个类，分析它们的异同点以及了解各个类适用的场景。下面是本文的目录大纲：</p><p>　　一.你了解String类吗？</p><p>　　二.深入理解String、StringBuffer、StringBuilder</p><p>　　三.不同场景下三个类的性能测试</p><p>　　四.常见的关于String、StringBuffer的面试题（辟谣网上流传的一些曲解String类的说法）</p><h2 id="一-你了解String类吗？"><a href="#一-你了解String类吗？" class="headerlink" title="一.你了解String类吗？"></a><strong>一.你了解String类吗？</strong></h2><p>　　想要了解一个类，最好的办法就是看这个类的实现源代码，String类的实现在</p><p>　　\jdk1.6.0_14\src\java\lang\String.java  文件中。</p><p>　　打开这个类文件就会发现String类是被final修饰的：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017404.webp" alt="图片"></p><p>​    从上面可以看出几点：</p><p>　　1）String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。</p><p>　　2）上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。</p><p>　　下面再继续看String类的一些方法实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line"></span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (endIndex &gt; count) &#123;</span><br><span class="line"></span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (beginIndex &gt; endIndex) &#123;</span><br><span class="line"></span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :</span><br><span class="line"></span><br><span class="line">        new String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> public String concat(String str) &#123;</span><br><span class="line"></span><br><span class="line">    int otherLen = str.length();</span><br><span class="line"></span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char buf[] = new char[count + otherLen];</span><br><span class="line"></span><br><span class="line">    getChars(0, count, buf, 0);</span><br><span class="line"></span><br><span class="line">    str.getChars(0, otherLen, buf, count);</span><br><span class="line"></span><br><span class="line">    return new String(0, count + otherLen, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> public String replace(char oldChar, char newChar) &#123;</span><br><span class="line"></span><br><span class="line">    if (oldChar != newChar) &#123;</span><br><span class="line"></span><br><span class="line">        int len = count;</span><br><span class="line"></span><br><span class="line">        int i = -1;</span><br><span class="line"></span><br><span class="line">        char[] val = value; /* avoid getfield opcode */</span><br><span class="line"></span><br><span class="line">        int off = offset;   /* avoid getfield opcode */</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        while (++i &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">        if (val[off + i] == oldChar) &#123;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (i &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">        char buf[] = new char[len];</span><br><span class="line"></span><br><span class="line">        for (int j = 0 ; j &lt; i ; j++) &#123;</span><br><span class="line"></span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">            char c = val[off + i];</span><br><span class="line"></span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new String(0, len, buf);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br></pre></td></tr></table></figure><p>　　从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。</p><p>　　在这里要永远记住一点：</p><p>　　“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。</p><p>　　在了解了于String类基础的知识后，下面来看一些在平常使用中容易忽略和混淆的地方。</p><h2 id="二-深入理解String、StringBuffer、StringBuilder"><a href="#二-深入理解String、StringBuffer、StringBuilder" class="headerlink" title="二.深入理解String、StringBuffer、StringBuilder"></a><strong>二.深入理解String、StringBuffer、StringBuilder</strong></h2><p>1.String str=”hello world”和String str=new String(“hello world”)的区别</p><p>　　想必大家对上面2个语句都不陌生，在平时写代码的过程中也经常遇到，那么它们到底有什么区别和联系呢？下面先看几个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str2 = new String(&quot;hello world&quot;);</span><br><span class="line">        String str3 = &quot;hello world&quot;;</span><br><span class="line">        String str4 = new String(&quot;hello world&quot;)</span><br><span class="line">        System.out.println(str1==str2);</span><br><span class="line">        System.out.println(str1==str3);</span><br><span class="line">        System.out.println(str2==str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　输出结果为</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012505.webp" alt="图片"></p><p>　　为什么会出现这样的结果？下面解释一下原因：</p><p>　　在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。</p><p>　　因此在上述代码中，String str1 = “hello world”;和String str3 = “hello world”; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量”hello world”被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。</p><p>　　总所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。</p><p>2.String、StringBuffer以及StringBuilder的区别</p><p>　　既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？</p><p>　　那么看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String string = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line"></span><br><span class="line">            string += &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这句 string += “hello”;的过程相当于将原有的string变量指向的对象内容取出与”hello”作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017332.webp" alt="图片"></p><p>　　从这段反编译出的字节码文件可以很清楚地看出：从第8行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。从上面还可以看出：string+=”hello”的操作事实上会自动被JVM优化成：</p><p>　　StringBuilder str = new StringBuilder(string);</p><p>　　str.append(“hello”);</p><p>　　str.toString();</p><p>　　再看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line"></span><br><span class="line">            stringBuilder.append(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　反编译字节码文件得到：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017970.webp" alt="图片"></p><p>　　从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。</p><p>　　那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全的。</p><p>　　下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现：</p><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160020813.png" alt="image-20211116002034612"></p><h2 id="三-不同场景下三个类的性能测试"><a href="#三-不同场景下三个类的性能测试" class="headerlink" title="三.不同场景下三个类的性能测试"></a><strong>三.不同场景下三个类的性能测试</strong></h2><p>　　从第二节我们已经看出了三个类的区别，这一小节我们来做个小测试，来测试一下三个类的性能区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int time = 50000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        testString();</span><br><span class="line"></span><br><span class="line">        testStringBuffer();</span><br><span class="line"></span><br><span class="line">        testStringBuilder();</span><br><span class="line"></span><br><span class="line">        test1String();</span><br><span class="line"></span><br><span class="line">        test2String();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void testString () &#123;</span><br><span class="line"></span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            s += &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+s.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void testStringBuffer () &#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+sb.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void testStringBuilder () &#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+sb.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void test1String () &#123;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            String s = &quot;I&quot;+&quot;love&quot;+&quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;字符串直接相加操作：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void test2String () &#123;</span><br><span class="line"></span><br><span class="line">        String s1 =&quot;I&quot;;</span><br><span class="line"></span><br><span class="line">        String s2 = &quot;love&quot;;</span><br><span class="line"></span><br><span class="line">        String s3 = &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            String s = s1+s2+s3;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;字符串间接相加操作：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　测试结果（win7，Eclipse，JDK6)：</p><p>　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012621.webp" alt="图片"></p><p>　　上面提到string+=”hello”的操作事实上会自动被JVM优化，看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int time = 50000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        testString();</span><br><span class="line"></span><br><span class="line">        testOptimalString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testString () &#123;</span><br><span class="line"></span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            s += &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+s.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    public static void testOptimalString () &#123;</span><br><span class="line"></span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb = new StringBuilder(s);</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">            s=sb.toString();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;模拟JVM优化操作的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　执行结果：</p><p>　　 <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017968.webp" alt="图片"></p><p>　　得到验证。</p><p>　　下面对上面的执行结果进行一般性的解释：</p><p>　　1）对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。这个可以用javap -c命令反编译生成的class文件进行验证。</p><p>　　对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。</p><p>　　2）String、StringBuilder、StringBuffer三者的执行效率：</p><p>　　StringBuilder &gt; StringBuffer &gt; String</p><p>　　当然这个是相对的，不一定在所有情况下都是这样。</p><p>　　比如String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高。</p><p>　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：</p><p>　　当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；</p><p>　　当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。</p><h2 id="四-常见的关于String、StringBuffer的面试题"><a href="#四-常见的关于String、StringBuffer的面试题" class="headerlink" title="四.常见的关于String、StringBuffer的面试题"></a><strong>四.常见的关于String、StringBuffer的面试题</strong></h2><p>　　下面是一些常见的关于String、StringBuffer的一些面试笔试题，若有不正之处，请谅解和批评指正。</p><p>\1. 下面这段代码的输出结果是什么？</p><p>　　String a = “hello2”; 　　String b = “hello” + 2; 　　System.out.println((a == b));</p><p>　　输出结果为：true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。</p><p>2.下面这段代码的输出结果是什么？</p><p>　　String a = “hello2”; 　 String b = “hello”;    String c = b + 2;    System.out.println((a == c));</p><p>　　输出结果为:false。由于有符号引用的存在，所以 String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。javap -c得到的内容：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012087.webp" alt="图片"></p><p>3.下面这段代码的输出结果是什么？</p><p>　　String a = “hello2”;  　 final String b = “hello”;    String c = b + 2;    System.out.println((a == c));</p><p>　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2; 下图是javap -c的内容：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012377.webp" alt="图片"></p><p>4.下面这段代码输出结果为：</p><table><thead><tr><th></th><th>public class Main {  public static void main(String[] args) {    String a = “hello2”;    final String b = getHello();    String c = b + 2;    System.out.println((a == c));  }     public static String getHello() {    return “hello”;  }}</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。</p><p>5.下面这段代码的输出结果是什么？</p><table><thead><tr><th></th><th>public class Main {  public static void main(String[] args) {    String a = “hello”;    String b = new String(“hello”);    String c = new String(“hello”);    String d = b.intern();         System.out.println(a==b);    System.out.println(b==c);    System.out.println(b==d);    System.out.println(a==d);  }}</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　输出结果为（JDK版本 JDK6)：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012351.webp" alt="图片"></p><p>　　这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。</p><p>6.String str = new String(“abc”)创建了多少个对象？</p><p>　　这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。</p><p>　　首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012569.webp" alt="图片"></p><p>　　很显然，new只调用了一次，也就是说只创建了一个对象。</p><p>　　而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了”abc”对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个”abc”对象，而在代码执行过程中确实只创建了一个String对象。</p><p>　　因此，这个问题如果换成 String str = new String(“abc”)涉及到几个String对象？合理的解释是2个。</p><p>　　个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。</p><p>7.下面这段代码1）和2）的区别是什么？</p><table><thead><tr><th></th><th>public class Main {  public static void main(String[] args) {    String str1 = “I”;    //str1 += “love”+”java”;    1)    str1 = str1+”love”+”java”;   //2)       }}</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　1）的效率比2）的效率要高，1）中的”love”+”java”在编译期间会被优化成”lovejava”，而2）中的不会被优化。下面是两种方式的字节码：</p><p>　　1）的字节码：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160022397.webp" alt="图片"></p><p>　　2）的字节码：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012654.webp" alt="图片"></p><p>　　可以看出，在1）中只进行了一次append操作，而在2）中进行了两次append操作。</p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自： &lt;a href=&quot;https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q&quot;&gt;https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q?&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;探秘J</summary>
      
    
    
    
    <category term="转载学习" scheme="http://example.com/categories/%E8%BD%AC%E8%BD%BD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Redis 复制</title>
    <link href="http://example.com/2021/11/15/Redis-%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2021/11/15/Redis-%E5%A4%8D%E5%88%B6/</id>
    <published>2021-11-15T14:12:00.000Z</published>
    <updated>2021-11-17T13:17:43.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>通过SLAVEOF 命令进行复制</p> <img src="https://i.loli.net/2021/11/17/81Dy94AgbwFop6B.png" alt="image-20211117210636423" style="zoom:67%;" /><p>被复制的叫做主服务器，相反，对主服务器进行复制的叫做从服务器</p><p>两个服务器经过复制之后数据库状态一致。</p><p>Redis2.8 版本前后对于服务器断线重连复制的问题解决方案不同，因此下面分两部分具体讨论。</p><h2 id="1-旧版复制实现"><a href="#1-旧版复制实现" class="headerlink" title="1.旧版复制实现"></a>1.旧版复制实现</h2><p>Redis2.8 版本之前</p><p>首先了解一些基本概念 ：</p><p>复制分为同步和命令传播</p><ul><li>同步： 从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播： 用于在主服务器的数据库状态修改， 主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li></ul><h3 id="1-1同步"><a href="#1-1同步" class="headerlink" title="1.1同步"></a>1.1同步</h3><p>通过SYNC命令实现</p><p>具体步骤如下：</p><p>1）从服务器向主服务器发送SYNC命令。</p><p>2）主服务器收到命令之后使用BGSAVE生成 RDB文件， 并且使用 缓冲区记录从现在开始执行的所有写命令。</p><p>3）当主服务器的BGSAVE命令执行完毕时， 将生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</p><p>4）主服务器将缓冲区内容发送给从服务器，从服务器进而将自身的数据库状态更新至主服务器数据库当前所处的状态。</p><img src="https://i.loli.net/2021/11/17/ATBDEmIwagXUzHu.png" alt="image-20211117202010473" style="zoom:80%;" /><p><strong>命令传播</strong></p><p>同步完成之后，主从服务器状态达到一致。主服务器执行相关写命令时这种状态将会被改变。</p><p>为了保持状态的一致性，主服务需要对从服务器进行命令传播：即将主服务器执行的命令动态发送给从服务器。</p><h2 id="2、旧版复制缺陷"><a href="#2、旧版复制缺陷" class="headerlink" title="2、旧版复制缺陷"></a>2、旧版复制缺陷</h2><p>通常复制的状态分成两种：初次和复制和断线后重复制</p><ul><li>初次复制：从服务器之前没有复制过任何主服务器</li><li>断线后重复制：从服务器复制时，因某些原因断线，重新连接之后复制的问题。</li></ul><p>新旧复制在初次复制处理没有太大区别，在断线重复值上面旧版复制效率十分低下。新版进行了解决。</p><p>旧版复制断线之后，从服务器重新连接，会重新新进行复制，包括断线状态时，主机进行的新的写操作。断线之前进行定复制操作全部丢弃。</p><p>注：SYNC命令是一个非常耗费资源的操作， 会耗费主服务器大量的CPU、内存和磁盘I/O资源，</p><p> 耗费主从服务器大量的网络资源。</p><h2 id="3、新版复制功能"><a href="#3、新版复制功能" class="headerlink" title="3、新版复制功能"></a>3、新版复制功能</h2><p>Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p><p>PSYNC命令 分成完整重同步 和部分重同步 </p><p>❑ 完整重同步：处理初次复制情况 ，其步骤和SYNC命令相同</p><p>❑ 部分重同步：用于处理断线后重复制情况，冲服务器如果条件允许，从服务器断线重连，主服务器将连接断开期间执行的写命令发送给从服务器，从服务器 根据这些命令进行状态同步（用来解决旧版重复制是效率低下的问题）</p><p><img src="https://i.loli.net/2021/11/17/GuqR9MIkO674aWK.png" alt="image-20211117204237041"></p><h2 id="4、部分重同步实现"><a href="#4、部分重同步实现" class="headerlink" title="4、部分重同步实现"></a>4、部分重同步实现</h2><p>具体分成以下三个组成部分：</p><p>❑主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。</p><p>❑主服务器的复制积压缓冲区（replicationbacklog）。</p><p>❑服务器的运行ID（run ID）。</p><p><strong>复制偏移量：</strong>主从服务器分别维护的一个状态量，两服务器每次传输一字节数据，复制偏移量都会变化1。对比主从服务器的复制偏移量，程序可以 知道主从服务器是否处于一致状态</p><p><strong>复制积压缓冲区</strong> ：（用于判断进行部分重同步还是完整重同步）</p><p>由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。</p><ul><li>当主服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区中</li><li>复制缓冲区保存一部分最近传播的命令</li><li>从服务器重连 ，从服务器通过PSYNC命令将自己的复制偏移量offset发送给主服务器</li><li>主服务器根据offset进行判断进行何种操作<ul><li>offset偏移量之后的数据 存在于复制积压缓冲区里面， 主服务器将对从服务器执行部分重同步操作</li><li>offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li></ul></li></ul><p>注：Redis为复制积压缓冲区设置的默认大小为1MB，可以自行调整。</p><p>​        复制积压缓冲区的最小大小可以根据公式second*write_size_per_second来估算</p><p><strong>服务器运行ID</strong>：主从服务器都有的六进制字符属性</p><ul><li>主从服务器初次复制时，主服务器发送自身运行ID 给从服务器进行保存</li><li>如果断线重连，通过比较运行ID，判断之前连接的服务器是否是同一个<ul><li>相同，进行复制缓冲区判断，决定是否进行部分重复制</li><li>不同，直接进行完整重同步</li></ul></li></ul><h2 id="5、PSYNC-的实现"><a href="#5、PSYNC-的实现" class="headerlink" title="5、PSYNC 的实现"></a>5、PSYNC 的实现</h2><p>psync的调用方法：</p><ul><li><p>从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令（哨兵选举主服务器时的操作）</p></li><li><p> 从服务器已经复制过某个主服务器， 从服务器在开始一次新的复制时就将向主服务器发送PSYNC ＜runid＞ ＜offset＞命令</p></li></ul>  <!--runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量--><p>主服务器接收psync命令后有三种返回状态：</p><ul><li><p>返回+FULLRESYNC ＜runid＞ ＜offset＞：表示执行完整重同步</p></li><li><p>主服务器返回+CONTINUE：主从服务器执行部分重同步，从服务器等待主服务器发送自身缺少的命令数据</p></li><li><p>主服务器返回+CONTINUE： 主服务器的版本低于Redis 2.8，不能识别PSYNC命令，之后从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</p><p>图15-12 PSYNC执行完整重同步和部分重同步时可能遇上的情况：</p></li></ul><img src="https://i.loli.net/2021/11/17/aT9PpAujX8l3dh5.png" alt="image-20211117210438067" style="zoom:80%;" /><h2 id="6、复制的实现"><a href="#6、复制的实现" class="headerlink" title="6、复制的实现"></a>6、复制的实现</h2><p>下面举例说明 Redis2.8或以上版本的复制功能的 实现步骤。</p><p>步骤1：设置主服务器的地址和端口</p><p>步骤3：发送PING命令</p><p>步骤3：发送PING命令</p><p>步骤4：身份验证</p><p> 步骤5：发送端口信息</p><p>步骤6：同步</p><p>步骤7：命令传播</p><h2 id="7、心跳检测"><a href="#7、心跳检测" class="headerlink" title="7、心跳检测"></a>7、心跳检测</h2><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p><p><img src="https://i.loli.net/2021/11/17/dwYsgN6SmbBPIvy.png" alt="image-20211117210958609"></p><p>有三个作用： ❑检测主从服务器的网络连接状态。</p><p>​                        ❑辅助实现min-slaves选项。</p><p>​                        ❑检测命令丢失。</p><p><strong>检测主从服务器的网络连接状态：</strong></p><p>主从服务器 通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接  主服务器一秒钟之内未收到从服务器 发来的REPLCONF ACK命令，主从服务器之间的网络连接出现了问题</p><p><strong>辅助实现min-slaves选项</strong>：</p><p>min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令（在一定的延迟或者从服务器链接数量下，主服务器都可能拒绝写命令）</p><p><strong>检测命令丢失</strong></p><p>通过发送的offset确定两者是否状态一致，命令是否丢失</p><p>注：Redis 2.8版本以前的命令丢失，主服务器和从服务器都不会注意到，主服务器更不会向从服务器补发丢失的数据。因此尽量使用2.8或以上版本的Redis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot; title=&quot;复制&quot;&gt;&lt;/a&gt;复制&lt;/h1&gt;&lt;p&gt;通过SLAVEOF 命令进行复制&lt;/p&gt;
 &lt;img src=&quot;https://i.loli.net/2021/11/17/81Dy94Ag</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 客户端与服务器</title>
    <link href="http://example.com/2021/11/14/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/11/14/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-11-14T12:14:31.000Z</published>
    <updated>2021-11-14T12:15:20.460Z</updated>
    
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
