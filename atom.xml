<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-15T11:15:40.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/19/Computer-network-Summery-of-basic/"/>
    <id>http://example.com/2022/04/19/Computer-network-Summery-of-basic/</id>
    <published>2022-04-19T11:37:37.941Z</published>
    <updated>2022-04-15T11:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-Summery-Basic"><a href="#Computer-Network-Summery-Basic" class="headerlink" title="Computer-Network-Summery-Basic"></a>Computer-Network-Summery-Basic</h1><p>主要介绍计算机网络的基础知识。</p><h3 id="OSI-参考模型？"><a href="#OSI-参考模型？" class="headerlink" title="OSI 参考模型？"></a>OSI 参考模型？</h3><p>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考 模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了 7 层。 </p><p>分别是：物理层、数据链路层、网络层、传输层、表示层、会话层、应用层。</p><p>最大优点是将服务、接口和协议这三个概念明确地区 分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</p><p>服务说明某一层为上一层提供一些什么功能， 接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务。</p><p>这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。</p><p>使网络的不同功能模块实现不同的功能：</p><p>从而带来如下好处： </p><p>● 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错； </p><p>● 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则 相对独立，一种高层协议可放在多种低层协议上运行； </p><p>● 能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手 术； ● 便于研究和教学。</p><p>五层协议 （5 层）：物理层、数据链路层、网络层、运输层、 应用层。 </p><p>每一层的协议如下： </p><p>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） </p><p>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） </p><p>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） </p><p>传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC </p><p>表示层：JPEG、MPEG、ASII </p><p>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS </p><h3 id="各层的作用"><a href="#各层的作用" class="headerlink" title="各层的作用"></a>各层的作用</h3><p>应⽤层 </p><p>应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤。应⽤层协议定义的 是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的 应⽤层协议。在互联⽹中应⽤层协议很多，如域名系统DNS，⽀持万维⽹应⽤的 HTTP协议，⽀持电⼦邮 件的 SMTP协议等等。我们把应⽤层交互的数据单元称为报⽂。 域名系统 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特⽹的⼀项核⼼服务，它作 为可以将域名和IP地址相互映射的⼀个分布式数据库，能够使⼈更⽅便的访问互联⽹，⽽不⽤去记 住能够被机器直接读取的IP数串。（百度百科）例如：⼀个公司的 Web ⽹站可看作是它在⽹上的⻔ 户，⽽域名就相当于其⻔牌地址，通常域名都使⽤该公司的名称或简称。例如上⾯提到的微软公司 的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、/">www.oracle.com、</a> Cisco公司的域名是 <a href="http://www.cisco.com/">www.cisco.com</a> 等。 HTTP协议 超⽂本传输协议（HTTP，HyperText Transfer Protocol)是互联⽹上应⽤最为⼴泛的⼀种⽹络协 议。所有的 WWW（万维⽹） ⽂件都必须遵守这个标准。设计 HTTP 最初的⽬的是为了提供⼀种发布 和接收 HTML ⻚⾯的⽅法。 </p><p>运输层 </p><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通⽤的数据传输服务。 应⽤进程利⽤该服务传送应⽤层报⽂。“通⽤的”是指并不针对某⼀个特定的⽹络应⽤，⽽是多种应⽤可 以使⽤同⼀个运输层服务。由于⼀台主机可同时运⾏多个线程，因此运输层有复⽤和分⽤的功能。所谓 复⽤就是指多个应⽤层进程可同时使⽤下⾯运输层的服务，分⽤和复⽤相反，是运输层把收到的信息分 别交付上⾯应⽤层中的相应进程。 </p><p>运输层主要使⽤以下两种协议: </p><ol><li><p>传输控制协议 TCP（Transmission Control Protocol）–提供⾯向连接的，可靠的数据传输服 务。 </p></li><li><p>⽤户数据协议 UDP（User Datagram Protocol）–提供⽆连接的，尽最⼤努⼒的数据传输服务 （不保证数据传输的可靠性）。   </p></li></ol><p>⽹络层 </p><p>在 计算机⽹络中进⾏通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信⼦ ⽹。⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送。 在发送数据时，⽹络层 把运输层产⽣的报⽂段或⽤户数据报封装成分组和包进⾏传送。在 TCP/IP 体系结构中，由于⽹络层使 ⽤ IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。 这⾥要注意：不要把运输层的“⽤户数据报 UDP ”和⽹络层的“ IP 数据报”弄混。另外，⽆论是哪⼀层 的数据单元，都可笼统地⽤“分组”来表示。 这⾥强调指出，⽹络层中的“⽹络”⼆字已经不是我们通常谈到的具体⽹络，⽽是指计算机⽹络体系结构 模型中第三层的名称. 互联⽹是由⼤量的异构（heterogeneous）⽹络通过路由器（router）相互连接起来的。互联⽹使⽤的 ⽹络层协议是⽆连接的⽹际协议（Intert Protocol）和许多路由选择协议，因此互联⽹的⽹络层也叫 做⽹际层或IP层。 </p><p>数据链路层 </p><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在⼀段⼀段的链路 上传送的，这就需要使⽤专⻔的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将⽹络 层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每⼀帧包括数据和必要的控制信 息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道⼀个帧从哪个⽐特开始和到哪个⽐特结束。这样，数据链路 层在收到⼀个帧后，就可从中提出数据部分，上交给⽹络层。 控制信息还使接收端能够检测到所收到 的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在⽹络中传 送下去⽩⽩浪费⽹络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要 检错，⽽且还要纠错），那么就要采⽤可靠性传输协议来纠正出现的差错。这种⽅法会使链路层的协议 复杂些。 </p><p>物理层 </p><p>在物理层上所传送的数据单位是⽐特。 物理层(physical layer)的作⽤是实现相邻计算机节点之间⽐ 特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上⾯的数据链路层不必考虑⽹ 络的具体传输介质是什么。“透明传送⽐特流”表示经实际电路传送后的⽐特流没有发⽣变化，对传送的 ⽐特流来说，这个电路好像是看不⻅的。 在互联⽹使⽤的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在⼈们经常提到的TCP/IP并不⼀ 定单指TCP和IP这两个具体的协议，⽽往往表示互联⽹所使⽤的整个TCP/IP协议族。</p><p> 物理层：通过媒介传输比特,确定机械及电气规范（比特 Bit） </p><p>数据链路层：将比特组装成帧和点到点的传递（帧 Frame） </p><p>网络层：负责数据包从源到宿的传递和网际互连（包 PackeT） </p><p>传输层：提供端到端的可靠报文传递和错误恢复（段 Segment） </p><p>会话层：建立、管理和终止会话（会话协议数据单元 SPDU） </p><p>表示层：对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） </p><p>应用层：允许访问 OSI 环境的手段（应用协议数据单元 APDU）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Computer-Network-Summery-Basic&quot;&gt;&lt;a href=&quot;#Computer-Network-Summery-Basic&quot; class=&quot;headerlink&quot; title=&quot;Computer-Network-Summery-Basic&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/04/16/JavaEE-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-16T07:31:53.335Z</published>
    <updated>2022-04-13T09:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Java中的String类包含了50多个方法。 绝大多数都很有用，可以设想使用的频繁非常高。下面的API注释汇总了一部分最常用的方法。</p><p>java.lang.string 1.0</p><p>● char charAt (int index)返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。</p><p>● int codePointAt(int index) 5.0返回从给定位置开始的码点。</p><p>● int offsetByCodePoints(int startIndex, int cpCount) 5.0返回从startIndex代码点开始，位移cpCount后的码点索引。</p><p>● int compareTo(String other)按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。</p><p>● IntStream codePoints() 8将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。</p><p>● new String(int[ ] codePoints, int offset, int count) 5.0用数组中从offset开始的count个码点构造一个字符串。</p><p>● boolean equals(Object other)如果字符串与other相等，返回true。</p><p>● boolean equalsIgnoreCase(String other)如果字符串与other相等（忽略大小写），返回true。</p><p>● boolean startsWith(String prefix)</p><p>● boolean endsWith(String suffix)如果字符串以suffix开头或结尾，则返回true。</p><p>● int index0f(String str)</p><p>● int index0f(String str, int fromIndex)</p><p>● int index0f(int cp)</p><p>● int index0f(int cp, int fromIndex)返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。</p><p>● int lastIndex0f(String str)</p><p>● int lastIndex0f(String str, int fromIndex)</p><p>● int lastindex0f(int cp)</p><p>● int lastindex0f(int cp, int fromIndex)返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。</p><p>● int length( )返回字符串的长度。</p><p>● int codePointCount(int startIndex, int endIndex) 5.0返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。</p><p>● String replace(CharSequence oldString, CharSequence newString)返回一个新字符串。这个字符串用</p><p>newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。</p><p>● String substring(int beginIndex)</p><p>● String substring(int beginIndex, int endIndex)返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex-1的所有代码单元。</p><p>● String toLowerCase( )</p><p>● String toUpperCase( )返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。</p><p>● String trim( )返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。</p><p>● String join(CharSequence delimiter, CharSequence… elements) </p><p>返回一个新字符串，用给定的定界符连接所有元素。</p><p>当然也可以使用联机文档：浏览器访问：docs/api/index.html</p><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220410223052516.png" alt="image-20220410223052516"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Stringbuilder和Stringbuffer的区别？"><a href="#Stringbuilder和Stringbuffer的区别？" class="headerlink" title="Stringbuilder和Stringbuffer的区别？"></a>Stringbuilder和Stringbuffer的区别？</h3><p> 1.可变性：只有 String 不可变 </p><p>2.安全性：只有 StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使 用 synchronized 进行同步  </p><p><strong>String 不可变的原因：</strong> </p><p>被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p><p>String 类和其存储 数据的成员变量 value 字节数组都是 final 修饰的。</p><p>对一个 String 对象的任何修改实际上 都是创建一个新 String 对象，再引用该对象。只是修改 String 变量引用的对象，没有修改 原 String 对象的内容。</p><p> <strong>2. String 不可变的好处</strong>： </p><p>（1）可以作为 hashmap 的 key </p><p>（2）String Pool 的需要 </p><p>（3）安全性，经常作为参数，保证不可变 </p><p>（4）线程安全 3. 字符串拼接的方式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;p&gt;Java中的String类包含了50多个方法。 绝大多数都很有用，可以设想使用的频繁非常高。下面的API注释汇总了一部分最常用的方法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-%E5%BC%82%E5%B8%B8/"/>
    <id>http://example.com/2022/04/16/JavaEE-%E5%BC%82%E5%B8%B8/</id>
    <published>2022-04-16T07:31:53.282Z</published>
    <updated>2022-04-12T06:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>什么是异常？</p><p>我们知道程序运行过程中，可能会因为外部问题导致程序异常，中断程序运行。</p><p>在Java等面向对象语言中，异常是一个对象，产生一个异常就是生成了一个异常对象。（java中异常不是错误） </p><h2 id="内置异常类"><a href="#内置异常类" class="headerlink" title="内置异常类"></a>内置异常类</h2><h3 id="Java中异常产生原因"><a href="#Java中异常产生原因" class="headerlink" title="Java中异常产生原因"></a>Java中异常产生原因</h3><ul><li> java内部异常，即虚拟机异常。</li><li>编写代码错误导致的异常。例如空指针异常、数组越界异常。</li><li>通过Throw语句自动生成。被称为检查异常，来告知方法的调用者一些信息。</li></ul><h3 id="内置异常类-1"><a href="#内置异常类-1" class="headerlink" title="内置异常类"></a>内置异常类</h3><p>Java中所有异常都是java.lang.Throwable类的子类。Throwable有两个子类：Error和Exception</p><p>Exception又分成运行时异常和非运行时异常。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202204122123319.png"></p><p> Java标准库内建了一些通用的异常。</p><p>以Throwable为顶层父类。Throwable 又派生出Error类和 Exception类。</p><p>（1)错误：Error类以及它的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出</p><p>现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p><p>（2)异常：Exception以及它的子类，代表程序运行时发生的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。Java异常的分类如图6-4所示。总体上根据javac对异常的处理要求，将异常类分为两类。</p><ul><li><p>非检查异常（unckecked exception):Error和 Runtime Exception以及它们的子类。</p><p>   在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。 这样的异常多半是因为代码编写问题。</p></li><li><p>检查异常（checked exception):除了 Error和Runtime Exception的其他异常。</p></li></ul><p>​    javac强制要求程序员为这样的异常做预备处理工作（使用try··catch···finally或者throws).在方法中要么用try···catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。</p><p>这样的异常一般是由程序的运行环境导致的。 </p><p>如SQLException、IOException、ClassNotFoundException异常等。<br><strong>☆注意☆ 检查和非检查是对于javac来说的</strong> </p><h3 id="Java常见异常类型"><a href="#Java常见异常类型" class="headerlink" title="Java常见异常类型"></a>Java常见异常类型</h3><p><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/202204122200024.png"></p><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p><strong>异常处理机制</strong></p><p>通常分成两种 ：</p><ul><li><p>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。</p><p>运行时系统负责寻找处置异常的代码并执行。</p></li><li><p>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exceptionhandler).潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查并且调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器时，运行时系统终止。同时，意味着Java程序的终止。</p></li></ul><p>总体来说：对于可查异常必须捕获或者声明抛出；允许忽略不可查的Runtime Exception和Error</p><p>抛出异常的方法有两种，分别为throws和throw</p><ul><li><p>throws：通常定义在方法生命的位置，制定方法可能抛出的异常，多个异常用逗号隔开。</p><p>表示此方法不处理异常，由方法调用处进行处理。</p><p>是将异常一层一层抛给上层代码，直到有能够处理异常的代码。</p></li><li><p>throw：定义在方法体中，或者抛出用户自定义异常。</p><p>作用就是抛出一个异常类的实例化对象。</p><p>程序执行到throw停止，想要捕获throw异常，需要使用try…catch或者try ….catch…..finally</p></li></ul><p> <strong>throw和throws的区别?</strong></p><p>①throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。</p><p>②throws 语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。</p><p>③throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。</p><p>④throw是具体向外抛异常的动作，所以它是抛出一个异常实例。</p><p>⑤throws 出现在方法函数头；而throw 出现在函数体。</p><p>⑥throws表示出现异常的一种可能性，并不一定会发生这些异常：throw则是抛出了异常，执行throw则一定抛出了某种异常。</p><p>⑦两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><strong>为什么要自定义异常呢？</strong></p><p>Java中的不同异常，分别代表不同类型的异常情况。具体开发中总会有没有定义好的但是同时需要的异常类型。</p><p>我们可以根据具体情况自定义异常类。</p><p><strong>如何定义？</strong></p><p> （1)所有异常都必须是Throwable的子类。</p><p>（2)如果希望写一个检查异常类，则需要继承 Exception类。</p><p>（3)如果希望写一个运行时异常类，则需要继承 RuntimeException类。</p><p>例子：</p><p>public class CommonException extends RuntimeExceptionpublic  {</p><p> public    CommonException(String msg) {</p><p>​        super (msg) ；</p><p>​    }</p><p>}</p><p>public void testCommonException (){</p><p>​    throw new CommonException(“错误”）；</p><p>}</p><p><strong>自定义异常的缺点？</strong></p><p> 发现异常、抛出异常和处理异常的工作必须靠编程人员在代码中利用异常处理机制自己完成。这样就相应地增加了一些开发成本和工作量，所以若没必要，也不一定非得要用自定义异常。 </p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="finally代码块一定会执行吗？"><a href="#finally代码块一定会执行吗？" class="headerlink" title="finally代码块一定会执行吗？"></a>finally代码块一定会执行吗？</h3><p>Java程序中的finally块并不一定会被执行，至少有两种情况finally语句是不会执行的。</p><p>（1)try语句没有被执行到。即没有进入try代码块，对应的finally 自然不会执行。比如，在try语句之前retun就返回了，这样finally不会执行；或者在程序进入Java之前就出现异常，会直接结束，也不会执行finally块。 </p><p>（2)在try···catch块中有 System.exit(0)来退出JVM.System.exit(0)是终止JVM的，会强制退出程序，finally{}中的代码就不会被执行。</p><h3 id="运行时异常和一般异常有什么区别？"><a href="#运行时异常和一般异常有什么区别？" class="headerlink" title="运行时异常和一般异常有什么区别？"></a>运行时异常和一般异常有什么区别？</h3><p>Java提供了常出现的两类异常；检查异常和运行时异常。</p><p>（1)检查异常主要是指V/O异常、SQL异常等。对于这种异常，JVM要求我们必须对其进行catch处理，所以，面对</p><p>这种异常，不管我们是否愿意，都是要写一大堆的catch块去处理可能出现的异常。</p><p>（2)运行时异常一般不处理，当出现这类异常的时候程序会由虚拟机接管。 出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码。</p><p>如果没有catch块进行处理，到了最上层。如果是多线程就有ThreadO抛出，如果不是多线程那么就由main抛出。</p><p> 也就是说，如果不对运行时异常进行catch处理，那么结果不是线程退出就是主程序终止。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;p&gt;什么是异常？&lt;/p&gt;
&lt;p&gt;我们知道程序运行过程中，可能会因为外部问题导致程序异常，中断程序运行。&lt;/p&gt;
&lt;p&gt;在Java等面向对象语言中</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-%E6%9E%9A%E4%B8%BE/"/>
    <id>http://example.com/2022/04/16/JavaEE-%E6%9E%9A%E4%B8%BE/</id>
    <published>2022-04-16T07:31:53.255Z</published>
    <updated>2022-04-14T06:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-Java-枚举"><a href="#深入理解-Java-枚举" class="headerlink" title="深入理解 Java 枚举"></a>深入理解 Java 枚举</h1><blockquote><p> 本文转载自：<a href="https://dunwu.github.io/javacore/basics/java-enum.html">https://dunwu.github.io/javacore/basics/java-enum.html</a></p><p>更多信息参见原博客</p></blockquote><ul><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8">2. 枚举的本质</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#3-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95">3. 枚举的方法</a></li><li>\4. 枚举的特性<ul><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#41-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">4.1. 基本特性</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#42-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95">4.2. 枚举可以添加方法</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#43-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">4.3. 枚举可以实现接口</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#44-%E6%9E%9A%E4%B8%BE%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF">4.4. 枚举不可以继承</a></li></ul></li><li>\5. 枚举的应用<ul><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#51-%E7%BB%84%E7%BB%87%E5%B8%B8%E9%87%8F">5.1. 组织常量</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#52-switch-%E7%8A%B6%E6%80%81%E6%9C%BA">5.2. switch 状态机</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#53-%E9%94%99%E8%AF%AF%E7%A0%81">5.3. 错误码</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#54-%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE">5.4. 组织枚举</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#55-%E7%AD%96%E7%95%A5%E6%9E%9A%E4%B8%BE">5.5. 策略枚举</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#56-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">5.6. 枚举实现单例模式</a></li></ul></li><li>\6. 枚举工具类<ul><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#61-enumset">6.1. EnumSet</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#62-enummap">6.2. EnumMap</a></li></ul></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#7-%E5%B0%8F%E7%BB%93">7. 小结</a></li><li><a href="https://dunwu.github.io/javacore/basics/java-enum.html#8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">8. 参考资料</a></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="#1. 简介"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_1-%E7%AE%80%E4%BB%8B">#</a>1. 简介</h2><p><code>enum</code> 的全称为 enumeration， 是 JDK5 中引入的特性。</p><p>在 Java 中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ColorEn</span> </span>&#123; RED, GREEN, BLUE &#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的好处</strong>：可以将常量组织起来，统一进行管理。</p><p><strong>枚举的典型应用场景</strong>：错误码、状态机等。</p><h2 id="2-枚举的本质"><a href="#2-枚举的本质" class="headerlink" title="#2. 枚举的本质"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8">#</a>2. 枚举的本质</h2><p><code>java.lang.Enum</code>类声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>新建一个 ColorEn.java 文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ColorEn</span> </span>&#123;</span><br><span class="line">    RED,YELLOW,BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>javac ColorEn.java</code> 命令，生成 ColorEn.class 文件。</p><p>然后执行 <code>javap ColorEn.class</code> 命令，输出如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;ColorEn.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">io</span>.<span class="title">github</span>.<span class="title">dunwu</span>.<span class="title">javacore</span>.<span class="title">enumeration</span>.<span class="title">ColorEn</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">io</span>.<span class="title">github</span>.<span class="title">dunwu</span>.<span class="title">javacore</span>.<span class="title">enumeration</span>.<span class="title">ColorEn</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn RED;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn YELLOW;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn BLUE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> io.github.dunwu.javacore.enumeration.ColorEn[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> io.github.dunwu.javacore.enumeration.<span class="function">ColorEn <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 说明：</p><p>从上面的例子可以看出：</p><p><strong>枚举的本质是 <code>java.lang.Enum</code> 的子类。</strong></p><p>尽管 <code>enum</code> 看起来像是一种新的数据类型，事实上，<strong>enum 是一种受限制的类，并且具有自己的方法</strong>。枚举这种特殊的类因为被修饰为 <code>final</code>，所以不能继承其他类。</p><p>定义的枚举值，会被默认修饰为 <code>public static final</code> ，从修饰关键字，即可看出枚举值本质上是静态常量。</p></blockquote><h2 id="3-枚举的方法"><a href="#3-枚举的方法" class="headerlink" title="#3. 枚举的方法"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_3-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95">#</a>3. 枚举的方法</h2><p>在 enum 中，提供了一些基本方法：</p><ul><li><code>values()</code>：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。</li><li><code>name()</code>：返回实例名。</li><li><code>ordinal()</code>：返回实例声明时的次序，从 0 开始。</li><li><code>getDeclaringClass()</code>：返回实例所属的 enum 类型。</li><li><code>equals()</code> ：判断是否为同一个对象。</li></ul><p>可以使用 <code>==</code> 来比较<code>enum</code>实例。</p><p>此外，<code>java.lang.Enum</code>实现了<code>Comparable</code>和 <code>Serializable</code> 接口，所以也提供 <code>compareTo()</code> 方法。</p><p><strong>例：展示 enum 的基本方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;RED, GREEN, BLUE;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;BIG, MIDDLE, SMALL;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========== Print all Color ===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;</span><br><span class="line">            System.out.println(c + <span class="string">&quot; ordinal: &quot;</span> + c.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========== Print all Size ===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Size s : Size.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot; ordinal: &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Color green = Color.GREEN;</span><br><span class="line">        System.out.println(<span class="string">&quot;green name(): &quot;</span> + green.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;green getDeclaringClass(): &quot;</span> + green.getDeclaringClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;green hashCode(): &quot;</span> + green.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;green compareTo Color.GREEN: &quot;</span> + green.compareTo(Color.GREEN));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals Color.GREEN: &quot;</span> + green.equals(Color.GREEN));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals Size.MIDDLE: &quot;</span> + green.equals(Size.MIDDLE));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals 1: &quot;</span> + green.equals(<span class="number">1</span>));</span><br><span class="line">        System.out.format(<span class="string">&quot;green == Color.BLUE: %b\n&quot;</span>, green == Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=========== Print all Color ===========</span><br><span class="line">RED ordinal: 0</span><br><span class="line">GREEN ordinal: 1</span><br><span class="line">BLUE ordinal: 2</span><br><span class="line">=========== Print all Size ===========</span><br><span class="line">BIG ordinal: 0</span><br><span class="line">MIDDLE ordinal: 1</span><br><span class="line">SMALL ordinal: 2</span><br><span class="line">green name(): GREEN</span><br><span class="line">green getDeclaringClass(): class org.zp.javase.enumeration.EnumDemo$Color</span><br><span class="line">green hashCode(): 460141958</span><br><span class="line">green compareTo Color.GREEN: 0</span><br><span class="line">green equals Color.GREEN: true</span><br><span class="line">green equals Size.MIDDLE: false</span><br><span class="line">green equals 1: false</span><br><span class="line">green == Color.BLUE: false</span><br></pre></td></tr></table></figure><h2 id="4-枚举的特性"><a href="#4-枚举的特性" class="headerlink" title="#4. 枚举的特性"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_4-%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%80%A7">#</a>4. 枚举的特性</h2><p>枚举的特性，归结起来就是一句话：</p><blockquote><p><strong>除了不能继承，基本上可以将 <code>enum</code> 看做一个常规的类</strong>。</p></blockquote><p>但是这句话需要拆分去理解，让我们细细道来。</p><h3 id="4-1-基本特性"><a href="#4-1-基本特性" class="headerlink" title="#4.1. 基本特性"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_4-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">#</a>4.1. 基本特性</h3><p><strong>如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。</strong></p><p>如果枚举中没有定义方法，<strong>枚举值默认为从 0 开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p><h3 id="4-2-枚举可以添加方法"><a href="#4-2-枚举可以添加方法" class="headerlink" title="#4.2. 枚举可以添加方法"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_4-2-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95">#</a>4.2. 枚举可以添加方法</h3><p>在概念章节提到了，<strong>枚举值默认为从 0 开始的有序数值</strong> 。那么问题来了：如何为枚举显式的赋值。</p><p>（1）<strong>Java 不允许使用 <code>=</code> 为枚举常量赋值</strong></p><p>如果你接触过 C/C++，你肯定会很自然的想到赋值符号 <code>=</code> 。在 C/C++语言中的 enum，可以用赋值符号<code>=</code>显式的为枚举常量赋值；但是 ，很遗憾，<strong>Java 语法中却不允许使用赋值符号 <code>=</code> 为枚举常量赋值</strong>。</p><p><strong>例：C/C++ 语言中的枚举声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ONE = <span class="number">1</span>,</span><br><span class="line">    TWO,</span><br><span class="line">    THREE = <span class="number">3</span>,</span><br><span class="line">    TEN = <span class="number">10</span></span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure><p>（2）<strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法</strong></p><p>Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：<strong>为 enum 添加方法来间接实现显式赋值</strong>。</p><p>创建 <code>enum</code> 时，可以为其添加多种方法，甚至可以为其添加构造方法。</p><p><strong>注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p><p><strong>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCodeEn</span> </span>&#123;</span><br><span class="line">    OK(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ERROR_A(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;错误A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ERROR_B(<span class="number">200</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;错误B&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCodeEn</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.code = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="comment">// 普通方法</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125; <span class="comment">// 普通方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;code: &quot;</span> + s.getCode() + <span class="string">&quot;, description: &quot;</span> + s.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// code: 0, description: 成功</span></span><br><span class="line"><span class="comment">// code: 100, description: 错误A</span></span><br><span class="line"><span class="comment">// code: 200, description: 错误B</span></span><br></pre></td></tr></table></figure><p>注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况<a href="https://dunwu.github.io/javacore/basics/java-enum.html#%E9%94%99%E8%AF%AF%E7%A0%81">错误码示例</a></p><h3 id="4-3-枚举可以实现接口"><a href="#4-3-枚举可以实现接口" class="headerlink" title="#4.3. 枚举可以实现接口"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_4-3-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">#</a>4.3. 枚举可以实现接口</h3><p><strong><code>enum</code> 可以像一般类一样实现接口。</strong></p><p>同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCodeEn2</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">    OK(<span class="number">0</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">    ERROR_A(<span class="number">100</span>, <span class="string">&quot;错误A&quot;</span>),</span><br><span class="line">    ERROR_B(<span class="number">200</span>, <span class="string">&quot;错误B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ErrorCodeEn2(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = number;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-枚举不可以继承"><a href="#4-4-枚举不可以继承" class="headerlink" title="#4.4. 枚举不可以继承"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_4-4-%E6%9E%9A%E4%B8%BE%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF">#</a>4.4. 枚举不可以继承</h3><p><strong>enum 不可以继承另外一个类，当然，也不能继承另一个 enum 。</strong></p><p>因为 <code>enum</code> 实际上都继承自 <code>java.lang.Enum</code> 类，而 Java 不支持多重继承，所以 <code>enum</code> 不能再继承其他类，当然也不能继承另一个 <code>enum</code>。</p><h2 id="5-枚举的应用"><a href="#5-枚举的应用" class="headerlink" title="#5. 枚举的应用"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%BA%94%E7%94%A8">#</a>5. 枚举的应用</h2><h3 id="5-1-组织常量"><a href="#5-1-组织常量" class="headerlink" title="#5.1. 组织常量"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-1-%E7%BB%84%E7%BB%87%E5%B8%B8%E9%87%8F">#</a>5.1. 组织常量</h3><p>在 JDK5 之前，在 Java 中定义常量都是<code>public static final TYPE a;</code> 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。</p><p>下面三种声明方式是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN, BLUE &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN, BLUE, &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN, BLUE; &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-switch-状态机"><a href="#5-2-switch-状态机" class="headerlink" title="#5.2. switch 状态机"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-2-switch-%E7%8A%B6%E6%80%81%E6%9C%BA">#</a>5.2. switch 状态机</h3><p>我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 <code>int</code>、<code>char</code>、<code>String</code>、<code>enum</code> 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTrafficInstruct</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line">        String instruct = <span class="string">&quot;信号灯故障&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                instruct = <span class="string">&quot;红灯停&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                instruct = <span class="string">&quot;黄灯请注意&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                instruct = <span class="string">&quot;绿灯行&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instruct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getTrafficInstruct(Signal.RED));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 红灯停</span></span><br></pre></td></tr></table></figure><h3 id="5-3-错误码"><a href="#5-3-错误码" class="headerlink" title="#5.3. 错误码"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-3-%E9%94%99%E8%AF%AF%E7%A0%81">#</a>5.3. 错误码</h3><p>枚举常被用于定义程序错误码。下面是一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCodeEnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCodeEn</span> </span>&#123;</span><br><span class="line">        OK(<span class="number">0</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">        ERROR_A(<span class="number">100</span>, <span class="string">&quot;错误A&quot;</span>),</span><br><span class="line">        ERROR_B(<span class="number">200</span>, <span class="string">&quot;错误B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ErrorCodeEn(<span class="keyword">int</span> number, String msg) &#123;</span><br><span class="line">            <span class="keyword">this</span>.code = number;</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ErrorCodeEn&#123;&quot;</span> + <span class="string">&quot;code=&quot;</span> + code + <span class="string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toStringAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">&quot;ErrorCodeEn All Elements: [&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (ErrorCodeEn code : ErrorCodeEn.values()) &#123;</span><br><span class="line">                sb.append(code.getCode()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ErrorCodeEn.toStringAll());</span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// ErrorCodeEn All Elements: [0, 100, 200, ]</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=0, msg=&#x27;成功&#x27;&#125;</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=100, msg=&#x27;错误A&#x27;&#125;</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=200, msg=&#x27;错误B&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-组织枚举"><a href="#5-4-组织枚举" class="headerlink" title="#5.4. 组织枚举"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-4-%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE">#</a>5.4. 组织枚举</h3><p>可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。</p><p>原因是：Java 接口在编译时会自动为 enum 类型加上<code>public static</code>修饰符；Java 类在编译时会自动为 <code>enum</code> 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 <code>enum</code>，如果你不给它修饰为 <code>public</code>，那么只能在本包中进行访问。</p><p><strong>例：在接口中组织 enum</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumInInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Vegetable</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            POTATO(<span class="number">0</span>, <span class="string">&quot;土豆&quot;</span>),</span><br><span class="line">            TOMATO(<span class="number">0</span>, <span class="string">&quot;西红柿&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Vegetable(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">                <span class="keyword">this</span>.code = number;</span><br><span class="line">                <span class="keyword">this</span>.description = description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">            <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.description;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            APPLE(<span class="number">0</span>, <span class="string">&quot;苹果&quot;</span>),</span><br><span class="line">            ORANGE(<span class="number">0</span>, <span class="string">&quot;桔子&quot;</span>),</span><br><span class="line">            BANANA(<span class="number">0</span>, <span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Fruit(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">                <span class="keyword">this</span>.code = number;</span><br><span class="line">                <span class="keyword">this</span>.description = description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">            <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.description;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Plant.Fruit f : Plant.Fruit.values()) &#123;</span><br><span class="line">            System.out.println(f.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 苹果</span></span><br><span class="line"><span class="comment">// 桔子</span></span><br><span class="line"><span class="comment">// 香蕉</span></span><br></pre></td></tr></table></figure><p><strong>例：在类中组织 enum</strong></p><p>本例和上例效果相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumInClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant2</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Vegetable</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 略，与上面完全相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 略，与上面完全相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 土豆</span></span><br><span class="line"><span class="comment">// 西红柿</span></span><br></pre></td></tr></table></figure><h3 id="5-5-策略枚举"><a href="#5-5-策略枚举" class="headerlink" title="#5.5. 策略枚举"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-5-%E7%AD%96%E7%95%A5%E6%9E%9A%E4%B8%BE">#</a>5.5. 策略枚举</h3><p>Effective Java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。</p><p>这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。</p><p><strong>例：EffectvieJava 中的策略枚举范例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PayrollDay</span> </span>&#123;</span><br><span class="line">    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(</span><br><span class="line">            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(</span><br><span class="line">            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.payType = payType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> hoursWorked, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(hoursWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">PayType</span> </span>&#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hours &lt;= HOURS_PER_SHIFT ? <span class="number">0</span> : (hours - HOURS_PER_SHIFT)</span><br><span class="line">                        * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hours * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOURS_PER_SHIFT = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hrs, <span class="keyword">double</span> payRate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> hoursWorked, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> basePay = hoursWorked * payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(hoursWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;时薪100的人在周五工作8小时的收入：&quot;</span> + PayrollDay.FRIDAY.pay(<span class="number">8.0</span>, <span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;时薪100的人在周六工作8小时的收入：&quot;</span> + PayrollDay.SATURDAY.pay(<span class="number">8.0</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure><h3 id="5-6-枚举实现单例模式"><a href="#5-6-枚举实现单例模式" class="headerlink" title="#5.6. 枚举实现单例模式"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_5-6-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">#</a>5.6. 枚举实现单例模式</h3><p>单例模式是最常用的设计模式。</p><p>单例模式在并发环境下存在线程安全问题。</p><p>为了线程安全问题，传统做法有以下几种：</p><ul><li>饿汉式加载</li><li>懒汉式 synchronize 和双重检查</li><li>利用 java 的静态加载机制</li></ul><p>相比上述的方法，使用枚举也可以实现单例，而且还更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleEnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleEn.INSTANCE.setName(<span class="string">&quot;zp&quot;</span>);</span><br><span class="line">        System.out.println(SingleEn.INSTANCE.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展阅读：<a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)(opens new window)</a></p><p>这篇文章对于 Java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。</p></blockquote><h2 id="6-枚举工具类"><a href="#6-枚举工具类" class="headerlink" title="#6. 枚举工具类"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_6-%E6%9E%9A%E4%B8%BE%E5%B7%A5%E5%85%B7%E7%B1%BB">#</a>6. 枚举工具类</h2><p>Java 中提供了两个方便操作 enum 的工具类——<code>EnumSet</code> 和 <code>EnumMap</code>。</p><h3 id="6-1-EnumSet"><a href="#6-1-EnumSet" class="headerlink" title="#6.1. EnumSet"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_6-1-enumset">#</a>6.1. EnumSet</h3><p><code>EnumSet</code> 是枚举类型的高性能 <code>Set</code> 实现。它要求放入它的枚举常量必须属于同一枚举类型。</p><p>主要接口：</p><ul><li><code>noneOf</code> - 创建一个具有指定元素类型的空 EnumSet</li><li><code>allOf</code> - 创建一个指定元素类型并包含所有枚举值的 EnumSet</li><li><code>range</code> - 创建一个包括枚举值中指定范围元素的 EnumSet</li><li><code>complementOf</code> - 初始集合包括指定集合的补集</li><li><code>of</code> - 创建一个包括参数中所有元素的 EnumSet</li><li><code>copyOf</code> - 创建一个包含参数容器中的所有元素的 EnumSet</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EnumSet展示&quot;</span>);</span><br><span class="line">        EnumSet&lt;ErrorCodeEn&gt; errSet = EnumSet.allOf(ErrorCodeEn.class);</span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn e : errSet) &#123;</span><br><span class="line">            System.out.println(e.name() + <span class="string">&quot; : &quot;</span> + e.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-EnumMap"><a href="#6-2-EnumMap" class="headerlink" title="#6.2. EnumMap"></a><a href="https://dunwu.github.io/javacore/basics/java-enum.html#_6-2-enummap">#</a>6.2. EnumMap</h3><p><code>EnumMap</code> 是专门为枚举类型量身定做的 <code>Map</code> 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。</p><p>主要接口：</p><ul><li><code>size</code> - 返回键值对数</li><li><code>containsValue</code> - 是否存在指定的 value</li><li><code>containsKey</code> - 是否存在指定的 key</li><li><code>get</code> - 根据指定 key 获取 value</li><li><code>put</code> - 取出指定的键值对</li><li><code>remove</code> - 删除指定 key</li><li><code>putAll</code> - 批量取出键值对</li><li><code>clear</code> - 清除数据</li><li><code>keySet</code> - 获取 key 集合</li><li><code>values</code> - 返回所有</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EnumMap展示&quot;</span>);</span><br><span class="line">        EnumMap&lt;Signal, String&gt; errMap = <span class="keyword">new</span> EnumMap(Signal.class);</span><br><span class="line">        errMap.put(Signal.RED, <span class="string">&quot;红灯&quot;</span>);</span><br><span class="line">        errMap.put(Signal.YELLOW, <span class="string">&quot;黄灯&quot;</span>);</span><br><span class="line">        errMap.put(Signal.GREEN, <span class="string">&quot;绿灯&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Signal, String&gt;&gt; iter = errMap.entrySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            Map.Entry&lt;Signal, String&gt; entry = iter.next();</span><br><span class="line">            System.out.println(entry.getKey().name() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展阅读：<a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)(opens new window)</a></p><p>这篇文章中对 EnumSet 和 EnumMap 原理做了较为详细的介绍。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解-Java-枚举&quot;&gt;&lt;a href=&quot;#深入理解-Java-枚举&quot; class=&quot;headerlink&quot; title=&quot;深入理解 Java 枚举&quot;&gt;&lt;/a&gt;深入理解 Java 枚举&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 本文转载自：&lt;a href=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/04/16/JavaEE-%E9%9B%86%E5%90%88/</id>
    <published>2022-04-16T07:31:53.218Z</published>
    <updated>2022-04-13T02:18:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是用来存放某种对象的。集合类有一个共同的特点。它们只容纳对象。集合容纳的对象都是Object的实例，集合类中存放的是指向Object的对象的指针。</p><h2 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection 集合"></a>Collection 集合</h2><p> Collection 是最基本的集合接口，一个Collection 代表一组 Object，即 Collection 的元素（elements）.一些Collection 允许相同的元素而另一些不行。一些能排序而另一些不行.Java SDK不提供直接继承自 Callection 的类，Java SDK 提供的类都是维承自Collection的“子接口”，如List和Set所有实现 Collection 接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的 Collection：有一个Collection 参数的构造函数用于创建一个新的 Collection，这个新的 Collection 与传入的Collection 有相同的元素。后一个构造函数允许用户复制一个<br>Collection</p><p><strong>如何遍历 Collection 中的每一个元素？</strong></p><p>不论 Collection 的实际类型如何，它都支持一个<br><strong>iterator</strong>方法，该方法返回一个送代子，使用该送代子即可逐一访问 Collection 中每一个元素。<br>典型的用法如下：<br>获得一个选代子<br>Iterator itcolleton.lcerator；<br>while(1t.hasNexc0）<br>//得到下一个元素<br>object obj t.next（）；</p><p><strong>Iterator和ListIterator的区别？</strong></p><ul><li><p>首先 ListIterator是继承Iterator<br> public interface Listiterator extends Iterator </p></li><li><p>  1.Iterator 迭代器包含的方法</p></li><li><p>hasNVext0):如果迭代器指向位置后面还有元素，则返回true,否则返回false</p></li><li><p>nex（）:返回集合中Iterator指向位置后面的元素。</p></li><li><p>remove（）:删除集合中 Iterator指向位置后面的元素。</p></li><li><p>Listlterator迭代器包含的方法 </p><ul><li>add(E  e):将指定的元素插入列表，插入位置为迭代器当前位置之前。</li><li>hasNex（）：以正向遍历列表时，如果列表迭代器后面还有元素，则返回true,否则返回false.</li><li>hasPrevious（）:如果以逆向遍历列表，列表迭代器前面还有元素，则返回true,否则返回false.</li><li>next0:返回列表中 Listlterator指向位置后面的元素。</li><li>nextIndex0:返回列表中 ListIterator所需位置后面元素的索引。</li><li>previous(:返回列表中 Listlterator指向位置前面的元素。</li><li>previousIndex():返回列表中 Listlterator所需位置前面元素的索引。</li><li>remove （）：同上</li><li>set(Ee):从列表中将next(或previous(返回的最后一个元素更改为指定元素 </li></ul></li><li><p>不同点</p><p>（1)使用范围不同，Iterator可以应用于所有的集合，Set、List和Map这些集合的子类型；而Listlterator只能</p><p>用于List及其子类型。</p><p>（2)Listlterator有add0方法，可以向List中添加对象，而Iterator不能。</p><p>（3)Listlterator 和Iterator 都有 hasNexi0和nex10方法，可以实现顺序向后遍历，但是Listlterator 有 </p><p>hasPrevious0和previous0方法，可以实现逆向（顺序向前）遍历，而Iterator不可以。</p><p>（4)Listlterator可以定位当前索引的位置，用nextIndex0和previouslndex0可以实现。Iterator没有此功能。</p><p>（5)都可实现删除操作，但是Listlterator可以实现对对象的修改，用set0方法可以实现。Iterator仅能遍历，</p><p>不能修改。</p></li></ul><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List 是有序的 Collection，使用此接口能够精确地控制每个元素插入的位置。用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，这类似于Java 的数组。<br> 除了具有Collection 接口必备的iterator方法外，List还提供一个 listteratoro方法，返回一个Listterator 接口，和标准的 Iterator接口相比，Lisuterator 多了一些 add之类的方法，允许添加、删除、设定元素，还能向前或向后遍历。<br>实现 List 接口的常用类有 LinkedList、ArrayList、Vector 和 Stack。</p><p>LIst集合的遍历？</p><p>遍历方式有以下几种：</p><ul><li>for循环遍历</li><li>foreach遍历</li><li>迭代器遍历：Iterator</li></ul><h4 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h4><p>LinkedList实现了List接口，允许null元素。此外LinkedList提外的geto、removeo.insen0方法在 LinkedList的首部或尾部。这些操作使 LinkedList 可被用作堆栈（stack)、（queue)或双向队列（deque).<br>☆注意☆ LinkedList没有同步方法。如果多个线程同时访问一个List,则必须自己实现访问同步。一种解决方法是在创建 Liu时构造一个同步的List:List l1st-Collections.synchronizedList (new LinkedList (··) ) ;</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList实现了可变大小的数组。它允许所有元素，包括null.ArrayList没有同步。sizc0、isEmpty0、get0、sct0方法运行时间为常数。但是addO方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个 ArrayList 实例都有一个容量（capacity),即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity0方法来增加ArrayList的容量以提高插入效率。和LinkedList一样，ArrayList也是非同步的（unsynchronized).</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector非常类似于ArrayList,但是Vector是同步的。</p><p>由Vector创建的Iterator虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator</p><p>被创建而且正在被使法时将抛出 ConcurentModificationException,因此必须捕获该异常。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack 继承自Vector,实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的有push0和pop0方法，还有peek0方法得到栈顶的元素，empty0方法测试堆栈是否为空，searchO方法检测一个元素在堆栈中的位置。</p><p>Stack刚创建后是空栈。</p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set是一种不包含重复的元素的集合，即任意的两个元素el和c2都有cl.equals(e2)=false.Set最多有一个null元素。很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。☆注意☆ 必须小心操作可变对象（mutable object),如果一个Set中的可变元素改变了自身状态导致 Object.equals(Object)=true将会出现一些问题。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>需要注意的是Map 没有继承 Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key,</p><p>每个key只能映射一个value.Map接口提供3种集合的视图，Map的内容以被当作一组key集合、一组value集合，</p><p>或者一组 key-value映射。</p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>继承Map接口，实现一个Key-Value映射的hashTable。</p><ul><li><p>key和Value不允许是空对象。</p></li><li><p>添加数据使用put(key,value),取出数据使用get(key), </p></li><li><p>由于作为key的对象将通过计算其哈希函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode0和equals0方法。</p></li><li><p>hashCode0和equals0方法继承自根类Object.objl.equals(obj2)=true,则它们的哈希码必须相同；</p></li><li><p>如果两个对象不同，则它们的哈希码不一定不同。</p></li><li><p>如果两个不同对象的哈希码相同，这种现象称为冲突，冲突会导致操作 HashTable的时间开销增大，所以尽量定义好的hashCode0方法，能加快HashTable的操作。</p></li><li><p>如果相同的对象有不同的哈希码，对HashTable的操作会出现意想不到的结果（期待的get0方法返回null),要避免这种问题，只需要牢记一条：<strong>要同时复写equals0方法和hashCode0方法，而不要只写其中一个</strong>。</p></li><li><p><strong>HashTable是同步的。</strong></p></li></ul><h4 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h4><p>HashMap和HashTable类似，不同之处在于HashMap是<strong>非同步</strong>的。</p><p>并且允许null,即null value和null key. </p><p> <strong>HashMap 底层数据结构+扩容机制</strong></p><p>  HashMap 原理 HashMap 在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据 因</p><p>为在查询上使用散列码（通过键生成一个数字作为数组下标，这个数字就是 hash code） 所以在查询上的访问速</p><p>度比较快，HashMap 最多允许一对键值对的 Key 为 Null，允许多对键 值对的 value 为 Null。它是非线程安全</p><p>的。在排序上面是无序的。 transient int size：表示当前 HashMap 包含的键值对数量 transient int </p><p>modCount：表示当前 HashMap 修改次数 int threshold：表示当前 HashMap 能够承受的最多的键值对数量，</p><p>一旦超过这个数量 HashMap 就会进行扩容 final float loadFactor：负载因子，用于扩容 static final int </p><p>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4：默认的 table 初始容量 static final float DEFAULT_LOAD_FACTOR = </p><p>0.75f：默认的负载因子 static final int TREEIFY_THRESHOLD = 8: 链表长度大于该参数转红黑树 static final int </p><p>UNTREEIFY_THRESHOLD = 6: 当树的节点数小于等于该参数转成链表  动态扩容 假设 hashmap 的 table 长度是 </p><p>m（默认初始长度为 16，并且每次扩展或者手动初始化时， 长度必须是 2 的幂），键值对为 n。每个链表长度为 </p><p>n/m，为了使查找成本尽可能的小， 要 m 尽可能的大。可以使用 resize 实现。</p><p><strong>HashMap和HashTable有什么区别 ？</strong></p><p> 1.父类不同</p><p>（1)HashMap是继承自 AbstractMap类，而HashTable是继承自 Dictionary.</p><p>不过它们都同时实现了Map、Cloneable(可复制）、Serializable(可序列化）这三个接口。（</p><p>2)HashTable比HashMap 多提供了elments(和contains(两个方法。</p><p>（3)elments0方法继承自 HashTable 的父类 Dictionnary.elements()方法用于返回此HashTable中的value的枚举。</p><p>（4)contains(0方法判断该HashTable是否包含传入的value,它的作用与containsValuco-致。事实上contansValueO就只是调用了一下contains0方法。</p><p>2.null 值问题</p><p>（1)HashTable既不支持null key也不支持 null value.HashTable的put0方法的注释中有说明。 </p><p>（2)HashMap中，null可以作为键，这样的键只有一个；</p><p>3.线程安全性</p><p>（1)HashTable是线程安全的，它的每个方法中都加入了synchronize0方法。 </p><p>（2)HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。 虽然HashMap不是线程安全的，但是它的效率会比HashTable要高很多。 </p><p>4.遍历方式不同</p><p>（1)HashTable、HashMap都使用了Iterator.而由于历史原因，HashTable还使用了Enumeration的方式。</p><p>（2)HashMap的Iterator是fail-fast迭代器。当有其他线程改变了HashMap的结构（增加、删除、修改元素），将会抛出 ConcurrentModificationException.不过，通过Iterator的remove0方法移除元素则不会抛出 ConcurrentModificationException异常。 </p><p>​    在JDK8及以后的版本中，HashTable也是使用fast-fail的。 </p><p>5.初始容量不同</p><p>HashTable的初始长度是11,之后每次扩充容量变为之前的2”+1(n为上一次的长度），</p><p>HashMap的初始长度为16,之后每次扩充变为原来的两倍。</p><p>创建时，如果给定了容量初始值，那么HashTable会直接使用给定的大小，而HashMap会将其扩充为2的幂次方大小。 </p><p>6.计算哈希值的方法不同</p><p>为了得到元素的位置，首先需要根据元素的key值计算出一个哈希值，然后再用这个哈希值来计算得到最终的位置。<br>HashTable 直接使用对象的哈希码，哈希码是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值，然后再使用除留余数法来获得最终的位置，然而除法运算是非常耗费时间的。HashMap为了提高计算效率，将HashTable的大小固定为2的幂，这样在取模计算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。 </p><p><strong>ArrayList 和 LinkedList 区别</strong> ?</p><p>1、ArrayList 是基于动态数组实现的，LinkedList 是基于双向链表实现的 </p><p>2、ArrayList 支持随机访问，查询速度快，LinkedList 访问数据的平均效率低，需要对链表进 行遍历 </p><p>3、ArrayList 删除和插入非尾部元素时候代价高，需要移动大量元素，LinkedList 的删除和插 入只需要改变指针。</p><p> <strong>ArrayList 的底层实现</strong> </p><p> 以数组实现，节约空间，但数组有容量限制。超出限制时会增加 50%容量，用 System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。</p><p>默认第一次插入元素时创建大小为 10 的数组。 ArrayList 是一个相对来说比较简单的数据结构，最重 要的一点就是它的自动扩容， 可以认为就是我们常说的“动态数组”。</p><p>  按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p><p>  直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素 —add(i,e), remove(i), remove(e)，则要用 System.arraycopy()来移动部分受影 响的元素，性能就变 差了，这是基本劣势。 </p><p> ArrayList 是容量可变的非线程安全列表，使用数组实现，集合扩容时会创建更大的数组， 把原有数组复制到新数组。</p><p>支持对元素的快速随机访问，但插入与删除速度很慢。</p><p> ArrayList 实现了 RandomAcess 标记接口，如果一个类实现了该接口，那么表示使用索 引遍历比迭代器更快。elementData 是 ArrayList 的数据域，被 transient 修饰，序列化 时会调用 writeObject 写入流，反序列化时调用 readObject 重新赋值到新对象的 elementData。</p><p>原因是 elementData 容量通常大于实际存储元素的数量，所以只需发送 真正有实际值的数组元素。</p><p>size 是当前实际大小，elementData 大小大于等于 size。 *modCount *记录了 ArrayList 结构性变化的次数，继承自 AbstractList。</p><p>所有涉及结构 变化的方法都会增加该值。expectedModCount 是迭代器初始化时记录的 modCount 值，每次访问新元素时都会检查 modCount 和 expectedModCount 是否相等，不相等 就会抛出异常。</p><p>这种机制叫做 fail-fast，所有集合类都有这种机制。</p><p> <strong>LinkedList 的底层实现</strong> </p><p> 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链 表指针操作。 </p><p> 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果 i&gt;数组 大小的 一半，会从末尾移起)。</p><p>  插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才 能移动 到下标所指的位置，只有在链表两头的操作—add()，addFirst()， removeLast()或用 iterator()上的 remove()能省掉指针的移动。</p><p>  LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很 慢。除继承 AbstractList 外还实现了 Deque 接口，这个接口具有队列和栈的性质。成 员变量被 transient 修饰，原理和 ArrayList 类似。LinkedList 包含三个重要的成员：size、 first 和 last。size 是双向链表中节点的个数，first 和 last 分别指向首尾节点的引用。 </p><p>LinkedList 的优点在于可以将零散的内存单元通过附加引用的方式关联起来，形成按链 路顺序查找的线性结构，内存利用率较高。</p><p>hashmap的具体实现参考了一篇博客：</p><p><a href="http://fangjian0423.github.io/2016/03/29/jdk_hashmap/?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">Hashmap实现</a></p><p><a href="http://fangjian0423.github.io/2016/03/29/jdk_hashmap/?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">java集合</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;p&gt;集合是用来存放某种对象的。集合类有一个共同的特点。它们只容纳对象。集合容纳的对象都是Object的实例，集合类中存放的是指向Object的对</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2022/04/16/JavaEE-%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-04-16T07:31:53.187Z</published>
    <updated>2022-04-12T16:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>泛型在java中有很重要的地位，无论是开源框架还是JDK源码都能看到它。</p><p><strong>毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课。</strong></p><p>1、泛型（Generic type 或者 generics）定义 泛型是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以 把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行 恐涉侵权，请勿传播 227 时传递的值的占位符一样。允许在定义接口、类时声明类型形参，类型形参在整个接口、类 体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。 2、泛型的目的 Java 泛型就是把一种语法糖（在计算机语言中添加的某种语法，这种语法对语言的功能并 没有影响，但是更方便程序员使用。Java 中最常用的语法糖主要有泛型、变长参数、条件编 译、自动拆装箱、内部类等。），通过泛型使得在编译阶段完成一些类型转换的工作，避免 在运行时强制类型转换而出现 ClassCastException ，即类型转换异常。 3、泛型的好处： ①类 型 安 全 。 类 型 错 误 现 在 在 编 译 期 间 就 被 捕 获 到 了 ， 而 不 是 在 运 行 时 当 作 java.lang.ClassCastException 展示出来，将类型检查从运行时挪到编译时有助于开发者更容易 找到错误，并提高程序的可靠性。 ②消除了代码中许多的强制类型转换，增强了代码的可读性，编码阶段就显式知道泛型集 合、泛型方法等处理的对象类型。 ③ 代码重用，合并了同类型的处理代码。 4、Java 的泛型是如何工作的 ? 什么是类型擦除 ? 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时 不存在任何类型相关的信息。例如 List在运行时仅用一个 List 来表示。这样做的目的， 是确保能和 Java 5 之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数， 因为编译器已经把泛型类型转换成了原始类型。因为不管为泛型的类型形参传入哪一种类型 实参，对于 Java 来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从 Java 泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确 检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的 class 文件中是不 包含任何泛型信息的。泛型信息不会进入到运行时阶段。在静态方法、静态初始化块或者静 态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以 instanceof 运算符后不能使用泛型类。 5、什么是泛型中的限定通配符和非限定通配符 限定通配符对类型进行了限制。有两种限定通配符，一种是可以接受任何继承 自 T 的类型的 List，它通过确保类型必须是 T 的子类来设定类型的上界，另一种是 可以接受任何 T 的父类构成的 List，它通过确保类型必须是 T 的父类来设定类型的下界。泛 型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面表示了非限 定通配符，因为可以用任意类型来替代。</p><p>7、类型擦除后保留的原始类型 原始类型就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一 个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变 量用 Object）替换。 8、类型擦除引起的问题及解决方法 Java 不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题， 但是也引起来许多新问题，所以，SUN 对这些问题做出了种种限制，避免我们发生各种错误。 （1）先检查，再编译以及编译的对象和引用传递问题 Q: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整 数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的 类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？ A: Java 编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。因为类 型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任 何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用 list1 来调用它的 方法，比如说调用 add 方法，所以 list1 引用能完成泛型类型的检查。而引用 list2 没有使用 泛型，所以不行。 （2）自动类型转换 因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。 既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？ 在 ArrayList.get()方法中 public E get(int index) { RangeCheck(index); return (E) elementData[index]; } 可以看到，在 return 之前，会根据泛型变量进行强转。假设泛型类型变量为 Date，虽然泛 型信息会被擦除掉，但是会将(E)elementData[index]，编译为(Date)elementData[index]。所以 我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设 Pair 类的 value 域是 public 的，那么表达式：Date date = pair.value; 也会自动地在结果字节码中插入强 制类型转换。 （3）类型擦除与多态的冲突和解决方法 虚拟机并不能将泛型类型变为 Date，只能将类型擦除掉，变为原始类型 Object。可是类型 擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。 解决方法：JVM 采用了一个特殊的方法，来完成这项功能，那就是桥方法。 用 javap -c className 的方式反编译下 DateInter 子类的字节码，从编译的结果来看，重写 setValue 和 getValue 方法的子类，竟然有 4 个方法，其实不用惊奇，最后的两个方法，就是 编译器自己生成的桥方法。可以看到桥方法的参数类型都是 Object，也就是说，子类中真正 覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的 setvalue 和 getValue 方法上面的@Oveerride 只不过是假象。而桥方法的内部实现，就只是去调用我们自 己重写的那两个方法。 所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。 不过，要提到一点，这里面的 setValue 和 getValue 这两个桥方法的意义又有不同。 恐涉侵权，请勿传播 229 setValue 方法是为了解决类型擦除与多态之间的冲突。 而 getValue 却有普遍的意义，怎么说呢，如果这是一个普通的继承关系。 子类中的巧方法 Object getValue()和 Date getValue()是同 时存在的，可是如果是常规的两个 方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自 己编写 Java 代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的， 因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许 自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。 （4）泛型类型变量不能是基本数据类型 不能用类型参数替换基本类型。就比如，没有 ArrayList，只有 ArrayList。 因为当类型擦除后，ArrayList 的原始类型变为 Object，但是 Object 类型不能存储 double 值， 只能引用 Double 的值。 （5）泛型在静态方法和静态类中的问题 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。 public class Test2 { public static T one; //编译错误 public static T show(T one){ //编译错误 return null; } } 因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需 要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误 的。 但是要注意区分下面的一种情况： public class Test2 { public static T show(T one){ //这是正确的 return null; } } 因为在泛型方法中使用的 T 是自己在方法中定义的 T，而不是泛型类中的 T。</p><h2 id="一：泛型本质"><a href="#一：泛型本质" class="headerlink" title="一：泛型本质"></a>一：泛型本质</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p><strong>泛型的本质是参数化类型</strong>，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/640.png" alt="图片"></p><h2 id="二：为什么使用泛型"><a href="#二：为什么使用泛型" class="headerlink" title="二：为什么使用泛型"></a>二：为什么使用泛型</h2><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p><strong>（1）保证了类型的安全性。</strong></p><p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。</p><p>比如：没有泛型的情况下使用集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void noGeneric() &#123;ArrayList names = new ArrayList();names.add(&quot;mikechen的互联网架构&quot;);names.add(123); //编译正常&#125;</span><br></pre></td></tr></table></figure><p>有泛型的情况下使用集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void useGeneric() &#123;ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();names.add(&quot;mikechen的互联网架构&quot;);names.add(123); //编译不通过&#125;</span><br></pre></td></tr></table></figure><p>有了泛型后，定义好的集合names在编译的时候add(123)就会编译不通过。</p><p>相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性。</p><p><strong>（2） 消除强制转换</strong></p><p>泛型的一个附带好处是，消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。<br>还是举例说明，以下没有泛型的代码段需要强制转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();list.add(&quot;hello&quot;);String s = (String) list.get(0);</span><br></pre></td></tr></table></figure><p>当重写为使用泛型时，代码不需要强制转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;hello&quot;);String s = list.get(0); // no cast</span><br></pre></td></tr></table></figure><p><strong>（3）避免了不必要的装箱、拆箱操作，提高程序的性能</strong></p><p>在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</p><p>泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object a=1;//由于是object类型，会自动进行装箱操作。 int b=(int)a;//强制转换，拆箱操作。这样一去一来，当次数多了以后会影响程序的运行效率。</span><br></pre></td></tr></table></figure><p>使用泛型之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static T GetValue&lt;T&gt;(T a) &#123;　　return a;&#125; public static void Main() &#123;　　int b=GetValue&lt;int&gt;(1);//使用这个方法的时候已经指定了类型是int，所以不会有装箱和拆箱的操作。&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）提高了代码的重用性。</strong></p><h2 id="三：如何使用泛型"><a href="#三：如何使用泛型" class="headerlink" title="三：如何使用泛型"></a>三：如何使用泛型</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p><p><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/640-16497881013771.png" alt="图片"></p><h3 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h3><p>泛型类：把泛型定义在类上</p><p>定义格式：<br><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/640-16497881013772.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class 类名 &lt;泛型类型1,...&gt; &#123;    &#125;</span><br></pre></td></tr></table></figure><p>注意事项：泛型类型必须是引用类型（非基本数据类型）</p><p>定义泛型类，在类名后添加一对尖括号，并在尖括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔：</p><p>public class GenericClass&lt;ab,a,c&gt; {}</p><p>当然，这个后面的参数类型也是有规范的，不能像上面一样随意，通常类型参数我们都使用大写的单个字母表示：</p><blockquote><p>T：任意类型 type<br>E：集合中元素的类型 element<br>K：key-value形式 key<br>V：key-value形式 value<br>示例代码：</p></blockquote><p>泛型类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class GenericClass&lt;T&gt; &#123;    private T value;      public GenericClass(T value) &#123;        this.value = value;    &#125;    public T getValue() &#123;        return value;    &#125;    public void setValue(T value) &#123;        this.value = value;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//TODO 1:泛型类GenericClass&lt;String&gt; name = new GenericClass&lt;&gt;(&quot;mikechen的互联网架构&quot;);System.out.println(name.getValue());  GenericClass&lt;Integer&gt; number = new GenericClass&lt;&gt;(123);System.out.println(number.getValue());</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/640-16497881013783.png" alt="图片"></p><h3 id="2、泛型接口"><a href="#2、泛型接口" class="headerlink" title="2、泛型接口"></a>2、泛型接口</h3><p>泛型方法概述：把泛型定义在方法上<br><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/640-16497881013784.png" alt="图片"><br>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;泛型类型&gt; 返回类型 方法名（泛型类型 变量名） &#123;    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意要点：</p></li><li><ul><li>方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface GenericInterface&lt;T&gt; &#123;void show(T value);&#125;&#125;public class StringShowImpl implements GenericInterface&lt;String&gt; &#123;@Overridepublic void show(String value) &#123;System.out.println(value);&#125;&#125; public class NumberShowImpl implements GenericInterface&lt;Integer&gt; &#123;@Overridepublic void show(Integer value) &#123;System.out.println(value);&#125;&#125;</span><br></pre></td></tr></table></figure><p>注意：使用泛型的时候，前后定义的泛型类型必须保持一致，否则会出现编译异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericInterface&lt;String&gt; genericInterface = new NumberShowImpl();//编译异常</span><br></pre></td></tr></table></figure><p>或者干脆不指定类型，那么 new 什么类型都是可以的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericInterface g1 = new NumberShowImpl();GenericInterface g2 = new StringShowImpl();</span><br></pre></td></tr></table></figure><h3 id="3、泛型方法"><a href="#3、泛型方法" class="headerlink" title="3、泛型方法"></a>3、泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><ul><li> 定义格式：</li></ul><blockquote><p>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**     *     * @param t 传入泛型的参数     * @param &lt;T&gt; 泛型的类型     * @return T 返回值为T类型     * 说明：     *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。     *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。     *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。     *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。     */    public &lt;T&gt; T genercMethod(T t)&#123;        System.out.println(t.getClass());        System.out.println(t);        return t;    &#125;  public static void main(String[] args) &#123;    GenericsClassDemo&lt;String&gt; genericString  = new GenericsClassDemo(&quot;helloGeneric&quot;); //这里的泛型跟下面调用的泛型方法可以不一样。    String str = genericString.genercMethod(&quot;hello&quot;);//传入的是String类型,返回的也是String类型    Integer i = genericString.genercMethod(123);//传入的是Integer类型,返回的也是Integer类型&#125;  class java.lang.Stringhello  class java.lang.Integer123</span><br></pre></td></tr></table></figure><p>这里可以看出，泛型方法随着我们的传入参数类型不同，他得到的类型也不同。泛型方法能使方法独立于类而产生变化。</p><h2 id="四：泛型通配符"><a href="#四：泛型通配符" class="headerlink" title="四：泛型通配符"></a>四：泛型通配符</h2><p><strong>Java泛型的通配符是用于解决泛型之间引用传递问题的特殊语法, 主要有以下三类:</strong></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 1：表示类型参数可以是任何类型public class Apple&lt;?&gt;&#123;&#125;  // 2：表示类型参数必须是A或者是A的子类public class Apple&lt;T extends A&gt;&#123;&#125;  // 3: 表示类型参数必须是A或者是A的超类型public class Apple&lt;T supers A&gt;&#123;&#125; </span><br></pre></td></tr></table></figure><p><strong>1. 无边界的通配符(Unbounded Wildcards), 就是<?>, 比如List<?></strong><br>无边界的通配符的主要作用就是让泛型能够接受未知类型的数据.</p><p><strong>2. 固定上边界的通配符(Upper Bounded Wildcards)，采用&lt;? extends E&gt;的形式</strong></p><p>使用固定上边界的通配符的泛型, 就能够接受指定类及其子类类型的数据。</p><p>要声明使用该类通配符, 采用&lt;? extends E&gt;的形式, 这里的E就是该泛型的上边界。</p><p>注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类</p><p><strong>3. 固定下边界的通配符(Lower Bounded Wildcards)，采用&lt;? super E&gt;的形式</strong></p><p>使用固定下边界的通配符的泛型, 就能够接受指定类及其父类类型的数据.。</p><p>要声明使用该类通配符, 采用&lt;? super E&gt;的形式, 这里的E就是该泛型的下边界.。</p><p>注意: 你可以为一个泛型指定上边界或下边界, 但是不能同时指定上下边界。</p><h2 id="五：泛型中KTVE的含义"><a href="#五：泛型中KTVE的含义" class="headerlink" title="五：泛型中KTVE的含义"></a>五：泛型中KTVE的含义</h2><p>果点开JDK中一些泛型类的源码，我们会看到下面这些代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;    ...&#125;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;    ...&#125;    </span><br></pre></td></tr></table></figure><p>上面这些泛型类定义中的泛型参数E、K和V都是什么意思呢？</p><p>其实这些参数名称是可以任意指定，就想方法的参数名一样可以任意指定，但是我们通常会起一个有意义的名称，让别人一看就知道是什么意思。</p><p><strong>常见泛型参数名称有如下：</strong></p><p>E：Element (在集合中使用，因为集合中存放的是元素)<br>T：Type（Java 类）<br>K：Key（键）<br>V：Value（值）<br>N：Number（数值类型）<br>？：表示不确定的java类型</p><h2 id="六：泛型的实现原理"><a href="#六：泛型的实现原理" class="headerlink" title="六：泛型的实现原理"></a>六：泛型的实现原理</h2><p>泛型本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作。</p><p>看一个例子就应该清楚了，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&lt;T&gt; &#123;    private T num; &#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。</p><p>反编译一下这个 Caculate 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&#123;    public Caculate()&#123;&#125;    private Object num;&#125;</span><br></pre></td></tr></table></figure><p>发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。</p><p>那么是不是所有的泛型类型都以 Object 进行擦除呢？大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&lt;T extends String&gt; &#123;    private T num;&#125;</span><br></pre></td></tr></table></figure><p>这种情况的泛型类型，num 会被替换为 String 而不再是 Object。</p><p>这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。</p><p>实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。</p><p>实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换，这一个过程就叫做『泛型翻译』。 </p><p><a href="https://mp.weixin.qq.com/s/fsB2bq9FrOQnNY5hE6s2wQ">https://mp.weixin.qq.com/s/fsB2bq9FrOQnNY5hE6s2wQ</a></p><p><a href="https://mp.weixin.qq.com/s/stonkCgsd2B-uhtOg1sobw">https://mp.weixin.qq.com/s/stonkCgsd2B-uhtOg1sobw</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;泛型在java中有很重要的地位，无论是开源框架还是JDK源码都能看到它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、泛型（Generic type 或者 gen</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2022/04/16/JavaEE-%E5%8F%8D%E5%B0%84/</id>
    <published>2022-04-16T07:31:53.160Z</published>
    <updated>2022-04-13T06:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java提供了一个特殊的类<code>Class</code>，用来描述类的内部信息，是反射的核心类。</p><p>Java获取反射的三种方法</p><p>1.通过new对象实现反射机制 </p><p>2.通过路径实现反射机制 </p><p>3.通过类名实现反射机制</p><p>当然还可以通过类加载器实现反射机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private int id;</span><br><span class="line">String name;</span><br><span class="line">protected boolean sex;</span><br><span class="line">public float score;</span><br><span class="line">&#125;</span><br><span class="line">public class Get &#123;</span><br><span class="line">//获取反射机制三种方式</span><br><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">//方式一(通过建立对象)</span><br><span class="line">Student stu = new Student();</span><br><span class="line">Class classobj1 = stu.getClass();</span><br><span class="line">System.out.println(classobj1.getName());</span><br><span class="line">//方式二(所在通过路径-相对路径)</span><br><span class="line">Class classobj2 = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">System.out.println(classobj2.getName());</span><br><span class="line">//方式三(通过类名)</span><br><span class="line">Class classobj3 = Student.class;</span><br><span class="line">System.out.println(classobj3.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java反射机制</strong><br>Java 反射机制是在运行状态中,对于任意一个类,都能够获得这个类的所有属性和方法,对于任意一个对象都能够<br>调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为 Java 的反射机<br>制。<br>Class 类与 java.lang.reflect 类库一起对反射的概念进行了支持,该类库包含了 Field,Method,Constructor 类 (每<br>个类都实现了 Member 接口)。这些类型的对象时由 JVM 在运行时创建的,用以表示未知类里对应的成员。<br>这样你就可以使用 Constructor 创建新的对象,用 get() 和 set() 方法读取和修改与 Field 对象关联的字段,用<br>invoke() 方法调用与 Method 对象关联的方法。另外,还可以调用 getFields() getMethods() 和<br>getConstructors() 等很便利的方法,以返回表示字段,方法,以及构造器的对象的数组。这样匿名对象的信息<br>就能在运行时被完全确定下来,而在编译时不需要知道任何事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">public class ReflectTest &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Class clazz = null;</span><br><span class="line">clazz = Class.forName(&quot;com.jas.reflect.Fruit&quot;);</span><br><span class="line">Constructor&lt;Fruit&gt; constructor1 = clazz.getConstructor();</span><br><span class="line">Constructor&lt;Fruit&gt; constructor2 = clazz.getConstructor(String.class);</span><br><span class="line">Fruit fruit1 = constructor1.newInstance();</span><br><span class="line">Fruit fruit2 = constructor2.newInstance(&quot;Apple&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Fruit&#123;</span><br><span class="line">public Fruit()&#123;</span><br><span class="line">System.out.println(&quot;无参构造器 Run...........&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public Fruit(String type)&#123;</span><br><span class="line">System.out.println(&quot;有参构造器 Run...........&quot; + type);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>java反射机制参考：</p><p><a href="https://mp.weixin.qq.com/s/-JfevVj0xVHBAZ_AgowZAQ">https://mp.weixin.qq.com/s/-JfevVj0xVHBAZ_AgowZAQ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java提供了一个特殊的类&lt;code&gt;Class&lt;/code&gt;，用来描述类的内部信息，是反射的核心类。&lt;/p&gt;
&lt;p&gt;Java获取反射的三种方法&lt;/p&gt;
&lt;p&gt;1.通过new对象实现反射机制 &lt;/p&gt;
&lt;p&gt;2.通过路径实现反射机制 &lt;/p&gt;
&lt;p&gt;3.通过类名实现反射机制</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/04/16/JavaEE-JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-04-16T07:31:53.121Z</published>
    <updated>2022-04-12T06:23:48.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/16/JavaEE-basic/"/>
    <id>http://example.com/2022/04/16/JavaEE-basic/</id>
    <published>2022-04-16T07:31:53.112Z</published>
    <updated>2022-04-13T09:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>自动装箱/拆箱是什么？</strong></p><p> 每个基本数据类型都对应一个包装类，除了 int 和 char 对应 Integer 和 Character 外，其 余基本数据类型的包装类都是首字母大写即可。 </p><p>自动装箱： 将基本数据类型包装为一个包装类对象，</p><p>例如向一个泛型为 Integer 的集合添 加 int 元素。  </p><p>自动拆箱： 将一个包装类对象转换为一个基本数据类型</p><p>例如将一个包装类对象赋值给一 个基本数据类型的变量。</p><p> 比较两个包装类数值要用 equals ，而不能用 == 。 </p><p>Java 按值调用还是引用调用 ?</p><p>按值调用指方法接收调用者提供的值。</p><p>按引用调用指方法接收调用者提供的变量地址。</p><p> <strong>Java 总是按值调用</strong>，方法得到的是所有参数值的副本，传递对象时实际上方法接收的是对 象引用的副本。</p><p>方法不能修改基本数据类型的参数，如果传递了一个 int 值 ，改变值不会 影响实参，因为改变的是值的一个副</p><p>本。 可以改变对象参数的状态，但不能让对象参数引用一个新的对象。</p><p>如果传递了一个 int 数 组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象。</p><p><strong>基本数据类型</strong>：</p><p><img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220413052002623.png" alt="image-20220413052002623"></p><p><strong>大数</strong>：</p><p>基本数据类型或者浮点数不够精确的话，那么可以使用java.Math中的两个很有用的类：BigInteger、BigDecimal</p><p>BigInteger将实现任意精度的整数运算、BigDecimal实现任意精度的浮点数运算。</p><p>使用静态的valueOf方法可以将普通的数值转换为大数值：</p><p>​        BigInteger a =BigInteger.Valueof(100);</p><p>更大的数可以使用带字符串参数的构造器</p><p>BigInteger aa=new BigInteger（“65463213218679879746546464”）</p><p>注：不能使用 熟悉的算术运算符（如：+和*）处理大数值。而需要使用大数值类中的add和multiply方法。</p><p>常见的API 方法：</p><p><strong>API java.math.BigInteger 1.1</strong></p><p>● BigInteger add(BigInteger other)</p><p>● BigInteger subtract(BigInteger other)</p><p>● BigInteger multiply(BigInteger other)</p><p>● BigInteger divide(BigInteger other)</p><p>● BigInteger mod(BigInteger other)返回这个大整数和另一个大整数other的和、差、积、商以及余数。</p><p>● int compareTo(BigInteger other)如果这个大整数与另一个大整数other相等，返回0；如果这个大整数小于另一个大整数other，返回负数；否则，返回正数。</p><p>● static BigInteger valueOf(long x)返回值等于x的大整数。</p><p> <strong>java.math.BigDecimal 1.1</strong></p><p>● BigDecimal add(BigDecimal other)</p><p>● BigDecimal subtract(BigDecimal other)</p><p>● BigDecimal multiply(BigDecimal other)</p><p>● BigDecimal divide(BigDecimal other RoundingMode mode) </p><p>返回这个大实数与另一个大实数other的和、差、积、商。要想计算商，必须给出舍入方式（rounding mode）。RoundingMode.HALF_UP是在学校中学习的四舍五入方式（即，数值0到4舍去，数值5到9进位）。它适用于常规的计算。有关其他的舍入方式请参看API文档。</p><p>● int compareTo(BigDecimal other)如果这个大实数与另一个大实数相等，返回0；如果这个大实数小于另一个大实数，返回负数；否则，返回正数。</p><p>● static BigDecimal valueOf(long x)</p><p>● static BigDecimal valueOf(long x, int scale)返回值为x或x / 10scale的一个大实数。</p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用final修饰的在程序运行中只能被赋值一次，之后值不会再改变的量。</p><p>通常使用大写字母定义名称；可以使用下划线、$、大小写字母、数字。</p><p>但是不能以数字开头。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量的作用域规定了变量所能使用的范围，只有在作用域范围内变量才能被使用。根据变量声明地点的不同，变量的作用域也不同。</p><p> 基本格式：</p><p>​    数据类型   变量名称</p><p>根据作用域的不同，一般将变量分为不同的类型：成员变量和局部变量。下面对这几种变量进行详细说明。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p><a href="http://c.biancheng.net/java/">Java</a> 的成员变量有两种，分别是全局变量和静态变量（类变量）。定义在方法体和语句块之外，不属于任何一个方法，作用域是整个类。</p><table><thead><tr><th>名称</th><th>修饰</th><th>访问</th><th>生命周期</th></tr></thead><tbody><tr><td>全局变量（实例变量）</td><td>无 static 修饰</td><td>对象名.变量名</td><td>只要对象被当作引用，实例变量就将存在</td></tr><tr><td>静态变量（类变量）</td><td>用 static 修饰</td><td>类名.变量名或对象名.变量名</td><td>其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁</td></tr></tbody></table><p> <img src="/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220410210924382.png" alt="image-20220410210924382"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>注：</p><p>实例方法可以对当前对象的实例变量进行操作，也可以对类变量进行操作。实例方法由实例对象调用。</p><p>类方法不能访问实例变量，只能访问类变量。类方法由类名或者实例对象调用。类方法中不能出现this或者super关键字</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：</p><ul><li>方法参数变量（形参）：在整个方法内有效。</li><li>方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。</li><li>代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。</li></ul><p>局部变量在使用前必须被程序员主动初始化值。</p><h4 id="1）方法局部变量"><a href="#1）方法局部变量" class="headerlink" title="1）方法局部变量"></a>1）方法局部变量</h4><p>声明两个局部变量并输出其值，其实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;    public static void main(String[] args) &#123;        int a = 7;        if (5 &gt; 3) &#123;            int s = 3; // 声明一个 int 类型的局部变量            System.out.println(&quot;s=&quot; + s);            System.out.println(&quot;a=&quot; + a);        &#125;        System.out.println(&quot;a=&quot; + a);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>上述实例中定义了 a 和 s 两个局部变星，其中 int 类型的 a 的作用域是整个 main() 方法，而 int 类型的变量 s 的作用域是 if 语句的代码块内，其执行结果如图 2 所示：</p><p>如果在 if 方法外调用变量 s，则会报无法解析该变量的错误。</p><h4 id="2）方法参数变量"><a href="#2）方法参数变量" class="headerlink" title="2）方法参数变量"></a>2）方法参数变量</h4><p>作为方法参数声明的变量的作用域是整个方法。</p><p>声明一个方法参数变量，实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test3 &#123;    public static void testFun(int n) &#123;        System.out.println(&quot;n=&quot; + n);    &#125;    public static void main(String[] args) &#123;        testFun(3);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>在上述实例中定义了一个 testFun() 方法，该方法中包含一个 int 类型的参数变量 n，其作用域是 testFun() 方法体内。当调用方法时传递进了一个参数 3，因此其输出控制台的 n 值是 3。</p><h4 id="3）代码块局部变量"><a href="#3）代码块局部变量" class="headerlink" title="3）代码块局部变量"></a>3）代码块局部变量</h4><p>代码块局部变量常用于 try catch 代码块中，成为异常处理参数变量。</p><p>异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似。</p><p>声明一个异常处理语句，实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">纯文本复制</span><br><span class="line">public class Test4 &#123;    public static void test() &#123;        try &#123;            System.out.println(&quot;Hello!Exception!&quot;);        &#125; catch (Exception e) &#123; // 异常处理块，参数为 Exception 类型            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>【java】static、final、static final 的区别</strong> </p><p>1、static static 表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态 static 代码块，但是 Java 语言中没有全局变量的概念。被 static 修饰的成员变量和成员方法 独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这 个类被加载，Java 虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static 对象可以在它的任何对象创建之前访问，无需引用任何对象。Public 修饰的 static 成员变量 和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成 static 变量的副本， 而是类的所有实例共享同一个 static 变量。 - 类成员变量 - 静态变量（类变量）: static 修饰 - 实例变量 : 无 static 修饰 - 局部变量</p><p>2、final final 类不能被继承，没有子类，final 类中的方法默认是 final 的； final 方法不能被子类的方法复盖，但可以被继承； final 成员变量表示常量，只能被赋值一次，赋值后不能再被改变； final 不能用于修饰构造方法； private 不能被子类方法覆盖，private 类型的方法默认是 final 类型的。 final 修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 注意：final 变量定义的时候，可以先声明，而不给初值，这中变量也称为 final 空白，无论 什么情况，编译器都确保空白 final 在使用之前必须被初始化。 3、static final static final 用来修饰成员变量和成员方法，可以理解为“全局变量”。 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 对于方法，表示不可覆盖，并且可以通过类名直接访问。 static 修饰的属性强调它们只有一个，final 修饰的属性表明是一个常数（创建后不能被修改）。 static final 修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final 也可 以修饰方法，表示该方法不能重写，可以在不 new 对象的情况下调用。 注意： 对于被 static 和 final 修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比 如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放 的对象。 static final 和 final static 语法和用法上没有任何区别，一般习惯 static 写在前面。</p><p><strong>局部变量和成员变量的区别？</strong></p><p>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。<br>成员变量是指在类的体系结构的变量部分中定义的变量<br>局部变量和成员变最的区别<br>(1）定义的位置。<br>局部变量：定义在方法的内部。<br>成员变量：定义在方法的外部，即直接写在类中。<br>（2）作用范围。<br>局部变量：只适用于方法中，描述类的公共属性<br>成员变量：整个类中都可以通用。<br>（3）默认值（初始化）。<br>局部变量：没有默认初始值，需要手动进行赋值之后才能使用<br>成员变量：有默认初始值，如int类型的默认值为0:foat 类型的默认值为0.0f:double 类<br>型的默认值为0.0。<br>（4）内存的位置。<br>局部变量：位于栈内存。<br>成员变量：位于堆内存<br>（5）生命周期<br>局部变量：在调用对应的方法时，局部变量因为执行创建语句而存在，超出自己的作用域<br>之后会立即从内存消失。</p><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h3><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if、if…..else 、if嵌套</p><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><p>switch </p><p>语句变量中的类型可以是：byte、short、char、int</p><p>每一个case之后加一个比较的值和一个冒号</p><p>可以在最后添加一个default分支</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>while、do…..while 、for  </p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象的理解？<br>在解释面向对象之前，先介绍一下什么是对象<br>在Java语言中，把对象当作一种变量，它不仅可以存储数据，还可以对自身进行操作。每个对象都有各自的属性及方法，Java 就是通过对象之间行为的交互来解决问题的。<br>在我看来，而向对象就是把构成问题的所有事务分解成一个个的对象，建立这些对象去描述某个事务在解决问题中的行为。而类就是面向对象中很重要的一部分，类是很多个具有相同属性和行为特征的对象所抽象由来的，对象是类的一个实例。<br>类还具有三个特性，即封装、继承和多态。<br>（1）封装：将一类事务的属性和行为抽象成一个类，只提供符合开发者意愿的公有方法来<br>访问这些数据和逻辑，在提高数据的隐秘性的同时，使代码模块化。<br>（2）继承：子类可以维承父类的属性和方法，并对其进行拓展。<br>（3）多态：同一种类型的对象执行同一个方法时可以表现由不同的行为特征。通过继承的<br>上下转型、接口的回调以及方法的重写和重载可以实现多态。</p><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>面向对象的核心思想。</p><p>指的是将对象的属性和行为进行封装，不让外界知道具体的实现细节。</p><p>封装的好处：</p><ul><li>安全性：把过程和数据封装，只能通过预定义的接口对数据进行访问。隐藏信息、实现细节。</li><li>减少耦合，类的内部结构可自由修改。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>指的是类与类之间的关系。</p><p>子类只能继承父类中的能够被访问的（public、protect）方法和属性；私有方法和属性能够被继承，但是无法访问。</p><p>好处：</p><p>高效的对原有类进行扩展。</p><p>提高代码的复用性</p><p>对于程序的修改，补充提供了便利条件。</p><p>继承使用extends关键字。</p><p>值得注意的是，Java中只支持使用单继承，这一点和C++中 不同。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是把子类型对象主观的看成父类型的对象。因此不同子类继承父类，就会有很多种类型。</p><p>运行的时候会根据不同种类型调用相关类型中定义的方法</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>java创建对象的方式：</p><p>（1）通过ncw 语句实例化一个对象。<br>使用 new 关键字创建对象是最常见的一种方式，但是使用 new 创建对象会增加帮合度。在使用new 时需要先查看new 后面的类型，然后再决定分配多大的内存空间：接着可以通过调用构造函数，来对对象的各个域进行充；根据构造方法的返回值进行对象的创建，最后把引用地址传递给外部。</p><p>例如：<br>package test;<br>/使用new 关使字创建对像<br>publlo class Newclass{<br>public static vold main(StringDargs){<br>Hello h = new Hel1o（）；<br>h.sayworld（）；</p><p>​    }</p><p>}</p><p>（2）通过反射机制创建对象。<br>使用反射机制的Class类的newInstance0方法。<br>（3）通过clonc0方法创建一个对象。<br>在使用 clone0方法时，不会调用构造函数，而是需要有一个分配了内存的源对象。在创建新对象时，首先应该分配一个和源对象一样大的内存空间。<br>（4）通过反序列化的方式创建对象。<br>序列化就是把对象通过流的方式存储到文件里面，那么反序列化就是把字节内容读出来并还原成Java对象，这里还原的过程就是反序列化。在使用反序列化时也不会调用构造方法。</p><h2 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h2><p>抽象类可以实现接口，当一个类实现一个借口，但是没有实现接口中的所有方法，那么这个类必须是抽象类。</p><p>抽象类可以继承实体类，但是实体类中必须有明确的构造函数。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口和抽象类的异同：</p><ul><li>相同点<ul><li>都可以被继承</li><li>都不能直接实例化</li><li>都可以包含抽象方法</li><li>派生类都必须实现未实现的方法</li></ul></li><li>不同点<ul><li>接口支持多继承</li><li>一个类只能继承一个抽象类，但是可以实现多个接口</li><li>接口中的成员变量只能是 pubic、static、final的，抽象类没有限制</li><li>接口只能定义抽象方法，抽象类可以定义抽象方法，也可以定义实现方法</li><li>接口中不能含有静态代码快以及静态方法。抽象类可以。</li></ul></li></ul><h2 id="java访问修饰符"><a href="#java访问修饰符" class="headerlink" title="java访问修饰符"></a>java访问修饰符</h2><p>Java 中有四种访问修饰符，分别为 publie、private、protected 和defaulte</p><ul><li><p>public：公有的。用 public 修饰的类、属性及方法，不仅可以踏类访问，而且允许路包<br>（package）访间。</p></li><li><p>private：私有的。用 private 修饰的类、属性以及方法只能被该类的对象访问，其子类<br>不能访问，更不允许踏包访问。</p></li><li><p>protected:介于 public 和 privale 之间的一种访问修饰符。用 prolected 修饰的类、属性<br>以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访间。</p></li><li><p>default：默认访问模式。在该模式下，只允许在同一个包中进行访问。</p></li><li><p>注意</p><p>☆ protected 修饰符所修饰的类属于成员变量和方法，只可以被子类访问，而不管<br>子类是不是和父类位于同一个包中。</p><p>defaullt修饰符所修饰的类也属于成员变量和方法，但只可被同一个包中的共他类访问，而不管其他类是不是该类的子类.</p><p>protecled 属于子类限制修饰，而default 属于包限制修饰符。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;自动装箱/拆箱是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 每个基本数据类型都对应一个包装类，除了 int 和</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-常见参数配置</title>
    <link href="http://example.com/2022/03/31/JVM-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/03/31/JVM-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-31T11:05:35.000Z</published>
    <updated>2022-03-31T12:58:42.707Z</updated>
    
    <content type="html"><![CDATA[<p>**测试环境：*<em>JVM配置为*<em>2核1G，JAVA8，固定设置堆大小 1G</em></em></p><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_192&quot;</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_192-b12)</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 默认大小通常太小，尽量授予尽可能多的内存，增加CPU的时候，内存也应该增加</span><br></pre></td></tr></table></figure><p>6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m  -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p><strong>1、 示例代码 -1</strong></p><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 启动程序，模拟用户请求</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 每100毫秒钟创建150线程，每个线程创建一个512kb的对象，最多一秒同时存在1500线程，占用内存750m（75%），查看GC的情况</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class PerformanceApplication &#123;</span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure><p>6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(PerformanceApplication.class, args);</span><br></pre></td></tr></table></figure><p>7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -&gt; &#123;</span><br></pre></td></tr></table></figure><p>8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br></pre></td></tr></table></figure><p>9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 150; i++) &#123;</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br></pre></td></tr></table></figure><p>11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  不干活，专门512kb的小对象</span><br></pre></td></tr></table></figure><p>12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] temp = new byte[1024 * 512];</span><br></pre></td></tr></table></figure><p>13</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(new Random().nextInt(1000)); // 随机睡眠1秒以内</span><br></pre></td></tr></table></figure><p>14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (InterruptedException e) &#123;</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure><p>16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>17</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>18</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>19</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;, 100, 100, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>23</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 打包 mvn clean package</span><br></pre></td></tr></table></figure><p>24</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 服务器上运行 performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 对象存活在1秒左右的场景，远远超过平时接口的响应时间要求，场景应该为吞吐量优先</span><br></pre></td></tr></table></figure><p>1.1 GC分析，主要查看GC导致的stop-the-world，这将导致我们的程序延时增大。</p><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查找到performance-1.0.0.jar的进程号</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd | grep &quot;performance-1.0.0.jar&quot; | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># jmap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap $(jcmd | grep &quot;performance-1.0.0.jar&quot; | awk &#x27;&#123;print $1&#125;&#x27;) </span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 收集GC日志（日志离线分析，主要用于检查故障看出是不是因为GC导致的程序卡顿）</span><br></pre></td></tr></table></figure><p>7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 不建议直接输出 java -Xmx1024m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m -Xloggc:/netease/gc1.log -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 分析GC日志（）</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCViewer工具，辅助分析GC日志文件 https://github.com/chewiebug/GCViewer</span><br></pre></td></tr></table></figure><p>11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># jstat 动态监控GC统计信息，间隔1000毫秒统计一次，每10行数据后输出列标题</span><br></pre></td></tr></table></figure><p>13</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc -h10 $(jcmd | grep &quot;performance-1.0.0.jar&quot; | awk &#x27;&#123;print $1&#125;&#x27;) 1000</span><br></pre></td></tr></table></figure><p>14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>1.2 GC调优</p><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过命令查看参数：java -XX:+PrintFlagsFinal –version | grep 参数关键字</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Parallel GC  服务器默认  java -Xmx1024m -Xloggc:/netease/gc1.log -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseAdaptiveSizePolicy自适应默认开启，所以Eden区会自动变化大小</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29184.0 29184.0  0.0    0.0   290816.0 275028.2  214528.0   90453.2   35068.0 33496.5 4656.0 4334.9     15    0.285   7      0.549    0.834</span><br></pre></td></tr></table></figure><p>6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29184.0 37888.0 28704.9  0.0   273408.0 195849.2  214528.0   136022.6  35068.0 33497.2 4656.0 4334.9     16    0.306   7      0.549    0.856</span><br></pre></td></tr></table></figure><p>7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37888.0 37888.0  0.0    0.0   273408.0 141381.4  230912.0   89954.2   35068.0 33497.7 4656.0 4334.9     17    0.341   8      0.624    0.966</span><br></pre></td></tr></table></figure><p>8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37888.0 49152.0 37409.1  0.0   250880.0 98232.2   230912.0   127331.4  35068.0 33498.4 4656.0 4334.9     18    0.363   8      0.624    0.987</span><br></pre></td></tr></table></figure><p>9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49152.0 49152.0  0.0   48673.5 250880.0 82729.6   230912.0   152932.2  35068.0 33498.8 4656.0 4334.9     19    0.385   8      0.624    1.009</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49152.0 63488.0  0.0    0.0   222208.0 70943.1   234496.0   90654.2   35068.0 33505.3 4656.0 4334.9     20    0.409   9      0.697    1.106</span><br></pre></td></tr></table></figure><p>11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">63488.0 63488.0  0.0   63009.9 222208.0 104636.8  234496.0   100894.5  35068.0 33508.4 4656.0 4334.9     21    0.431   9      0.697    1.128</span><br></pre></td></tr></table></figure><p>12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">63488.0 81920.0 63009.9  0.0   185344.0 139024.0  234496.0   111646.8  35068.0 33512.1 4656.0 4334.9     22    0.452   9      0.697    1.149</span><br></pre></td></tr></table></figure><p>13</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">91648.0 100864.0 74786.3  0.0   147456.0 33980.1   234496.0   111646.8  35068.0 33528.3 4656.0 4334.9     24    0.495   9      0.697   1.192</span><br></pre></td></tr></table></figure><p>14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">107520.0 112640.0 74274.3  0.0   123904.0 30746.2   234496.0   111646.8  35068.0 33528.3 4656.0 4334.9     26    0.539   9      0.697  1.236</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认情况，实时监控结果：10秒内11次YGC，2次FullGC，总耗时0.4秒</span><br></pre></td></tr></table></figure><p>16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>17</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、 调大-XX:ParallelGCThreads=4  java -Xmx1024m -Xloggc:/netease/gc2.log -XX:ParallelGCThreads=4  -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>18</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>19</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10752.0 9216.0  0.0    0.0   264192.0 195460.3  105472.0   58165.2   35120.0 33480.3 4656.0 4333.8     13    0.153   3      0.219    0.373</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10752.0 12288.0  0.0    0.0   324608.0 59139.9   135168.0   69954.5   35120.0 33483.8 4656.0 4334.9     14    0.180   4      0.277    0.458</span><br></pre></td></tr></table></figure><p>21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10752.0 12288.0  0.0    0.0   324608.0 190623.5  135168.0   69954.5   35120.0 33483.8 4656.0 4334.9     14    0.180   4      0.277    0.458</span><br></pre></td></tr></table></figure><p>22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10752.0 12288.0  0.0    0.0   324608.0 317022.0  135168.0   69954.5   35120.0 33483.8 4656.0 4334.9     14    0.180   4      0.277    0.458</span><br></pre></td></tr></table></figure><p>23</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12288.0 12288.0  0.0    0.0   324608.0 156095.2  166912.0   82766.1   35120.0 33486.7 4656.0 4334.9     15    0.199   5      0.325    0.524</span><br></pre></td></tr></table></figure><p>24</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12288.0 12288.0  0.0    0.0   324608.0 311437.3  166912.0   82766.1   35120.0 33486.7 4656.0 4334.9     15    0.199   5      0.325    0.524</span><br></pre></td></tr></table></figure><p>25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12288.0 15360.0  0.0    0.0   318464.0 175117.9  195072.0   90455.3   35120.0 33487.1 4656.0 4334.9     16    0.217   6      0.380    0.598</span><br></pre></td></tr></table></figure><p>26</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15360.0 15360.0  0.0    0.0   318464.0 37004.8   212480.0   90463.3   35120.0 33487.1 4656.0 4334.9     17    0.231   7      0.430    0.661</span><br></pre></td></tr></table></figure><p>27</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15360.0 15360.0  0.0    0.0   318464.0 225927.9  212480.0   90463.3   35120.0 33487.1 4656.0 4334.9     17    0.231   7      0.430    0.661</span><br></pre></td></tr></table></figure><p>28</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15360.0 19456.0  0.0    0.0   310272.0 103539.3  230400.0   90983.0   35120.0 33487.8 4656.0 4334.9     18    0.243   8      0.484    0.727</span><br></pre></td></tr></table></figure><p>29</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：10秒内5次GC，总耗时0.35。 如果有多线程，一定要调大参数</span><br></pre></td></tr></table></figure><p>30</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>31</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、 降低耗时，设置-XX:MaxGCPauseMills=10   java -Xmx1024m -Xloggc:/netease/gc3.log -XX:MaxGCPauseMillis=10  -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>32</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>33</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12800.0 18944.0  0.0    0.0   121856.0 15777.8   176640.0   86351.4   35120.0 33512.4 4656.0 4333.5     21    0.217  11      0.523    0.740</span><br></pre></td></tr></table></figure><p>34</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12800.0 22016.0  0.0    0.0   121856.0 54705.3   185856.0   88403.0   35120.0 33513.2 4656.0 4333.5     22    0.230  12      0.568    0.798</span><br></pre></td></tr></table></figure><p>35</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25088.0 22016.0  0.0    0.0   121856.0 91971.1   188416.0   88918.6   35120.0 33513.2 4656.0 4333.5     23    0.243  13      0.613    0.856</span><br></pre></td></tr></table></figure><p>36</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33280.0 29184.0  0.0    0.0   117760.0 31698.5   183296.0   88412.8   35120.0 33513.2 4656.0 4333.5     25    0.268  15      0.707    0.975</span><br></pre></td></tr></table></figure><p>37</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33280.0 38912.0  0.0    0.0   112128.0 91608.5   179200.0   88928.0   35120.0 33513.2 4656.0 4333.5     26    0.280  16      0.754    1.035</span><br></pre></td></tr></table></figure><p>38</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45056.0 52224.0  0.0    0.0   104960.0 64733.6   174080.0   88420.9   35120.0 33513.7 4656.0 4333.5     28    0.305  18      0.844    1.149</span><br></pre></td></tr></table></figure><p>39</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">60416.0 70144.0  0.0    0.0   95232.0  51840.1   173568.0   89100.1   35120.0 33514.1 4656.0 4333.5     30    0.331  19      0.891    1.222</span><br></pre></td></tr></table></figure><p>40</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">74752.0 86016.0 71714.2  0.0   83968.0  79793.1   173568.0   89100.1   35120.0 33514.1 4656.0 4333.5     32    0.355  19      0.891    1.245</span><br></pre></td></tr></table></figure><p>41</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">108032.0 102400.0  0.0   72770.2 76800.0  62256.3   173568.0   89100.1   35120.0 33514.8 4656.0 4333.5     35    0.392  19    0.891    1.283</span><br></pre></td></tr></table></figure><p>42</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">116224.0 116224.0  0.0   73282.2 71680.0   3641.2   173568.0   89108.1   35120.0 33518.8 4656.0 4333.5     39    0.441  19    0.891    1.331</span><br></pre></td></tr></table></figure><p>43</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：10秒内18次YGC，8次FGC，GC次数变多，总的时间反倒变长。 代表单次GC时间加速，会换来更多的GC次数，这种情况下不合适。</span><br></pre></td></tr></table></figure><p>44</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>45</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># CMS</span><br></pre></td></tr></table></figure><p>46</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3、 改用CMS回收器  java -Xmx1024m -Xloggc:/netease/gc4.log -XX:+UseConcMarkSweepGC  -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>47</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>48</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1540.4  0.0   16384.0   3091.6   166784.0   144616.6  35144.0 33474.4 4680.0 4334.1     84    0.415  39      0.235    0.651</span><br></pre></td></tr></table></figure><p>49</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1540.4  0.0   16384.0    0.0     195804.0   166637.9  35144.0 33477.0 4680.0 4334.1     92    0.450  44      0.271    0.721</span><br></pre></td></tr></table></figure><p>50</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1538.4  0.0   16384.0   5661.8   195804.0   125169.0  35144.0 33477.0 4680.0 4334.1    100    0.480  49      0.298    0.778</span><br></pre></td></tr></table></figure><p>51</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1538.4  0.0   16384.0   5153.7   217156.0   187639.7  35144.0 33477.4 4680.0 4334.1    110    0.520  53      0.323    0.843</span><br></pre></td></tr></table></figure><p>52</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1540.4 16384.0    0.0     241052.0   207613.3  35144.0 33477.4 4680.0 4334.1    121    0.564  57      0.347    0.911</span><br></pre></td></tr></table></figure><p>53</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1540.4 16384.0   8773.2   241052.0   185600.7  35144.0 33477.4 4680.0 4334.1    131    0.603  61      0.371    0.974</span><br></pre></td></tr></table></figure><p>54</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1538.4 16384.0    0.0     242600.0   160004.8  35144.0 33477.4 4680.0 4334.1    143    0.649  65      0.396    1.045</span><br></pre></td></tr></table></figure><p>55</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1540.4 16384.0   4648.6   381032.0   228619.2  35144.0 33478.1 4680.0 4334.1    155    0.709  66      0.409    1.118</span><br></pre></td></tr></table></figure><p>56</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1566.2  0.0   16384.0   5402.5   381548.0   374564.8  35400.0 33721.3 4680.0 4364.3    168    0.782  67      0.410    1.192</span><br></pre></td></tr></table></figure><p>57</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：10秒内85次YGC，28次FGC，总耗时0.54。 cms这种高频回收并不是适合这个场景。</span><br></pre></td></tr></table></figure><p>58</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4、 增加线程 java -Xmx1024m -Xloggc:/netease/gc4.log -XX:+UseConcMarkSweepGC  -XX:ConcGCThreads=3 -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>59</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>60</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1538.8 16384.0   7246.8   156612.0   80654.6   35196.0 33516.0 4732.0 4333.0     73    0.364  38      0.225    0.589</span><br></pre></td></tr></table></figure><p>61</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1538.4  0.0   16384.0   5170.8   163448.0   84756.2   35196.0 33516.3 4732.0 4333.0     80    0.393  42      0.250    0.643</span><br></pre></td></tr></table></figure><p>62</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1540.4  0.0   16384.0    0.0     177112.0   146202.8  35196.0 33517.5 4732.0 4333.0     88    0.423  46      0.275    0.698</span><br></pre></td></tr></table></figure><p>63</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1540.8  0.0   16384.0   8246.7   203568.0   125726.2  35196.0 33519.0 4732.0 4333.0     96    0.455  50      0.299    0.754</span><br></pre></td></tr></table></figure><p>64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1540.4  0.0   16384.0    0.0     213816.0   158500.2  35196.0 33519.0 4732.0 4333.0    106    0.497  55      0.325    0.822</span><br></pre></td></tr></table></figure><p>65</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1538.4  0.0   16384.0    0.0     217236.0   157992.8  35196.0 33519.3 4732.0 4333.0    116    0.536  59      0.349    0.886</span><br></pre></td></tr></table></figure><p>66</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1540.8  0.0   16384.0    0.0     259916.0   167213.6  35196.0 33519.3 4732.0 4333.0    126    0.577  62      0.373    0.950</span><br></pre></td></tr></table></figure><p>67</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1538.4 16384.0    0.0     259916.0   211763.6  35196.0 33519.3 4732.0 4333.0    137    0.617  65      0.387    1.004</span><br></pre></td></tr></table></figure><p>68</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1536.0 16384.0   3608.3   349532.0   256826.1  35196.0 33519.3 4732.0 4333.0    149    0.682  67      0.399    1.081</span><br></pre></td></tr></table></figure><p>69</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0  0.0   1540.4 16384.0   3087.0   349532.0   250174.0  35196.0 33520.5 4732.0 4333.0    161    0.726  69      0.412    1.139</span><br></pre></td></tr></table></figure><p>70</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：10秒内88次YGC，31次FGC，总耗时0.55，差不多的情况。</span><br></pre></td></tr></table></figure><p>71</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># G1 建议大堆使用</span><br></pre></td></tr></table></figure><p>72</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5、 改用G1 java -Xmx1024m -Xloggc:/netease/gc10.log  -XX:+UseG1GC -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>73</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>74</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   4096.0   993280.0   244610.8  35200.0 33464.4 4736.0 4333.5    168    1.229   0      0.000    1.229</span><br></pre></td></tr></table></figure><p>75</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   6144.0   993280.0   411220.0  35200.0 33466.3 4736.0 4333.5    177    1.414   0      0.000    1.414</span><br></pre></td></tr></table></figure><p>76</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   660480.0 17408.0   388096.0   248910.9  35200.0 33466.3 4736.0 4333.5    187    1.645   0      0.000    1.645</span><br></pre></td></tr></table></figure><p>77</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   613376.0 39936.0   435200.0   435196.7  35200.0 33466.3 4736.0 4333.5    197    1.863   0      0.000    1.863</span><br></pre></td></tr></table></figure><p>78</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   6144.0   993280.0   502275.2  35200.0 33466.3 4736.0 4333.5    206    2.088   0      0.000    2.088</span><br></pre></td></tr></table></figure><p>79</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   6144.0   993280.0   497159.3  35200.0 33466.3 4736.0 4333.5    216    2.320   0      0.000    2.320</span><br></pre></td></tr></table></figure><p>80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   493568.0 41984.0   555008.0   553992.8  35200.0 33466.3 4736.0 4333.5    227    2.556   0      0.000    2.556</span><br></pre></td></tr></table></figure><p>81</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   660480.0  1024.0   388096.0   205221.1  35200.0 33466.3 4736.0 4333.5    237    2.822   0      0.000    2.822</span><br></pre></td></tr></table></figure><p>82</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   6144.0   993280.0   464105.0  35200.0 33466.7 4736.0 4333.5    247    3.056   0      0.000    3.056</span><br></pre></td></tr></table></figure><p>83</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   570368.0 38912.0   478208.0   477630.5  35200.0 33469.3 4736.0 4333.5    258    3.322   0      0.000    3.322</span><br></pre></td></tr></table></figure><p>84</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：不行...</span><br></pre></td></tr></table></figure><p>85</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6、增加分区大小 java -Xmx1024m -Xloggc:/netease/gc11.log  -XX:+UseG1GC -XX:G1HeapRegionSize=64m -jar performance-1.0.0.jar</span><br></pre></td></tr></table></figure><p>86</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>87</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 65536.0    0.0     360448.0   248859.1  35196.0 33493.9 4732.0 4333.3    123    1.723   0      0.000    1.723</span><br></pre></td></tr></table></figure><p>88</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 163840.0 65536.0   262144.0   150835.5  35196.0 33493.9 4732.0 4333.3    127    1.784   0      0.000    1.784</span><br></pre></td></tr></table></figure><p>89</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 65536.0    0.0     360448.0   194563.3  35196.0 33493.9 4732.0 4333.3    132    1.834   0      0.000    1.834</span><br></pre></td></tr></table></figure><p>90</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 131072.0   0.0     294912.0   192001.0  35196.0 33493.9 4732.0 4333.3    136    1.880   0      0.000    1.880</span><br></pre></td></tr></table></figure><p>91</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 196608.0   0.0     229376.0   111728.2  35196.0 33493.9 4732.0 4333.3    142    1.943   0      0.000    1.943</span><br></pre></td></tr></table></figure><p>92</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 131072.0 65536.0   294912.0   180224.5  35196.0 33493.9 4732.0 4333.3    144    1.972   0      0.000    1.972</span><br></pre></td></tr></table></figure><p>93</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 163840.0 98304.0   262144.0   126091.5  35196.0 33493.9 4732.0 4333.3    150    2.036   0      0.000    2.036</span><br></pre></td></tr></table></figure><p>94</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 98304.0  32768.0   327680.0   201220.0  35196.0 33493.9 4732.0 4333.3    154    2.081   0      0.000    2.081</span><br></pre></td></tr></table></figure><p>95</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 163840.0 65536.0   262144.0   144384.5  35196.0 33493.9 4732.0 4333.3    159    2.132   0      0.000    2.132</span><br></pre></td></tr></table></figure><p>96</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   32768.0  0.0   32768.0 196608.0   0.0     229376.0   107380.4  35196.0 33493.9 4732.0 4333.3    166    2.199   0      0.000    2.199</span><br></pre></td></tr></table></figure><p><strong>2、 示例代码 -2</strong></p><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 启动程序，模拟用户请求</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 每100毫秒钟创建1000线程，每个线程创建一个512kb的对象，最多100毫秒内同时存在1000线程，并发量1000/s，吞吐量6000/s，查看GC的情况</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class PerformanceApplication &#123;</span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure><p>6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(PerformanceApplication.class, args);</span><br></pre></td></tr></table></figure><p>7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -&gt; &#123;</span><br></pre></td></tr></table></figure><p>8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br></pre></td></tr></table></figure><p>9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br></pre></td></tr></table></figure><p>11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  不干活，专门512kb的小对象</span><br></pre></td></tr></table></figure><p>12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] temp = new byte[1024 * 512];</span><br></pre></td></tr></table></figure><p>13</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(new Random().nextInt(100)); // 随机睡眠200毫秒秒以内</span><br></pre></td></tr></table></figure><p>14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (InterruptedException e) &#123;</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure><p>16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>17</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>18</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>19</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;, 100, 100, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>23</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 打包 mvn clean package</span><br></pre></td></tr></table></figure><p>24</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 服务器上运行 performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 对象存活时间短，处理量大，属于响应时间优先</span><br></pre></td></tr></table></figure><p><strong>2.1</strong>  <strong>GC调优</strong></p><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 实时监控：jstat -gc -h10 $(jcmd | grep &quot;performance-1.1.0.jar&quot; | awk &#x27;&#123;print $1&#125;&#x27;) 1000</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Parallel GC  服务器默认  java -Xmx1024m -Xloggc:/netease/gc6.log -jar performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseAdaptiveSizePolicy自适应默认开启，所以Eden区会自动变化大小</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37376.0 37888.0 34817.1  0.0   272384.0 92500.6   125952.0   57532.9   35120.0 33541.2 4656.0 4335.4    286    2.698   7      0.360    3.059</span><br></pre></td></tr></table></figure><p>6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">36864.0 36864.0 32289.0  0.0   275456.0   0.0     125952.0   87877.8   35120.0 33541.2 4656.0 4335.4    300    2.812   7      0.360    3.173</span><br></pre></td></tr></table></figure><p>7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35328.0 35840.0 31777.0  0.0   276480.0   0.0     128000.0   61118.4   35120.0 33542.5 4656.0 4335.4    314    2.924   8      0.404    3.328</span><br></pre></td></tr></table></figure><p>8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34816.0 34816.0 31297.0  0.0   279552.0 139082.4  128000.0   102215.6  35120.0 33555.8 4656.0 4335.4    328    3.029   8      0.404    3.433</span><br></pre></td></tr></table></figure><p>9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33792.0 33792.0 30752.9  0.0   281600.0 181082.7  130048.0   68303.1   35120.0 33555.8 4656.0 4335.4    342    3.138   9      0.448    3.586</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33280.0 33280.0  0.0   29728.9 282624.0 132715.1  130048.0   122168.7  35120.0 33555.8 4656.0 4335.4    357    3.254   9      0.448    3.701</span><br></pre></td></tr></table></figure><p>11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33280.0 33280.0 25152.8  0.0   282624.0 78765.8   132608.0   98078.6   35120.0 33556.9 4656.0 4335.4    372    3.361  10      0.490    3.851</span><br></pre></td></tr></table></figure><p>12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31232.0 27136.0  0.0   26688.8 285696.0 136307.1  136704.0   76004.6   35120.0 33558.1 4656.0 4335.4    387    3.479  11      0.542    4.021</span><br></pre></td></tr></table></figure><p>13</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31744.0 31232.0 26656.8  0.0   286208.0   0.0     138752.0   49337.7   35120.0 33558.1 4656.0 4335.4    402    3.595  12      0.585    4.180</span><br></pre></td></tr></table></figure><p>14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29184.0 29184.0 25152.8  0.0   289792.0   0.0     138752.0   112435.6  35120.0 33558.1 4656.0 4335.4    418    3.716  12      0.585    4.301</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认情况，实时监控结果：10秒内132次YGC，5次FullGC，单词YGC耗时0.008s，总耗时1.242秒</span><br></pre></td></tr></table></figure><p>16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>17</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、 调大-XX:ParallelGCThreads=4  java -Xmx1024m -Xloggc:/netease/gc7.log -XX:ParallelGCThreads=4  -jar performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>18</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>19</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47616.0 48128.0 43073.3  0.0   252416.0 227997.7  130560.0   122261.9  35120.0 33506.0 4656.0 4334.8    197    2.479   6      0.359    2.838</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47104.0 47104.0 43105.3  0.0   254976.0 153173.5  116736.0   67205.9   35120.0 33506.0 4656.0 4334.8    208    2.629   7      0.405    3.034</span><br></pre></td></tr></table></figure><p>21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">46080.0 46080.0 44097.3 42529.3 257024.0   0.0     116736.0   86822.5   35120.0 33506.0 4656.0 4334.8   221    2.767   7      0.405    3.172</span><br></pre></td></tr></table></figure><p>22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45568.0 45568.0  0.0   42049.3 258048.0 129250.1  116736.0   104391.0  35120.0 33506.0 4656.0 4334.8    233    2.933   7      0.405    3.338</span><br></pre></td></tr></table></figure><p>23</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44544.0 44544.0  0.0   43041.3 260096.0 27359.1   120320.0   68802.0   35120.0 33506.0 4656.0 4334.8    245    3.111   8      0.463    3.574</span><br></pre></td></tr></table></figure><p>24</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44544.0 44544.0 39937.2  0.0   260096.0 51577.7   120320.0   97642.8   35120.0 33506.0 4656.0 4334.8    258    3.283   8      0.463    3.746</span><br></pre></td></tr></table></figure><p>25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44544.0 36864.0  0.0   36353.1 261120.0  7862.2   121856.0   68276.2   35120.0 33506.0 4656.0 4334.8    271    3.439   9      0.508    3.947</span><br></pre></td></tr></table></figure><p>26</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42496.0 42496.0  0.0   37441.1 263680.0   0.0     121856.0   106301.3  35120.0 33506.0 4656.0 4334.8    285    3.654   9      0.508    4.162</span><br></pre></td></tr></table></figure><p>27</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40960.0 41472.0 37889.2  0.0   265216.0   0.0     122880.0   85228.3   35120.0 33506.0 4656.0 4334.8    298    3.834  10      0.551    4.385</span><br></pre></td></tr></table></figure><p>28</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41472.0 41472.0 37441.1  0.0   266240.0   0.0     123904.0   57506.1   35120.0 33515.1 4656.0 4334.8    312    4.010  11      0.595    4.605</span><br></pre></td></tr></table></figure><p>29</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：10秒内115次GC，5次fullGC，总耗时1.767，单次YGC时间0.014s 多线程，也不管用</span><br></pre></td></tr></table></figure><p>30</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>31</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、 降低耗时，设置-XX:MaxGCPauseMills=5   java -Xmx1024m -Xloggc:/netease/gc8.log -XX:MaxGCPauseMillis=5  -jar performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>32</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>33</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11264.0 12800.0  0.0    0.0   50688.0    0.0     48128.0    28445.5   35200.0 33483.7 4736.0 4334.6     22    0.136   3      0.184    0.320</span><br></pre></td></tr></table></figure><p>34</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26624.0 25088.0  0.0   18496.6 44032.0  11192.5   48128.0    32045.6   35200.0 33483.7 4736.0 4334.6     29    0.165   3      0.184    0.349</span><br></pre></td></tr></table></figure><p>35</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33792.0 34304.0 21504.7  0.0   39424.0  11034.2   48128.0    36789.8   35200.0 33483.7 4736.0 4334.6     40    0.218   3      0.184    0.401</span><br></pre></td></tr></table></figure><p>36</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34304.0 34816.0 27712.8  0.0   37888.0    0.0     64512.0    44331.6   35200.0 33483.9 4736.0 4334.6     54    0.296   5      0.266    0.561</span><br></pre></td></tr></table></figure><p>37</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32768.0 26624.0  0.0    0.0   37888.0    0.0     76288.0    49968.7   35200.0 33483.9 4736.0 4334.6     69    0.385   9      0.429    0.815</span><br></pre></td></tr></table></figure><p>38</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47616.0 48640.0 39489.2  0.0   28672.0    0.0     84992.0    54068.5   35200.0 33483.9 4736.0 4334.6     92    0.543  11      0.513    1.056</span><br></pre></td></tr></table></figure><p>39</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">57856.0 57856.0  0.0   19968.6 20480.0   9283.9   100352.0   59194.0   35200.0 33484.9 4736.0 4334.6    123    0.764  15      0.682    1.446</span><br></pre></td></tr></table></figure><p>40</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35840.0 36864.0 13312.4  0.0   13824.0    0.0     115200.0   88901.4   35200.0 33487.8 4736.0 4335.7    172    1.076  26      1.113    2.188</span><br></pre></td></tr></table></figure><p>41</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24576.0 17408.0  0.0   16896.5  9216.0    0.0     99840.0    82761.6   35200.0 33488.2 4736.0 4335.7    227    1.363  40      1.757    3.121</span><br></pre></td></tr></table></figure><p>42</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14848.0 14848.0 9216.3  0.0    6144.0    0.0     95744.0    84799.3   35200.0 33488.5 4736.0 4335.7    310    1.657  55      2.399    4.056</span><br></pre></td></tr></table></figure><p>43</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：结果不太好，不合适。</span><br></pre></td></tr></table></figure><p>44</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>45</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># CMS</span><br></pre></td></tr></table></figure><p>46</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3、 改用CMS回收器  java -Xmx1024m -Xloggc:/netease/gc9.log -XX:+UseConcMarkSweepGC  -jar performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>47</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>48</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2048.0 2048.0 1536.0  0.0   16384.0    0.0     848412.0   836821.7  35220.0 33468.3 4756.0 4331.8    116    0.804   7      0.037    0.841</span><br></pre></td></tr></table></figure><p>49</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0 16901.3  0.0   136320.0 91188.6   878208.0   75373.9   35220.0 33468.5 4756.0 4331.8    122    0.859   8      0.114    0.973</span><br></pre></td></tr></table></figure><p>50</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0  0.0   16901.3 136320.0 90524.2   878208.0   154741.3  35220.0 33468.5 4756.0 4331.8    127    0.900   8      0.114    1.015</span><br></pre></td></tr></table></figure><p>51</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0  0.0   16901.3 136320.0 67869.0   878208.0   279165.8  35220.0 33468.5 4756.0 4331.8    133    0.953   8      0.114    1.068</span><br></pre></td></tr></table></figure><p>52</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0 16898.9  0.0   136320.0 29055.4   878208.0   462985.0  35220.0 33469.5 4756.0 4331.8    140    1.020   8      0.114    1.134</span><br></pre></td></tr></table></figure><p>53</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0  0.0   16898.9 136320.0 32667.9   878208.0   681621.7  35220.0 33472.4 4756.0 4332.9    147    1.089   8      0.114    1.204</span><br></pre></td></tr></table></figure><p>54</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0  0.0   16902.3 136320.0 27188.4   878208.0   294018.9  35220.0 33472.8 4756.0 4332.9    155    1.174  10      0.128    1.302</span><br></pre></td></tr></table></figure><p>55</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0 16900.9  0.0   136320.0   0.0     878208.0   607890.7  35220.0 33473.4 4756.0 4332.9    164    1.266  10      0.128    1.394</span><br></pre></td></tr></table></figure><p>56</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0  0.0   16898.9 136320.0 80996.3   878208.0   225418.4  35220.0 33475.7 4756.0 4332.9    173    1.358  12      0.140    1.499</span><br></pre></td></tr></table></figure><p>57</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17024.0 17024.0 16898.9  0.0   136320.0   0.0     878208.0   607899.4  35220.0 33475.7 4756.0 4332.9    184    1.470  12      0.140    1.611</span><br></pre></td></tr></table></figure><p>58</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：高频回收，会抢占用户线程，根据实际需要进行调优</span><br></pre></td></tr></table></figure><p>59</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>60</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># G1 建议大堆使用</span><br></pre></td></tr></table></figure><p>61</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4、 改用G1 java -Xmx1024m -Xloggc:/netease/gc10.log  -XX:+UseG1GC -jar performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>62</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>63</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   8192.0   993280.0   592928.3  35200.0 33534.8 4736.0 4331.4    272    3.725   0      0.000    3.725</span><br></pre></td></tr></table></figure><p>64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   8192.0   993280.0   597028.5  35200.0 33534.8 4736.0 4331.4    284    3.988   0      0.000    3.988</span><br></pre></td></tr></table></figure><p>65</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   7168.0   993280.0   490485.7  35200.0 33535.9 4736.0 4331.4    295    4.299   0      0.000    4.299</span><br></pre></td></tr></table></figure><p>66</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   8192.0   993280.0   603137.7  35200.0 33537.1 4736.0 4331.4    308    4.568   0      0.000    4.568</span><br></pre></td></tr></table></figure><p>67</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   641024.0 22528.0   407552.0   392447.4  35200.0 33537.1 4736.0 4331.4    319    4.869   0      0.000    4.869</span><br></pre></td></tr></table></figure><p>68</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   2048.0   993280.0   316671.2  35200.0 33537.1 4736.0 4331.4    330    5.151   0      0.000    5.151</span><br></pre></td></tr></table></figure><p>69</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   7168.0   993280.0   614372.8  35200.0 33537.1 4736.0 4331.4    342    5.408   0      0.000    5.408</span><br></pre></td></tr></table></figure><p>70</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   449536.0 44032.0   599040.0   598790.9  35200.0 33537.1 4736.0 4331.4    355    5.715   0      0.000    5.715</span><br></pre></td></tr></table></figure><p>71</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   1024.0   993280.0   299773.5  35200.0 33537.1 4736.0 4331.4    367    6.045   0      0.000    6.045</span><br></pre></td></tr></table></figure><p>72</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0    0.0    0.0    0.0   55296.0   7168.0   993280.0   625419.5  35200.0 33537.1 4736.0 4331.4    380    6.335   0      0.000    6.335</span><br></pre></td></tr></table></figure><p>73</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时监控结果：难看的数据</span><br></pre></td></tr></table></figure><p>74</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5、增加分区大小 java -Xmx1024m -Xloggc:/netease/gc11.log  -XX:+UseG1GC -XX:G1HeapRegionSize=64m -jar performance-1.1.0.jar</span><br></pre></td></tr></table></figure><p>75</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></pre></td></tr></table></figure><p>76</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 262144.0  229376.0   43625.6   35196.0 33417.9 4732.0 4335.1     84    0.899   0      0.000    0.899</span><br></pre></td></tr></table></figure><p>77</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 229376.0  229376.0   44153.1   35196.0 33417.9 4732.0 4335.1     89    0.944   0      0.000    0.944</span><br></pre></td></tr></table></figure><p>78</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0   0.0     229376.0   43658.6   35196.0 33417.9 4732.0 4335.1     95    1.001   0      0.000    1.001</span><br></pre></td></tr></table></figure><p>79</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 196608.0  229376.0   43673.1   35196.0 33417.9 4732.0 4335.1    100    1.047   0      0.000    1.047</span><br></pre></td></tr></table></figure><p>80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 131072.0  229376.0   43690.6   35196.0 33417.9 4732.0 4335.1    106    1.113   0      0.000    1.113</span><br></pre></td></tr></table></figure><p>81</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 196608.0  229376.0   43705.6   35196.0 33417.9 4732.0 4335.1    112    1.181   0      0.000    1.181</span><br></pre></td></tr></table></figure><p>82</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 98304.0   229376.0   44236.6   35196.0 33418.6 4732.0 4335.1    119    1.271   0      0.000    1.271</span><br></pre></td></tr></table></figure><p>83</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 131072.0  229376.0   43743.6   35196.0 33419.1 4732.0 4335.1    126    1.360   0      0.000    1.360</span><br></pre></td></tr></table></figure><p>84</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 327680.0 196608.0  229376.0   44274.6   35196.0 33419.8 4732.0 4335.1    133    1.461   0      0.000    1.461</span><br></pre></td></tr></table></figure><p>85</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0   65536.0  0.0   65536.0 393216.0 196608.0  262144.0   43781.6   35196.0 33419.8 4732.0 4335.1    140    1.546   0      0.000    1.546</span><br></pre></td></tr></table></figure><p>**<br>**</p><p><strong>3、 结语</strong></p><p>主要是演示切换的过程和思路，实际还是要结合系统情况、系统需要来调整。</p><p>1、 GC调优就是逐步调试的过程，对每个参数的含义了解后，再根据官方手册，一个个调试，找到符合应用的最佳配置点。是一个细致活，难度高。</p><p>2、 再重复一句，性能问题，98.75%上是业务代码上面。</p><p>3、 无监控，不调优。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;**测试环境：*&lt;em&gt;JVM配置为*&lt;em&gt;2核1G，JAVA8，固定设置堆大小 1G&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git常见操作总结</title>
    <link href="http://example.com/2022/03/21/Git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/21/Git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-21T07:09:36.000Z</published>
    <updated>2022-03-31T12:58:56.059Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220321162417377.png" alt="image-20220321162417377"></p><p>首先是简单的操作：</p><ul><li><p>git init - 初始化仓库。</p></li><li><p>git add . - 添加文件到暂存区。</p></li><li><p>git commit - 将暂存区内容添加到仓库中。</p></li><li><p>git clone -拷贝一份远程仓库，也就是下载一个项目。</p></li><li><p>git  rm   删除工作区文件。</p></li><li><p>git  commit    提交暂存区到本地仓库。</p></li><li><p>git diff     比较文件的不同，即暂存区和工作区的差异。</p></li><li><p>git status    查看仓库当前的状态，显示有变更的文件。</p></li><li><p>git  mv  移动或重命名工作区文件。</p></li><li><p>git reset – hard HEAD^   回退到当前版本之前提交的版本（一个^相当于往前一个版本）。</p></li><li><p>git reset –hard  （部分）版本号    回退到任意一个之前提交的版本</p></li><li><p>git checkout – &lt;文件路径&gt;  回退到上一个版本提交的状态（此时是没有提交的状态，相当于Ctrl + z）</p></li><li><p>git  reset HEAD  &lt;文件路径文件名&gt;  将文件撤销追踪 ，撤出暂存区。</p></li><li><p>git log -查看提交本地仓库的记录日志</p></li><li><p>git tag -创建标签 格式：git tag &lt;标签名&gt;</p><p>标签默认加到最新的一次提交上。</p><p>git tag &lt;标签名&gt;  &lt;某一次commit的ID&gt;  ：给某一次的commit添加标签</p><p>git tag -d &lt;标签名&gt; : 标签名</p></li></ul><p>远程操作：</p><ul><li><p>git remote ：远程仓库操作</p></li><li><p>git fetch  ：从远程获取代码库</p></li><li><p>git push ：本地仓库文件推送到远程仓库</p><p>例如：git push origin master</p></li><li><p>git pull：拉取远程仓库到本地。</p></li></ul><p>分支</p><ul><li><p>git branch &lt;分支名&gt; -创建分支</p><p>git branch -查看所有分支</p><p>git checkout &lt;分支名字&gt; -切换分支</p><p>git branch -d &lt;分支名称&gt;   -删除分支，注意的是不能删除当前分支。并且分支有commit操作的时候也不能删除（必须经过合并）</p><p>git branch -D &lt;分支名称&gt;  强制删除某一分支</p><p>git checkout -b &lt;分支名称&gt;  -直接创建一个新的分支并且跳转。</p></li><li><p>git merge &lt;合并的分支名&gt; </p></li></ul><p>合并冲突：</p><ul><li>git merge -abort  ：忽略其他分支，保留现在分支代码（解决合并冲突）</li></ul><p>创建 远程仓库</p><p><a href="https://www.runoob.com/git/git-remote-repo.html">GIT教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们先来理解下 Git 工作区、暂存区和版本库概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作区：&lt;/strong&gt;就是你在电脑里能看到的目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂存区：&lt;/strong&gt;英文叫 stage 或 index。一般存放在 &lt;strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/21/vim/"/>
    <id>http://example.com/2022/03/21/vim/</id>
    <published>2022-03-21T06:07:52.732Z</published>
    <updated>2022-03-21T06:07:53.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>正常模式下：</p><p>（）：移动到上一句下一句</p><p>{}：移动到上一段下一段</p><p>H/J/K/L：左上下右移动光标</p><p>gg：移动到开头行第一个字符</p><p>G：移动到文本结尾行第一个字符</p><p>命令模式下：</p><p>:0   :跳转到行首</p><p>:$   :跳转到行尾</p><p>如果444你只关心当前屏幕的话，可以快速移动光标到屏幕的顶部、中间和底部：用 H（High）、</p><p>M（Middle）和 L（Low）就可以做到。</p><h3 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h3><p>熟练掌握这些按键 </p><p>正常模式下</p><p><strong>d 加动作来进行删除</strong>（dd 删除整行）；D 则相当于 d$，删除到行尾。 </p><p><strong>c 加动作来进行修改</strong>（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模</p><p>式。</p><p><strong>s</strong>     相当于 cl，删除一个字符然后进入插入模式；</p><p><strong>S</strong>     相当于 cc，替换整行的内容。</p><p>i     在<strong>当前字符前面</strong>进入插入模式；</p><p>I     则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。</p><p>a     在<strong>当前字符后面</strong>进入插入模式；</p><p>A     相当于 $a，把光标移到行尾然后进入插入模式。</p><p>o     在当前行下方插入一个新行，然后在这行进入插入模式；</p><p>O     在当前行上方插入一个新行，然后在这行进入插入模式。</p><p>r     替换光标下的字符；</p><p>R     则进入替换模式，每次按键（直到 <Esc>）替换一个字符。</p><p>u     撤销最近的一个修改动作；</p><p>U     撤销当前行上的所有修改。</p><p><strong>文本对象选择</strong></p><p> 还有几个动作只能在 c、d、v 这样命令之后用，我们也需要学习一下。</p><p>这些选择动作的基本附加键是 a 和 i。其中，a 可以简单理解为英文单词 a，表示选定后</p><p>续动作要求的完整内容，而 i 可理解为英文单词 inner，代表后续动作要求的内容的“内</p><p>部”。 我们来看一下具体的例子。</p><p>假设有下面的文本内容：</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>;     重复最近的字符查找（f、t 等）操作</p><p>,     重复最近的字符查找操作，反方向</p><p>n     重复最近的字符串查找操作（/ 和 ?） </p><p>N     重复最近的字符串查找操作（/ 和 ?），反方向</p><p>.     重复执行最近的修改操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h1&gt;&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux概念和常见命令</title>
    <link href="http://example.com/2022/03/20/Linux%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/20/Linux%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-20T09:47:07.000Z</published>
    <updated>2022-03-31T13:09:40.926Z</updated>
    
    <content type="html"><![CDATA[<p>统一Linunx 规范：</p><p>FHS 规范，规定了目录以及子目录的内容和功能。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220320194341172.png" alt="image-20220320194341172"></p><p>可分享：可以分享给网络上其他主机使用的</p><p>可变：可以根据用户要求进行更改。</p><p>常用快捷键</p><p>ctrl + u ：</p><p>Ctrl +L ：清理屏幕</p><p>ctrl +D ：关闭终端</p><p>ctrl + A :光标跳转一行的开头</p><p>ctrl + E ：光标跳转到一行的结尾</p><p>ctrl + R ：查找使用过的命令</p><p>“#” 表示超级用户</p><p>“$”  表示普通用户</p><p>查询当前用户： whoami </p><p>长参数和短参数</p><p>短参数加在命令的后面，中间用空格隔开，前面添加   ‘ - ‘</p><p>长参数是是较长的参数，加在命令后面，使用两个 -  隔开</p><p>参数可以多个组合。</p><p>Linux中的文件</p><p>linux中一切可以理解成文件。</p><p>目录结构</p><p>1、find查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line"></span><br><span class="line">与时间有关的参数：</span><br><span class="line">-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；</span><br><span class="line">-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；</span><br><span class="line">-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</span><br><span class="line">-newer file : 列出比file还要新的文件名</span><br><span class="line"># 例如：</span><br><span class="line">find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件</span><br><span class="line"></span><br><span class="line"># 与用户或用户组名有关的参数：</span><br><span class="line">-user name : 列出文件所有者为name的文件</span><br><span class="line">-group name : 列出文件所属用户组为name的文件</span><br><span class="line">-uid n : 列出文件所有者为用户ID为n的文件</span><br><span class="line">-gid n : 列出文件所属用户组为用户组ID为n的文件</span><br><span class="line"># 例如：</span><br><span class="line">find /home/hadoop -user hadoop # 在目录/home/hadoop中找出所有者为hadoop的文件</span><br><span class="line"></span><br><span class="line"># 与文件权限及名称有关的参数：</span><br><span class="line">-name filename ：找出文件名为filename的文件</span><br><span class="line">-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件</span><br><span class="line">-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、</span><br><span class="line">             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；</span><br><span class="line">-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；</span><br><span class="line">-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示</span><br><span class="line">-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示</span><br><span class="line"># 例如：</span><br><span class="line">find / -name passwd # 查找文件名为passwd的文件</span><br><span class="line">find . -perm 0755 # 查找当前目录中文件权限的0755的文件</span><br><span class="line">find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</span><br></pre></td></tr></table></figure><ol start="2"><li>ls 命令，展示文件夹内内容。常见的参数有：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ </span><br><span class="line">-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的档案数据 </span><br><span class="line">-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) </span><br><span class="line">-F ：根据档案、目录等信息，给予附加数据结构，例如： </span><br><span class="line">*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； </span><br><span class="line">-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； </span><br><span class="line">-i ：列出 inode 位置，而非列出档案属性； </span><br><span class="line">-l ：长数据串行出，包含档案的属性等等数据； </span><br><span class="line">-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) </span><br><span class="line">-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； </span><br><span class="line">-R ：连同子目录内容一起列出来； </span><br><span class="line">-S ：以档案容量大小排序！ </span><br><span class="line">-t ：依时间排序 </span><br><span class="line">颜色：蓝色表示目录</span><br><span class="line">绿色表示可执行文件</span><br><span class="line">灰色表示压缩文件</span><br><span class="line">浅蓝色表示链接文件</span><br><span class="line">红色表示其他文件</span><br><span class="line">可以使用 ls --color=none来关闭颜色提示</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ol start="3"><li>cd 命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /root/Docements # 切换到目录/root/Docements</span><br><span class="line">cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  </span><br><span class="line">cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</span><br></pre></td></tr></table></figure><ol start="4"><li>tree命令，显示树形的层级目录结构，非原生命令，需要安装tree</li></ol><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160505224228810-901250058.png" alt="img"></p><ol start="5"><li><p>cp 命令 复制的作用，参数如下：</p><p>cp  源文件路径   目标路径 </p><p>注：第一个文件是已经存在的文件，业就是被拷贝的文件</p><p>​        目标路径也可以是目录下的一个文件，即需要创建的文件，是一个副本。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为</span><br><span class="line">-u ：目标文件与源文件有差异时才会复制</span><br></pre></td></tr></table></figure><ol start="6"><li>rm命令作用为删除，参数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作</span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br></pre></td></tr></table></figure><ol start="7"><li><p>mv命令作用为移动文件：</p><p>和cp类似，但是不会创建副本，也可以<strong>使用通配符</strong>。</p><p>还可以用来更改名字</p><p>mv old_name  new_name</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新</span><br></pre></td></tr></table></figure><ol start="8"><li>pwd命令，作用为查看”当前工作目录“的完整路径</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</span><br></pre></td></tr></table></figure><ol start="9"><li>tar命令，用于压缩解压：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c ：新建打包文件</span><br><span class="line">-t ：查看打包文件的内容含有哪些文件名</span><br><span class="line">-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span><br><span class="line">-j ：通过bzip2的支持进行压缩/解压缩</span><br><span class="line">-z ：通过gzip的支持进行压缩/解压缩</span><br><span class="line">-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</span><br><span class="line">-f filename ：filename为要处理的文件</span><br><span class="line">-C dir ：指定压缩/解压缩的目录dir</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称</span><br><span class="line">查询：tar -jtv -f filename.tar.bz2</span><br><span class="line">解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</span><br></pre></td></tr></table></figure><ol start="10"><li>mkdir命令 创建目录：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项]... 目录...  -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod) </span><br><span class="line"></span><br><span class="line"> -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即递归创建目录; </span><br><span class="line"> -v, --verbose  每次创建新目录都显示信息</span><br></pre></td></tr></table></figure><ol start="11"><li>rmdir 命令删除目录：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmdir [选项]... 目录...</span><br><span class="line">-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 </span><br><span class="line">-v --verbose  显示指令执行过程 </span><br></pre></td></tr></table></figure><ol start="12"><li>gzip 命令压缩文件或文件夹为 .gz文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> gzip[参数][文件或者目录]</span><br><span class="line">-a or --ascii 　使用ASCII文字模式。 </span><br><span class="line">-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </span><br><span class="line">-d or --decompress or ----uncompress 　解开压缩文件。 </span><br><span class="line">-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 </span><br><span class="line">-h or --help 　在线帮助。 </span><br><span class="line">-l or --list 　列出压缩文件的相关信息。 </span><br><span class="line">-L or --license 　显示版本与版权信息。 </span><br><span class="line">-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 </span><br><span class="line">-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 </span><br><span class="line">-q or --quiet 　不显示警告信息。 </span><br><span class="line">-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </span><br><span class="line">-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </span><br><span class="line">-t or --test 　测试压缩文件是否正确无误。 </span><br><span class="line">-v or --verbose 　显示指令执行过程。 </span><br><span class="line">-V or --version 　显示版本信息。 </span><br><span class="line">-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。</span><br></pre></td></tr></table></figure><p><strong>二. 进程相关命令：</strong></p><p>\13.  ps 命令显示运行的进程，还会显示进程的一些信息如pid, cpu和内存使用情况等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-A ：所有的进程均显示出来</span><br><span class="line">-a ：不与terminal有关的所有进程</span><br><span class="line">-u ：有效用户的相关进程</span><br><span class="line">-x ：一般与a参数一起使用，可列出较完整的信息</span><br><span class="line">-l ：较长，较详细地将PID的信息列出</span><br></pre></td></tr></table></figure><p> 使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160505224418591-275764025.png" alt="img"></p><p>\14. kill 命令用于终止进程，参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kill -signal PID</span><br><span class="line"></span><br><span class="line">1：SIGHUP，启动被终止的进程</span><br><span class="line">2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</span><br><span class="line">9：SIGKILL，强制中断一个进程的进行</span><br><span class="line">15：SIGTERM，以正常的结束进程方式来终止进程</span><br><span class="line">17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</span><br></pre></td></tr></table></figure><p>\15. killall 命令和参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">killall [-iIe] [command name]</span><br><span class="line"></span><br><span class="line">-i ：交互式的意思，若需要删除时，会询问用户</span><br><span class="line">-e ：表示后面接的command name要一致，但command name不能超过15个字符</span><br><span class="line">-I ：命令名称忽略大小写</span><br><span class="line"># 例如：</span><br><span class="line">killall -SIGHUP syslogd # 重新启动syslogd</span><br></pre></td></tr></table></figure><p>\16. crontab命令是启动linux定时任务的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service cron start # 启动cronjob</span><br><span class="line">service cron stop # 停止cronjob</span><br><span class="line">service cron restart #  重启cronjob</span><br><span class="line">crontab -e # 编辑cronjob任务</span><br></pre></td></tr></table></figure><p>\17.  free 命令用于显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">free [参数]</span><br><span class="line">-b 　以Byte为单位显示内存使用情况。 </span><br><span class="line">-k 　以KB为单位显示内存使用情况。 </span><br><span class="line">-m 　以MB为单位显示内存使用情况。</span><br><span class="line">-g   以GB为单位显示内存使用情况。 </span><br><span class="line">-o 　不显示缓冲区调节列。 </span><br><span class="line">-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 </span><br><span class="line">-t 　显示内存总和列。 </span><br><span class="line">-V 　显示版本信息。</span><br></pre></td></tr></table></figure><p>\18. top 命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top [参数]</span><br><span class="line">-b 批处理</span><br><span class="line">-c 显示完整的治命令</span><br><span class="line">-I 忽略失效过程</span><br><span class="line">-s 保密模式</span><br><span class="line">-S 累积模式</span><br><span class="line">-i&lt;时间&gt; 设置间隔时间</span><br><span class="line">-u&lt;用户名&gt; 指定用户名</span><br><span class="line">-p&lt;进程号&gt; 指定进程</span><br><span class="line">-n&lt;次数&gt; 循环显示的次数</span><br></pre></td></tr></table></figure><p><strong>三. 权限相关命令：</strong></p><p>\19. chmod命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br><span class="line">-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</span><br><span class="line">#同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改，编号是各种权限的数字代码，示例：</span><br><span class="line">chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x</span><br><span class="line">chmod g+w file # 向file的文件权限中加入用户组可写权限</span><br></pre></td></tr></table></figure><p>chmod不需要是root用户才能使用，只要是文件的所有者即可。</p><p>可以使用数字来为文件分配权限。</p><p>为每种操作分配了相应的数字值。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220322165627576.png" alt="image-20220322165627576"></p><p>所有权限组合：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220322165723428.png"></p><p>也可以使用字母来文件权限</p><p>\20. chown命令改变文件所有者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [para]... [owner][:[group]] file...</span><br></pre></td></tr></table></figure><p> -c 显示更改的部分的信息</p><p>　-f 忽略错误信息</p><p>　-h 修复符号链接</p><p>　-R 处理指定目录以及其子目录下的所有文件</p><p>　-v 显示详细的处理信息</p><p>　-deference 作用于符号链接的指向，而不是链接文件本身</p><p>\21. chgrp命令，改变文件所属组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c 当发生改变时输出调试信息</span><br><span class="line">-f 不显示错误信息</span><br><span class="line">-R 处理指定目录以及其子目录下的所有文件</span><br><span class="line">-v 运行时显示详细的处理信息</span><br><span class="line">--dereference 作用于符号链接的指向，而不是符号链接本身</span><br><span class="line">--no-dereference 作用于符号链接本身</span><br></pre></td></tr></table></figure><p>\22. useradd 命令建立用户账号：</p><p>可以创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号] </span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">    -c #&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　</span><br><span class="line">　　-d #&lt;登入目录&gt; 　指定用户登入时的启始目录。</span><br><span class="line">　　-D #　变更预设值．</span><br><span class="line">　　-e # &lt;有效期限&gt; 　指定帐号的有效期限。</span><br><span class="line">　　-f # &lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。</span><br><span class="line">　　-g # &lt;群组&gt; 　指定用户所属的群组。</span><br><span class="line">　　-G # &lt;群组&gt; 　指定用户所属的附加群组。</span><br><span class="line">　　-m # 自动建立用户的登入目录。</span><br><span class="line">　　-M # 不要自动建立用户的登入目录。</span><br><span class="line">　　-n # 取消建立以用户名称为名的群组．</span><br><span class="line">　　-r # 建立系统帐号。</span><br><span class="line">　　-s # 指定用户登入后所使用的shell。</span><br><span class="line">　　-u # 指定用户ID。</span><br></pre></td></tr></table></figure><p>\23. usermod 修改用户信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod -h</span><br><span class="line">usermod [options] LOGIN</span><br></pre></td></tr></table></figure><p> -c #后面接账号的说明，即/etc/passwd第五栏的说明栏，可以加入一些账号的说明<br> -d #后面接账号的家目录，即修改/etc/passwd的第六栏<br> -e #后面接日期，格式是YYYY-MM-DD也就是在/etc/shadow内的第八栏<br> -f #后面接天数，修改shadow的第七栏<br> -g #后面接主群组，修改/etc/passwd的第四个字段，即是GID的字段<br> <strong>-G</strong> #后面接附加群组，修改这个使用者能够支持的群组，修改的是/etc/group，可以修改多个用户<br> <strong>-a</strong> #与 -G 合用，可增加附加群组的支持而非设定，即不改变当前群组，追加另一个群组。<br> -l #后面接账号名称。修改账号名称，/etc/passwd的第一栏<br> -s #后面接Shell的文件，例如/bin/bash或/bin/csh等等<br> -u #后面接 UID 数字，修改用户的UID /etc/passwd第三栏<br> -L #暂时将用户的密码冻结，让他无法登入。其实就是在/etc/shadow的密码栏前面加上了“!”<br> -U #将/etc/shadow 密码栏的“!”去掉</p><p>\24. userdel 删除用户：</p><p>是 user和 delete的缩写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userdel [options] LOGIN</span><br><span class="line">-f # 强制删除，包括用户的一切相关内容，这个参数是危险的参数，不建议大家使用。详细说明看MAN</span><br><span class="line">-r # 删除用户的家目录和用户的邮件池</span><br></pre></td></tr></table></figure><p>\25. groupadd　命令用于将新组加入群组：</p><p>创建用户的时候如果没有设置创建，默认以用户名字新建一个群组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd [－g gid] [－o]] [－r] [－f] groupname</span><br><span class="line"></span><br><span class="line">－g gid：指定组ID号。</span><br><span class="line">－o：允许组ID号，不必惟一。</span><br><span class="line">－r：加入组ID号，低于499系统账号。</span><br><span class="line">－f：加入已经有的组时，发展程序退出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507160630437-2146888110.png" alt="img"></p><p>\26. groupdel　命令删除组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃　用于删除不再需要的组，如果指定的组中包含用户，则必须先删除组里面的用户&gt;以后，才能删除组</span><br><span class="line">groupdel [options] GROUP</span><br></pre></td></tr></table></figure><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507160852921-1183669033.png" alt="img"></p><p>\27. sudo 用来以其他身份来执行命令，预设的身份为root:</p><p>临时获取root的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo(选项)(参数)</span><br><span class="line"></span><br><span class="line">-b：在后台执行指令；</span><br><span class="line">-h：显示帮助；</span><br><span class="line">-H：将HOME环境变量设为新身份的HOME环境变量；</span><br><span class="line">-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。</span><br><span class="line">-l：列出目前用户可执行与无法执行的指令；</span><br><span class="line">-p：改变询问密码的提示符号；</span><br><span class="line">-s：执行指定的shell；</span><br><span class="line">-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；</span><br><span class="line">-v：延长密码有效期限5分钟；</span><br><span class="line">-V ：显示版本信息。</span><br></pre></td></tr></table></figure><p>\28. passwd 设置用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">passwd [OPTION...] &lt;accountName&gt;</span><br><span class="line">-k, --keep-tokens       keep non-expired authentication tokens</span><br><span class="line">-d, --delete            delete the password for the named account (root only)</span><br><span class="line">-l, --lock              lock the named account (root only)</span><br><span class="line">-u, --unlock            unlock the named account (root only)</span><br><span class="line">-f, --force             force operation</span><br><span class="line">-x, --maximum=DAYS      maximum password lifetime (root only)</span><br><span class="line">-n, --minimum=DAYS      minimum password lifetime (root only)</span><br><span class="line">-w, --warning=DAYS      number of days warning users receives before password expiration (root only)</span><br><span class="line">-i, --inactive=DAYS     number of days after password expiration when an account becomes disabled (root only)</span><br><span class="line">-S, --status            report password status on the named account (root)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160506224436591-1531781308.png" alt="img"></p><p>\29. groups 显示用户所属群组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groups # 默认显示当前用户的组</span><br><span class="line"></span><br><span class="line">groups hadoop2 # 显示hadoop2用户的组</span><br></pre></td></tr></table></figure><p><strong>四. 文本查看编辑等命令</strong></p><p>\30. vi/vim 是使用vi编辑器的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑</span><br></pre></td></tr></table></figure><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160506230148357-1610633511.png" alt="img"></p><p>vi的操作命令比较复杂，就不在这里详细展开了。</p><p>\31. cat　是concatenate的缩写 ，表示连接/串联</p><p>用途是连接文件或标准输入并打印。可以一次性的显示文件的所有内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> cat [选项] [文件]...</span><br><span class="line">-A, --show-all           等价于 -vET</span><br><span class="line">-b, --number-nonblank    对非空输出行编号</span><br><span class="line">-e                       等价于 -vE</span><br><span class="line">-E, --show-ends          在每行结束处显示 $</span><br><span class="line">-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号</span><br><span class="line">-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 </span><br><span class="line">-t                       与 -vT 等价</span><br><span class="line">-T, --show-tabs          将跳格字符显示为 ^I</span><br><span class="line">-u                       (被忽略)</span><br><span class="line">-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160504212825669-939030026.png" alt="img"></p><p>\32. more 命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以<strong>按页来查看文件</strong>的内容，还支持直接跳转行等功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] </span><br><span class="line">命令参数：</span><br><span class="line">+n 从笫n行开始显示</span><br><span class="line">-n 定义屏幕大小为n行</span><br><span class="line">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class="line">-c 从顶部清屏，然后显示</span><br><span class="line">-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-l 忽略Ctrl+l（换页）字符</span><br><span class="line">-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s 把连续的多个空行显示为一行</span><br><span class="line">-u 把文件内容中的下画线去掉</span><br><span class="line"></span><br><span class="line">常用快捷键：</span><br><span class="line">Enter 向下n行，需要定义。默认为1行</span><br><span class="line">Ctrl+F 向下滚动一屏</span><br><span class="line">空格键 向下滚动一屏</span><br><span class="line">Ctrl+B 返回上一屏</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">：f 输出文件名和当前行的行号</span><br><span class="line">V 调用vi编辑器</span><br><span class="line">!命令 调用Shell，并执行命令 </span><br><span class="line">q 退出more</span><br></pre></td></tr></table></figure><p>\33. less　命令用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> less [参数]  文件 </span><br><span class="line">-b &lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e 当文件显示结束后，自动离开</span><br><span class="line">-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g 只标志最后搜索的关键词</span><br><span class="line">-i 忽略搜索时的大小写</span><br><span class="line">-m 显示类似more命令的百分比</span><br><span class="line">-N 显示每行的行号</span><br><span class="line">-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q 不使用警告音</span><br><span class="line">-s 显示连续空行为一行</span><br><span class="line">-S 行过长时间将超出部分舍弃</span><br><span class="line">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">/字符串：向下搜索“字符串”的功能</span><br><span class="line">?字符串：向上搜索“字符串”的功能</span><br><span class="line">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b 向后翻一页</span><br><span class="line">d 向后翻半页</span><br><span class="line">h 显示帮助界面</span><br><span class="line">Q 退出less 命令</span><br><span class="line">u 向前滚动半页</span><br><span class="line">y 向前滚动一行</span><br><span class="line">空格键 滚动一行</span><br><span class="line">回车键 滚动一页</span><br><span class="line">[pagedown]： 向下翻动一页</span><br><span class="line">[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507155949515-2041094265.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507155954203-792380505.png" alt="img"></p><p>\34. tail 命令</p><p>从指定点开始将文件写到标准输出.</p><p>使用tail命令的-f选项可以方便的查阅正在改变的日志文件,</p><p>tail -f filename    会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  tail[必要参数][选择参数][文件]   </span><br><span class="line"></span><br><span class="line">-f 循环读取</span><br><span class="line">-q 不显示处理信息</span><br><span class="line">-v 显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示行数</span><br><span class="line">--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. </span><br><span class="line">-q, --quiet, --silent 从不输出给出文件名的首部 </span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507161540578-1725764142.png" alt="img"></p><p>\35. head 命令用于显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head [参数]... [文件]...  </span><br><span class="line">-q 隐藏文件名</span><br><span class="line">-v 显示文件名</span><br><span class="line">-c&lt;字节&gt; 显示字节数</span><br><span class="line">-n&lt;行数&gt; 显示的行数</span><br></pre></td></tr></table></figure><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507171401093-1165050949.png" alt="img"></p><p>\36. diff 命令用于比较两个文件或目录的不同：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> diff[参数][文件1或目录1][文件2或目录2]</span><br><span class="line"># diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的</span><br><span class="line"># 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</span><br><span class="line"></span><br><span class="line">-a or --text 　#diff预设只会逐行比较文本文件。</span><br><span class="line">-b or --ignore-space-change 　#不检查空格字符的不同。</span><br><span class="line">-B or --ignore-blank-lines 　#不检查空白行。</span><br><span class="line">-c 　#显示全部内文，并标出不同之处。</span><br><span class="line">-C or --context 　#与执行&quot;-c-&quot;指令相同。</span><br><span class="line">-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。</span><br><span class="line">-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。</span><br><span class="line">-e or --ed 　#此参数的输出格式可用于ed的script文件。</span><br><span class="line">-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span><br><span class="line">-H or --speed-large-files 　#比较大文件时，可加快速度。</span><br><span class="line">-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。</span><br><span class="line">-i or --ignore-case 　#不检查大小写的不同。</span><br><span class="line">-l or --paginate 　#将结果交由pr程序来分页。</span><br><span class="line">-n or --rcs 　#将比较结果以RCS的格式来显示。</span><br><span class="line">-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span><br><span class="line">-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span><br><span class="line">-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span><br><span class="line">-q or --brief 　#仅显示有无差异，不显示详细的信息。</span><br><span class="line">-r or --recursive 　#比较子目录中的文件。</span><br><span class="line">-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。</span><br><span class="line">-S or --starting-file 　#在比较目录时，从指定的文件开始比较。</span><br><span class="line">-t or --expand-tabs 　#在输出时，将tab字符展开。</span><br><span class="line">-T or --initial-tab 　#在每行前面加上tab字符以便对齐。</span><br><span class="line">-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。</span><br><span class="line">-v or --version 　#显示版本信息。</span><br><span class="line">-w or --ignore-all-space 　#忽略全部的空格字符。</span><br><span class="line">-W or --width 　#在使用-y参数时，指定栏宽。</span><br><span class="line">-x or --exclude 　#不比较选项中所指定的文件 or 目录。</span><br><span class="line">-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。</span><br><span class="line">-y or --side-by-side 　#以并列的方式显示文件的异同之处。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160506231719044-1459869351.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160506231937419-1089214833.png" alt="img"></p><p><strong>网络相关命令：</strong></p><p>\37. ping 用于确定主机与外部连接状态：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br><span class="line">-d 使用Socket的SO_DEBUG功能。</span><br><span class="line">-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。</span><br><span class="line">-n 只输出数值。</span><br><span class="line">-q 不显示任何传送封包的信息，只显示最后的结果。</span><br><span class="line">-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</span><br><span class="line">-R 记录路由过程。</span><br><span class="line">-v 详细显示指令的执行过程。</span><br><span class="line">&lt;p&gt;-c 数目：在发送指定数目的包后停止。</span><br><span class="line">-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</span><br><span class="line">-I 网络界面：使用指定的网络界面送出数据包。</span><br><span class="line">-l 前置载入：设置在送出要求信息之前，先行发出的数据包。</span><br><span class="line">-p 范本样式：设置填满数据包的范本样式。</span><br><span class="line">-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</span><br><span class="line">-t 存活数值：设置存活数值TTL的大小。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160506233110654-1816209180.png" alt="img"></p><p>\38. ssh 命令用于远程登录上Linux主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br></pre></td></tr></table></figure><p>使用示例：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507161933859-275513198.png" alt="img"></p><p>\39. scp 命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">-1 强制scp命令使用协议ssh1 </span><br><span class="line">-2 强制scp命令使用协议ssh2 </span><br><span class="line">-4 强制scp命令只使用IPv4寻址 </span><br><span class="line">-6 强制scp命令只使用IPv6寻址 </span><br><span class="line">-B 使用批处理模式（传输过程中不询问传输口令或短语） </span><br><span class="line">-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） </span><br><span class="line">-p 保留原文件的修改时间，访问时间和访问权限。 </span><br><span class="line">-q 不显示传输进度条。 </span><br><span class="line">-r 递归复制整个目录。 </span><br><span class="line">-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 </span><br><span class="line">-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 </span><br><span class="line">-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 </span><br><span class="line">-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 </span><br><span class="line">-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 </span><br><span class="line">-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， </span><br><span class="line">-P port 注意是大写的P, port是指定数据传输用到的端口号 </span><br><span class="line">-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507162205062-1894875589.png" alt="img"></p><p>\40. telnet 命令用来远程登录操作：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> telnet[参数][主机]-8 允许使用8位字符资料，包括输入与输出。</span><br><span class="line">-a 尝试自动登入远端系统。</span><br><span class="line">-b&lt;主机别名&gt; 使用别名指定远端主机名称。</span><br><span class="line">-c 不读取用户专属目录里的.telnetrc文件。</span><br><span class="line">-d 启动排错模式。</span><br><span class="line">-e&lt;脱离字符&gt; 设置脱离字符。</span><br><span class="line">-E 滤除脱离字符。</span><br><span class="line">-f 此参数的效果和指定&quot;-F&quot;参数相同。</span><br><span class="line">-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</span><br><span class="line">-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</span><br><span class="line">-K 不自动登入远端主机。</span><br><span class="line">-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</span><br><span class="line">-L 允许输出8位字符资料。</span><br><span class="line">-n&lt;记录文件&gt; 指定文件记录相关信息。</span><br><span class="line">-r 使用类似rlogin指令的用户界面。</span><br><span class="line">-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</span><br><span class="line">-x 假设主机有支持数据加密的功能，就使用它。</span><br><span class="line">-X&lt;认证形态&gt; 关闭指定的认证形态。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507170054765-1719215967.png" alt="img"></p><p>\41. wget 是从远程下载的工具：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br><span class="line"></span><br><span class="line">启动参数：</span><br><span class="line">-V, –version 显示wget的版本后退出</span><br><span class="line">-h, –help 打印语法帮助</span><br><span class="line">-b, –background 启动后转入后台执行</span><br><span class="line">-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</span><br><span class="line"></span><br><span class="line">记录和输入文件参数：</span><br><span class="line">-o, –output-file=FILE 把记录写到FILE文件中</span><br><span class="line">-a, –append-output=FILE 把记录追加到FILE文件中</span><br><span class="line">-d, –debug 打印调试输出</span><br><span class="line">-q, –quiet 安静模式(没有输出)</span><br><span class="line">-v, –verbose 冗长模式(这是缺省设置)</span><br><span class="line">-nv, –non-verbose 关掉冗长模式，但不是安静模式</span><br><span class="line">-i, –input-file=FILE 下载在FILE文件中出现的URLs</span><br><span class="line">-F, –force-html 把输入文件当作HTML格式文件对待</span><br><span class="line">-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀</span><br><span class="line">–sslcertfile=FILE 可选客户端证书</span><br><span class="line">–sslcertkey=KEYFILE 可选客户端证书的KEYFILE</span><br><span class="line">–egd-file=FILE 指定EGD socket的文件名</span><br><span class="line"></span><br><span class="line">下载参数：</span><br><span class="line">–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)</span><br><span class="line">-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).</span><br><span class="line">-O –output-document=FILE 把文档写到FILE文件中</span><br><span class="line">-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀</span><br><span class="line">-c, –continue 接着下载没下载完的文件</span><br><span class="line">–progress=TYPE 设定进程条标记</span><br><span class="line">-N, –timestamping 不要重新下载文件除非比本地文件新</span><br><span class="line">-S, –server-response 打印服务器的回应</span><br><span class="line">–spider 不下载任何东西</span><br><span class="line">-T, –timeout=SECONDS 设定响应超时的秒数</span><br><span class="line">-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒</span><br><span class="line">–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒</span><br><span class="line">–random-wait 在下载之间等待0…2*WAIT秒</span><br><span class="line">-Y, –proxy=on/off 打开或关闭代理</span><br><span class="line">-Q, –quota=NUMBER 设置下载的容量限制</span><br><span class="line">–limit-rate=RATE 限定下载输率</span><br><span class="line"></span><br><span class="line">目录参数：</span><br><span class="line">-nd –no-directories 不创建目录</span><br><span class="line">-x, –force-directories 强制创建目录</span><br><span class="line">-nH, –no-host-directories 不创建主机目录</span><br><span class="line">-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…</span><br><span class="line">–cut-dirs=NUMBER 忽略 NUMBER层远程目录</span><br><span class="line"></span><br><span class="line">HTTP 选项参数：</span><br><span class="line">–http-user=USER 设定HTTP用户名为 USER.</span><br><span class="line">–http-passwd=PASS 设定http密码为 PASS</span><br><span class="line">-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)</span><br><span class="line">-E, –html-extension 将所有text/html文档以.html扩展名保存</span><br><span class="line">–ignore-length 忽略 `Content-Length’头域</span><br><span class="line">–header=STRING 在headers中插入字符串 STRING</span><br><span class="line">–proxy-user=USER 设定代理的用户名为 USER</span><br><span class="line">–proxy-passwd=PASS 设定代理的密码为 PASS</span><br><span class="line">–referer=URL 在HTTP请求中包含 `Referer: URL’头</span><br><span class="line">-s, –save-headers 保存HTTP头到文件</span><br><span class="line">-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION</span><br><span class="line">–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)</span><br><span class="line">–cookies=off 不使用 cookies</span><br><span class="line">–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie</span><br><span class="line">–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中</span><br><span class="line"></span><br><span class="line">FTP 选项参数：</span><br><span class="line">-nr, –dont-remove-listing 不移走 `.listing’文件</span><br><span class="line">-g, –glob=on/off 打开或关闭文件名的 globbing机制</span><br><span class="line">–passive-ftp 使用被动传输模式 (缺省值).</span><br><span class="line">–active-ftp 使用主动传输模式</span><br><span class="line">–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)</span><br><span class="line"></span><br><span class="line">递归下载参数：</span><br><span class="line">-r, –recursive 递归下载－－慎用!</span><br><span class="line">-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)</span><br><span class="line">–delete-after 在现在完毕后局部删除文件</span><br><span class="line">-k, –convert-links 转换非相对链接为相对链接</span><br><span class="line">-K, –backup-converted 在转换文件X之前，将之备份为 X.orig</span><br><span class="line">-m, –mirror 等价于 -r -N -l inf -nr</span><br><span class="line">-p, –page-requisites 下载显示HTML文件的所有图片</span><br><span class="line"></span><br><span class="line">递归下载中的包含和不包含(accept/reject)：</span><br><span class="line">-A, –accept=LIST 分号分隔的被接受扩展名的列表</span><br><span class="line">-R, –reject=LIST 分号分隔的不被接受的扩展名的列表</span><br><span class="line">-D, –domains=LIST 分号分隔的被接受域的列表</span><br><span class="line">–exclude-domains=LIST 分号分隔的不被接受的域的列表</span><br><span class="line">–follow-ftp 跟踪HTML文档中的FTP链接</span><br><span class="line">–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表</span><br><span class="line">-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表</span><br><span class="line">-H, –span-hosts 当递归时转到外部主机</span><br><span class="line">-L, –relative 仅仅跟踪相对链接</span><br><span class="line">-I, –include-directories=LIST 允许目录的列表</span><br><span class="line">-X, –exclude-directories=LIST 不被包含目录的列表</span><br><span class="line">-np, –no-parent 不要追溯到父目录</span><br><span class="line">wget -S –spider url 不下载只显示过程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160506232247638-1707921731.png" alt="img"></p><p>\42. ifconfig　命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> ifconfig [网络设备] [参数]</span><br><span class="line"></span><br><span class="line">up 启动指定网络设备/网卡。</span><br><span class="line">down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。</span><br><span class="line">arp 设置指定网卡是否支持ARP协议。</span><br><span class="line">-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</span><br><span class="line">-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</span><br><span class="line">-a 显示全部接口信息</span><br><span class="line">-s 显示摘要信息（类似于 netstat -i）</span><br><span class="line">add 给指定网卡配置IPv6地址</span><br><span class="line">del 删除指定网卡的IPv6地址</span><br><span class="line">&lt;硬件地址&gt; 配置网卡最大的传输单元</span><br><span class="line">mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)</span><br><span class="line">netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。</span><br><span class="line">tunel 建立隧道</span><br><span class="line">dstaddr 设定一个远端地址，建立点对点通信</span><br><span class="line">-broadcast&lt;地址&gt; 为指定网卡设置广播协议</span><br><span class="line">-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议</span><br><span class="line">multicast 为网卡设置组播标志</span><br><span class="line">address 为网卡设置IPv4地址</span><br><span class="line">txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507155647328-1087993873.png" alt="img"></p><p>\43. route</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] </span><br><span class="line">-c  # 显示更多信息</span><br><span class="line">-n  # 不解析名字</span><br><span class="line">-v  # 显示详细的处理信息</span><br><span class="line">-F  # 显示发送信息</span><br><span class="line">-C # 显示路由缓存</span><br><span class="line">-f  # 清除所有网关入口的路由表。 </span><br><span class="line">-p # 与 add 命令一起使用时使路由具有永久性。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507164049640-1243837423.png" alt="img"></p><p><strong>五. 搜索文件：</strong></p><p>\44. whereis 命令：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 </span><br><span class="line"></span><br><span class="line"> whereis [-bmsu] [BMS 目录名 -f ] 文件名</span><br></pre></td></tr></table></figure><p>　-b 定位可执行文件。<br>　-m 定位帮助文件。<br>　-s 定位源代码文件。<br>　-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。<br>　-B 指定搜索可执行文件的路径。<br>　-M 指定搜索帮助文件的路径。<br>　-S 指定搜索源代码文件的路径。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507154350125-1160038978.png" alt="img"></p><p>\45. locate　命令</p><p>搜索包含所有有关关键字的文件和目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃　locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)Locate [选择参数] [样式]</span><br><span class="line">-e   将排除在寻找的范围之外。</span><br><span class="line">-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</span><br><span class="line">-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</span><br><span class="line">-q  安静模式，不会显示任何错误讯息。</span><br><span class="line">-n 至多显示 n个输出。</span><br><span class="line">-r 使用正规运算式 做寻找的条件。</span><br><span class="line">-o 指定资料库存的名称。</span><br><span class="line">-d 指定资料库的路径</span><br><span class="line">-h 显示辅助讯息</span><br><span class="line">-V 显示程式的版本讯息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160507155323671-910488154.png" alt="img"></p><ol start="46"><li>which 会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果：</li></ol><p>注：LInux中每一个命令对应了一个可执行文件，which返回可执行程序在哪里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">which 可执行文件名称 </span><br><span class="line">-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</span><br><span class="line">-p 　与-n参数相同，但此处的包括了文件的路径。</span><br><span class="line">-w 　指定输出时栏位的宽度。</span><br><span class="line">-V 　显示版本信息</span><br></pre></td></tr></table></figure><p><strong>六. 其他：</strong></p><p>\47. grep命令</p><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，比如可以加在ps, tail, cat后面</p><p>它的简单语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] &#x27;查找字符串&#x27; filename</span><br></pre></td></tr></table></figure><p> 使用示例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/947313-20160506225115169-5091461.png" alt="img"></p><p>\48. clear 命令用于清除终端屏幕上现有的文字内容，将之上滚：</p><p> 额，这条不需要啥示例，非常简单…用了以后就没有了…</p><p>\49. date 命令用于显示或设定时间：</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">date [参数]... [+格式]</span><br><span class="line"></span><br><span class="line">必要参数:</span><br><span class="line">%H 小时(以00-23来表示)。 </span><br><span class="line">%I 小时(以01-12来表示)。 </span><br><span class="line">%K 小时(以0-23来表示)。 </span><br><span class="line">%l 小时(以0-12来表示)。 </span><br><span class="line">%M 分钟(以00-59来表示)。 </span><br><span class="line">%P AM或PM。 </span><br><span class="line">%r 时间(含时分秒，小时以12小时AM/PM来表示)。 </span><br><span class="line">%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 </span><br><span class="line">%S 秒(以本地的惯用法来表示)。 </span><br><span class="line">%T 时间(含时分秒，小时以24小时制来表示)。 </span><br><span class="line">%X 时间(以本地的惯用法来表示)。 </span><br><span class="line">%Z 市区。 </span><br><span class="line">%a 星期的缩写。 </span><br><span class="line">%A 星期的完整名称。 </span><br><span class="line"></span><br><span class="line">%b 月份英文名的缩写。 </span><br><span class="line">%B 月份的完整英文名称。 </span><br><span class="line">%c 日期与时间。只输入date指令也会显示同样的结果。 </span><br><span class="line">%d 日期(以01-31来表示)。 </span><br><span class="line">%D 日期(含年月日)。 </span><br><span class="line">%j 该年中的第几天。 </span><br><span class="line">%m 月份(以01-12来表示)。 </span><br><span class="line">%U 该年中的周数。 </span><br><span class="line">%w 该周的天数，0代表周日，1代表周一，异词类推。 </span><br><span class="line">%x 日期(以本地的惯用法来表示)。 </span><br><span class="line">%y 年份(以00-99来表示)。 </span><br><span class="line">%Y 年份(以四位数来表示)。 </span><br><span class="line">%n 在显示时，插入新的一行。 </span><br><span class="line">%t 在显示时，插入tab。 </span><br><span class="line">MM 月份(必要) </span><br><span class="line">DD 日期(必要) </span><br><span class="line">hh 小时(必要) </span><br><span class="line">mm 分钟(必要)</span><br><span class="line">ss 秒(选择性) </span><br><span class="line"></span><br><span class="line">选择参数:</span><br><span class="line">-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 </span><br><span class="line">-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 </span><br><span class="line">-u 　显示GMT。 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/copycode.gif" alt="复制代码"></a></p><p>使用示例：</p><p><img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507170629203-1386945480.png" alt="img"></p><p>\50. ln 命令是为某一个文件在另外一个位置建立一个同步的链接</p><p>熟悉命令之前了解一下linux的链接：</p><p> 链接(link)：可以将其视为档案的别名。</p><p> 可分为两种 : </p><ul><li>硬链接(hard link)：硬链接的意思是一个档案可以有多个名称，硬链接是存在同一个文件系统中。</li><li>软链接(symbolic link)：而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。 可以跨越不同的文件系统。</li></ul><p>软链接：<br>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接</p><p>硬链接:<br>1.硬链接，以文件副本的形式存在。但不占用实际空间。<br>2.不允许给目录创建硬链接<br>3.硬链接只有在同一个文件系统中才能创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br><span class="line"></span><br><span class="line">必要参数:</span><br><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-d 允许超级用户制作目录的硬链接</span><br><span class="line">-f 强制执行</span><br><span class="line">-i 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n 把符号链接视为一般目录</span><br><span class="line">-s 软链接(符号链接)</span><br><span class="line">-v 显示详细的处理过程</span><br><span class="line"></span><br><span class="line">选择参数:</span><br><span class="line">-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”</span><br><span class="line">-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</span><br></pre></td></tr></table></figure><p>\51 、data命令</p><p>显示当前日期</p><p>\52、du命令</p><p>让我们知道文件和目录所占的空间大小。（统计更完全深入）</p><p>显示磁盘使用/占用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- h ：以MB为单位显示文件大小</span><br><span class="line">- s ：只显示当前目录的总计大小</span><br><span class="line">- a ：显示文件和目录的大小</span><br></pre></td></tr></table></figure><p>\53 、touch</p><p>用于修改文件的时间戳到当前，如果输入的文件名不存在，那么就会创建一个新的文件</p><p>可以以此创建多个文件，中间用空格隔开。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;统一Linunx 规范：&lt;/p&gt;
&lt;p&gt;FHS 规范，规定了目录以及子目录的内容和功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220320194341</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis-集群</title>
    <link href="http://example.com/2022/03/17/Redis-%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2022/03/17/Redis-%E9%9B%86%E7%BE%A4/</id>
    <published>2022-03-17T07:33:57.000Z</published>
    <updated>2022-03-18T06:18:22.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Redis集群是Redis提供的分布式数据库方案， 通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><p>下面重点介绍：集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息等各个方面</p><h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><p>一个Redis集群通常由多个节点（node）组成。</p><p>刚开始时节点相互独立，组建集群就要将节点连接起来。构成多节点的集群。</p><p>连接节点的命令：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318114812146.png" alt="image-20220318114812146"></p><p>通过向节点发送命令，令其与指定的ip和端口的节点握手。从而将ip和port指向的节点加入当前所在集群。</p><p>下面详细介绍启动节点的方法、与集群有关的数据结构，以及CLUSTER MEET命令的实现原理</p><h3 id="1、启动节点"><a href="#1、启动节点" class="headerlink" title="1、启动节点"></a>1、启动节点</h3><p>一个结点就是一个Redis服务器，启动时根据cluster-enabled配置选项确定是否开启集群功能。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318115229354.png" alt="image-20220318115229354"></p><p>节点会继续使用单机模式使用的所有组件</p><p>包括：</p><ul><li>使用文件事件处理器来处理命令请求和返回命令回复。</li><li>使用时间事件处理器来执行serverCron函数</li><li>继续使用数据库来保存键值对数据</li><li>继续使用数据库来保存键值对数据</li><li>继续使用发布与订阅模块来执行PUBLISH、SUBSCRIBE等命令</li><li>继续使用复制模块来进行节点的复制工作</li><li>继续使用Lua脚本环境来执行客户端输入的Lua脚本。</li><li>继续使用redisServer结构来保存服务器的状态，使用redisClient结构来保存客户端的状态</li></ul><h3 id="2、集群数据结构"><a href="#2、集群数据结构" class="headerlink" title="2、集群数据结构"></a>2、集群数据结构</h3><p>上面介绍集群使用的常规单机组建，下面介绍集群模式下特有的数据结构。</p><p>集群模式下才会用到的数据，节点将它们保存到了cluster.h/clusterNode结构、cluster.h/clusterLink结构，以及cluster.h/clusterState结构里面 </p><p><strong>clusterNode结构</strong></p><p>用来保存节点的状态（每个节点都有），</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318115843866.png" alt="image-20220318115843866" style="zoom:67%;" /><p>其中的link属性是一个<strong>clusterLink结构</strong>，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：</p><p>注：redisClient结构和clusterLink结构的有什么异同呢？</p><p>同：都有自己的套接字描述符和输入、输出缓冲区</p><p>异：redisClient结构中的套接字和缓冲区是用于连接客户端的；</p><p>​        clusterLink结构中的套接字和缓冲区则是用于连接节点的。</p><p><strong>clusterState结构</strong></p><p>每个节点都保存着一个，这个结构记录了在当前节点的视角下，集群目前所处的状态</p><h3 id="3、CLUSTER-MEET命令的实现"><a href="#3、CLUSTER-MEET命令的实现" class="headerlink" title="3、CLUSTER MEET命令的实现"></a>3、CLUSTER MEET命令的实现</h3><p>假设向节点 A 发送命令，让节点 B加入集群。</p><p>那么要经过以下流程：</p><ul><li> 节点A会为节点B创建一个clusterNode结构，将该结构添加到自己的clusterState.nodes字典里面。</li><li>节点A将根据给定的IP地址和端口号，向节点B发送一条MEET消息（message）。</li><li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点B将向节点A返回一条PONG消息。</li><li>节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li><li>节点A将向节点B返回一条PING消息。</li><li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li></ul><p>类似三次握手协议，可以对比着进行记忆。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318120552027.png" alt="image-20220318120552027"></p><h2 id="二、槽指派"><a href="#二、槽指派" class="headerlink" title="二、槽指派"></a>二、槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对</p><p>具体形式：</p><ul><li>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽。</li><li>每个键都属于这16384个槽的其中一个。</li><li>每个节点可以处理0个或最多16384个槽</li></ul><p>集群中16384个槽只要有一个没有得到处理，那么集群就处于下线状态。（fail）。</p><p><strong>命令</strong></p><p>槽指派通过向节点发送CLUSTER ADDSLOTS命令，一个节点可以指多个槽。</p><p>举例：<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121224118.png" alt="image-20220318121224118" style="zoom:80%;" /></p><p>全部的槽指派成功之后，集群进入上线状态。</p><h3 id="1、记录节点的槽指派信息"><a href="#1、记录节点的槽指派信息" class="headerlink" title="1、记录节点的槽指派信息"></a>1、记录节点的槽指派信息</h3><p>clusterNode结构的<strong>slots属性</strong>和<strong>numslot属性</strong>记录了节点负责处理哪些槽。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121423532.png" alt="image-20220318121423532"></p><p>slots属性</p><p>Slot是一个数组</p><p>Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号</p><p>用数组元素的值是否为1确定是否被分配处理（1：表示处理）</p><p>示例如下：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121607634.png" alt="image-20220318121607634"></p><p><strong>numslots属性</strong></p><p>记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制位的数量。</p><h3 id="2、传播节点的槽指派信息"><a href="#2、传播节点的槽指派信息" class="headerlink" title="2、传播节点的槽指派信息"></a>2、传播节点的槽指派信息</h3><p>一个节点会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。通过接受其他节点发送的节点slot数组，更新自身的clusterState.nodes字典中的clusterNode结构。</p><p>每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面。</p><h4 id="3、记录集群所有槽的指派信息"><a href="#3、记录集群所有槽的指派信息" class="headerlink" title="3、记录集群所有槽的指派信息"></a>3、记录集群所有槽的指派信息</h4><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318131756379.png" alt="image-20220318131756379"></p><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：</p><ul><li>如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。</li><li>如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。</li></ul><p>通过将所有槽的指派信息保存在clusterState.slots数组里面，程序要检查槽i是否已经被指派， 只需要访问clusterState.slots[i]的值即可，这个操作的复杂度仅为O（1）。</p><p>需要说明的是：虽然clusterState.slots数组记录了集群中所有槽的指派信息，但使用clusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的。</p><h4 id="4、CLUSTER-ADDSLOTS命令的实现"><a href="#4、CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="4、CLUSTER ADDSLOTS命令的实现"></a>4、CLUSTER ADDSLOTS命令的实现</h4><p>CLUSTER ADDSLOTS命令有一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318132213728.png" alt="image-20220318132213728"></p><p>用一段伪代码定义命令的实现：</p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318132247998.png" alt="image-20220318132247998" style="zoom:67%;" /></p><h2 id="三、在集群中执行命令"><a href="#三、在集群中执行命令" class="headerlink" title="三、在集群中执行命令"></a>三、在集群中执行命令</h2><p>集群处于上线状态，那么客户端就可以向集群中的节点发送数据命令了。</p><p>执行流程图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133044005.png" alt="image-20220318133044005" style="zoom:67%;" /></p><p>下面介绍计算所属槽的方法</p><h3 id="1、计算键属于哪个槽"><a href="#1、计算键属于哪个槽" class="headerlink" title="1、计算键属于哪个槽"></a>1、计算键属于哪个槽</h3><p>计算算法：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133200870.png" alt="image-20220318133200870"></p><p>CRC16（key）语句用于计算键key的CRC-16校验和。</p><p>使用CLUSTER KEYSLOT＜key＞命令可以查看一个给定键属于哪个槽</p><h3 id="2、判断槽是否由当前节点负责处理"><a href="#2、判断槽是否由当前节点负责处理" class="headerlink" title="2、判断槽是否由当前节点负责处理"></a>2、判断槽是否由当前节点负责处理</h3><p>上面计算出键所属的槽之后，节点就会检查自己的clusterState.slots数组中的项i，进行判断。</p><ul><li>如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令。</li><li>如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回<strong>MOVED错误</strong>，指引客户端转向至正在处理槽i的节点。</li></ul><h3 id="3、MOVED错误"><a href="#3、MOVED错误" class="headerlink" title="3、MOVED错误"></a>3、MOVED错误</h3><p>当节点发现键所在的槽并非由自己负责处理时，向客户端发送的错误。</p><p>格式：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133644636.png" alt="image-20220318133644636" style="zoom:67%;" /></p><p>客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点。</p><p>并且向其重新发送之前想要执行的命令。</p><h3 id="4、节点数据库的实现"><a href="#4、节点数据库的实现" class="headerlink" title="4、节点数据库的实现"></a>4、节点数据库的实现</h3><p>集群节点保存键值对以及键值对过期时间的方式和之前介绍的单机Redis的方式完全相同。</p><p>节点和单机服务器在数据库方面的一个区别是，<strong>节点只能使用0号数据库</strong>，而单机Redis服务器则没有这一限制。</p><p>另外，除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133958399.png" alt="image-20220318133958399"></p><h2 id="四、重新分片"><a href="#四、重新分片" class="headerlink" title="四、重新分片"></a>四、重新分片</h2><p>将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片可以线上进行 ，集群不需要下线，可以继续处理命令请求。</p><h3 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h3><p>重新分片由集群管理软件redis-trib负责执行，通过向<strong>源节点</strong>和<strong>目标节点</strong>发送命令来进行重新分片操作。</p><p>首先是操作单个槽：</p><p>步骤如下：</p><ul><li>目标节点发送CLUSTER SETSLOT＜slot＞IMPORTING＜source_id＞命令，令其准备好接收slot</li></ul><p>键值对。</p><ul><li><p>对源节点发送CLUSTER SETSLOT＜slot＞MIGRATING＜target_id＞命令，令其准备好slot槽的键值对迁移。</p></li><li><p>向源节点发送CLUSTER GETKEYSINSLOT＜slot＞＜count＞命令，获得最多count个属于槽slot的键值对的键名（key name）。</p></li><li><p>对于获取的每一个键名，redis-trib都向源节点发送一个MIGRATE＜target_ip＞＜target_port＞＜key_name＞0＜timeout＞命令， 原子地从源节点迁移至目标节点。</p></li><li><p>重复执行获取键名和迁移的过程</p><p>如图所示：（迁移键的过程）</p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318134854939.png" alt="image-20220318134854939"></p></li><li><p>redis-trib向集群中的任意一个节点发送CLUSTERSETSLOT＜slot＞NODE＜target_id＞命令，通知槽slot已经指派给目标节点。</p></li></ul><p>对于多个槽的重新分配。需要对每个槽分别执行上述步骤。</p><h2 id="五、ASK错误"><a href="#五、ASK错误" class="headerlink" title="五、ASK错误"></a>五、ASK错误</h2><h3 id="1、ASK错误"><a href="#1、ASK错误" class="headerlink" title="1、ASK错误"></a>1、ASK错误</h3><p>重新分片期间，可能会发生这样的错误：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。</p><p>有趣的情况发生了:客户端向源节点请求命令含有的数据库建恰好属于被迁移的槽的时候。</p><ul><li>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</li><li> 如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，则返回ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</li></ul><p><strong>被隐藏的ASK错误</strong></p><p>和接到MOVED错误时的情况类似，集群模式的redis-cli在接到ASK错误时也不会打印错误，对用户来说是隐藏的。</p><p>接到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送原本想要执行的命令</p><h3 id="2、ASKING命令"><a href="#2、ASKING命令" class="headerlink" title="2、ASKING命令"></a>2、ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识</p><p>如果节点的clusterState.importing_slots_from[i]显示节点正在导入槽i，并且发送命令的客户端带有REDIS_ASKING标识，那么节点将破例执行这个关于槽i的命令一次。</p><p>如图所示：    </p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318135750323.png" alt="image-20220318135750323" style="zoom:67%;" /></p><h3 id="3、ASK错误和MOVED错误的区别"><a href="#3、ASK错误和MOVED错误的区别" class="headerlink" title="3、ASK错误和MOVED错误的区别"></a>3、ASK错误和MOVED错误的区别</h3><p>同：两者都会导致客户端转向。</p><p>异：MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，<strong>客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点</strong>。</p><p>​        与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施，<strong>这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响</strong>。</p><h2 id="六、复制与故障转移"><a href="#六、复制与故障转移" class="headerlink" title="六、复制与故障转移"></a>六、复制与故障转移</h2><p>Redis集群中的节点分为主节点（master）和从节点</p><p>主节点：用于处理槽</p><p>从节点：复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p><p>下面将介绍节点的复制方法，检测节点是否下线的方法，以及对下线主节点进行故障转移的方法。</p><h3 id="1、设置从节点"><a href="#1、设置从节点" class="headerlink" title="1、设置从节点"></a>1、设置从节点</h3><p>使用</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318140329801.png" alt="image-20220318140329801" style="zoom:67%;" /></p><p>命令</p><p>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p><p>从节点复制主节点，</p><p>:one:首先要查找自己的clusterState.nodes字典。找到node_id所对应节点的clusterNode结构，将自己的clusterState.myself.slaveof指针指向这个结构。</p><p>:two:修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识（自己已经变成了从节点）</p><p>:three: 节点调用复制代码，根据指向的那个clusterNode结构（主节点），进行赋值</p><p>从上面来看：从节点复制主节点相当于向从节点发送命令SLAVEOF。</p><h3 id="2、故障检测"><a href="#2、故障检测" class="headerlink" title="2、故障检测"></a>2、故障检测</h3><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><p>如果接收节点没能在规定时间内返回PONG消息，那么发送节点认定该节点<strong>疑似下线</strong>。</p><p>需要注意的是：集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息</p><p>（包括：某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL））</p><p>举个例子：</p><p>​    当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的</p><p>clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告</p><p>（failure report）添加到clusterNode结构的fail_reports链表里面：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318141033674.png" alt="image-20220318141033674"></p><p>​        那么如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL）。</p><p>​    之后主节点通过广播的形式，通知集群中的所有节点，该节点下线的消息。</p><h3 id="3、-故障转移"><a href="#3、-故障转移" class="headerlink" title="3、 故障转移"></a>3、 故障转移</h3><p>发生条件：一个<strong>从节点</strong>发现自己正在复制的<strong>主节点</strong>进入了已下线状态时，从节点将开始对下线主节点进行故障转移</p><p>步骤如下：</p><p>​    1）复制下线主节点的所有从节点里面，会有一个从节点被选中。</p><p>​    2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p><p>​    3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</p><p>​    4）新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</p><p>​    5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p><h3 id="4、新的主节点的选取"><a href="#4、新的主节点的选取" class="headerlink" title="4、新的主节点的选取"></a>4、新的主节点的选取</h3><p>选举方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）集群的配置纪元是一个自增计数器，它的初始值为0。</span><br><span class="line">2）当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</span><br><span class="line">3）对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</span><br><span class="line">4）当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</span><br><span class="line">5）如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</span><br><span class="line">6）每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</span><br><span class="line">7）如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</span><br><span class="line">8）因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</span><br><span class="line">9）如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</span><br></pre></td></tr></table></figure><p>选举新主节点的方法和 选举领头Sentinel的方法非常相似， 都是基于Raft算法的领头选举（leader election）方法来实现的。</p><h2 id="七、消息"><a href="#七、消息" class="headerlink" title="七、消息"></a>七、消息</h2><p>集群中的各个节点通过发送和接收消息（message）来进行通信。</p><p>称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）</p><p>节点之间发送的消息种类：</p><ul><li>MEET消息：当发送者接到客户端发送的CLUSTERMEET命令时，发送者会向接收者发送MEET消息</li><li>PING消息：检测被选中的节点是否在线</li><li>PONG消息：回复PING</li><li>FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li><li>PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h1&gt;&lt;p&gt;Redis集群是Redis提供的分布式数据库方案， 通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。&lt;/p&gt;
&lt;p&gt;下</summary>
      
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-慢查询日志</title>
    <link href="http://example.com/2022/03/17/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2022/03/17/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-17T07:16:19.000Z</published>
    <updated>2022-03-17T07:29:20.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，通过这个功能产生的日志来监视和优化查询速度。</p><h3 id="一、配置选项"><a href="#一、配置选项" class="headerlink" title="一、配置选项"></a>一、配置选项</h3><p>有两个和慢查询日志相关的选项：</p><ul><li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。</li><li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</li></ul><p>服务器使用先进先出的方式保存多条慢查询日志，当 存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。</p><h3 id="二、慢查询记录的保存"><a href="#二、慢查询记录的保存" class="headerlink" title="二、慢查询记录的保存"></a>二、慢查询记录的保存</h3><p>服务器状态中包含了几个和慢查询日志功能有关的属性</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203171521925.png" alt="image-20220317152127766"></p><p>说明：</p><ul><li><p>slowlog_entry_id属性的初始值为0，随着新的日志的创建不断更新。</p></li><li><p>slowlog<strong>链表</strong>保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203171523416.png" alt="image-20220317152318278"></p></li></ul><h3 id="三、浏览和删除"><a href="#三、浏览和删除" class="headerlink" title="三、浏览和删除"></a>三、浏览和删除</h3><p>查看日志的SLOWLOG GET</p><p>查看日志数量的SLOWLOG LEN</p><p>清除所有慢查询日志的SLOWLOG RESET</p><p>打印和删除慢查询日志可以通过遍历slowlog链表实现。</p><h3 id="四、添加新日志"><a href="#四、添加新日志" class="headerlink" title="四、添加新日志"></a>四、添加新日志</h3><p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长。</p><p>这个时长传递给<strong>slowlogPushEntryIfNeeded函数</strong>，最终决定是否创建慢查询日志。</p><p>并且新创建的日志放到slowlog的链表头，并且将slowlog_entry_id的值增加1。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-15T07:19:11.000Z</published>
    <updated>2022-03-15T07:19:11.716Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统-内存管理</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-14T12:19:57.000Z</published>
    <updated>2022-03-15T10:45:27.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>需要了解的知识：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142030815.png" alt="image-20220314203051697"></p><p>1、什么是内存？作用？</p><p>内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾。</p><p>2、内存装入的三种方式</p><ul><li><p>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。</p><p>绝对装入只适用于单道程序环境。</p></li><li><p>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地 址、数据存放的地址都是相对于起始地址而言的逻辑地址。</p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求 的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申 请内存空间。</p></li><li><p>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装 入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。</p></li></ul><p>3、程序的运行</p><ul><li><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言） </p></li><li><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块 </p></li><li><p>装入（装载）：由装入程序将装入模块装入内存运行</p></li></ul><h3 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h3><ul><li>内存空间分配和回收</li><li>内存空间扩容</li><li>地址转换</li><li>内存保护</li></ul><p>1、内存空间分配和回收：操作系统负责<strong>内存空间的分配与回收</strong></p><p>2、内存空间扩容：操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></p><p>3、地址转换：操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换（三种装入方式）</p><p>4、内存保护：操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</p><p>（CPU检查是否越界）</p><h3 id="三、覆盖和交换"><a href="#三、覆盖和交换" class="headerlink" title="三、覆盖和交换"></a>三、覆盖和交换</h3><p>覆盖和交换是内存空间扩容的方法，此外还有虚拟内存技术。</p><p>1、覆盖技术</p><p>覆盖技术的思想：将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。 需要常驻内存的段放在“固定区”中，调入后就不再 调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存， 用不到时调出内存。</p><p>如图所示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142107600.png" alt="image-20220314210738510"></p><p>-缺点：对用户不透明，现在已经成为历史。</p><p>2、交换技术</p><p>​    设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中 某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>​    回忆之前的知识：中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>​    暂时换出外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p>​    总结之前的状态模型：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142109908.png" alt="image-20220314210948530"></p><p>注意：PCB 会常驻内存，不会被换出外存</p><h3 id="四、连续内存分配管理"><a href="#四、连续内存分配管理" class="headerlink" title="四、连续内存分配管理"></a>四、连续内存分配管理</h3><p>连续内存分配管理是内存空间分配和回收的方式之一</p><p>如图所示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142111790.png" alt="image-20220314211149486"></p><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><p><strong>分类</strong>：</p><p>可以分成单一连续分配、固定分区分配、动态分区分配。</p><p>1、单一连续分配</p><p>​    内存被分为系统区和用户区。 </p><p>​        系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；</p><p>​        用户区用于存放用户进程相关数据。 </p><p>​    内存中只能有一道用户程序，用户程序独占整个用户区 空间。 </p><p>​    优点：实现简单；无外部碎片；可以采用覆盖技术扩充 内存；不一定需要采取内存保护 </p><p>​    缺点：只能用于单用户、单任务的操作系统中；有内部 碎片；存储器利用率极低。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142119367.png" alt="image-20220314211952123"></p><p>2、固定分区分配</p><p>​        整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。</p><p>​    分成</p><ul><li><p>分区大小相同：</p><p>分区大小相等：缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合</p></li><li><p>分区大小不同：</p><p>增加了灵活性，可以满足不同大小的进 程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142118494.png" alt="image-20220314211830222"></p></li></ul><p><strong>3、动态分区分配</strong></p><p>​    又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。</p><p>​    动态分区分配没有内部碎片，但是有外部碎片。 </p><p>注：</p><ul><li><p>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 </p></li><li><p>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。（通过紧凑技术来解决）</p></li></ul><p>4、总结</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142115124.png" alt="image-20220314211520809"></p><h3 id="五、动态分区分配算法"><a href="#五、动态分区分配算法" class="headerlink" title="五、动态分区分配算法"></a>五、动态分区分配算法</h3><p>在上面学习的动态分区分配时，多个分区都空闲的时候，那么要选择哪个呢？</p><p>下面是解决这个问题的四种算法。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142121060.png" alt="image-20220314212136836"></p><p>1、首次适应算法</p><p>​        算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 </p><p>​        实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142123637.png" alt="image-20220314212314372"></p><p>2、最坏适应算法</p><p>​        算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区 域。 优先使用更小的空闲区。 </p><pre><code>     实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 </code></pre><p>表），找到大小能满足要求的第一个空闲分区。 </p><p>​        <strong>缺点： 这种方法会产生很多的外部碎片。</strong></p><p>3、最佳适应算法</p><p>​        算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，</p><pre><code>     实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 </code></pre><p>表），找到大小能满足要求的第一个空闲分区。</p><p><strong>缺点： 这种方式会导致较大的连续空闲区被</strong> <strong>迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong> </p><p>4、临近适应算法</p><p>​        算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲 分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 </p><pre><code>     实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查 找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</code></pre><p>5、总结</p><p>​        综合来看，四种算法中，首次适应算法的效果反而更好</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142122366.png" alt="image-20220314212231038"></p><h3 id="六、基本分页存储管理的基-本概念"><a href="#六、基本分页存储管理的基-本概念" class="headerlink" title="六、基本分页存储管理的基 本概念"></a>六、基本分页存储管理的基 本概念</h3><p>之前上面介绍到的都是连续分配的形式。下面介绍非连续分配。</p><p>连续分配：为用户进程分配的必须是一个连续的内存空间。 </p><p>非连续分配：为用户进程分配的可以是一些分散的内存空间。</p><p>​        关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142127675.png" alt="image-20220314212735413"></p><p>1、什么是分页存储？</p><ul><li><p>将内存空间分为一个个大小相等的分区，，每个分区就是一个“页框”</p><p>（页框号=页帧号=内存块号=物理块号=物理页号）</p></li><li><p>将进程的逻辑地址空间也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“页”或“页面” 。</p></li></ul><p>下面是几点说明：</p><ul><li><p>操作系统以页框为单位为各个进程分配内存空间。</p></li><li><p>进程的页面与内存的页框有一一对应的关系。</p></li><li><p>页面可以不是连续存放的，也可以不放到相邻的页框中。</p></li></ul><p>2、页表</p><p>​    下面是一个重要的概念，”页表“</p><p>​    页表通常存储在进程控制块中PCB 。</p><p>图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142147228.png" alt="image-20220314214751984"></p><p>说明：</p><p>   1.一个进程对应一张页表</p><ol start="2"><li><p>进程的每个页面对应一个页表项</p></li><li><p>每个页表项由“页号”和“块号”组成</p></li><li><p>页表记录进程页面和实际存放的内存块之间的映射关系</p></li><li><p>每个页表项的长度是相同的</p></li></ol><p>问题：</p><p> 问题一：每个页表多少字节？</p><p>​        计算机中内存块的数量——&gt;页表项中块号至少占多少字节</p><p>总结：        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142150512.png" alt="image-20220314215008122"></p><h3 id="七、虚拟内存"><a href="#七、虚拟内存" class="headerlink" title="七、虚拟内存"></a>七、虚拟内存</h3><p>之前了解了传统内存扩容的方式，加上覆盖和交换。下面学习虚拟内存技术。</p><p>基本概念：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142129890.png" alt="image-20220314212947614"></p><p>1、传统存储管理方式</p><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：</p><p>​    ①作业很大时，不能全 部装入内存，导致大作业无法运行；</p><p>​    ②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 </p><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。导致了内存中会驻留大量的、暂时用不到的 数据，浪费了内存资源。</p><p>2、局部性原理</p><p>时间局部性：如果执行了程序中的某条指令，那么不久后<strong>这条指令</strong>很有可能再次执行；（因为程序中存在大量的循环） </p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其<strong>附近的存储单元</strong>也很有可能被访问。 （因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><p>3、虚拟内存</p><p><strong>定义</strong>：（用一段文字说明）</p><p><strong>基于局部性原理</strong>，在程序装入时，可以将程序中很快 会用到的部分装入内存，暂时用不到的部分留在外存， 就可以让程序开始执行。 </p><p>在程序执行过程中，当所访问的信息不在内存时，由 操作系统负责将所需信息从外存调入内存，然后继续执行程序。 </p><p>若内存空间不够，由操作系统负责将内存中暂时用不 到的信息换出到外存。 在操作系统的管理下，在用户看来<strong>似乎有一个比实际 内存大得多的内存</strong>，这就是<strong>虚拟内存</strong></p><p>注：</p><ul><li><p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 </p></li><li><p>虚拟内存的实际容量 =    min（内存和外存容量之和，CPU寻址范围）</p></li></ul><p><strong>特征：</strong></p><ul><li><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 </p></li><li><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换 入、换出。 </p></li><li><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p></li></ul><p><strong>实现</strong></p><p>由于一个作业会分多次调入调出内存，因此连续内存分配不方便，因此<strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上</strong>。</p><p>实现如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142137261.png" alt="image-20220314213743950"></p><p>操作系统需要提供页面置换和请求调页的功能。</p><h3 id="八、基本地址变换机构"><a href="#八、基本地址变换机构" class="headerlink" title="八、基本地址变换机构"></a>八、基本地址变换机构</h3><p>基本地址编制机构可以借助进程把逻辑地址转换成物理地址。</p><p>通常会在系统设置页表寄存器(PTR),用来存放页表和内存的启示地址和页表长度。</p><p>程序未执行时，页表和起始地址存放在PCB中，进程被调用的时候后，操作系统会把他们调到页表寄存器中。</p><p>流程如下：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151057772.png" alt="image-20220315105732653"></p><p>总结：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151058482.png" alt="image-20220315105817409"></p><h3 id="九、具有快表的地址变换机构"><a href="#九、具有快表的地址变换机构" class="headerlink" title="九、具有快表的地址变换机构"></a>九、具有快表的地址变换机构</h3><p>是基本地址变换机构的改进版。</p><p>1、什么事快表？TLB</p><p>​    快表：（TLB）一种访问速度比内存刈很多的高速缓存（TLB不是内存！） 用来存放最近访问的页表项的副本，可以加速地址变换的速度。 </p><p>​    与此对应，内存中的页表常称为慢表。</p><p>2、引入快表的地址变换过程？</p><p>引入快表之后优先查询块表是否命中。加快速度。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151102229.png" alt="image-20220315110210155"></p><p>具体流程：</p><p>①算页号、页内偏移量 </p><p>②检查页号合法性 </p><p>③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤； </p><p>若未命中则进行④ </p><p>④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 </p><p>⑤根据内存块号与页内偏移量得到物理地址 </p><p>⑥访问目标内存单元 </p><h3 id="十、二级页表"><a href="#十、二级页表" class="headerlink" title="十、二级页表"></a>十、二级页表</h3><p>之前都是分配给进程单级页表。</p><p>1、那么单级页表存在什么问题呢？</p><p>单级页表要在所有的页表项都连续存放的基础上才能找到页表项。当页表很大时，需要占用很多个连续的页框。</p><p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面 就可以正常运行了。因此没有必要让整个页表都常驻内存。</p><p>2、二级页表</p><p>那么为了解决这两个问题，我们可以把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151109832.png" alt="image-20220315110906749"></p><p>可以分成以下几步：</p><p>①按照地址结构将逻辑地址拆分成三部分 </p><p>②从PCB 中读出页目录表始址，再根据一级页号查页目录 </p><p>表，找到下一级页表在内存中的存放位置 </p><p>③根据二级页号查二级页表，找到最终想访问的内存块号 </p><p>④结合页内偏移量得到物理地址</p><p>3、注意事项</p><p>两级页表的访存次数分析（假设没有快表机构） </p><p>第一次访存：访问内存中的页目录表 </p><p>第二次访存：访问内存中的二级页表 </p><p>第三次访存：访问目标内存单元</p><h3 id="十一、基本分段存储管理方式"><a href="#十一、基本分段存储管理方式" class="headerlink" title="十一、基本分段存储管理方式"></a>十一、基本分段存储管理方式</h3><h3 id="十二、请求分页管理方式"><a href="#十二、请求分页管理方式" class="headerlink" title="十二、请求分页管理方式"></a>十二、请求分页管理方式</h3><p>之前介绍的都是基本的分页存储管理。</p><p>下面介绍请求分页管理方式</p><p>两者存在一些差别：</p><ul><li><p>在程序执行过程中，当<strong>所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然 后继续执行程序。 </p></li><li><p>若内存空间不够，由操作系统负责将<strong>内存中暂时用不到的信息换出到外存</strong>。</p></li></ul><p>请求分页管理方式主要有以下几点注意事项：</p><ul><li>页表机制</li><li>缺页中断机构</li><li>地址变换机构（注意与基本分页存储管理的页表 机制、地址变换流程对比）</li></ul><p>1、页表机制</p><p>与基本分页管理相比，实现“请求调页”，操作系统需要 知道每个页面是<strong>否已经调入内存</strong>；如果还没调入，那么也需要知道该页面在<strong>外存中存放的位置</strong>。</p><p>​    当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到 底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页 面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面 <strong>是否被修改</strong>的信息。</p><p>因此两者的页表结构也所不同。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151118557.png" alt="image-20220315111813484"></p><p>2、缺页中断机构</p><p>​    在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然 后由操作系统的缺页中断处理程序处理中断。 </p><p>​    此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修 改页表中相应的页表项。</p><p>​    缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 </p><p>一条指令在执行期间，可能产生多次缺页中断。</p><p>3、地址变换机构</p><p>​    请求分页存储管理与基本分页存储管理的主要区别： </p><p>​    在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然 后继续执行程序。 </p><p>​    若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>注：新增步骤1：请求调页（查到页表项时进行判断） </p><p>​        新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行） </p><p>​        新增步骤3：需要修改请求页表中新增的表项</p><h3 id="十三、页面置换算法"><a href="#十三、页面置换算法" class="headerlink" title="十三、页面置换算法"></a>十三、页面置换算法</h3><p>​    之前说到操作系统要为请求页面分配管理的方式提供页面置换和请求调页的功能。</p><p>​    下面关注页面置换算法的实现。</p><p>好的页面置换算法应该追求更少的缺页率。</p><p>下面介绍五种页面置换算法。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151130032.png" alt="image-20220315113004952"></p><p>1、最佳置换算法</p><p>最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被 访问的页面，这样可以保证最低的缺页率。</p><p>根据算法思想我们可以知道最佳置换算法总是淘汰最先出现的那个页面。</p><p>这个算法有一定的局限性，操作系统无法提前预判页面访问序列的情况下，最佳置换算法无法实现。</p><p>2、先进先出置换算法</p><p>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面 </p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 </p><p>队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>缺点是虽然实现简单，但是可能会产生Belady异常，算法性能差</p><p>注：Belady 异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>3、最近最久未使用算法</p><p>​    最近最久未使用置换算法（LRU，least    recently    used）：每次淘汰的页面是最近最久未使用的页面 </p><p>​    实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</p><p>​    <strong>缺点</strong>：该算法的实现需要专门的硬 件支持，虽然算法性能好， 但是实现困难，开销大</p><p>4、时钟置换算法</p><p>​    时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，NotRecently Used）</p><p>​    实现有一些复杂</p><p>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫᧿ （第二轮扫描 中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描 ）</p><p>​        如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151138515.png" alt="image-20220315113846445"></p><p>5、改进型时钟置换算法</p><p>对于简单的时钟算法，对于是否页面被修改并不关心，只关注是否被访问。之后进行写入内存。可以设置一种算法，将没有修改的页面不写进内存。避免不必要的开销。</p><p>扫描的规则：</p><p>将所有可能被置换的页面排成一个循环队列 </p><p>第一轮：从当前位置开始扫᧿ 到第一个（0,    0）的帧用于替换。本轮扫᧿ </p><p>不修改任何标志位 </p><p>第二轮：若第一轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    1）的帧用于 </p><p>替换。本轮将所有扫᧿ 过的帧访问位设为0 </p><p>第三轮：若第二轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    0）的帧用于 </p><p>替换。本轮扫᧿ 不修改任何标志位 </p><p>第四轮：若第三轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    1）的帧用于 </p><p>替换。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151141679.png" alt="image-20220315114139618"></p><p>此经过第三轮、第四轮扫᧿ 一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多 会进行四轮扫描。</p><h3 id="十四、页面分配策略"><a href="#十四、页面分配策略" class="headerlink" title="十四、页面分配策略"></a>十四、页面分配策略</h3><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151125804.png" alt="image-20220315112557721"></p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-文件管理</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-14T04:47:48.000Z</published>
    <updated>2022-03-15T10:45:17.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>文件——就是一组有意义的信息/数据集合</p><p>文件管理：</p><p>重点关注和解决以下问题：</p><ul><li><p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p></li><li><p>文件内部的数据应该怎样组织起来？</p></li><li><p>文件之间又应该又应该怎么组织起来？</p></li><li><p>从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？</p></li><li><p>从上往下看，文件数据应该怎么存放在外存（磁盘）上？</p></li></ul><p>文件属性：</p><p>常见的文件属性包括：</p><p>​    文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p><p>​    标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p><p>​    类型：指明文件的类型</p><p>​    位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p><p>​    大小：指明文件大小</p><p>​    创建时间、上次修改时间</p><p>​    文件所有者信息</p><p>​    保护信息：对文件进行保护的访问控制信息</p><p>重点回顾：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141642420.png" alt="image-20220314164225069"></p><h3 id="二、文件逻辑结构"><a href="#二、文件逻辑结构" class="headerlink" title="二、文件逻辑结构"></a>二、文件逻辑结构</h3><p>概念：指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p><p><strong>文件操作的具体实现与文件的逻辑结构、物理结构都有关</strong></p><p>分类：</p><p>​    分类标准：是否有结构</p><p>​    无结构文件、有结构文件文件</p><p>一、无结构文件</p><p>​    无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件。</p><p>​    因此也不用探讨无结构文件的“逻辑结构”问题。</p><p>​    举例：比如 .txt 文件</p><p>二、有结构文件</p><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。</p><p>1、定长记录、可变长记录</p><p>有结构文件是由一条条记录组成的。通常记录可以分成：定长记录和可变长记录。</p><p>​    定长记录：每条记录的长度相同。</p><p>​    可变长记录：各条记录的长度不确定，不一定是相同的。</p><p>2、<strong>有结构文件的逻辑结构</strong></p><p>分类标准： 根据有结构文件中的各条记录在逻辑上如何组织</p><p>:one:顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p>​    顺序文件的分类如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141700629.png" alt="image-20220314170005560"></p><p>​    一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件</p><p>​    缺点：删除一个记录比较困难。</p><p>:two:索引文件：索引文件本身是定长记录的顺序文件。(解决可变长记录文件，顺序查找的问题)</p><p>​    索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合</p><p>如图：</p><pre><code> &lt;img src=&quot;https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141704354.png&quot; alt=&quot;image-20220314170423294&quot; style=&quot;zoom:80%;&quot; /&gt;</code></pre><p>优点：可以使用不同的数据项创建多个索引表。</p><p>​            检索速度很快。</p><p>:three:索引顺序文件</p><p>​    索引顺序文件是索引文件和顺序文件思想的结合。</p><p>​    索引顺序文件，会为文件建立一张索引表，但是：并不是每个记录对应一个索引表项，而是<strong>一组</strong>记录对应一个索引表项。</p><p>如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141706960.png" alt="image-20220314170641899"></p><p>也就是说把相同组的文件索引放到一个新的索引文件中，组成一个顺序文件，由原来的索引文件进行索引。</p><p>:four:多级索引顺序文件</p><p>为了进一步提高效率，可以为顺序文件建立多级索引表。在此不做过多赘述。</p><h3 id="三、文件目录"><a href="#三、文件目录" class="headerlink" title="三、文件目录"></a>三、文件目录</h3><p>一层一层的文件目录对用户有什么好处？</p><p>​    文件组织清晰，易于查找</p><p>​    轻松的实现按名存取的目的。</p><p>那么文件目录是如何实现的呢？</p><p>随着计算机的发展文件目录的结构也在发生着变化。</p><h4 id="一、文件控制块"><a href="#一、文件控制块" class="headerlink" title="一、文件控制块"></a>一、文件控制块</h4><p>1、首先了解相关概念：文件控制块</p><p>​    文件控制块是为了实现目录的关键数据结构。</p><p>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件</p><p>目录文件中的一条记录就是一个<strong>文件控制块（FCB）</strong></p><p>2、需要对目录 进行哪些<strong>操作</strong>？</p><ul><li><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p></li><li><p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p></li><li><p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p></li><li><p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p></li><li><p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文</p></li></ul><p>件重命名）</p><h4 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a><strong>二、目录结构</strong></h4><p>:one:<strong>单级目录结构</strong></p><p>​    整个系统中值建立一张目录表</p><p>​    不允许文件重名；应用于早期操作系统。</p><p>:two:<strong>两级目录结构</strong></p><p>​    到了早期多用户操作系统使用两级目录结构。</p><p>​    分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User FlieDirectory）。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录</p><p>的用户名是否匹配）</p><p>​    <strong>缺点</strong>：用户不能对文件进行分类，灵活性不足。</p><p>:three:<strong>多级目录结构</strong></p><p>了解几个概念：</p><p>​    绝对路径：从根路径出发的路径</p><p>​    当前目录：当前所在的那一级目录</p><p>​    相对路径：指的是相对于当前目录的路径。</p><p>树型目录结构</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141721733.png" alt="image-20220314172144652"></p><p>​    如果查找文件时，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径” 。 <strong>引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</strong></p><p>缺点：不利于实现 文件的共享</p><p>​    树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><p>:four:无环图目录结构</p><p>具体思路是：</p><p>​    可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。需要为每个共享结点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。只有共享计数器减为0时，才删除结点。</p><p>​    因为文件是共享的，因此在共享文件中，一个用户修改了文件数据，那么所有用户都能看到文件变化。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141722761.png" alt="image-20220314172221700"></p><h4 id="三、索引节点"><a href="#三、索引节点" class="headerlink" title="三、索引节点"></a>三、索引节点</h4><p>FCB的改进：目录的使用只有文件名匹配之后才会读取其他信息。考虑让目录表“瘦身”来提升效率。</p><p>​    因此把目录中除了文件名之外的文件描述信息都放到一个索引节点。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141730554.png" alt="image-20220314173018481"></p><p>当找到文件名对应的目录项时，索引节点才调入内存。</p><p>注：存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="四、文件的物理结构"><a href="#四、文件的物理结构" class="headerlink" title="四、文件的物理结构 %*%"></a>四、文件的物理结构 %*%</h3><p>文件数据应该怎样存放在外存中？</p><p>文件的物理结构分类</p><p> 分类标准：文件分配方式</p><ul><li>连续分配</li><li><h2 id="连接分配"><a href="#连接分配" class="headerlink" title="连接分配"></a>连接分配</h2></li><li>索引分配</li></ul><p>一、文件块、磁盘块</p><p>操作系统为文件分配存储空间是以快为基本单位的。</p><p>类似于内存中的存储，也是分成一个个快/磁盘块</p><p>二、连续分配</p><p>​    连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><p>1、逻辑地址到物理地址的映射？</p><p>（逻辑块号，块内地址）——&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p><p>​    物理块号 = 起始块号 + 逻辑块号</p><p>​    当然还要检查是否逻辑块号合法（逻辑块号 ≥ 长度 就不合法）</p><p>2、图示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141836258.png" alt="image-20220314183641193"></p><p>​        分别存放块的起始地址和长度。不被包括的就是空的块</p><p>3、优缺点？</p><p>​    优点：<strong>支持随机读取和顺序读取</strong></p><p>​                连续分配在顺序读/写的速度最快。</p><p>​    缺点：连续分配物理上是连续的，因此想要拓展更改不方便。</p><p>​                存储空间利用率低，产生外部碎片。</p><p>三、链接分配</p><p>​    链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p>:one:显示链接</p><p>图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141926941.png" alt="image-20220314192635871"></p><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）</p><p>​    需要注意的是：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻内存。</p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，<strong>支持顺序存储</strong>，并且<strong>支持随机访问</strong>。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间</li></ul><p>:two:隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录</p><p>包括文件第一块的指针和最后一块的指针。</p><p>图示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141839578.png" alt="image-20220314183941511"></p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点：<strong>只支持顺序访问，不支持随机访问</strong>，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><p>四、索引分配</p><p>文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文</p><p>件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间</p><p>的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p>若文件太大，单个磁盘块存储不下整张索引表，如何解决？</p><p>有三种方案：</p><ul><li><p>①<strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，这就导致磁盘I/O次数过多，查找效率低下。 </p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932482.png" alt="image-20220314193232419"></p></li><li><p>②<strong>多层索引</strong>：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作。</p><p>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932185.png" alt="image-20220314193219131"></p></li><li><p>③<strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。</p><p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932230.png" alt="image-20220314193200149"></p></li></ul><h3 id="五、文件存储空间管理"><a href="#五、文件存储空间管理" class="headerlink" title="五、文件存储空间管理"></a>五、文件存储空间管理</h3><p>一、文件空间的划分和初始化</p><p>文件卷</p><p>文件区：存放文件数据。</p><p>目录区：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区</p><p>二、文件存储空间管理方法</p><p>学习时注意从三个方面进行理解：</p><ul><li><p>用什么方式记录、组织空闲块？</p></li><li><p>如何分配磁盘块？</p></li><li><p>如何回收磁盘块？</p></li></ul><p>:one:空闲表法</p><p>概述：（适用于连续表法分配方式）</p><ul><li><p>磁盘块分配：与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间</p></li><li><p>磁盘块回收：与内存管理中的动态分区分配很类似，当回收某个</p><p>存储区时需要有四种情况</p><ul><li>①回收区的前后都没有相邻空闲区；</li><li>②回收区的前后都是空闲区；</li><li>③回收区前面是空闲区；</li><li>④回收区后面是空闲区。总之，<strong>回收时需要注意表项的合并问题。</strong></li></ul></li></ul><p>:two:空闲链表法</p><p>具体如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141949582.png" alt="image-20220314194930505"></p><ul><li><p>分配：若某文件申请 K 个盘块，则从链头开始依次摘</p><p>下 K 个盘块分配，并修改空闲链的链头指针。</p></li><li><p>回收：回收的盘块依次挂到链尾，并修改空闲链的链</p><p>尾指针。</p></li></ul><p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p><p>:three:位示图法</p><p>​    位示图：每个二进制位对应一个盘块。用0和1来表示盘快是否分配。</p><p>​    注意<strong>盘块号与（字号</strong><strong>,</strong> <strong>位号）相互转换的公式：</strong></p><p>​        (字号, 位号)=(i, j) 的二进制位对应的 盘块号 b = ni + j</p><ul><li><p>分配：若文件需要K个块，</p><ul><li>顺序扫描位示图，找到K个相邻或不相邻的“0”；</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件；</li><li>将相应位设置为“1”。</li></ul></li><li><p>回收：</p><ul><li>根据回收的盘块号计算出对应的字号、位号；</li><li>将相应二进制位设为“0”     </li></ul></li></ul><p>:four:成组链接法</p><p>​        空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。</p><p>因此诞生了成组链表法：</p><p>​    使用一个专用的磁盘作为<strong>超级块</strong>,指向下一级内存块，每一级内存块的大小都是有限制的。</p><p>超级块中包含下一组空闲盘的快数。</p><p>​    如图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141958464.png" alt="image-20220314195800380"></p><h3 id="六、文件的基本操作"><a href="#六、文件的基本操作" class="headerlink" title="六、文件的基本操作"></a>六、文件的基本操作</h3><p>​    操作系统向上提供的基本功能：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141935390.png" alt="image-20220314193503323"></p><p>一、创建文件</p><p>​    调用Create，需要几个参数：</p><ul><li><p> 所需的外存空间大小（如：一个盘块，即1KB）</p></li><li><p>文件存放路径（“D:/Demo”）</p></li><li><p>文件名 </p></li></ul><p>Create的流程：</p><ul><li><p>在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</p></li><li><p>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中创建该文件对应的目录项。<strong>目录项中包含了文件名、文件在外存中的存放位置等信息。</strong></p></li></ul><p>二、删除文件</p><p>​    调用Delete，需要提供参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>Delete的流程：</p><ul><li><p> 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p></li><li><p>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</p><p>（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p></li><li><p>从目录表中删除文件对应的目录项。</p></li></ul><p>三、打开文件</p><p>​    在对文件进行操作之前，要求用户先使用 open 系统调用“打开文件”，需要提供的几个主要参数：</p><ul><li><p>文件存放路径</p></li><li><p>文件名</p></li><li><p>要对文件的操作类型（如：r 只读；rw 读写等）</p></li></ul><p>open 系统调用：</p><ul><li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p></li><li><p>将目录项复制到内存中的<strong>“打开文件表</strong>”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p></li></ul><p>打开文件之后，创建了打开文件表，用户再操作该文件就不需要重新查目录了。加快文件访问速度。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141942606.png" alt="image-20220314194229529"></p><p>四、关闭文件</p><p>​    进程使用完文件后，要“关闭文件”</p><p>  Close 系统调用 ：</p><ul><li><p>将进程的打开文件表相应表项删除</p></li><li><p>回收分配给该文件的内存空间等资源</p></li><li><p>系统打开文件表的打开计数器count 减1，若 <strong>count = 0，则删除对应表项</strong>。</p></li></ul><p>五、读文件</p><p>​    根据读指针、读入数据量、内存位置将文件数据从外存读入内存。</p><p>六、写文件</p><p>​    根据写指针、写出数据量、内存位置将文件从文件数据从内存写出外存。</p><h3 id="七、文件共享"><a href="#七、文件共享" class="headerlink" title="七、文件共享"></a>七、文件共享</h3><p>文件共享意味着系统中只含有一份文件数据，由多个用户共享。注意和文件复制的区别。</p><p>文件共享：为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。</p><p>下面是共享文件的两种方式：</p><p>一、硬链接</p><p>基于索引节点。索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p><p>若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减 1。 </p><p>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p><p>当 count = 0 时系统负责删除文件。</p><p>​    图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142000927.png" alt="image-20220314200030859"></p><p>二、软连接（符号链接）</p><p>基于符号链接的共享文件，相当于windows的桌面快捷方式。通过路径引用，定位到文件 。</p><p>图示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142001670.png" alt="image-20220314200143592"></p><h3 id="八、文件保护"><a href="#八、文件保护" class="headerlink" title="八、文件保护"></a>八、文件保护</h3><p>文件保护，是为了保护文件数据的安全。有三种常见方式。</p><p>一、口令保护</p><p>​    为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。</p><ul><li><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p></li><li><p>缺点：正确的“口令”存放在系统内部，不够安全。</p></li></ul><p>二、加密保护</p><p>​    使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p><ul><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码/译码，或者说加密/解密要花费一定时间。</li></ul><p>三、访问控制</p><p>​    在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。</p><p>例图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142005887.png" alt="image-20220314200523812"></p><p>​    精简的访问列表：（避免用户过多带来的负荷。）</p><p>​    系统会按照一定的分类标准 分组。每个组中的成员的权限是相同的。</p><h3 id="九、文进系统结构层次"><a href="#九、文进系统结构层次" class="headerlink" title="九、文进系统结构层次"></a>九、文进系统结构层次</h3><p>​        层次图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142005582.png" alt="image-20220314200548502"></p><h3 id="十、磁盘"><a href="#十、磁盘" class="headerlink" title="十、磁盘"></a>十、磁盘</h3><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142006860.png" alt="image-20220314200640766"></p><h3 id="十一、磁盘调度算法"><a href="#十一、磁盘调度算法" class="headerlink" title="十一、磁盘调度算法"></a>十一、磁盘调度算法</h3><p>1、寻找时间</p><p>​    在读/写数据前，将磁头移动到指定磁道所花的时间。</p><ul><li><p>①启动磁头臂是需要时间的。假设耗时为 s； </p></li><li><p>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道。则：寻道时间 TS = s + m*n</p></li></ul><p>2、延迟时间</p><p>​    通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p><p>​    设磁盘转速为 r （单位：转/秒，或 转/分），则平均所需的延迟时间 </p><p>​            TR = (1/2)*(1/r) = 1/(2r)</p><p>3、传输时间</p><p>​    从磁盘读出或向磁盘写入数据所经历的时间，</p><p>​    假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N。</p><p>​        则：传输时间Tt = (1/r) * (b/N) = b/(rN)</p><p>一、先来先服务算法（FCFS）</p><p>​    根据进程请求访问磁盘的先后顺序进行调度。</p><ul><li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li><li>缺点：近似于随机寻道</li></ul><p>二、最短寻找时间算法（SSTF）</p><p>​        会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（贪心的思想）</p><ul><li><p>优点：性能较好，平均寻道时间短</p></li><li><p>缺点：可能产生“饥饿”现象</p></li></ul><p>三、扫描算法（电梯算法）（SCAN）</p><p>在SSTF的基础上，规定：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移 动。这就是扫描算法（SCAN）的思想</p><ul><li><p>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</p></li><li><p>缺点：</p><ul><li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均</li></ul></li></ul><p>四、look算法</p><p>​        在SCAN 算法基础上规定：如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。</p><p>例：    </p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142014944.png" alt="image-20220314201413868"></p><ul><li>优点：比起 SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul><p>五、循环扫描算法（C-SCAN ）</p><p>​        在SCAN 的基础上：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><ul><li><p>优点：比起SCAN 来，对于各个位置磁道的响应频率很平均。</p></li><li><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向；比起SCAN算法来，平均寻道时间更长</p></li></ul><p>六、C-look算法</p><p>​    C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>例：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142016716.png" alt="image-20220314201638648"></p><ul><li>优点：比起 C-SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间</li></ul><p>进一步缩短</p><h3 id="十二、磁盘管理"><a href="#十二、磁盘管理" class="headerlink" title="十二、磁盘管理"></a>十二、磁盘管理</h3><p>可以认为的减少磁盘寻道的时间（其余两个都和磁盘本身的转速有关）</p><p>常见的方法：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142017014.png" alt="image-20220314201722940"></p><p>​    </p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-常见问题总结</title>
    <link href="http://example.com/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-13T12:29:59.000Z</published>
    <updated>2022-03-15T10:45:54.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见操作系统问题"><a href="#常见操作系统问题" class="headerlink" title="常见操作系统问题"></a>常见操作系统问题</h2><ul><li>进程和线程的区别？</li><li>进程调度算法有哪些</li><li>常见的进程通信方式</li><li>进程IPC问题</li><li>进程死锁</li><li>什么叫做内核进程？与普通用户进程有什么区别？</li><li>fork/vfork调用</li><li>孤儿进程/僵尸进程</li><li>时间片轮转算法的发展</li><li>常见的进程调度器</li><li>抢占式调度VS 协作式调度</li><li>系统调用</li><li>POSIX</li><li>系统调用参数传递过程</li><li>常用的内核数据结构有哪些？都是在什么场景使用</li><li>什么是中断</li><li>软中断和硬中断</li><li>描述一下中断处理程序的执行过程</li><li>使用网卡描述一下硬件使用中断来完成数据传输的过程</li><li>操作系统是如何感知中断并处理的</li><li>中断的上半部和下半部</li><li>介绍一下内核同步方法</li><li>Linux里面都有哪些锁？</li><li>悲观锁和乐观锁</li><li>说说Linux内存管理</li><li>内存映射策略</li><li>使用C 函数Malloc描述一下内存分配的过程</li><li>Linux虚拟文件系统</li><li>Linux IO调度程序 </li></ul>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-12T08:01:40.000Z</published>
    <updated>2022-03-15T10:45:36.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>下面是操作系统基本功能的进程管理。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1、概念：</p><p>​    例如windows的进程管理器中的每一条进程都是进程。</p><ul><li><p>程序是存放在磁盘中的可执行文件，是静态的。是一系列程序的集合。</p></li><li><p>进程是动态的，是程序的依次执行过程。</p></li></ul><p>2、组成</p><p>操作系统的进程由PCB 来控制。是进程存在的标志。</p><p>PCB中存放的都是操作系统对进程进行管理所需要的信息。是给操作系统用的</p><p>程序段、数据段是给进程自己用的。</p><p>通常PCB 中包含以下信息：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121609867.png" alt="image-20220312160940762" style="zoom:80%;" /></p><p>一个进程实体（进程映像 ）是由：PCB 、程序段、数据段组成。</p><p>注意：进程实体是动态的，进程是进程运行过程中某一时刻的状态。是资源分配和调度的独立单位。</p><p>3、特征</p><ul><li>动态性：最基本的特性</li><li>并发性</li><li>独立性</li><li>异步性</li><li>结构性</li></ul><h3 id="二、进程状态转换和组织"><a href="#二、进程状态转换和组织" class="headerlink" title="二、进程状态转换和组织"></a>二、进程状态转换和组织</h3><p>1、状态</p><ul><li>创建态：进程正在被创建，系统完成创建的一系列工作。</li><li>就绪态：进程准备好进行执行。</li><li>运行态：进程被调度。CPU 正好执行这个程序的程序序列</li><li>阻塞态：进程因为某些原因被阻塞了。</li><li>终止态：进程结束</li></ul><p>2、转换</p><p>转换图：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121644953.png" alt="image-20220312164405817" style="zoom:80%;" /><p>注意：</p><p>​    进程不能由阻塞态直接转换成运行态，也不能从就绪态直接转换成阻塞态。因为阻塞态是进程主动请求的，必须是运行态才能完成这个功能。</p><p>​    进程是可以从运行态转换成就绪态的。例如系统分配的时间片用完了。 </p><h3 id="三、进程控制"><a href="#三、进程控制" class="headerlink" title="三、进程控制"></a>三、进程控制</h3><p>进程控制：进程的状态转换，包括创建、撤销、实现转换等功能。</p><p>1、如何实现?</p><p>是使用原语实现的，原语的实现具有原子性。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
