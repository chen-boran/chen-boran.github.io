<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-19T13:41:35.828Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="http://example.com/2021/11/17/Redis-Sentinel/"/>
    <id>http://example.com/2021/11/17/Redis-Sentinel/</id>
    <published>2021-11-17T13:19:49.000Z</published>
    <updated>2021-11-19T13:41:35.828Z</updated>
    
    <content type="html"><![CDATA[<p>Sentinel（哨岗、哨兵）是Redis的高可用性（highavailability）解决方案</p><p> 首先哨兵主要实现了以下功能： </p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>Sentinel系统监视任意多的主服务器和从服务器，自动升级下线主服务器的从属服务器为主服务器，代理执行原主机的相关工作</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111182216003.png" alt="image-20211118221623916" style="zoom:67%;" /><p>故障转移：解决主服务器下线时长超过设定限度，进行故障的解决的过程</p><p>步骤（以上图为例）：</p><ul><li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li><li>  向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li> Sentinel 继续监视 server1，在它重新上线时，将它设置为新的主服务器的从服务器。</li></ul><p><strong>重点知识脉络</strong>： Sentinel初始化过程；Sentinel和一般Redis服务器的区别；Sentinel监视服务器的方法和原理；Sentinel判断服务器是否在线方法；故障转移详细过程。</p><h2 id="1-启动并初始化Sentinel"><a href="#1-启动并初始化Sentinel" class="headerlink" title="1. 启动并初始化Sentinel"></a>1. 启动并初始化Sentinel</h2><p>启动Sentinel可以使用：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111182345373.png" alt="image-20211118234503273"></p><p>或者：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111182345559.png" alt="image-20211118234559449"></p><p>Sentinel启动大致要经过以下<strong>步骤</strong>：</p><p>​        1）初始化服务器。</p><p>​        2）将普通Redis服务器使用的代码替换成Sentinel专用代码。</p><p>​        3）初始化Sentinel状态。</p><p>​        4）根据给定的配置文件，初始化Sentinel的监视主服务器列表。</p><p>​        5）创建连向主服务器的网络连接。</p><p><strong>说明</strong>：</p><p><strong>Sentinel和一般Redis服务器的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sentinel本质上是运行在特殊环境上的Redis服务器</span><br><span class="line"></span><br><span class="line">​普通Redis服务器使用redis.h/REDIS_SERVERPORT常量的值作为服务器端口 ；</span><br><span class="line"></span><br><span class="line">​Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口 ；</span><br><span class="line"></span><br><span class="line">​在服务器的命令表上存在差别，普通Redis服务器使用redis.c/redisCommandTable S    entinel则使用sentinel.c/sentinelcmds</span><br><span class="line"></span><br><span class="line">​在Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令(未载入)</span><br><span class="line"></span><br><span class="line">​Sentinel可以执行的命令： (PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE)</span><br></pre></td></tr></table></figure><p><strong>创建连向主服务器的网络连接</strong></p><p> 每个被 监视的主服务器，都会与Sentinel创建两个异步网络连接：</p><p>❑ 命令连接： 专门用于向主服务器发送命令，并接收命令回复。</p><p>❑ 订阅连接：专门用于订阅主服务器的__sentinel__:hello频道。</p><p>为什么是异步网络连接？：Sentinel需要与多个实例创建多个网络连接</p><p>链接示例图：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190000569.png" alt="image-20211119000053403" style="zoom:67%;" /><h2 id="2-获取主服务器信息"><a href="#2-获取主服务器信息" class="headerlink" title="2.获取主服务器信息"></a>2.获取主服务器信息</h2><p>Sentinel已经创建成功，连接建立完毕，接着就是哨兵如何对主服务器进行监听。</p><p>Sentinel默认以每十秒一次的频率，向被监视的主服务器发送INFO命令（命令连接），分析INFO命令的回复来获取主服务器的当前信息。</p><p>获取信息通常有以下两方面：</p><ul><li><p>关于主服务器本身的信息，run_id域记录的服务器运行ID，role域记录的服务器角色；</p></li><li><p>关于主服务器属下所有从服务器的信息（根据从服务器Slave字段）</p><p>ip=域记录了从服务器的IP地址，</p><p>port=域则记录了从服务器的端口号。根据IP地址和端口号，Sentinel自动发现从服务器。</p></li></ul><p>主服务器回复信息示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190006659.png" alt="image-20211119000657543"></p><p>根据返回信息，Sentinel对主服务器实例结构进行更新，并由主服务器更新其实例结构字典（记录slave的从服务器信息）</p><h2 id="3-获取从服务器信息"><a href="#3-获取从服务器信息" class="headerlink" title="3.获取从服务器信息"></a>3.获取从服务器信息</h2><p>Sentinel发现主服务器有新的从服务器出现时，Sentinel会为这个新的从服务器创建相应的实例结构之外， 还会创建连接到从服务器的命令连接和订阅连接</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190012033.png" alt="image-20211119001225887"></p><p>和主服务器相同Sentinel每十秒一次发送INFO命令，获取信息</p><p>举例如下：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111190013205.png" alt="image-20211119001352120" style="zoom:67%;" /><p>注：图中包含以下信息</p><p>​        ❑从服务器的运行ID run_id。</p><p>​        ❑从服务器的角色role。</p><p>​        ❑主服务器的IP地址master_host，以及主服务器的端口号master_port。</p><p>​        ❑主从服务器的连接状态master_link_status。</p><p>​        ❑从服务器的优先级slave_priority。</p><p>​        ❑从服务器的复制偏移量slave_repl_offset。</p><p>根据这些信息，Sentinel 对从服务器的实例结构进行更新</p><h2 id="4-向主服务器和从服务器发送信息"><a href="#4-向主服务器和从服务器发送信息" class="headerlink" title="4 向主服务器和从服务器发送信息"></a>4 向主服务器和从服务器发送信息</h2><p>Sentinel系统，通过命令连接向主从服务器发送消息，来进行信息交换，控制等效果</p><p>命令中通常包含以下内容：</p><ul><li><p>和Sentinel相关的参数</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111192040224.png" alt="image-20211119203756108"></p></li><li><p>和主服务器有关的参数</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111192040631.png" alt="image-20211119203820574"></p></li></ul><h2 id="5-接收来自主服务器和从服务器的频道信息"><a href="#5-接收来自主服务器和从服务器的频道信息" class="headerlink" title="5.接收来自主服务器和从服务器的频道信息"></a>5.接收来自主服务器和从服务器的频道信息</h2><p>Sentinel与一个主服务器或者从服务器建立起订阅连接之后，就会通过订阅连接发送以下命令</p><p>Sentinel对 频道的订阅会一直持续到Sentinel与服务器的连接断开为止</p><ul><li> 对每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息</li><li>监视一个服务器的多个Sentinel之间信息都是共享的，用来更新各自对于服务器和其他Sentinel的认知</li></ul><p><strong>更新sentinels字典</strong></p><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料</p><p>举个例子：一个Sentinel接受来自来自其他Sentinel的信息之后，会提取其主要信息（与Sentinel和服务器有关的参数），根据主服务器参数在自己的master字典中找到相应服务器的实例结构并更新</p><p>（如果发送信息的Sentinel之前不存在，就新创建）</p><p><strong>连向其他Sentinel的命令连接</strong></p><p>Sentinel发现新的Sentinel时，会在sentinel字典中创建相关实例，并且创建与其连接的命令连接</p><p>因此，监视同一服务器的Sentinel之间会形成互通的网络，可以互相发送命令请求来进行信息交换。</p><p>注：Sentinel之间不会创建订阅连接</p><h2 id="6-检测主观下线状态"><a href="#6-检测主观下线状态" class="headerlink" title="6.检测主观下线状态"></a>6.检测主观下线状态</h2><p>Sentinel与服务器之间连接创建成功，Sentinel会连续不断的监视服务器的状态</p><p>默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从</p><p>服务器、其他Sentinel在内）发送PING命令，通过返回的回复判断实例是否在线</p><p><strong>回复的种类</strong></p><p>​    ❑有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种。</p><p>​    ❑无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者</p><p>在指定时限内没有返回任何回复。</p><p>如果一个实例在down-after-milliseconds设定的时间（毫秒）内，都向Sentinel返回无效回复，Sentinel就会确定该主机处于下线状态修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识。</p><p>注：多个Sentinel设置的主观下线时长可能不同</p><h2 id="7-检查客观下线状态"><a href="#7-检查客观下线状态" class="headerlink" title="7 检查客观下线状态"></a>7 检查客观下线状态</h2><p>判断主观下线之后，需要进一步进行确定，排除其他不必要的原因，进行客观下线状态检查</p><p> 通过向同样监视这一主服务器的其他Sentinel进行询问， 看是否有满足一定数量的其他Sentinel也认为该主服务器进入下线状态。满足条件 Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p><ul><li><p>一般通过  is-master-down-by-addr命令在各个Sentinel之间确定主观下线状态</p></li><li><p>不同Sentinel判断客观下线的条件可能不同（满足一定数量的Sentinel都认为主服务器已经处于下线状态）</p></li></ul><h2 id="8-选举领头Sentinel"><a href="#8-选举领头Sentinel" class="headerlink" title="8 选举领头Sentinel"></a>8 选举领头Sentinel</h2><p>当主服务器最终被确定已经客观下线，监视他的Sentinel们就要选举出一个新的领头Sentinel，由领头Sentinel对其他从服务器进行故障转移</p><p><strong>规则</strong></p><p>规则较多，举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❑所有在线的Sentinel都有被选为领头Sentinel的资格， </span><br><span class="line"></span><br><span class="line">❑每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configurationepoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。</span><br><span class="line"></span><br><span class="line"> ❑每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</span><br><span class="line"></span><br><span class="line">❑当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</span><br><span class="line"></span><br><span class="line">❑Sentinel设置局部领头Sentinel的规则是先到先得： </span><br><span class="line"></span><br><span class="line">❑领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentine </span><br><span class="line"></span><br><span class="line">在一个配置纪元里面，只会出现一个领头Sentinel。 </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="9-故障的转移"><a href="#9-故障的转移" class="headerlink" title="9.故障的转移"></a>9.故障的转移</h2><blockquote><p>新的主库选择出来后，就可以开始进行故障的转移了。</p></blockquote><p>（我们假设：判断主库客观下线了，同时选出<code>sentinel 3</code>是哨兵leader）</p><p><strong>故障转移流程如下</strong>：</p><p><img src="https://www.pdai.tech/_images/db/redis/db-redis-sen-4.png" alt="img"></p><ul><li>将slave-1脱离原从节点（PS: 5.0 中应该是<code>replicaof no one</code>)，升级主节点，</li><li>将从节点slave-2指向新的主节点</li><li>通知客户端主节点已更换</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点</li></ul><p><strong>转移之后</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111192131841.png" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>总的来说就是进行了以下步骤：</p><p>1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</p><p>2）让已下线主服务器属下的所有从服务器改为复制新的主服务器。</p><p>3）将已下线主服务器设置为新的主服务器的从服务器，当 旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</p><p><strong>新主服务器选举</strong></p><p>在所有的从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将其变成主服务器。</p><p>发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升</p><p>级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，直到其状态变成master</p><p><strong>修改从服务器的复制目标</strong></p><p>所有从服务器去复制新的主服务器，通过领头Sentinel向剩下的所有从服务器发送Slaveof命令来实现。</p><p><strong>旧的主服务器变为从服务器</strong></p><p>已下线的主服务器设置为新的主服务器的从服务器，这种设置保存在旧主服务器对应的实例结构中。并且由Sentine控制执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Sentinel（哨岗、哨兵）是Redis的高可用性（highavailability）解决方案&lt;/p&gt;
&lt;p&gt; 首先哨兵主要实现了以下功能： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：哨兵会不断地检查主节点和从节点是否运作</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>String StringBuilder StringBuffer</title>
    <link href="http://example.com/2021/11/16/String-StringBuilder-StringBuffer/"/>
    <id>http://example.com/2021/11/16/String-StringBuilder-StringBuffer/</id>
    <published>2021-11-15T16:12:22.000Z</published>
    <updated>2021-11-15T16:22:33.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自： <a href="https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q">https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q?</a></p><h1 id="探秘Java中String、StringBuilder以及StringBuffer"><a href="#探秘Java中String、StringBuilder以及StringBuffer" class="headerlink" title="探秘Java中String、StringBuilder以及StringBuffer"></a>探秘Java中String、StringBuilder以及StringBuffer</h1><p>​    相信String这个类是Java中使用得最频繁的类之一，并且又是各大公司面试喜欢问到的地方，今天就来和大家一起学习一下String、StringBuilder和StringBuffer这几个类，分析它们的异同点以及了解各个类适用的场景。下面是本文的目录大纲：</p><p>　　一.你了解String类吗？</p><p>　　二.深入理解String、StringBuffer、StringBuilder</p><p>　　三.不同场景下三个类的性能测试</p><p>　　四.常见的关于String、StringBuffer的面试题（辟谣网上流传的一些曲解String类的说法）</p><h2 id="一-你了解String类吗？"><a href="#一-你了解String类吗？" class="headerlink" title="一.你了解String类吗？"></a><strong>一.你了解String类吗？</strong></h2><p>　　想要了解一个类，最好的办法就是看这个类的实现源代码，String类的实现在</p><p>　　\jdk1.6.0_14\src\java\lang\String.java  文件中。</p><p>　　打开这个类文件就会发现String类是被final修饰的：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017404.webp" alt="图片"></p><p>​    从上面可以看出几点：</p><p>　　1）String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。</p><p>　　2）上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。</p><p>　　下面再继续看String类的一些方法实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line"></span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (endIndex &gt; count) &#123;</span><br><span class="line"></span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (beginIndex &gt; endIndex) &#123;</span><br><span class="line"></span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :</span><br><span class="line"></span><br><span class="line">        new String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> public String concat(String str) &#123;</span><br><span class="line"></span><br><span class="line">    int otherLen = str.length();</span><br><span class="line"></span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char buf[] = new char[count + otherLen];</span><br><span class="line"></span><br><span class="line">    getChars(0, count, buf, 0);</span><br><span class="line"></span><br><span class="line">    str.getChars(0, otherLen, buf, count);</span><br><span class="line"></span><br><span class="line">    return new String(0, count + otherLen, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> public String replace(char oldChar, char newChar) &#123;</span><br><span class="line"></span><br><span class="line">    if (oldChar != newChar) &#123;</span><br><span class="line"></span><br><span class="line">        int len = count;</span><br><span class="line"></span><br><span class="line">        int i = -1;</span><br><span class="line"></span><br><span class="line">        char[] val = value; /* avoid getfield opcode */</span><br><span class="line"></span><br><span class="line">        int off = offset;   /* avoid getfield opcode */</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        while (++i &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">        if (val[off + i] == oldChar) &#123;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (i &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">        char buf[] = new char[len];</span><br><span class="line"></span><br><span class="line">        for (int j = 0 ; j &lt; i ; j++) &#123;</span><br><span class="line"></span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">            char c = val[off + i];</span><br><span class="line"></span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new String(0, len, buf);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br></pre></td></tr></table></figure><p>　　从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。</p><p>　　在这里要永远记住一点：</p><p>　　“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。</p><p>　　在了解了于String类基础的知识后，下面来看一些在平常使用中容易忽略和混淆的地方。</p><h2 id="二-深入理解String、StringBuffer、StringBuilder"><a href="#二-深入理解String、StringBuffer、StringBuilder" class="headerlink" title="二.深入理解String、StringBuffer、StringBuilder"></a><strong>二.深入理解String、StringBuffer、StringBuilder</strong></h2><p>1.String str=”hello world”和String str=new String(“hello world”)的区别</p><p>　　想必大家对上面2个语句都不陌生，在平时写代码的过程中也经常遇到，那么它们到底有什么区别和联系呢？下面先看几个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str2 = new String(&quot;hello world&quot;);</span><br><span class="line">        String str3 = &quot;hello world&quot;;</span><br><span class="line">        String str4 = new String(&quot;hello world&quot;)</span><br><span class="line">        System.out.println(str1==str2);</span><br><span class="line">        System.out.println(str1==str3);</span><br><span class="line">        System.out.println(str2==str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　输出结果为</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012505.webp" alt="图片"></p><p>　　为什么会出现这样的结果？下面解释一下原因：</p><p>　　在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。</p><p>　　因此在上述代码中，String str1 = “hello world”;和String str3 = “hello world”; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量”hello world”被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。</p><p>　　总所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。</p><p>2.String、StringBuffer以及StringBuilder的区别</p><p>　　既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？</p><p>　　那么看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String string = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line"></span><br><span class="line">            string += &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这句 string += “hello”;的过程相当于将原有的string变量指向的对象内容取出与”hello”作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017332.webp" alt="图片"></p><p>　　从这段反编译出的字节码文件可以很清楚地看出：从第8行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。从上面还可以看出：string+=”hello”的操作事实上会自动被JVM优化成：</p><p>　　StringBuilder str = new StringBuilder(string);</p><p>　　str.append(“hello”);</p><p>　　str.toString();</p><p>　　再看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line"></span><br><span class="line">            stringBuilder.append(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　反编译字节码文件得到：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017970.webp" alt="图片"></p><p>　　从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。</p><p>　　那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全的。</p><p>　　下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现：</p><p>　　</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160020813.png" alt="image-20211116002034612"></p><h2 id="三-不同场景下三个类的性能测试"><a href="#三-不同场景下三个类的性能测试" class="headerlink" title="三.不同场景下三个类的性能测试"></a><strong>三.不同场景下三个类的性能测试</strong></h2><p>　　从第二节我们已经看出了三个类的区别，这一小节我们来做个小测试，来测试一下三个类的性能区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int time = 50000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        testString();</span><br><span class="line"></span><br><span class="line">        testStringBuffer();</span><br><span class="line"></span><br><span class="line">        testStringBuilder();</span><br><span class="line"></span><br><span class="line">        test1String();</span><br><span class="line"></span><br><span class="line">        test2String();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void testString () &#123;</span><br><span class="line"></span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            s += &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+s.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void testStringBuffer () &#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+sb.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void testStringBuilder () &#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+sb.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void test1String () &#123;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            String s = &quot;I&quot;+&quot;love&quot;+&quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;字符串直接相加操作：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    public static void test2String () &#123;</span><br><span class="line"></span><br><span class="line">        String s1 =&quot;I&quot;;</span><br><span class="line"></span><br><span class="line">        String s2 = &quot;love&quot;;</span><br><span class="line"></span><br><span class="line">        String s3 = &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            String s = s1+s2+s3;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;字符串间接相加操作：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　测试结果（win7，Eclipse，JDK6)：</p><p>　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012621.webp" alt="图片"></p><p>　　上面提到string+=”hello”的操作事实上会自动被JVM优化，看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int time = 50000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        testString();</span><br><span class="line"></span><br><span class="line">        testOptimalString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testString () &#123;</span><br><span class="line"></span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            s += &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;操作&quot;+s.getClass().getName()+&quot;类型使用的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    public static void testOptimalString () &#123;</span><br><span class="line"></span><br><span class="line">        String s=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;time; i++)&#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb = new StringBuilder(s);</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">            s=sb.toString();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;模拟JVM优化操作的时间为：&quot;+(over-begin)+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　执行结果：</p><p>　　 <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160017968.webp" alt="图片"></p><p>　　得到验证。</p><p>　　下面对上面的执行结果进行一般性的解释：</p><p>　　1）对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。这个可以用javap -c命令反编译生成的class文件进行验证。</p><p>　　对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。</p><p>　　2）String、StringBuilder、StringBuffer三者的执行效率：</p><p>　　StringBuilder &gt; StringBuffer &gt; String</p><p>　　当然这个是相对的，不一定在所有情况下都是这样。</p><p>　　比如String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高。</p><p>　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：</p><p>　　当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；</p><p>　　当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。</p><h2 id="四-常见的关于String、StringBuffer的面试题"><a href="#四-常见的关于String、StringBuffer的面试题" class="headerlink" title="四.常见的关于String、StringBuffer的面试题"></a><strong>四.常见的关于String、StringBuffer的面试题</strong></h2><p>　　下面是一些常见的关于String、StringBuffer的一些面试笔试题，若有不正之处，请谅解和批评指正。</p><p>\1. 下面这段代码的输出结果是什么？</p><p>　　String a = “hello2”; 　　String b = “hello” + 2; 　　System.out.println((a == b));</p><p>　　输出结果为：true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。</p><p>2.下面这段代码的输出结果是什么？</p><p>　　String a = “hello2”; 　 String b = “hello”;    String c = b + 2;    System.out.println((a == c));</p><p>　　输出结果为:false。由于有符号引用的存在，所以 String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。javap -c得到的内容：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012087.webp" alt="图片"></p><p>3.下面这段代码的输出结果是什么？</p><p>　　String a = “hello2”;  　 final String b = “hello”;    String c = b + 2;    System.out.println((a == c));</p><p>　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2; 下图是javap -c的内容：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012377.webp" alt="图片"></p><p>4.下面这段代码输出结果为：</p><table><thead><tr><th></th><th>public class Main {  public static void main(String[] args) {    String a = “hello2”;    final String b = getHello();    String c = b + 2;    System.out.println((a == c));  }     public static String getHello() {    return “hello”;  }}</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。</p><p>5.下面这段代码的输出结果是什么？</p><table><thead><tr><th></th><th>public class Main {  public static void main(String[] args) {    String a = “hello”;    String b = new String(“hello”);    String c = new String(“hello”);    String d = b.intern();         System.out.println(a==b);    System.out.println(b==c);    System.out.println(b==d);    System.out.println(a==d);  }}</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　输出结果为（JDK版本 JDK6)：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012351.webp" alt="图片"></p><p>　　这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。</p><p>6.String str = new String(“abc”)创建了多少个对象？</p><p>　　这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。</p><p>　　首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012569.webp" alt="图片"></p><p>　　很显然，new只调用了一次，也就是说只创建了一个对象。</p><p>　　而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了”abc”对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个”abc”对象，而在代码执行过程中确实只创建了一个String对象。</p><p>　　因此，这个问题如果换成 String str = new String(“abc”)涉及到几个String对象？合理的解释是2个。</p><p>　　个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。</p><p>7.下面这段代码1）和2）的区别是什么？</p><table><thead><tr><th></th><th>public class Main {  public static void main(String[] args) {    String str1 = “I”;    //str1 += “love”+”java”;    1)    str1 = str1+”love”+”java”;   //2)       }}</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>　　1）的效率比2）的效率要高，1）中的”love”+”java”在编译期间会被优化成”lovejava”，而2）中的不会被优化。下面是两种方式的字节码：</p><p>　　1）的字节码：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160022397.webp" alt="图片"></p><p>　　2）的字节码：</p><p>　　<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111160012654.webp" alt="图片"></p><p>　　可以看出，在1）中只进行了一次append操作，而在2）中进行了两次append操作。</p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自： &lt;a href=&quot;https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q&quot;&gt;https://mp.weixin.qq.com/s/X8nb65ADEQfT4kSNvTti-Q?&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;探秘J</summary>
      
    
    
    
    <category term="转载学习" scheme="http://example.com/categories/%E8%BD%AC%E8%BD%BD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Redis 复制</title>
    <link href="http://example.com/2021/11/15/Redis-%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2021/11/15/Redis-%E5%A4%8D%E5%88%B6/</id>
    <published>2021-11-15T14:12:00.000Z</published>
    <updated>2021-11-17T13:17:43.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>通过SLAVEOF 命令进行复制</p> <img src="https://i.loli.net/2021/11/17/81Dy94AgbwFop6B.png" alt="image-20211117210636423" style="zoom:67%;" /><p>被复制的叫做主服务器，相反，对主服务器进行复制的叫做从服务器</p><p>两个服务器经过复制之后数据库状态一致。</p><p>Redis2.8 版本前后对于服务器断线重连复制的问题解决方案不同，因此下面分两部分具体讨论。</p><h2 id="1-旧版复制实现"><a href="#1-旧版复制实现" class="headerlink" title="1.旧版复制实现"></a>1.旧版复制实现</h2><p>Redis2.8 版本之前</p><p>首先了解一些基本概念 ：</p><p>复制分为同步和命令传播</p><ul><li>同步： 从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播： 用于在主服务器的数据库状态修改， 主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li></ul><h3 id="1-1同步"><a href="#1-1同步" class="headerlink" title="1.1同步"></a>1.1同步</h3><p>通过SYNC命令实现</p><p>具体步骤如下：</p><p>1）从服务器向主服务器发送SYNC命令。</p><p>2）主服务器收到命令之后使用BGSAVE生成 RDB文件， 并且使用 缓冲区记录从现在开始执行的所有写命令。</p><p>3）当主服务器的BGSAVE命令执行完毕时， 将生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</p><p>4）主服务器将缓冲区内容发送给从服务器，从服务器进而将自身的数据库状态更新至主服务器数据库当前所处的状态。</p><img src="https://i.loli.net/2021/11/17/ATBDEmIwagXUzHu.png" alt="image-20211117202010473" style="zoom:80%;" /><p><strong>命令传播</strong></p><p>同步完成之后，主从服务器状态达到一致。主服务器执行相关写命令时这种状态将会被改变。</p><p>为了保持状态的一致性，主服务需要对从服务器进行命令传播：即将主服务器执行的命令动态发送给从服务器。</p><h2 id="2、旧版复制缺陷"><a href="#2、旧版复制缺陷" class="headerlink" title="2、旧版复制缺陷"></a>2、旧版复制缺陷</h2><p>通常复制的状态分成两种：初次和复制和断线后重复制</p><ul><li>初次复制：从服务器之前没有复制过任何主服务器</li><li>断线后重复制：从服务器复制时，因某些原因断线，重新连接之后复制的问题。</li></ul><p>新旧复制在初次复制处理没有太大区别，在断线重复值上面旧版复制效率十分低下。新版进行了解决。</p><p>旧版复制断线之后，从服务器重新连接，会重新新进行复制，包括断线状态时，主机进行的新的写操作。断线之前进行定复制操作全部丢弃。</p><p>注：SYNC命令是一个非常耗费资源的操作， 会耗费主服务器大量的CPU、内存和磁盘I/O资源，</p><p> 耗费主从服务器大量的网络资源。</p><h2 id="3、新版复制功能"><a href="#3、新版复制功能" class="headerlink" title="3、新版复制功能"></a>3、新版复制功能</h2><p>Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p><p>PSYNC命令 分成完整重同步 和部分重同步 </p><p>❑ 完整重同步：处理初次复制情况 ，其步骤和SYNC命令相同</p><p>❑ 部分重同步：用于处理断线后重复制情况，冲服务器如果条件允许，从服务器断线重连，主服务器将连接断开期间执行的写命令发送给从服务器，从服务器 根据这些命令进行状态同步（用来解决旧版重复制是效率低下的问题）</p><p><img src="https://i.loli.net/2021/11/17/GuqR9MIkO674aWK.png" alt="image-20211117204237041"></p><h2 id="4、部分重同步实现"><a href="#4、部分重同步实现" class="headerlink" title="4、部分重同步实现"></a>4、部分重同步实现</h2><p>具体分成以下三个组成部分：</p><p>❑主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。</p><p>❑主服务器的复制积压缓冲区（replicationbacklog）。</p><p>❑服务器的运行ID（run ID）。</p><p><strong>复制偏移量：</strong>主从服务器分别维护的一个状态量，两服务器每次传输一字节数据，复制偏移量都会变化1。对比主从服务器的复制偏移量，程序可以 知道主从服务器是否处于一致状态</p><p><strong>复制积压缓冲区</strong> ：（用于判断进行部分重同步还是完整重同步）</p><p>由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。</p><ul><li>当主服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区中</li><li>复制缓冲区保存一部分最近传播的命令</li><li>从服务器重连 ，从服务器通过PSYNC命令将自己的复制偏移量offset发送给主服务器</li><li>主服务器根据offset进行判断进行何种操作<ul><li>offset偏移量之后的数据 存在于复制积压缓冲区里面， 主服务器将对从服务器执行部分重同步操作</li><li>offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li></ul></li></ul><p>注：Redis为复制积压缓冲区设置的默认大小为1MB，可以自行调整。</p><p>​        复制积压缓冲区的最小大小可以根据公式second*write_size_per_second来估算</p><p><strong>服务器运行ID</strong>：主从服务器都有的六进制字符属性</p><ul><li>主从服务器初次复制时，主服务器发送自身运行ID 给从服务器进行保存</li><li>如果断线重连，通过比较运行ID，判断之前连接的服务器是否是同一个<ul><li>相同，进行复制缓冲区判断，决定是否进行部分重复制</li><li>不同，直接进行完整重同步</li></ul></li></ul><h2 id="5、PSYNC-的实现"><a href="#5、PSYNC-的实现" class="headerlink" title="5、PSYNC 的实现"></a>5、PSYNC 的实现</h2><p>psync的调用方法：</p><ul><li><p>从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令（哨兵选举主服务器时的操作）</p></li><li><p> 从服务器已经复制过某个主服务器， 从服务器在开始一次新的复制时就将向主服务器发送PSYNC ＜runid＞ ＜offset＞命令</p></li></ul>  <!--runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量--><p>主服务器接收psync命令后有三种返回状态：</p><ul><li><p>返回+FULLRESYNC ＜runid＞ ＜offset＞：表示执行完整重同步</p></li><li><p>主服务器返回+CONTINUE：主从服务器执行部分重同步，从服务器等待主服务器发送自身缺少的命令数据</p></li><li><p>主服务器返回+CONTINUE： 主服务器的版本低于Redis 2.8，不能识别PSYNC命令，之后从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</p><p>图15-12 PSYNC执行完整重同步和部分重同步时可能遇上的情况：</p></li></ul><img src="https://i.loli.net/2021/11/17/aT9PpAujX8l3dh5.png" alt="image-20211117210438067" style="zoom:80%;" /><h2 id="6、复制的实现"><a href="#6、复制的实现" class="headerlink" title="6、复制的实现"></a>6、复制的实现</h2><p>下面举例说明 Redis2.8或以上版本的复制功能的 实现步骤。</p><p>步骤1：设置主服务器的地址和端口</p><p>步骤3：发送PING命令</p><p>步骤3：发送PING命令</p><p>步骤4：身份验证</p><p> 步骤5：发送端口信息</p><p>步骤6：同步</p><p>步骤7：命令传播</p><h2 id="7、心跳检测"><a href="#7、心跳检测" class="headerlink" title="7、心跳检测"></a>7、心跳检测</h2><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p><p><img src="https://i.loli.net/2021/11/17/dwYsgN6SmbBPIvy.png" alt="image-20211117210958609"></p><p>有三个作用： ❑检测主从服务器的网络连接状态。</p><p>​                        ❑辅助实现min-slaves选项。</p><p>​                        ❑检测命令丢失。</p><p><strong>检测主从服务器的网络连接状态：</strong></p><p>主从服务器 通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接  主服务器一秒钟之内未收到从服务器 发来的REPLCONF ACK命令，主从服务器之间的网络连接出现了问题</p><p><strong>辅助实现min-slaves选项</strong>：</p><p>min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令（在一定的延迟或者从服务器链接数量下，主服务器都可能拒绝写命令）</p><p><strong>检测命令丢失</strong></p><p>通过发送的offset确定两者是否状态一致，命令是否丢失</p><p>注：Redis 2.8版本以前的命令丢失，主服务器和从服务器都不会注意到，主服务器更不会向从服务器补发丢失的数据。因此尽量使用2.8或以上版本的Redis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot; title=&quot;复制&quot;&gt;&lt;/a&gt;复制&lt;/h1&gt;&lt;p&gt;通过SLAVEOF 命令进行复制&lt;/p&gt;
 &lt;img src=&quot;https://i.loli.net/2021/11/17/81Dy94Ag</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 客户端与服务器</title>
    <link href="http://example.com/2021/11/14/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/11/14/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-11-14T12:14:31.000Z</published>
    <updated>2021-11-14T12:15:20.460Z</updated>
    
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化</title>
    <link href="http://example.com/2021/11/14/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2021/11/14/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-11-14T12:14:13.000Z</published>
    <updated>2021-11-15T14:09:25.212Z</updated>
    
    <content type="html"><![CDATA[<p>持久化：将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p> Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库</p><h2 id="一、RDB-持久化"><a href="#一、RDB-持久化" class="headerlink" title="一、RDB 持久化"></a>一、RDB 持久化</h2><p> RDB 持久化可以选择手动执行和 定期执行（根据服务器选项），意图将数据库某一时间的状态保存到一个二进制的RDB 文件中。</p><p>RDB文件保存在硬盘中，不受服务器开关机状态的影响</p><h3 id="1-RDB文件-载入与创建"><a href="#1-RDB文件-载入与创建" class="headerlink" title="1.RDB文件 载入与创建"></a>1.RDB文件 载入与创建</h3><p><strong>创建：</strong>通常使用 SAVE 和BGSAVE两个命令创建</p><ul><li>SAVE ：由服务器主进程创建文件，阻塞服务器其他进程</li><li>BGSAVE ：由服务器派生子进程创建RDB文件，父进程急需处理其他请求</li></ul><p>实际工作由rdb.c/rdbSave函数</p><p><strong>注：</strong></p><p>AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>服务器开启了AOF持久化功能，则会优先使用AOF文件来还原数据库状态。</li><li>AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152042711.png" alt="image-20211115204243601" style="zoom:80%;" /><p><strong>载入：</strong></p><p>载入RDB文件的实际工作由rdb.c/rdbLoad函数完成</p><p><strong>服务器状态</strong></p><ul><li>执行SAVE时：客户端所有命令被阻塞</li><li>BGSAVE：服务器拒绝SAVE，BGSAVE命令，BGREWRITEAOF和BGSAVE两个命令不能同时执行（性能原因）</li><li>RDB 文件载入时:服务器一直被阻塞</li></ul><h2 id="2-自动间隔性保存"><a href="#2-自动间隔性保存" class="headerlink" title="2.自动间隔性保存"></a>2.自动间隔性保存</h2><p> BGSAVE命令可以在不阻塞服务器进程的情况下执行， 用户通过设置服务器配置的save选项来设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><p>例如：save 900 1</p><p>​    表示服务器在九百秒内至少进行了一次修改，则执行BGSAVE命令</p><p><strong>设置保存条件</strong></p><p>若用户没有主动设置save选项，服务器会为save选项设置默认条件：</p><p> 服务器程序根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：（每个saveparam结构都保存了一个save选项设置的保存条件）</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152107791.png" alt="image-20211115210704732"></p><p><strong>dirty计数器和lastsave属性</strong></p><ul><li><p>dirty计数器：从上一次成功生成磁盘文件之后进行修改的次数（每次加一）</p></li><li><p>lastsave：UNIX时间戳，记录上一次生成RDB文件的时间点</p></li></ul><p><strong>检查保存条件</strong></p><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，通过它检查save选项所设置的保存条件是否已经满足 </p><p>流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152112273.png" alt="image-20211115211222220"></p><h3 id="3-RDB文件结构"><a href="#3-RDB文件结构" class="headerlink" title="3.RDB文件结构"></a>3.RDB文件结构</h3><p>完整结构图：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152113546.png" alt="image-20211115211307502" style="zoom:80%;" /><p> 简要说明：</p><table><thead><tr><th>名称</th><th></th><th></th></tr></thead><tbody><tr><td>REDIS</td><td>五字节</td><td>‘R’、’E’、’D’、’I’、’S’五个字符</td></tr><tr><td>db_version</td><td>四字节</td><td>这个整数记录了RDB文件的版本号</td></tr><tr><td>databace</td><td>··</td><td>包含着零个或任意多个数据库，以及各个数据库中的键值对数据</td></tr><tr><td>EOF</td><td>一字节</td><td>包含着零个或任意多个数据库，以及各个数据库中的键值对数据</td></tr><tr><td>check_sum</td><td></td><td>和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的校验和</td></tr></tbody></table><p><strong>databace</strong></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152118809.png" alt="image-20211115211857775" style="zoom:80%;" /><ul><li><p>SELECTDB常量 ，1字节 预示接下来读入的将是一个数据库号码。</p></li><li><p>db_number保存着一个数据库号码， 这个部分的长度可以是1字节、2字节或者5字节。 </p></li><li><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。 </p><p> key_value_pairs分成带过期时间和不带过期时间两种键值对：</p><ul><li><p>不带过期时间的键值对由TYPE、key、value三部分组成</p><ul><li>TYPE：记录VALUE的类型决定如何读入和解释value的数据</li><li>key：键值对键对象</li><li>value：键值对值对象</li></ul></li><li><p>带过期时间的额外有EXPIRETIME_MS和ms两个部分：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152127767.png" alt="image-20211115212704720" style="zoom:50%;" /><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul></li></ul></li></ul><p><strong>VALUE编码</strong></p><p> 每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><p>value可以使五种基本对象中的任意一种。</p><h3 id="4-分析RDB"><a href="#4-分析RDB" class="headerlink" title="4. 分析RDB"></a>4. 分析RDB</h3><p>通常使用od命令分析Redis服务器产生的RDB文件 </p><p>例如：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152132106.png" alt="image-20211115213211057"></p><p>下面举例说明RDB文件中各个标识含义：</p><p>  包含带有过期时间的字符串键的RDB文件</p><p>打印RDB文件：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152134622.png" alt="image-20211115213450589"></p><p>❑一个一字节长的EXPIRETIME_MS特殊值。</p><p>❑一个八字节长的过期时间（ms）。</p><p>❑一个一字节长的类型（TYPE）。</p><p>❑一个键（key）和一个值（value）。根据这些特征，可以得出RDB文件各个部分的意义：❑REDIS0006：RDB文件标志和版本号。</p><p>❑376\0：切换到0号数据库。</p><p>❑374：代表特殊值EXPIRETIME_MS。</p><p>❑\2 365 336@001\0\0：代表八字节长的过期时间。</p><p>❑\0 003 M S G：\0表示这是一个字符串键，003是键的长度，MSG是键。</p><p>❑005 H E L L O：005是值的长度，HELLO是值。</p><p>❑377：代表EOF常量。</p><p>❑212 231 x 247 252 } 021 306：代表八字节长的校验和。</p><h2 id="二、AOF持久化"><a href="#二、AOF持久化" class="headerlink" title="二、AOF持久化"></a>二、AOF持久化</h2><p>与RDB 持久化不同AOF 持久化通过保存数据库写命令来记录状态</p><p>写入AOF 文件的命令都会以redis命令请求协议格式保存</p><h3 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h3><p><strong>命令追加</strong></p><p>当AOF处于打开时，每次完成一个写命令，都会在服务器状态的aof_buf缓冲区追加相应的写命令</p><p><strong>写入与同步</strong></p><p> 服务器每次结束一个事件循环之前， 都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件中</p><p>最后调用flushAppendOnlyFile函数，其行为由服务器配置的appendfsync选项的值决定</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152148921.png" alt="image-20211115214826867"></p><p>默认是everysec</p><p>注：为了提高文件写效率，通常将写数据加入内存缓冲区，到达一定条件之后再写入磁盘</p><p>​        因此：系统提供了fsync和fdatasync两个同步函数， 可以强制让操作系统立即将缓冲区中的数据    写入到硬盘 确保写入数据的安全性。</p><p><strong>AOF持久化的效率和安全性</strong></p><p>appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>always：每一个事件都会将aof_buf缓冲区所有内容写入AOF 文件，并且进行同步。效率最慢</li><li>everysec：每一个事件都会将所有内容写入AOF 文件， 每隔一秒 在子线程中对AOF文件进行一次同步</li><li>no：每一个事件都会将所有内容写入AOF 文件，何时对AOF文件进行同步，则由操作系统控制</li></ul><h3 id="2-载入与还原"><a href="#2-载入与还原" class="headerlink" title="2.载入与还原"></a>2.载入与还原</h3><p><strong>载入还原</strong></p><p> 读取AOF文件并还原数据库状态 ,步骤如下:</p><p>1）创建一个不带网络连接的伪客户端（fake client）（ 服务器使用一个没有网络连接的伪客户端来执行AOF文件保存的写命令， 效果与实际使用客户端完全没有影响。）</p><p>2）从AOF文件中分析并读取出一条写命令。</p><p>3）使用伪客户端执行被读出的写命令。</p><p>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111152157784.png" alt="image-20211115215741707" style="zoom:80%;" /><h3 id="3-AOF-重写"><a href="#3-AOF-重写" class="headerlink" title="3.AOF 重写"></a>3.AOF 重写</h3><p>重写：解决AOF文件体积膨胀的问题</p><p>通过读取服务器当前状态实现，解决了之前对于同一个键的大量操作引起臃肿的问题。</p><p>使用 aof_rewrite函数生成的新AOF文件，只包含还原当前数据库状态所必须的命令， 浪费任何硬盘空间。</p><p><strong>后台重写</strong></p><p>重写函数会占用大量的线程时间（Redis服务器使用单个线程来处理命令请求），无法处理客户端请求。</p><p>因此将AOF重写程序放到子进程里执行</p><p>好处：</p><p>❑子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</p><p>❑子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</p><p><strong>重写缓冲区</strong></p><p>同样，重写时主进程进行操作会影响数据库状态，避免这种情况，服务器设置了重写缓冲区，与重写子进程一同开启。</p><p>——&gt;Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区</p><p>——&gt;当子进程完成AOF重写后，向父进程发送信号，父进程把重写缓冲区内容写入到新的AOF文件中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;持久化：将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。&lt;/p&gt;
&lt;p&gt; Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库&lt;/p&gt;
&lt;h2 id=&quot;一、RDB-持久化&quot;&gt;&lt;a href=&quot;#一、RDB-持久化&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据库</title>
    <link href="http://example.com/2021/11/14/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2021/11/14/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-11-14T12:12:56.000Z</published>
    <updated>2021-11-14T13:18:16.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><p>重点掌握：服务器保存数据库方法</p><p>​                    客户端切换数据库的方法</p><p>​                    数据库保存键值对方法</p><p>​                    数据库增删改查更新等操作的实现</p><h2 id="1-服务器中的数据库"><a href="#1-服务器中的数据库" class="headerlink" title="1. 服务器中的数据库"></a>1. 服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，</p><p>数组的每个项都是一个redis.h/redisDb结构</p><p>每个redisDb结构代表一个数据库</p><p>要构建多少个数据库由服务器状态的dbnum决定，默认是16个（db0~db15）</p><h2 id="2-切换数据库"><a href="#2-切换数据库" class="headerlink" title="2.切换数据库"></a>2.切换数据库</h2><p>默认情况适用0号数据库即：db0</p><p>可以使用SELECT命令切换 目标数据库</p><p>服务器中，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库</p><p>是一个指向redisDb的指针，通过更改指针实现数据库的切换。</p><p>图示：客户端使用一号数据库</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111142025992.png" alt="image-20211114202527753"></p><h2 id="3-数据库键空间"><a href="#3-数据库键空间" class="headerlink" title="3. 数据库键空间"></a>3. 数据库键空间</h2><p>Redis是一个键值对（key-value pair）数据库服务器</p><p> 数据库都对应一个redis.h/redisDb结构</p><p>redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）</p><p>说明：</p><ul><li><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。</p></li><li><p>键空间的值也就是数据库的值，每个值可以是 Redis五种基本对象类型任意一种。</p></li></ul><p>键空间举例：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111142030044.png" alt="image-20211114203011821"></p><p><strong>添加键</strong></p><p>即：添加新建到dict中</p><p>使用  SET</p><p><strong>删除键</strong></p><p>使用 DEL </p><p><strong>更新键</strong></p><p>使用 SET加想要更改的 键名 加更改的值</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111142033634.png" alt="image-20211114203359483" style="zoom:80%;" /><p><strong>取值</strong> </p><p>GET 键名</p><p><strong>清空数据库</strong></p><p>FLUSHDB命令（清空键空间所有键值对）</p><h2 id="4-键的生存和过期时间"><a href="#4-键的生存和过期时间" class="headerlink" title="4.键的生存和过期时间"></a>4.键的生存和过期时间</h2><p><strong>设置生存时间</strong>（Time To Live，TTL）</p><p>使用EXPIRE命令或者PEXPIRE（毫秒）命令，客户端可以以秒或者毫秒精度为数据库中的某个键 </p><p><strong>设置过期时间</strong></p><p> 客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）</p><p> 实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111142040344.png" alt="image-20211114204048256"></p><p><strong>保存过期时间</strong></p><p>redisDb的expires字典保存了数据库中所有键的过期时间 ，称为过期字典</p><p>❑过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</p><p>❑过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</p><p>增加过期字典之后，RedisDb结构如下：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111142042813.png" alt="image-20211114204250575" style="zoom:80%;" /><p><strong>移除过期时间</strong> </p><p>PERSIST命令可以移除一个键的过期时间</p><p>对应的过期字典中的键值对被删除</p><p><strong>计算返回剩余生存时间</strong></p><p>通过以下两个命令实现：</p><p>TTL命令以秒为单位返回键的剩余生存时间，</p><p>PTTL命令则以毫秒为单位返回键的剩余生存时间：</p><p>他们都是通过计算键的过期时间和当前时间之间的差来实现的</p><h2 id="5-过期键的删除"><a href="#5-过期键的删除" class="headerlink" title="5.过期键的删除"></a>5.过期键的删除</h2><p>键过期之后的删除策略分为三种：定时删除、惰性删除、定期删除</p><p>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。</p><table><thead><tr><th>策略</th><th>特点</th><th>说明</th><th>常用</th></tr></thead><tbody><tr><td>定时删除</td><td>对内存友好，对CPU时间最不友好</td><td>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</td><td>不常用</td></tr><tr><td>对惰性删除</td><td>对CPU时间最不友好，对CPU 时间最友好</td><td>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键</td><td>常用</td></tr><tr><td>定期删除</td><td>介于前两者之间</td><td>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键</td><td>常用</td></tr></tbody></table><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：配合使用这两种删除策略</p><ul><li><p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现</p></li><li><p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现</p></li></ul><h2 id="6-不同功能对过期键的处理"><a href="#6-不同功能对过期键的处理" class="headerlink" title="6. 不同功能对过期键的处理"></a>6. 不同功能对过期键的处理</h2><p><strong>RDB持久化</strong></p><p>在载入RDB文件时：</p><ul><li>主服务器运行：数据库只载入未过期的键值</li><li>从服务器模式运行：数据库载入所有的键值，无论是否过期，通过主从服务器的数据同步进行数据一致化</li></ul><p><strong>AOF持久化</strong></p><ol><li><p>在创建AOF 文件时，过期键如果还没有被删除，则不会有影响</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p></li><li><p>在载入AOF 文件时过期键不会被保存</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis数据库&quot;&gt;&lt;a href=&quot;#Redis数据库&quot; class=&quot;headerlink&quot; title=&quot;Redis数据库&quot;&gt;&lt;/a&gt;Redis数据库&lt;/h1&gt;&lt;p&gt;重点掌握：服务器保存数据库方法&lt;/p&gt;
&lt;p&gt;​                    客户</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象</title>
    <link href="http://example.com/2021/11/14/Redis%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/11/14/Redis%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-11-14T10:09:11.000Z</published>
    <updated>2021-11-14T12:10:41.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h1><h2 id="1-对象的类型和编码"><a href="#1-对象的类型和编码" class="headerlink" title="1. 对象的类型和编码"></a>1. 对象的类型和编码</h2><p>redis没使用之前提到的数据结构来构建键值对数据库</p><p>而是基于基本数据结构构建了包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种类型对象的对象系统</p><p>使用对象的好处：根据类型判断给定命令是否能够执行；针对不同场景，设置对象的数据结构实现，优化使用效率；可以实现基于引用计数计数的内存回收，对象共享（节约内存）；</p><p>Redis使用两个对象分别表示数据库中的键和值</p><p>Redis中的每个对象都由一个redisObject结构表示，</p><p>该结构中和保存数据有关的三个属性分别是type、encoding、ptr</p><p><strong>一、类型</strong></p><p>对象的类型由type记录</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141856669.png" alt="image-20211114185656361"></p><p>数据库中，键总是一个字符串对象，值则可以是五种对象中的一种。</p><p>称呼数据库键时一般都指的是键的值的类型：例如：列表键，指的是数据库键对应的值是列表对象</p><p>​    使用TYPE 返回 数据库键对应的值对象的类型</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141904420.png" alt="image-20211114190455258"></p><p><strong>二，编码与底层实现</strong></p><p> ptr指针指向对象的底层实现数据结构  </p><p>encoding属性记录了对象所使用的编码 </p><p>基本数据结构对应的编码</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141908765.png" alt="image-20211114190813600" style="zoom:80%;" /><p>每种对象至少使用两种不同编码：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141909934.png" alt="image-20211114190904728" style="zoom:80%;" /><p>使用 <strong>OBJECT Encoding</strong>可以查看数据库键的值对象编码</p><p>下面逐个进行分析各个对象</p><h2 id="2-字符串对象"><a href="#2-字符串对象" class="headerlink" title="2. 字符串对象"></a>2. 字符串对象</h2><p>字符串对象的编码可以是int、raw或者embstr。</p><p>（int 编码是用来保存整数值，而embstr是用来保存短字符串，raw编码是用来保存长字符串）</p><p>最基本的数据结构；字符串的长度不能超过512M。</p><p> <strong>一，编码方式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141922759.png" alt="image-20211114192207607"></p><p><strong>二、编码的转换</strong></p><p>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。</p><p>对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节</p><p><strong>三、命令的实现</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141920440.png" alt="image-20211114192013105"></p><h2 id="3-列表对象"><a href="#3-列表对象" class="headerlink" title="3.列表对象"></a>3.列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>linkedlist编码的列表对象使用双端链表作为底层实现</p><p><strong>一、内存结构</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141923098.png" alt="img"></p><p><strong>二、编码转换</strong></p><p>当列表对象同时满足以下两个条件，则使用ziplist编码（否则使用linkedlist）：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个； </li></ul><p><strong>三、列表命令的实现</strong></p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141926743.png" alt="image-20211114192617413" style="zoom: 80%;" /><h2 id="4-哈希对象"><a href="#4-哈希对象" class="headerlink" title="4.哈希对象"></a>4.哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现</p><p>hashtable编码的哈希对象使用字典作为底层实现</p><p><strong>一、内存结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141929955.png" alt="img"></p><p><strong>二、编码转换</strong></p><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码（否则使用hashtable）：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个 </li></ul><p>注：第一个条件可以通过配置文件中的 <code>set-max-intset-entries</code> 进行修改。</p><p><strong>三、哈希命令的实现</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141928521.png" alt="image-20211114192848168"></p><h2 id="5-集合对象"><a href="#5-集合对象" class="headerlink" title="5. 集合对象"></a>5. 集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现</p><p>intset编码的集合对象使用整数集合作为底层实现</p><p><strong>一、存储结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141932020.png" alt="img"></p><p><strong>二、编码转换</strong></p><p>编码的转换当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li><p>集合对象保存的所有元素都是整数值</p></li><li><p>集合对象保存的元素数量不超过512个。</p><p>注：第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置</p></li></ul><p><strong>三、集合命令的实现</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141935439.png" alt="image-20211114193515168"></p><h2 id="6-有序集合对象"><a href="#6-有序集合对象" class="headerlink" title="6. 有序集合对象"></a>6. 有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现</p><p><strong>一、存储结构</strong></p><p>首先是编码为ZIPLIST时, 有序集合的内存布局如下</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141940209.png" alt="img"></p><p> 编码为SKIPLIST时, 有序集合的内存布局如下</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141940445.png" alt="img"></p><p> <strong>二、编码转换</strong></p><p>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><p>1、保存的元素数量小于128；</p><p>2、保存的所有元素长度都小于64字节。</p><p> 以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改</p><p><strong>三、有序集合命令的实现</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141939509.png" alt="image-20211114193924211"></p><h2 id="7-类型检查和命令多态"><a href="#7-类型检查和命令多态" class="headerlink" title="7. 类型检查和命令多态"></a>7. 类型检查和命令多态</h2><p>Redis中用于操作键的命令可以分为两种类型。</p><p>其中一种命令可以对任何类型的键执行，</p><p>​    例如：DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等</p><p>另一种命令只能对特定类型的键执行 </p><ul><li><p>SET、GET、APPEND、STRLEN等命令只能对字符串键执行；</p></li><li><p>HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；</p></li><li><p>RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；</p></li><li><p>SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；</p></li><li><p>ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；</p><p>相应的键只能执行适合自身类型的键命令</p></li></ul><p>一、类型检查</p><p>执行命令之前需要检查目标键的类型是否符合要求，类型不符合要求则会拒绝命令。</p><p>通过RedisObject中的Type来实现</p><p>二、命令多态</p><p>由于数据库中键的值对象可以有多种类型的实现，相同的命令在确保类型正确的前提下，可以有多种键值对象的实现</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111141953246.png" alt="image-20211114195334038"></p><h2 id="8-内存回收"><a href="#8-内存回收" class="headerlink" title="8. 内存回收"></a>8. 内存回收</h2><p>C语言并不具备自动内存回收功能</p><p> Redis 构建了基于引用计数技术实现的内存回收机制</p><p>每个对象的引用计数信息由redisObject结构的refcount属性记录</p><p>相关的基本规则：</p><ul><li><p>当新创建一个对象时，它的refcount属性被设置为1；</p></li><li><p>当对一个对象进行共享时，redis将这个对象的refcount加一；</p></li><li><p>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一</p></li></ul><h2 id="9-对象共享"><a href="#9-对象共享" class="headerlink" title="9. 对象共享"></a>9. 对象共享</h2><p>对象的引用计数属性还带有对象共享的作用</p><p>Redis中，多个键共享同一个值对象需要执行以下两个步骤：</p><p>​    1）将数据库键的<strong>值指针</strong>指向一个现有的值对象；</p><p>​    2）将被共享的值对象的引用计数增一。</p><p>共享对象是用来节约内存的。（数据库中保存的值对象越多，节省内存越显著）</p><p>注：创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改</p><p>​        共享对象只能被字典和双向链表这类能带有指针的数据结构使用</p><p>通过上面介绍我们知道，对象共享可以共享字符串对象。 </p><p><strong>那么为什么Redis不共享包含字符串的对象</strong>？</p><ul><li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li><li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li><li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li></ul><p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的</p><hr><h2 id="10-空转时长"><a href="#10-空转时长" class="headerlink" title="10. 空转时长"></a>10. 空转时长</h2><p>RedisObject结构包含的另一个属性:lru</p><p>​    记录了对象最后一次被命令程序访问的时间</p><p>通常使用OBJECT IDLETIME命令打印出给定键的空转时长</p><p>即：空转时长=当前时间 - 键的值对象的lru时间</p><p> 这个命令在访问键的值对象时，不会修改值对象的lru属性。</p><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h2><p>❑Redis数据库中的每个键值对的键和值都是一个对象。</p><p>❑Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</p><p>❑服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</p><p>❑Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</p><p>❑Redis会共享值为0到9999的字符串对象。</p><p>❑对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</p><p>参考：</p><p>《Redis 设计与实现》 黄健宏</p><p>​    <a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html">https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis对象&quot;&gt;&lt;a href=&quot;#Redis对象&quot; class=&quot;headerlink&quot; title=&quot;Redis对象&quot;&gt;&lt;/a&gt;Redis对象&lt;/h1&gt;&lt;h2 id=&quot;1-对象的类型和编码&quot;&gt;&lt;a href=&quot;#1-对象的类型和编码&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构</title>
    <link href="http://example.com/2021/11/14/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/11/14/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-11-14T09:47:22.000Z</published>
    <updated>2021-11-14T09:59:29.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h2><h2 id="1-1-SDS"><a href="#1-1-SDS" class="headerlink" title="1.1 SDS"></a>1.1 SDS</h2><h2 id="1-2-SDS-与C字符串的区别"><a href="#1-2-SDS-与C字符串的区别" class="headerlink" title="1.2 SDS 与C字符串的区别"></a>1.2 SDS 与C字符串的区别</h2><h2 id="1-3-SDS-API"><a href="#1-3-SDS-API" class="headerlink" title="1.3 SDS API"></a>1.3 SDS API</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><h3 id="2-1-链表和链表节点"><a href="#2-1-链表和链表节点" class="headerlink" title="2.1 链表和链表节点"></a>2.1 链表和链表节点</h3><h3 id="2-2-API"><a href="#2-2-API" class="headerlink" title="2.2 API"></a>2.2 API</h3><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><h3 id="3-1字典"><a href="#3-1字典" class="headerlink" title="3.1字典"></a>3.1字典</h3><h3 id="3-2-哈希算法"><a href="#3-2-哈希算法" class="headerlink" title="3.2 哈希算法"></a>3.2 哈希算法</h3><h3 id="3-3-键冲突"><a href="#3-3-键冲突" class="headerlink" title="3.3 键冲突"></a>3.3 键冲突</h3><h3 id="3-4-rehash"><a href="#3-4-rehash" class="headerlink" title="3.4 rehash"></a>3.4 rehash</h3><h3 id="3-5-渐进式hash"><a href="#3-5-渐进式hash" class="headerlink" title="3.5 渐进式hash"></a>3.5 渐进式hash</h3><h3 id="3-6-字典API"><a href="#3-6-字典API" class="headerlink" title="3.6 字典API"></a>3.6 字典API</h3><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h2><h3 id="4-1-跳跃表"><a href="#4-1-跳跃表" class="headerlink" title="4.1 跳跃表"></a>4.1 跳跃表</h3><h3 id="4-2-API"><a href="#4-2-API" class="headerlink" title="4.2 API"></a>4.2 API</h3><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5. 整数集合"></a>5. 整数集合</h2><h3 id="5-1-整数集合"><a href="#5-1-整数集合" class="headerlink" title="5.1 整数集合"></a>5.1 整数集合</h3><h3 id="5-2-升级"><a href="#5-2-升级" class="headerlink" title="5.2 升级"></a>5.2 升级</h3><h3 id="5-3-升级的好处"><a href="#5-3-升级的好处" class="headerlink" title="5.3 升级的好处"></a>5.3 升级的好处</h3><h3 id="5-4-降级"><a href="#5-4-降级" class="headerlink" title="5.4 降级"></a>5.4 降级</h3><h3 id="5-5-API"><a href="#5-5-API" class="headerlink" title="5.5 API"></a>5.5 API</h3><h3 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h3><h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h2><h3 id="6-1-压缩列表构成"><a href="#6-1-压缩列表构成" class="headerlink" title="6.1 压缩列表构成"></a>6.1 压缩列表构成</h3><h3 id="6-2-压缩列表节点的构成"><a href="#6-2-压缩列表节点的构成" class="headerlink" title="6.2 压缩列表节点的构成"></a>6.2 压缩列表节点的构成</h3><h3 id="6-3-连锁更新"><a href="#6-3-连锁更新" class="headerlink" title="6.3 连锁更新"></a>6.3 连锁更新</h3><h3 id="6-4-API"><a href="#6-4-API" class="headerlink" title="6.4 API"></a>6.4 API</h3><h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-简单动态字符串&quot;&gt;&lt;a href=&quot;#1-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;1.简单动态字符串&quot;&gt;&lt;/a&gt;1.简单动态字符串&lt;/h2&gt;&lt;h2 id=&quot;1-1-SDS&quot;&gt;&lt;a href=&quot;#1-1-SDS&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 事件驱动模型</title>
    <link href="http://example.com/2021/11/11/Redis-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/11/11/Redis-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-11-11T13:05:50.000Z</published>
    <updated>2021-11-11T13:08:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-事件驱动模型"><a href="#Redis-事件驱动模型" class="headerlink" title="Redis 事件驱动模型"></a>Redis 事件驱动模型</h1><p>本文转载于：<a href="https://www.xilidou.com/2018/03/22/redis-event/">转载</a> </p><p>Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件。</p><ul><li>文件事件</li><li>时间事件</li></ul><p>下面就会介绍这两种事件的实现原理。</p><h1 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h1><p>Redis 服务器通过 socket 实现与客户端（或其他redis服务器）的交互,文件事件就是服务器对 socket 操作的抽象。 Redis 服务器，通过监听这些 socket 产生的文件事件并处理这些事件，实现对客户端调用的响应。</p><h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>Redis 基于 Reactor 模式开发了自己的事件处理器。</p><p>这里就先展开讲一讲 Reactor 模式。看下图：</p><p>  <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111112101800.png" alt="image-20211111210107719"></p><p>“I/O 多路复用模块”会监听多个 FD ，当这些FD产生，accept，read，write 或 close 的文件事件。会向“文件事件分发器（dispatcher）”传送事件。</p><p>文件事件分发器（dispatcher）在收到事件之后，会根据事件的类型将事件分发给对应的 handler。</p><p>我们顺着图，从上到下的逐一讲解 Redis 是怎么实现这个 Reactor 模型的。</p><h2 id="I-O-多路复用模块"><a href="#I-O-多路复用模块" class="headerlink" title="I/O 多路复用模块"></a>I/O 多路复用模块</h2><p>Redis 的 I/O 多路复用模块，其实是封装了操作系统提供的 select，epoll，avport 和 kqueue 这些基础函数。向上层提供了一个统一的接口，屏蔽了底层实现的细节。</p><p>一般而言 Redis 都是部署到 Linux 系统上，所以我们就看看使用 Redis 是怎么利用 linux 提供的 epoll 实现I/O 多路复用。</p><p>首先看看 epoll 提供的三个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line"> */</span><br><span class="line">int epoll_create(int size)；</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 可以理解为，增删改 fd 需要监听的事件</span><br><span class="line"> * epfd 是 epoll_create() 创建的句柄。</span><br><span class="line"> * op 表示 增删改</span><br><span class="line"> * epoll_event 表示需要监听的事件，Redis 只用到了可读，可写，错误，挂断 四个状态</span><br><span class="line"> */</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 可以理解为查询符合条件的事件</span><br><span class="line"> * epfd 是 epoll_create() 创建的句柄。</span><br><span class="line"> * epoll_event 用来存放从内核得到事件的集合</span><br><span class="line"> * maxevents 获取的最大事件数</span><br><span class="line"> * timeout 等待超时时间</span><br><span class="line"> */</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>再看 Redis 对文件事件，封装epoll向上提供的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 事件状态</span><br><span class="line"> */</span><br><span class="line">typedef struct aeApiState &#123;</span><br><span class="line"></span><br><span class="line">    // epoll_event 实例描述符</span><br><span class="line">    int epfd;</span><br><span class="line"></span><br><span class="line">    // 事件槽</span><br><span class="line">    struct epoll_event *events;</span><br><span class="line"></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 创建一个新的 epoll </span><br><span class="line"> */</span><br><span class="line">static int  aeApiCreate(aeEventLoop *eventLoop)</span><br><span class="line">/*</span><br><span class="line"> * 调整事件槽的大小</span><br><span class="line"> */</span><br><span class="line">static int  aeApiResize(aeEventLoop *eventLoop, int setsize)</span><br><span class="line">/*</span><br><span class="line"> * 释放 epoll 实例和事件槽</span><br><span class="line"> */</span><br><span class="line">static void aeApiFree(aeEventLoop *eventLoop)</span><br><span class="line">/*</span><br><span class="line"> * 关联给定事件到 fd</span><br><span class="line"> */</span><br><span class="line">static int  aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</span><br><span class="line">/*</span><br><span class="line"> * 从 fd 中删除给定事件</span><br><span class="line"> */</span><br><span class="line">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask)</span><br><span class="line">/*</span><br><span class="line"> * 获取可执行事件</span><br><span class="line"> */</span><br><span class="line">static int  aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)</span><br></pre></td></tr></table></figure><p>所以看看这个ae_peoll.c 如何对 epoll 进行封装的：</p><ul><li><code>aeApiCreate()</code> 是对 <code>epoll.epoll_create()</code> 的封装。</li><li><code>aeApiAddEvent()</code>和<code>aeApiDelEvent()</code> 是对 <code>epoll.epoll_ctl()</code>的封装。</li><li><code>aeApiPoll()</code> 是对 <code>epoll_wait()</code>的封装。</li></ul><p>这样 Redis 的利用 epoll 实现的 I/O 复用器就比较清晰了。</p><p>再往上一层次我们需要看看 ea.c 是怎么封装的？</p><p>首先需要关注的是事件处理器的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct aeFileEvent &#123;</span><br><span class="line"></span><br><span class="line">    // 监听事件类型掩码，</span><br><span class="line">    // 值可以是 AE_READABLE 或 AE_WRITABLE ，</span><br><span class="line">    // 或者 AE_READABLE | AE_WRITABLE</span><br><span class="line">    int mask; /* one of AE_(READABLE|WRITABLE) */</span><br><span class="line"></span><br><span class="line">    // 读事件处理器</span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line"></span><br><span class="line">    // 写事件处理器</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line"></span><br><span class="line">    // 多路复用库的私有数据</span><br><span class="line">    void *clientData;</span><br><span class="line"></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure><p><code>mask</code> 就是可以理解为事件的类型。</p><p>除了使用 ae_peoll.c 提供的方法外,ae.c 还增加 “增删查” 的几个 API。</p><ul><li>增:<code>aeCreateFileEvent</code></li><li>删:<code>aeDeleteFileEvent</code></li><li>查: 查包括两个维度 <code>aeGetFileEvents</code> 获取某个 fd 的监听类型和<code>aeWait</code>等待某个fd 直到超时或者达到某个状态。</li></ul><h2 id="事件分发器（dispatcher）"><a href="#事件分发器（dispatcher）" class="headerlink" title="事件分发器（dispatcher）"></a>事件分发器（dispatcher）</h2><p>Redis 的事件分发器 <code>ae.c/aeProcessEvents</code> 不但处理文件事件还处理时间事件，所以这里只贴与文件分发相关的出部分代码，dispather 根据 mask 调用不同的事件处理器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//从 epoll 中获关注的事件</span><br><span class="line">numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">for (j = 0; j &lt; numevents; j++) &#123;</span><br><span class="line">    // 从已就绪数组中获取事件</span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line"></span><br><span class="line">    int mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">    int fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">    int rfired = 0;</span><br><span class="line"></span><br><span class="line">    // 读事件</span><br><span class="line">    if (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">        // rfired 确保读/写事件只能执行其中一个</span><br><span class="line">        rfired = 1;</span><br><span class="line">        fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">    &#125;</span><br><span class="line">    // 写事件</span><br><span class="line">    if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">        if (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">            fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processed++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个分发器，根据 mask 的不同将事件分别分发给了读事件和写事件。</p><h2 id="文件事件处理器的类型"><a href="#文件事件处理器的类型" class="headerlink" title="文件事件处理器的类型"></a>文件事件处理器的类型</h2><p>Redis 有大量的事件处理器类型，我们就讲解处理一个简单命令涉及到的三个处理器：</p><ul><li>acceptTcpHandler 连接应答处理器，负责处理连接相关的事件，当有client 连接到Redis的时候们就会产生 AE_READABLE 事件。引发它执行。</li><li>readQueryFromClinet 命令请求处理器，负责读取通过 sokect 发送来的命令。</li><li>sendReplyToClient 命令回复处理器，当Redis处理完命令，就会产生 AE_WRITEABLE 事件，将数据回复给 client。</li></ul><h2 id="文件事件实现总结"><a href="#文件事件实现总结" class="headerlink" title="文件事件实现总结"></a>文件事件实现总结</h2><p>我们按照开始给出的 Reactor 模型，从上到下讲解了文件事件处理器的实现，下面将会介绍时间时间的实现。</p><h1 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h1><p>Reids 有很多操作需要在给定的时间点进行处理，时间事件就是对这类定时任务的抽象。</p><p>先看时间事件的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Time event structure</span><br><span class="line"> *</span><br><span class="line"> * 时间事件结构</span><br><span class="line"> */</span><br><span class="line">typedef struct aeTimeEvent &#123;</span><br><span class="line"></span><br><span class="line">    // 时间事件的唯一标识符</span><br><span class="line">    long long id; /* time event identifier. */</span><br><span class="line"></span><br><span class="line">    // 事件的到达时间</span><br><span class="line">    long when_sec; /* seconds */</span><br><span class="line">    long when_ms; /* milliseconds */</span><br><span class="line"></span><br><span class="line">    // 事件处理函数</span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line"></span><br><span class="line">    // 事件释放函数</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line"></span><br><span class="line">    // 多路复用库的私有数据</span><br><span class="line">    void *clientData;</span><br><span class="line"></span><br><span class="line">    // 指向下个时间事件结构，形成链表</span><br><span class="line">    struct aeTimeEvent *next;</span><br><span class="line"></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>看见 <code>next</code> 我们就知道这个 aeTimeEvent 是一个链表结构。看图：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202111112100348.png" alt="image-20211111210032286"></p><p>注意这是一个按照id倒序排列的链表，并没有按照事件顺序排序。</p><h2 id="processTimeEvent"><a href="#processTimeEvent" class="headerlink" title="processTimeEvent"></a>processTimeEvent</h2><p>Redis 使用这个函数处理所有的时间事件，我们整理一下执行思路：</p><ol><li>记录最新一次执行这个函数的时间，用于处理系统时间被修改产生的问题。</li><li>遍历链表找出所有 when_sec 和 when_ms 小于现在时间的事件。</li><li>执行事件对应的处理函数。</li><li>检查事件类型，如果是周期事件则刷新该事件下一次的执行事件。</li><li>否则从列表中删除事件。</li></ol><h1 id="综合调度器（aeProcessEvents）"><a href="#综合调度器（aeProcessEvents）" class="headerlink" title="综合调度器（aeProcessEvents）"></a>综合调度器（aeProcessEvents）</h1><p>综合调度器是 Redis 统一处理所有事件的地方。我们梳理一下这个函数的简单逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1. 获取离当前时间最近的时间事件</span><br><span class="line">shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line"></span><br><span class="line">// 2. 获取间隔时间</span><br><span class="line">timeval = shortest - nowTime;</span><br><span class="line"></span><br><span class="line">// 如果timeval 小于 0，说明已经有需要执行的时间事件了。</span><br><span class="line">if(timeval &lt; 0)&#123;</span><br><span class="line">    timeval = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 在 timeval 时间内，取出文件事件。</span><br><span class="line">numevents = aeApiPoll(eventLoop, timeval);</span><br><span class="line"></span><br><span class="line">// 4.根据文件事件的类型指定不同的文件处理器</span><br><span class="line">if (AE_READABLE) &#123;</span><br><span class="line">    // 读事件</span><br><span class="line">    rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">&#125;</span><br><span class="line">    // 写事件</span><br><span class="line">if (AE_WRITABLE) &#123;</span><br><span class="line">    wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的伪代码就是整个 Redis 事件处理器的逻辑。</p><p>我们可以再看看谁执行了这个 <code>aeProcessEvents</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void aeMain(aeEventLoop *eventLoop) &#123;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line"></span><br><span class="line">    while (!eventLoop-&gt;stop) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果有需要在事件处理前执行的函数，那么运行它</span><br><span class="line">        if (eventLoop-&gt;beforesleep != NULL)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        // 开始处理事件</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再看看是谁调用了 <code>eaMain</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    //一些配置和准备</span><br><span class="line">    ...</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    </span><br><span class="line">    //结束后的回收工作</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 Redis 的 main 方法中找个了它。</p><p>这个时候我们整理出的思路就是:</p><ul><li>Redis 的 main() 方法执行了一些配置和准备以后就调用 <code>eaMain()</code> 方法。</li><li><code>eaMain()</code> while(true) 的调用 <code>aeProcessEvents()</code>。</li></ul><p>因此我们说 Redis 是一个事件驱动的程序，期间我们发现，Redis 没有 fork 过任何线程。所以也可以说 Redis 是一个基于事件驱动的单线程应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-事件驱动模型&quot;&gt;&lt;a href=&quot;#Redis-事件驱动模型&quot; class=&quot;headerlink&quot; title=&quot;Redis 事件驱动模型&quot;&gt;&lt;/a&gt;Redis 事件驱动模型&lt;/h1&gt;&lt;p&gt;本文转载于：&lt;a href=&quot;https://www.xil</summary>
      
    
    
    
    <category term="技术转载学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E8%BD%AC%E8%BD%BD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC学习笔记</title>
    <link href="http://example.com/2021/11/09/SpringMVC/"/>
    <id>http://example.com/2021/11/09/SpringMVC/</id>
    <published>2021-11-09T09:14:53.000Z</published>
    <updated>2021-11-08T12:08:14.398Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h1><h3 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p><h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p><p>SpringMVC 是 Spring 为<strong>表述层</strong>开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p></blockquote><h3 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h3><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>(封装)，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>IDE：idea 2019.2</p><p>构建工具：maven3.5.4</p><p>服务器：tomcat7</p><p>Spring版本：5.3.1</p><h3 id="2、创建maven工程"><a href="#2、创建maven工程" class="headerlink" title="2、创建maven工程"></a>2、创建maven工程</h3><h5 id="a-gt-添加web模块"><a href="#a-gt-添加web模块" class="headerlink" title="a&gt;添加web模块"></a>a&gt;添加web模块</h5><h5 id="b-gt-打包方式：war"><a href="#b-gt-打包方式：war" class="headerlink" title="b&gt;打包方式：war"></a>b&gt;打包方式：war</h5><h5 id="c-gt-引入依赖"><a href="#c-gt-引入依赖" class="headerlink" title="c&gt;引入依赖"></a>c&gt;引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p><p><img src="C:\Users\ASUS\Desktop\img\img001.png" alt="images"></p><h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p><h5 id="a-gt-默认配置方式"><a href="#a-gt-默认配置方式" class="headerlink" title="a&gt;默认配置方式"></a>a&gt;默认配置方式</h5><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">去除掉警示牌请求，其他所有请求交给前端控制器处理</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-扩展配置方式"><a href="#b-gt-扩展配置方式" class="headerlink" title="b&gt;扩展配置方式"></a>b&gt;扩展配置方式</h5><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>&lt;url-pattern&gt;标签中使用/和/*的区别：</p><p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p><p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p><p>/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p></blockquote><h3 id="4、创建请求控制器"><a href="#4、创建请求控制器" class="headerlink" title="4、创建请求控制器"></a>4、创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p><p>请求控制器中每一个处理请求的方法成为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、创建springMVC的配置文件"><a href="#5、创建springMVC的配置文件" class="headerlink" title="5、创建springMVC的配置文件"></a>5、创建springMVC的配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6、测试HelloWorld"><a href="#6、测试HelloWorld" class="headerlink" title="6、测试HelloWorld"></a>6、测试HelloWorld</h3><h5 id="a-gt-实现对首页的访问"><a href="#a-gt-实现对首页的访问" class="headerlink" title="a&gt;实现对首页的访问"></a>a&gt;实现对首页的访问</h5><p>在请求控制器中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-通过超链接跳转到指定页面"><a href="#b-gt-通过超链接跳转到指定页面" class="headerlink" title="b&gt;通过超链接跳转到指定页面"></a>b&gt;通过超链接跳转到指定页面</h5><p>在主页index.html中设置超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在请求控制器中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面(web页面的地址没有改变)</p><h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><h3 id="1、-RequestMapping注解的功能"><a href="#1、-RequestMapping注解的功能" class="headerlink" title="1、@RequestMapping注解的功能"></a>1、@RequestMapping注解的功能</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><h3 id="2、-RequestMapping注解的位置"><a href="#2、-RequestMapping注解的位置" class="headerlink" title="2、@RequestMapping注解的位置"></a>2、@RequestMapping注解的位置</h3><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><p>所以想要访问类里面方法的注解信息，请求的路径中要额外添加类上注解的路径：/text</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、-RequestMapping注解的value属性"><a href="#3、-RequestMapping注解的value属性" class="headerlink" title="3、@RequestMapping注解的value属性"></a>3、@RequestMapping注解的value属性</h3><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p><p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、-RequestMapping注解的method属性"><a href="#4、-RequestMapping注解的method属性" class="headerlink" title="4、@RequestMapping注解的method属性"></a>4、@RequestMapping注解的method属性</h3><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><h3 id="5、-RequestMapping注解的params属性（了解）"><a href="#5、-RequestMapping注解的params属性（了解）" class="headerlink" title="5、@RequestMapping注解的params属性（了解）"></a>5、@RequestMapping注解的params属性（了解）</h3><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p></blockquote><h3 id="6、-RequestMapping注解的headers属性（了解）"><a href="#6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="6、@RequestMapping注解的headers属性（了解）"></a>6、@RequestMapping注解的headers属性（了解）</h3><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p><h3 id="7、SpringMVC支持ant风格的路径"><a href="#7、SpringMVC支持ant风格的路径" class="headerlink" title="7、SpringMVC支持ant风格的路径"></a>7、SpringMVC支持ant风格的路径</h3><p>？：表示任意的<strong>单</strong>个字符(/和？不可以)</p><p>*：表示任意的0个或多个字符</p><p>**：表示任意的一层或多层目录</p><p>注意：在使用**时，只能使用/**/xxx的方式</p><h3 id="8、SpringMVC支持路径中的占位符（重点）"><a href="#8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="8、SpringMVC支持路径中的占位符（重点）"></a>8、SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：/deleteUser?id=1</p><p>rest方式：/deleteUser/1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure><h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h3 id="1、通过ServletAPI获取"><a href="#1、通过ServletAPI获取" class="headerlink" title="1、通过ServletAPI获取"></a>1、通过ServletAPI获取</h3><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">     <span class="comment">//形参对象的request表示当前表单，当前的request自动赋值给形参</span></span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、通过控制器方法的形参获取请求参数"><a href="#2、通过控制器方法的形参获取请求参数" class="headerlink" title="2、通过控制器方法的形参获取请求参数"></a>2、通过控制器方法的形参获取请求参数</h3><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h3 id="3、-RequestParam"><a href="#3、-RequestParam" class="headerlink" title="3、@RequestParam"></a>3、@RequestParam</h3><p>@RequestParam是<strong>将请求参数和控制器方法的形参</strong>创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><p>value：指定为形参赋值的请求参数的参数名</p><p>required：设置是否必须传输此请求参数，默认值为true</p><p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p><h3 id="4、-RequestHeader"><a href="#4、-RequestHeader" class="headerlink" title="4、@RequestHeader"></a>4、@RequestHeader</h3><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="5、-CookieValue"><a href="#5、-CookieValue" class="headerlink" title="5、@CookieValue"></a>5、@CookieValue</h3><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="6、通过POJO获取请求参数"><a href="#6、通过POJO获取请求参数" class="headerlink" title="6、通过POJO获取请求参数"></a>6、通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPOJO</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7、解决获取请求参数的乱码问题"><a href="#7、解决获取请求参数的乱码问题" class="headerlink" title="7、解决获取请求参数的乱码问题"></a>7、解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p></blockquote><h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h3 id="1、使用ServletAPI向request域对象共享数据"><a href="#1、使用ServletAPI向request域对象共享数据" class="headerlink" title="1、使用ServletAPI向request域对象共享数据"></a>1、使用ServletAPI向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用ModelAndView向request域对象共享数据"><a href="#2、使用ModelAndView向request域对象共享数据" class="headerlink" title="2、使用ModelAndView向request域对象共享数据"></a>2、使用ModelAndView向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、使用Model向request域对象共享数据"><a href="#3、使用Model向request域对象共享数据" class="headerlink" title="3、使用Model向request域对象共享数据"></a>3、使用Model向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModel</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、使用map向request域对象共享数据"><a href="#4、使用map向request域对象共享数据" class="headerlink" title="4、使用map向request域对象共享数据"></a>4、使用map向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、使用ModelMap向request域对象共享数据"><a href="#5、使用ModelMap向request域对象共享数据" class="headerlink" title="5、使用ModelMap向request域对象共享数据"></a>5、使用ModelMap向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelMap</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Model、ModelMap、Map的关系"><a href="#6、Model、ModelMap、Map的关系" class="headerlink" title="6、Model、ModelMap、Map的关系"></a>6、Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Model&#123;&#125;</span><br><span class="line">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br><span class="line">public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="7、向session域共享数据"><a href="#7、向session域共享数据" class="headerlink" title="7、向session域共享数据"></a>7、向session域共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSession</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、向application域共享数据"><a href="#8、向application域共享数据" class="headerlink" title="8、向application域共享数据"></a>8、向application域共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testApplication</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">ServletContext application = session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h3 id="1、ThymeleafView"><a href="#1、ThymeleafView" class="headerlink" title="1、ThymeleafView"></a>1、ThymeleafView</h3><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\Desktop\img\img002.png"></p><h3 id="2、转发视图"><a href="#2、转发视图" class="headerlink" title="2、转发视图"></a>2、转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><p>例如”forward:/“，”forward:/employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\Desktop\img\img003.png" alt="image-20210706201316593"></p><h3 id="3、重定向视图"><a href="#3、重定向视图" class="headerlink" title="3、重定向视图"></a>3、重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><p>例如”redirect:/“，”redirect:/employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\Desktop\img\img004.png" alt="image-20210706201602267"></p><blockquote><p>注：</p><p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p><p>转发和重定向的区别：</p><p>转发是一次请求（浏览器），地址栏不变；重定向是两次请求，地址栏发生改变</p><p>转发可以获取请求域中的数据，转发不可以</p><p>转发可以访问web_inf中的文件，重定向不可以</p><p>转发发生在服务器内部，可以访问web_inf等对外部隐藏的文件（只能服务器内部资源 ）</p><p>重定向是浏览器资源，访问浏览器任何资源</p></blockquote><h3 id="4、视图控制器view-controller"><a href="#4、视图控制器view-controller" class="headerlink" title="4、视图控制器view-controller"></a>4、视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p><p>&lt;mvc:annotation-driven /&gt;   //开启注解驱动</p></blockquote><h1 id="七、RESTful"><a href="#七、RESTful" class="headerlink" title="七、RESTful"></a>七、RESTful</h1><h3 id="1、RESTful简介"><a href="#1、RESTful简介" class="headerlink" title="1、RESTful简介"></a>1、RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><p>一种软件架构的风格。</p><h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a&gt;资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b&gt;资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c&gt;状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h3 id="2、RESTful的实现"><a href="#2、RESTful的实现" class="headerlink" title="2、RESTful的实现"></a>2、RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id=1</td><td>user/1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id=1</td><td>user/1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table><h3 id="3、HiddenHttpMethodFilter"><a href="#3、HiddenHttpMethodFilter" class="headerlink" title="3、HiddenHttpMethodFilter"></a>3、HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p><p>a&gt;当前请求的请求方式必须为post</p><p>b&gt;当前请求必须传输请求参数_method</p><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p><p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p></li><li><p>```<br>String paramValue = request.getParameter(this.methodParam);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 八、RESTful案例</span><br><span class="line"></span><br><span class="line">### 1、准备工作</span><br><span class="line"></span><br><span class="line">和传统 CRUD 一样，实现对员工信息的增删改查。</span><br><span class="line"></span><br><span class="line">- 搭建环境</span><br><span class="line"></span><br><span class="line">- 准备实体类</span><br><span class="line"></span><br><span class="line"> ```java</span><br><span class="line"> package com.atguigu.mvc.bean;</span><br><span class="line"> </span><br><span class="line"> public class Employee &#123;</span><br><span class="line"> </span><br><span class="line">    private Integer id;</span><br><span class="line">    private String lastName;</span><br><span class="line"> </span><br><span class="line">    private String email;</span><br><span class="line">    //1 male, 0 female</span><br><span class="line">    private Integer gender;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">       return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">       this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">       return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">       return email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">       this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Integer getGender() &#123;</span><br><span class="line">       return gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setGender(Integer gender) &#123;</span><br><span class="line">       this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee(Integer id, String lastName, String email, Integer gender) &#123;</span><br><span class="line">       super();</span><br><span class="line">       this.id = id;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">       this.email = email;</span><br><span class="line">       this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>准备dao模拟数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mvc.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      employees = <span class="keyword">new</span> HashMap&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">      employees.put(<span class="number">1001</span>, <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1002</span>, <span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1003</span>, <span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1004</span>, <span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1005</span>, <span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Integer initId = <span class="number">1006</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(employee.getId() == <span class="keyword">null</span>)&#123;</span><br><span class="line">         employee.setId(initId++);</span><br><span class="line">      &#125;</span><br><span class="line">      employees.put(employee.getId(), employee);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.values();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.get(id);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      employees.remove(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、功能清单"><a href="#2、功能清单" class="headerlink" title="2、功能清单"></a>2、功能清单</h3><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页√</td><td>/</td><td>GET</td></tr><tr><td>查询全部数据√</td><td>/employee</td><td>GET</td></tr><tr><td>删除√</td><td>/employee/2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面√</td><td>/toAdd</td><td>GET</td></tr><tr><td>执行保存√</td><td>/employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面√</td><td>/employee/2</td><td>GET</td></tr><tr><td>执行更新√</td><td>/employee</td><td>PUT</td></tr></tbody></table><h3 id="3、具体功能：访问首页"><a href="#3、具体功能：访问首页" class="headerlink" title="3、具体功能：访问首页"></a>3、具体功能：访问首页</h3><h5 id="a-gt-配置view-controller"><a href="#a-gt-配置view-controller" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-创建页面"><a href="#b-gt-创建页面" class="headerlink" title="b&gt;创建页面"></a>b&gt;创建页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>访问员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、具体功能：查询所有员工数据"><a href="#4、具体功能：查询所有员工数据" class="headerlink" title="4、具体功能：查询所有员工数据"></a>4、具体功能：查询所有员工数据</h3><h5 id="a-gt-控制器方法"><a href="#a-gt-控制器方法" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeList</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-创建employee-list-html"><a href="#b-gt-创建employee-list-html" class="headerlink" title="b&gt;创建employee_list.html"></a>b&gt;创建employee_list.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options(<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、具体功能：删除"><a href="#5、具体功能：删除" class="headerlink" title="5、具体功能：删除"></a>5、具体功能：删除</h3><h5 id="a-gt-创建处理delete请求方式的表单"><a href="#a-gt-创建处理delete请求方式的表单" class="headerlink" title="a&gt;创建处理delete请求方式的表单"></a>a&gt;创建处理delete请求方式的表单</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delete_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-删除超链接绑定点击事件"><a href="#b-gt-删除超链接绑定点击事件" class="headerlink" title="b&gt;删除超链接绑定点击事件"></a>b&gt;删除超链接绑定点击事件</h5><p>引入vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过vue处理点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//event表示当前事件</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">deleteEmployee</span>:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//通过id获取表单标签</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delete_form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;delete_form&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span></span><br><span class="line"><span class="javascript">                delete_form.action = event.target.href;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line"><span class="javascript">                delete_form.submit();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//阻止超链接的默认跳转行为</span></span></span><br><span class="line"><span class="javascript">                event.preventDefault();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="c-gt-控制器方法"><a href="#c-gt-控制器方法" class="headerlink" title="c&gt;控制器方法"></a>c&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、具体功能：跳转到添加数据页面"><a href="#6、具体功能：跳转到添加数据页面" class="headerlink" title="6、具体功能：跳转到添加数据页面"></a>6、具体功能：跳转到添加数据页面</h3><h5 id="a-gt-配置view-controller-1"><a href="#a-gt-配置view-controller-1" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/toAdd&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;employee_add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-创建employee-add-html"><a href="#b-gt-创建employee-add-html" class="headerlink" title="b&gt;创建employee_add.html"></a>b&gt;创建employee_add.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7、具体功能：执行保存"><a href="#7、具体功能：执行保存" class="headerlink" title="7、具体功能：执行保存"></a>7、具体功能：执行保存</h3><h5 id="a-gt-控制器方法-1"><a href="#a-gt-控制器方法-1" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、具体功能：跳转到更新数据页面"><a href="#8、具体功能：跳转到更新数据页面" class="headerlink" title="8、具体功能：跳转到更新数据页面"></a>8、具体功能：跳转到更新数据页面</h3><h5 id="a-gt-修改超链接"><a href="#a-gt-修改超链接" class="headerlink" title="a&gt;修改超链接"></a>a&gt;修改超链接</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="b-gt-控制器方法"><a href="#b-gt-控制器方法" class="headerlink" title="b&gt;控制器方法"></a>b&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span></span>&#123;</span><br><span class="line">    Employee employee = employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-创建employee-update-html"><a href="#c-gt-创建employee-update-html" class="headerlink" title="c&gt;创建employee_update.html"></a>c&gt;创建employee_update.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显</span></span><br><span class="line"><span class="comment">        若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9、具体功能：执行更新"><a href="#9、具体功能：执行更新" class="headerlink" title="9、具体功能：执行更新"></a>9、具体功能：执行更新</h3><h5 id="a-gt-控制器方法-2"><a href="#a-gt-控制器方法-2" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、HttpMessageConverter"><a href="#八、HttpMessageConverter" class="headerlink" title="八、HttpMessageConverter"></a>八、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p><p>ResponseEntity</p><h3 id="1、-RequestBody"><a href="#1、-RequestBody" class="headerlink" title="1、@RequestBody"></a>1、@RequestBody</h3><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>requestBody:username=admin&amp;password=123456</p><h3 id="2、RequestEntity"><a href="#2、RequestEntity" class="headerlink" title="2、RequestEntity"></a>2、RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]<br>requestBody:username=admin&amp;password=123</p><h3 id="3、-ResponseBody"><a href="#3、-ResponseBody" class="headerlink" title="3、@ResponseBody"></a>3、@ResponseBody</h3><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：浏览器页面显示success</p><h3 id="4、SpringMVC处理json"><a href="#4、SpringMVC处理json" class="headerlink" title="4、SpringMVC处理json"></a>4、SpringMVC处理json</h3><p>@ResponseBody处理json的步骤：</p><p>a&gt;导入jackson的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p><p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testResponseUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器的页面中展示的结果：</p><p>{“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”}</p><h3 id="5、SpringMVC处理ajax"><a href="#5、SpringMVC处理ajax" class="headerlink" title="5、SpringMVC处理ajax"></a>5、SpringMVC处理ajax</h3><p>a&gt;请求超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b&gt;通过vue和axios处理点击事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">testAjax</span>:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                axios(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">url</span>:event.target.href,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(response.data);</span></span><br><span class="line"><span class="javascript">                &#125;);</span></span><br><span class="line"><span class="javascript">                event.preventDefault();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c&gt;控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAjax</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、-RestController注解"><a href="#6、-RestController注解" class="headerlink" title="6、@RestController注解"></a>6、@RestController注解</h3><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h3 id="7、ResponseEntity"><a href="#7、ResponseEntity" class="headerlink" title="7、ResponseEntity"></a>7、ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p><h1 id="九、文件上传和下载"><a href="#九、文件上传和下载" class="headerlink" title="九、文件上传和下载"></a>九、文件上传和下载</h1><h3 id="1、文件下载"><a href="#1、文件下载" class="headerlink" title="1、文件下载"></a>1、文件下载</h3><p>使用ResponseEntity实现下载文件的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    String realPath = servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><p>上传步骤：</p><p>a&gt;添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b&gt;在SpringMVC的配置文件中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c&gt;控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    String hzName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> File(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十、拦截器"><a href="#十、拦截器" class="headerlink" title="十、拦截器"></a>十、拦截器</h1><h3 id="1、拦截器的配置"><a href="#1、拦截器的配置" class="headerlink" title="1、拦截器的配置"></a>1、拦截器的配置</h3><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor</p><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、拦截器的三个抽象方法"><a href="#2、拦截器的三个抽象方法" class="headerlink" title="2、拦截器的三个抽象方法"></a>2、拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p><p>postHandle：控制器方法执行之后执行postHandle()</p><p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p><h3 id="3、多个拦截器的执行顺序"><a href="#3、多个拦截器的执行顺序" class="headerlink" title="3、多个拦截器的执行顺序"></a>3、多个拦截器的执行顺序</h3><p>a&gt;若每个拦截器的preHandle()都返回true</p><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p><p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p><p>b&gt;若某个拦截器的preHandle()返回了false</p><p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p><h1 id="十一、异常处理器"><a href="#十一、异常处理器" class="headerlink" title="十一、异常处理器"></a>十一、异常处理器</h1><h3 id="1、基于配置的异常处理"><a href="#1、基于配置的异常处理" class="headerlink" title="1、基于配置的异常处理"></a>1、基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、基于注解的异常处理"><a href="#2、基于注解的异常处理" class="headerlink" title="2、基于注解的异常处理"></a>2、基于注解的异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十二、注解配置SpringMVC"><a href="#十二、注解配置SpringMVC" class="headerlink" title="十二、注解配置SpringMVC"></a>十二、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h3 id="1、创建初始化类，代替web-xml"><a href="#1、创建初始化类，代替web-xml" class="headerlink" title="1、创建初始化类，代替web.xml"></a>1、创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。<br>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebInit</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter encodingFilter = <span class="keyword">new</span> CharacterEncodingFilter();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="keyword">true</span>);</span><br><span class="line">        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、创建SpringConfig配置类，代替spring的配置文件"><a href="#2、创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="2、创建SpringConfig配置类，代替spring的配置文件"></a>2、创建SpringConfig配置类，代替spring的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#3、创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="3、创建WebConfig配置类，代替SpringMVC的配置文件"></a>3、创建WebConfig配置类，代替SpringMVC的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonsMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        FirstInterceptor firstInterceptor = <span class="keyword">new</span> FirstInterceptor();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        ServletContextTemplateResolver templateResolver = <span class="keyword">new</span> ServletContextTemplateResolver(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> </span>&#123;</span><br><span class="line">        SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class="line">        ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、测试功能"><a href="#4、测试功能" class="headerlink" title="4、测试功能"></a>4、测试功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十三、SpringMVC执行流程"><a href="#十三、SpringMVC执行流程" class="headerlink" title="十三、SpringMVC执行流程"></a>十三、SpringMVC执行流程</h1><h3 id="1、SpringMVC常用组件"><a href="#1、SpringMVC常用组件" class="headerlink" title="1、SpringMVC常用组件"></a>1、SpringMVC常用组件</h3><ul><li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p><ul><li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p><ul><li>Handler：<strong>处理器</strong>，需要工程师开发</li></ul><p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p><ul><li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p><ul><li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p><ul><li>View：<strong>视图</strong></li></ul><p>作用：将模型数据通过页面展示给用户</p><h3 id="2、DispatcherServlet初始化过程"><a href="#2、DispatcherServlet初始化过程" class="headerlink" title="2、DispatcherServlet初始化过程"></a>2、DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p><p><img src="C:\Users\ASUS\Desktop\img\img005.png" alt="images"></p><h5 id="a-gt-初始化WebApplicationContext"><a href="#a-gt-初始化WebApplicationContext" class="headerlink" title="a&gt;初始化WebApplicationContext"></a>a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-创建WebApplicationContext"><a href="#b-gt-创建WebApplicationContext" class="headerlink" title="b&gt;创建WebApplicationContext"></a>b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    String configLocation = getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-DispatcherServlet初始化策略"><a href="#c-gt-DispatcherServlet初始化策略" class="headerlink" title="c&gt;DispatcherServlet初始化策略"></a>c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、DispatcherServlet调用组件处理请求"><a href="#3、DispatcherServlet调用组件处理请求" class="headerlink" title="3、DispatcherServlet调用组件处理请求"></a>3、DispatcherServlet调用组件处理请求</h3><h5 id="a-gt-processRequest"><a href="#a-gt-processRequest" class="headerlink" title="a&gt;processRequest()"></a>a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-doService"><a href="#b-gt-doService" class="headerlink" title="b&gt;doService()"></a>b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestPath requestPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-doDispatch"><a href="#c-gt-doDispatch" class="headerlink" title="c&gt;doDispatch()"></a>c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           <span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d-gt-processDispatchResult"><a href="#d-gt-processDispatchResult" class="headerlink" title="d&gt;processDispatchResult()"></a>d&gt;processDispatchResult()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、SpringMVC的执行流程"><a href="#4、SpringMVC的执行流程" class="headerlink" title="4、SpringMVC的执行流程"></a>4、SpringMVC的执行流程</h3><ol><li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p></li></ol><p>a) 不存在</p><p>i. 再判断是否配置了mvc:default-servlet-handler</p><p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p><img src="C:\Users\ASUS\Desktop\img\img006.png" alt="image-20210709214911404"></p><p><img src="C:\Users\ASUS\Desktop\img\img007.png" alt="image-20210709214947432"></p><p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p><p><img src="C:\Users\ASUS\Desktop\img\img008.png" alt="image-20210709215255693"></p><p><img src="C:\Users\ASUS\Desktop\img\img009.png" alt="image-20210709215336097"></p><p>b) 存在则执行下面的流程</p><ol start="3"><li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p></li><li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p></li></ol><p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p><p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><ol start="7"><li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p></li><li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】。</p></li><li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p></li><li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p></li><li><p>将渲染结果返回给客户端。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、SpringMVC简介&quot;&gt;&lt;a href=&quot;#一、SpringMVC简介&quot; class=&quot;headerlink&quot; title=&quot;一、SpringMVC简介&quot;&gt;&lt;/a&gt;一、SpringMVC简介&lt;/h1&gt;&lt;h3 id=&quot;1、什么是MVC</summary>
      
    
    
    
    <category term="技术转载学习" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E8%BD%AC%E8%BD%BD%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="SpringMVC" scheme="http://example.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>picGo+github图床创建踩坑</title>
    <link href="http://example.com/2021/10/28/picGo-github%E5%9B%BE%E5%BA%8A%E5%88%9B%E5%BB%BA%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2021/10/28/picGo-github%E5%9B%BE%E5%BA%8A%E5%88%9B%E5%BB%BA%E8%B8%A9%E5%9D%91/</id>
    <published>2021-10-28T13:22:41.000Z</published>
    <updated>2021-11-08T15:59:56.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>typora升级到最新版本 </p><p>picgo升级到最新版本：version2.3.0</p><p>一：创建GitHub仓库<br>首先登陆 GitHub，新建一个仓库或者也可以使用一个已有仓库</p><p>注意：仓库属性必须为公共（public）的，否则图片上传上去之后是没法显示，之后的调用也会出错</p><p>二：设置token</p><p>需要在 GitHub 上生成一个 token 以便 PicGo 来操作我们的仓库，</p><p>步骤如下：</p><p>个人中心Settings-&gt;Developer settings -&gt;Personal access tokens</p><p>创建 token</p><p>点击 Generate new token 创建一个新 token，选择 repo，同时它会把包含其中的都会勾选上。点击绿色按钮，Generate token 。生成一个 token ，记得复制保存到其他地方，这个 token 只显示一次！！</p><p> 3.PicGo配置<br>PicGo下载地址<br><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>配置 PicGo</p><p>打开 PicGo 面板，</p><p>选择github仓库</p><p>仓库名格式为 用户名/仓库名<br>分支名：master<br>token：上一个咱们创建的token</p><p>然后点击确定即可完成绑定，即可设置成默认图床</p><h2 id="在typore配置自动上传"><a href="#在typore配置自动上传" class="headerlink" title="在typore配置自动上传"></a>在typore配置自动上传</h2><p>打开typora，点开左上角文件，选择<strong>偏好设置</strong></p><ol><li>设置插入图片时为【上传图片】</li><li>勾选【对本地位置的图片应用上述规则】</li><li>在上传服务中选择“PicGo(app)”</li><li>在路径中选择picgo安装目录<strong>PicGo.exe</strong></li></ol><p>可以点击下面的验证图片上传选项，上传成功！</p><p> 配置完成之后，图片复制进typora之后就会自动经由picGo上传到github的仓库了，并且生成相关的URL地址。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>在上传图片到picGo的时候，显示上传失败：服务器错误</p><p>仔细检查github图床配置的相关信息</p><p>错误原因是：<strong>仓库名前面没有添加github账号</strong></p><p>​                        注意格式一定要是：账号名/仓库名</p><p>​                        缺一不可！！！！！</p><p>​                        并且仓库名中最好不要有特殊字符，空格等，避免发生不知名的错误</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>安装 picGo的时候想要更改安装路径，更改之后安装目录没有文件，应用程序无法打开。</p><p>使用了默认路径之后重新安装，才解决这个问题。</p><p>建议使用系统默认路径即可</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>picGo上传成功typore中显示加载失败</p><p>查找相关资料，原因是github屏蔽掉了图片，需要修改host。<br>路径：C:\Windows\System32\drivers\etc\hosts</p><p> 找到host文件，用记事本格式打开，添加代码</p><p>#GitHub Start </p><p>140.82.113.3      github.com<br>140.82.114.20     gist.github.com<br>151.101.184.133    assets-cdn.github.com<br>151.101.184.133    raw.githubusercontent.com<br>151.101.184.133    gist.githubusercontent.com<br>151.101.184.133    cloud.githubusercontent.com<br>151.101.184.133    camo.githubusercontent.com<br>151.101.184.133    avatars0.githubusercontent.com<br>199.232.68.133     avatars0.githubusercontent.com<br>199.232.28.133     avatars1.githubusercontent.com<br>151.101.184.133    avatars1.githubusercontent.com<br>151.101.184.133    avatars2.githubusercontent.com<br>199.232.28.133     avatars2.githubusercontent.com<br>151.101.184.133    avatars3.githubusercontent.com<br>199.232.68.133     avatars3.githubusercontent.com<br>151.101.184.133    avatars4.githubusercontent.com<br>199.232.68.133     avatars4.githubusercontent.com<br>151.101.184.133    avatars5.githubusercontent.com<br>199.232.68.133     avatars5.githubusercontent.com<br>151.101.184.133    avatars6.githubusercontent.com<br>199.232.68.133     avatars6.githubusercontent.com<br>151.101.184.133    avatars7.githubusercontent.com<br>199.232.68.133     avatars7.githubusercontent.com<br>151.101.184.133    avatars8.githubusercontent.com<br>199.232.68.133     avatars8.githubusercontent.com</p><p>#GitHub End</p><p>host更改权限具体参考：<a href="https://www.jb51.net/os/win10/526668.html">https://www.jb51.net/os/win10/526668.html</a></p><p>保存重启一下Typora软件即可</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>保存某些格式的图片 例如 png</p><p>可能会出现上传失败的问题，更改图片格式重新上传即可！</p><p>参考博客： <a href="https://blog.csdn.net/weixin_46025371/article/details/111105266">https://blog.csdn.net/weixin_46025371/article/details/111105266</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h2&gt;&lt;p&gt;typora升级到最新版本 &lt;/p&gt;
&lt;p&gt;picgo升级到最新版本：version2.3.0&lt;/p&gt;
&lt;p&gt;一：创建Git</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer Network summery  网络层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-06-20T12:01:53.000Z</published>
    <updated>2021-11-08T15:59:56.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-network-summery-网络层"><a href="#Computer-network-summery-网络层" class="headerlink" title="Computer network summery :网络层"></a>Computer network summery :网络层</h1><h2 id="一、功能和服务"><a href="#一、功能和服务" class="headerlink" title="一、功能和服务"></a>一、功能和服务</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><ul><li><p>路由器不运行应用层和运输层协议</p></li><li><p>功能：转发和路由选择</p></li><li><p> 网络层只向上提供简单灵活的，无连接的，尽力而为的<strong>数据报服务</strong></p></li><li><p>路由选择：网络层决定分组所采用的路径或路由；计算方法是<strong>路由选择算法</strong>( routing algorithm)</p></li><li><p>路由器都具有一张<strong>转发表</strong> (fOlwarding tahle) </p></li><li><p>某些网络体系结构也要求在数据报在路径中流动之前建立连接</p><p>​    例如：ATM 、帧中继、 MPLS</p></li></ul><h3 id="1-2-交换机"><a href="#1-2-交换机" class="headerlink" title="1.2 交换机"></a>1.2 交换机</h3><p>某些分组交换机称为</p><p>链路层交换机(link-Iayer switches) </p><p>其他分组交换机称为路由器( router) </p><h3 id="1-3-服务模型"><a href="#1-3-服务模型" class="headerlink" title="1.3 服务模型"></a>1.3 服务模型</h3><p>定义了分组在发送与接收端系统之间的端到端运输特性</p><ul><li>网络层提供的特定服务<ul><li>确保支付</li><li>具有时延上界的确 保交付</li><li>有序分组支付</li><li>确保最小带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li><li>网络层提供尽力而为服务</li></ul><h3 id="1-4虚电路和数据报网络"><a href="#1-4虚电路和数据报网络" class="headerlink" title="1.4虚电路和数据报网络"></a>1.4虚电路和数据报网络</h3><ul><li>与运输层类似，网络层也能够在两台主机之间提供无连接服务或连接服务</li></ul><ol><li><p><strong>虚电路网络</strong>:仅在网络层提供连接服务的计算机网络</p></li><li><p><strong>数据报网络</strong>:仅在网络层提供无连接服务的计算机网络</p></li><li><p>几乎所有主要计算机网络体系中都不<strong>同时</strong>提供两种服务</p></li><li><p>与运输层的<strong>区别</strong>：运输层服务在端系统中实现，网络层连接服务在端系统中，也在位于网络核心的路由器中实现</p></li><li><p>虚电路网络和数据报网络是计算机网络的两种基本类型 作出转发时，使用了非常不同的信息。</p></li></ol><ul><li><p>虚电路网络</p></li><li><p>数据报网络</p><ul><li><p>端系统要发送分组—&gt;就为该分组加上目的端系统的地</p><p>址，—&gt;将分组推进网络中  </p><p>无需建立任何虚电路，路由器不维护任何虚电路的状态信息</p></li></ul></li></ul><h2 id="二、路由转发"><a href="#二、路由转发" class="headerlink" title="二、路由转发"></a>二、路由转发</h2><h3 id="1、路由器："><a href="#1、路由器：" class="headerlink" title="1、路由器："></a>1、路由器：</h3><ul><li><p>结构</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528204542791.png" alt="image-20210528204542791"></p><ul><li>输入端口：与物理链路相连</li><li>交换结构：网络路由器中的网络</li><li>输出端口：存储和传输交换结构传出的分组</li><li>路由选择处理器：执行路由选择协议</li></ul></li></ul><h3 id="2、输入端口"><a href="#2、输入端口" class="headerlink" title="2、输入端口"></a>2、输入端口</h3><ul><li>输入端口的处理<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205032133.png" alt="image-20210528205032133"></li><li>从链路接收分组，对分组进行处理，通过路由表查找某分组的输出端口，发送到交换结构。</li><li>阻塞的分组在输入端口进行排队</li></ul></li></ul><h3 id="3、交换结构"><a href="#3、交换结构" class="headerlink" title="3、交换结构"></a>3、交换结构</h3><ul><li><p>交换结构：核心部位</p><ul><li><p>三种交换技术：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205614574.png" alt="image-20210528205614574"></p><ul><li><p>内存交换</p></li><li><p>总线交换</p></li><li><p>互联网络交换</p><p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p></li></ul></li></ul></li></ul><h3 id="4、输出端口"><a href="#4、输出端口" class="headerlink" title="4、输出端口"></a>4、输出端口</h3><ul><li>输出端口<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205817371.png" alt="image-20210528205817371"></li><li>选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能</li></ul></li><li>排队（拥塞）<ul><li>输入线路速率，比输出速率大，路由器空间耗尽，后到达的分组会丢包</li></ul></li></ul><h2 id="三、网际协议-IP"><a href="#三、网际协议-IP" class="headerlink" title="三、网际协议 IP"></a>三、网际协议 IP</h2><ul><li><p>TCP/IP 体系中最重要的协议之一</p></li><li><p>与IP配套使用的相关协议由IGMP、ARP、ICMP等</p></li><li><p>通过IP协议使不同的网络在逻辑层面互相连接（虚拟连接）</p></li><li><p>通过IP区分不同的网络，一个网络可以由多种异构网络构成</p></li><li></li></ul><p>因特网中的转发和编址</p><ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211114845.png" alt="image-20210528211114845"></li></ul><h3 id="1、数据报格式"><a href="#1、数据报格式" class="headerlink" title="1、数据报格式"></a>1、数据报格式</h3><p>（IPv4）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211224903.png" alt="image-20210528211224903"></p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本号</td><td align="center">IPv4/IPv6</td></tr><tr><td align="center">首部长度</td><td align="center">一般20字节</td></tr><tr><td align="center">服务类型</td><td align="center">服务类型</td></tr><tr><td align="center">数据报长度</td><td align="center">IP数据报总长度</td></tr><tr><td align="center">标识、标志、片偏移</td><td align="center">与ip分片有关的标示量</td></tr><tr><td align="center">寿命</td><td align="center">寿命 (Time-To- Live TTL)；避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源和目的IP</td><td align="center">转发的地址</td></tr><tr><td align="center">选项</td><td align="center">选项字段 首部扩展（超过20字节）</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table><h3 id="2、数据报分片"><a href="#2、数据报分片" class="headerlink" title="2、数据报分片"></a>2、数据报分片</h3><ul><li><p>数据报不能超过链路层所能承受的最大网络层分组</p></li><li><p>数据报过大时，进行分组，分成的较小数据报叫做片</p></li><li><p>片在目的地端系统进行重新组装，而不是路由器（简便网络内核）</p></li><li><p>发送方为它发送的每个数据报的标识号加1；也就是同一数据报，不同的片 标志相同</p></li><li><p>分片之后转发的片中，最后一个片的标志比特被设为0 ，而所有其他片的标志比特被设为1，</p></li><li><p>偏移字段指定该片应放在初始 数据报的哪个位置</p></li></ul><h3 id="3、IP编址"><a href="#3、IP编址" class="headerlink" title="3、IP编址"></a>3、IP编址</h3><ul><li>网络IP编制涉及以下几个问题：<ul><li>子网划分</li><li>分类的IP地址</li><li>子网掩码</li></ul></li></ul><p><strong>3.1 IP地址分类</strong>：</p><ul><li><p>a类地址：1~126<br>127被lookupback（回环地址）占用–》测试tcp/ip协议的是否正常，任何一台计算机上都有这个地址，这个地址代表本机（127.0.0.1）<br>网络+主机+主机+主机<br>1.0.0.0/8 –》google –》2^24 = 16777216<br>1.0.0.1 1.0.0.2<br>2.0.0.0/8 –&gt;Harvard<br>3.0.0.0/8 –&gt;ibm<br>4.0.0.0/8 –&gt;microsoft</p></li><li><p>b类地址：128~191<br>网络+网络+主机+主机<br>网络的个数：2^14 = 16384<br>每个网络里可以容纳的主机数=2^16 -2<br>129.1.0.0/16</p></li><li><p>c类地址：192~223<br>网络+网络+网络+主机<br>网络的个数：2^21 = 2097152<br>每个网络里可以容纳的主机数=2^8 - 2 =254<br>主机部分全为0代表网段<br>主机部分全为1代表这个网段的广播地址</p></li><li><p>d类：224~239拥有组播通信</p></li><li><p>E类：240~255 保留给科学研究使用</p><!--公网上使用的ip地址是A,B,C类--></li><li><p>私有地址</p><ul><li>满足企业用户在内部网络中使用的需求</li><li>私有地址不能在Internet上使用</li><li>私有地址包括3组<br>A类：10.0.0.0<del>10.255.255.255<br>B类：172.16.0.0</del>172.31.255.255<br>C类：192.168.0.0~192.168.255.255</li></ul></li></ul><p> <strong>具体详解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">1. A类IP地址</span><br><span class="line">   1.1 网络号——占1个字节</span><br><span class="line">   A类地址的网络号字段占1个字节，但前面的1位(0)已经固定，只剩下7位可以进行分配。即可指派的网络号是126个(即2^7-2)。</span><br><span class="line">   网络号字段为全0的IP地址是个保留地址，意思是“本网络”。</span><br><span class="line">   网络号为127(即01111111)保留作为本地软件环回测试(loopback test)本主机的进程之间的通信只用。</span><br><span class="line">   若主机发送一个目的地址为环回地址(例如 127.0.0.1)的IP数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。</span><br><span class="line">   目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。。</span><br><span class="line">   1.2 主机号——占3个字节</span><br><span class="line">   A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是2^24-2，即16777214。</span><br><span class="line">   全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为5.6.7.8，则该主机所在的网络地址就是5.0.0.0)。</span><br><span class="line">   全1的主机号字段表示该IP地址是“所有的”，即该网络上的所有主机。</span><br><span class="line">   注：IP地址空间共有2^32(即4294967296)个地址。整个A类地址空间共有2^31个地址，占有整个IP地址空间的50%。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. B类IP地址</span><br><span class="line">   2.1 网络号——占2个字节</span><br><span class="line">   B类地址的网络号字段占2个字节，但前面的2位(1 0)已经固定，只剩下14位可以进行分配。</span><br><span class="line">   B类网络地址128.0.0.0是不指派的，而可以指派的B类最小网络地址是128.1.0.0。因此B类地址可指派的网络数是2^14-1，即16383。</span><br><span class="line">   2.2 主机号——占2个字节</span><br><span class="line">   B类地址的每一个网络上的最大主机数是2^16-2，即65534，这里需要减2是因为要扣除全0和全1的主机号。</span><br><span class="line">   注：整个B类地址空间共约2^30个地址，占有整个IP地址空间的25%。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. C类IP地址</span><br><span class="line">   3.1 网络号——占3个字节</span><br><span class="line">   C类地址的网络号字段占3个字节，但前面的3位(1 1 0)已经固定，只剩下21位可以进行分配。</span><br><span class="line"></span><br><span class="line">   C类网络地址192.0.0.0是不指派的，而可以指派的C类最小网络地址是192.0.1.0。因此B类地址可指派的网络数是2^21-1，即2097151。</span><br><span class="line"></span><br><span class="line">   3.2 主机号——占1个字节</span><br><span class="line">   C类地址的每一个网络上的最大主机数是2^8-2，即254，这里需要减2是因为要扣除全0和全1的主机号。</span><br><span class="line">   注：整个C类地址空间共约2^29个地址，占有整个IP地址空间的12.5%。</span><br><span class="line"></span><br><span class="line">一些特殊的网络地址：</span><br><span class="line">一、0.0.0.0</span><br><span class="line">严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。</span><br><span class="line">二、255.255.255.255</span><br><span class="line">限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。</span><br><span class="line">三、127.0.0.1</span><br><span class="line">本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。</span><br><span class="line">四、224.0.0.1</span><br><span class="line">组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP(Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。</span><br><span class="line">五、169.254.X.X</span><br><span class="line">如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</span><br><span class="line">六、10.X.X.X、172.16.X.X～172.31.X.X、192.168.X.X</span><br><span class="line">私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。</span><br><span class="line">七，广播地址(Broadcast Address)</span><br><span class="line">是专门用于同时向网络中（通常指同一子网）所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID（简称主机 ID） 为全 1 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为 2 进制的 11111111 ），当发出一个目的地址为10.1.1.255 的数据包时，它将被分发给该网段上的所有计算机。广播地址应用于网络内的所有主机。</span><br><span class="line">八，网络地址</span><br><span class="line">指的是互联网上的节点在网络中具有的逻辑地址，可对节点进行寻址。主机地址指的是IP地址右边部分用来标识主机本身的部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个 IP地址的网络部分被称为网络号或者网络地址,主机可以与具有相同的网络号的设备直接通讯，在没有连接设备的情况下，即使共享相同的物理网段，网络号不同则无法进行通讯，IP 地址的网络地址使路由器可以将分组置于正确的网段上 。</span><br></pre></td></tr></table></figure><p><strong>2.子网掩码：</strong><br>16 表示网络部分的长度 –》子网掩码也是32位<br>作用：标识ip地址里网络部分的长度<br>用来确定IP的网络地址<br>11111111.11111111.00000000.00000000</p><p>32个二进制位<br>对应IP地址的网络部分用1表示<br>对应IP地址的主机部分用0表示<br>IP地址和子网掩码作逻辑“与”运算得到网络地址</p><p>0和任何数相与都等于0<br>1和任何数相与都等于任何数本身</p><p>网段：就是网络部分的内容<br>192.168.0.4/24 –&gt;192.168.0.0</p><p>A、B、C三类地址的默认子网掩码<br>A类：255.0.0.0<br>B类：255.255.0.0<br>C类：255.255.255.0</p><p><strong>3.子网划分：</strong></p><p>将一个大网络划分为许多的小网络（网络位向主机位借位）<br>子网划分的原因：</p><ul><li>满足不同网络对IP地址的需求</li><li>实现网络的层次性</li></ul><h3 id="4、互联网控制报文协议-ICMP"><a href="#4、互联网控制报文协议-ICMP" class="headerlink" title="4、互联网控制报文协议 (ICMP)"></a>4、互联网控制报文协议 (ICMP)</h3><ul><li><p>主机和路由器用来彼此沟通网络层的信息，用来进行差错报告。</p></li><li><p>ICMP报文是承载在ip 分组中，但是也被看做ip的一部分</p></li><li><p>ICMP协议的功能主要是：</p><ul><li><ol><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ol></li></ul></li><li><p>ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6</p></li><li><p><strong>ICMP的报文格式</strong><br>ICMP报文包含在IP数据报中 。</p><p>​    一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）    和ICMP报文（属于ICMP报文的数据部分）<strong>。当IP报头中的协议字段值    为1时，就说明这是一个ICMP报文。</strong>ICMP报头如下图所示。<br> <img src="https://img-blog.csdn.net/201805301801365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>字段说明：</p><ul><li>类型    一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</li><li>代码    占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</li><li>校验和    这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与在我们介绍IP报头中的校验和计算方法是一样的） </li></ul></li><li></li><li><p>ICMP报文分类：</p><ul><li><p>一类是通知出错原因 （差错报告报文）；</p></li><li><p>一类是用于诊断查询（询问报文）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210704145410714.png" alt="image-20210704145410714"></p></li></ul></li><li><p>众所周知的 ping 程序发送一个 ICMP 类型 编码 的报文到指定主机</p></li></ul><h3 id="5、IGMP网际组管理协议"><a href="#5、IGMP网际组管理协议" class="headerlink" title="5、IGMP网际组管理协议"></a>5、IGMP网际组管理协议</h3><h3 id="6、arp地址解析协议"><a href="#6、arp地址解析协议" class="headerlink" title="6、arp地址解析协议"></a>6、arp地址解析协议</h3><ul><li>逆地址解析协议RARP（现在几乎已经不使用了）</li><li>具体功能是：由IP地址解析得到硬件地址（MAC）</li></ul><p>1.要点</p><ul><li>在主机的高速缓存ARP 缓存中存放一个IP到硬件地址的动态映射表<ul><li>通过响应分组和请求分组动态获取想要发送的IP的未知硬件地址</li><li>响应分组是单播；请求分组是广播</li><li>每一个地址映射信息都有生存时间</li></ul></li></ul><h3 id="7、ipv6"><a href="#7、ipv6" class="headerlink" title="7、ipv6"></a>7、ipv6</h3><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528213948939.png" alt="image-20210528213948939"></p><p><strong>概述</strong></p><ul><li><p>解决ipv4地址不足的问题</p></li><li><p>报文结构</p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本</td><td align="center">IPv4/IPv6                         4比特</td></tr><tr><td align="center">流标签</td><td align="center">于标识一条数据报的流    20比特</td></tr><tr><td align="center">流量类型</td><td align="center">与TOS 字段的含义相似   8比特</td></tr><tr><td align="center">有效负载长度</td><td align="center">IP首部后数据字节数量  16比特</td></tr><tr><td align="center">下一个首部</td><td align="center">标识数据包交付对象（TCP/UDP ）</td></tr><tr><td align="center">跳限制</td><td align="center">与TTL类似  避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源地址</td><td align="center">128比特</td></tr><tr><td align="center">目的地址</td><td align="center">128比特</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table></li><li><p>IPv6首部40字节</p></li></ul><p><strong>相对ipv4特点（不同）：</strong></p><ul><li>不允许在中间路由器上进行分片与重新组装，只能在源与目的地上执行———-没有了分片标志</li><li>没有首部检验和字段，检验在运输层和数据链路层中完成</li><li>没有选项字段，删除选项字段使得 IP 首部成为定长的 40 字节</li><li>地址容量扩大了</li><li>拥有流标签和优先级</li></ul><h2 id="四、路由选择算法"><a href="#四、路由选择算法" class="headerlink" title="四、路由选择算法"></a>四、路由选择算法</h2><p>主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器 (default router) , 又称为该主机的第一跳路由器 (first- hop router）</p><p>源主机的默认路由器称作源路由器( source 川出r) ，把目的主机的默认路由器称作目的路由器 (destination router)</p><p>一个分组从源主机到目的主机的路由选择的较好 方法即路由选择算法</p><p>在两个路由之间根据链路开销，存在一条或者多条最低开销路径。</p><p>最低开销路径也就是最短路径———————最短路径算法SPF；</p><p><strong>路由控制</strong></p><ul><li><p>每路由控制。</p><p>每台路由器中运行一种路由选择算法的情况，每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。这种每路由器控制的方法在因特网中已经使用了几十年。</p><p>OSPF和BGP协议都是基于这种每路由器的方法进行控制的。</p></li><li><p>逻辑集中式控制。</p><p>逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况。通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能(负载共享、防火墙功能、NAT)的丰富集合，而这些功能先前是在单独的中间盒中实现的。</p><p>SDN采用了逻辑集中控制器的概念，而这种方法在生产部署中得到了越来越多的应用。</p></li></ul><h4 id="1-路由选择算法"><a href="#1-路由选择算法" class="headerlink" title="1.路由选择算法"></a>1.路由选择算法</h4><p><strong>分类：</strong></p><ul><li><p><code>全局式路由选择算法</code> (globaJ routing aJgorithm) </p><p>：用完整的、全局性的网络知识计算从源到目的地之间的最低开销路径，即 以所有结点之间的连通</p><p>性及所有链路的费用为输入</p><p>例：链路状态算法  LS  </p><p>​       适应每路由和逻辑集中控制：路由计算可以在集中式路由选择器 开门中，也可以在每台路由器的路优选择组件</p></li></ul><p>​        <code>分散式路由选择算法**</code> (dece t.ralized routing aJgorithm)</p><p>​                以迭代、分布式的方式计算最低开销路径 ，没有结点拥有关于所有网络链路费用的完整信息，                而每个结点仅有与其直接相连链路的费用知识即可开始工作</p><p>​        例：距离向量算法 DV   </p><p>​                天然适应逻辑集中式控制</p><ul><li><p><code>静态路由选择算法</code> (SlaLÌc rouling aJgorithm)：**手工配置、路由更新慢、优先级高</p><p>简单，开销小，但不能及时适应网络状态的变化，适用于小型网络。</p><p><code>动态路由选择算法</code>(dynamic rouling aJ gorithm)**：路由更新快（定期更新、及时响应链路费用或网络拓扑变化）</p><p>能较好地适应网络状态的变化，实现较为复杂，适用于大型网络。</p><p>容易受到路优选择循环、路由震荡的影响</p></li><li><p><code>负载敏感算法</code> load-sensiLÌve aJ gorithm)</p><p>：链路开销动态变化，反映当前链路底层链路的拥塞水平</p><p><code>负载迟钝算法</code>(load-insensitive) </p><p>当今的路由选择算法都是负载迟钝的。</p></li></ul><p><strong>常见算法：</strong></p><ul><li><p>电路交换路由选择算 (circuiL- swiLched routing algorith m)</p></li><li><p>距离向量(Distance- Vector, DV) 算法</p><ul><li>路由器周期性地向其相邻路由器广播自己知道的路由信息，用以通知相邻路由器自己可以到达的网络以及到达该网络的距离。相邻路由器可以根据收到的路由信息修改和刷新自己的路由表。</li><li>优点：算法简单、易于实现。</li><li>缺点：慢收敛问题，路由器的路径变化需要像波浪一样从相邻路由器传播出去，过程缓慢。</li></ul></li><li><p>链路状态广播 (link state broadcast) 算法 </p><ul><li>也叫最短路径优先(shortest path first SPF)算法，它的主要做法如下：<ul><li>首先由路由器向相邻路由器发送查询报文，测试和它相邻路由器的链路状态。如果可以收到相邻路由器发回的响应，则说明该相邻路由器和这个路由器之间可以正常通信；</li><li>在收到该路由器和其他相邻路由器的链路状态后，还向系统中所有参加最短路径优先算法的路由器发送链路状态报文；</li><li>各路由器收到其他路由器发来的链路状态报文后，根据报文中的数据刷新本路由器所保存的网络拓扑结构图。如果链路发生变化，路由器将启用Dijkstra算法生成新的最短路径优先数，并刷新本地路由表；</li></ul></li></ul></li></ul><p><em><strong>分层次的路由选择协议：</strong></em></p><p>因特网采用的路由选择协议主要是<strong>自适应的、动态的、分布式的、分层次的</strong>路由选择协议。</p><p><em><strong>自治系统（autonomous system,AS）</strong></em></p><p> 就是几个路由器组成了一个小团体，小团体内部使用专用的协议进行通信，而小团体和小团体之间也使用专用的协议进行通信。</p><p>目前的因特网中，ISP就是一个自治系统。</p><h2 id="五、路由选择协议"><a href="#五、路由选择协议" class="headerlink" title="五、路由选择协议"></a>五、路由选择协议</h2><p>计算出用于在网络中转发分组的转发表</p><p>两种 AS 内部路由选择协议 (RIP/OSPF) 和一种 AS 间路由选择协议 (BGP)</p><h3 id="1、AS-内部路由选择协议"><a href="#1、AS-内部路由选择协议" class="headerlink" title="1、AS 内部路由选择协议"></a>1、AS 内部路由选择协议</h3><h4 id="1-1-路由信息协议-RIP"><a href="#1-1-路由信息协议-RIP" class="headerlink" title="1.1 路由信息协议 RIP"></a>1.1 路由信息协议 RIP</h4><p> (Routing Information Protocol)</p><p>✅ 它是一种分布式的、基于距离向量的路由选择协议。<br>✅ 它要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。<br><strong>关于距离的定义：</strong></p><p>从一个路由器到直接连接的网络的距离定义为 1。<br>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。<br>“距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。<br>这里的“距离”实际上指的是“最短距离”。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p><p>RIP 允许一条路径最多只能包含 15 个路由器。</p><p>这意味着 RIP 只会选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p><p><strong>RIP 协议的三个特点:</strong></p><ul><li><p>仅和相邻路由器交换信息。</p></li><li><p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</p></li><li><p>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p><p><strong>AS（自治系统）之内的路由器如何建立路由表？</strong></p></li></ul><p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。它的路由表是空的。以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。<br>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。<br>RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</p><p> <strong>RIP2的报文格式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414151233228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>RIP2 报文由首部和路由部分组成。</p><ul><li>RIP2 报文中的路由部分由若干个路由信息组成。</li><li>地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</li><li>路由标记填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。</li><li>再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。</li></ul><p>一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4 + 20 × 25 = 504 4+20\times25=5044+20×25=504字节。如超过，必须再用一个 RIP 报文来传送。</p><h4 id="1-2-开放最短路径优先-OSPF"><a href="#1-2-开放最短路径优先-OSPF" class="headerlink" title="1.2 开放最短路径优先 OSPF"></a>1.2 开放最短路径优先 OSPF</h4><ul><li><p>OSPF (Open Shortest Path First) 是为克服 RIP 的缺点在<code>1989</code>年开发出来的。</p></li><li><p>使用了 Dijkstra 提出的最短路径算法 SPF</p></li></ul><p><strong>区域</strong></p><p>OSPF 将一个自治系统再划分为若干个更小的范围，叫作<code>区域</code>。</p><p>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</p><p><img src="https://img-blog.csdnimg.cn/20200414174248189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>OSPF 使用 IP 数据报传送：</strong></p><ul><li>✅ OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>✅ OSPF 构成的数据报很短。好处是可以不必将长的数据报分片传送。</li><li>✅ 支持可变长度的子网划分和无分类编址 CIDR。</li></ul><p><strong>OSPF 分组</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414174524743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>五种分组类型</p><p>1️⃣ 类型1：问候 (Hello) 分组。<br>2️⃣ 类型2：数据库描述 (Database Description) 分组。<br>3️⃣ 类型3：链路状态请求 (Link State Request) 分组。<br>4️⃣ 类型4：链路状态更新 (Link State Update) 分组，用洪泛法对全网更新链路状态。<br>5️⃣ 类型5：链路状态确认 (Link State Acknowledgment) 分组。</p><h3 id="2、AS-间路由选择协议"><a href="#2、AS-间路由选择协议" class="headerlink" title="2、AS 间路由选择协议"></a>2、AS 间路由选择协议</h3><p> <strong>(边界网关协议 BGP）</strong></p><ul><li><p>BGP 是不同自治系统的路由器之间交换路由信息的协议</p></li><li><p>要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200414174933546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>BGP-4 共使用四种报文</strong> </p><ol><li> 打开 (OPEN) 报文：用来与相邻的另一个BGP发言人建立关系。</li><li> 更新 (UPDATE) 报文：用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li> 保活 (KEEPALIVE) 报文：用来确认打开报文和周期性地证实邻站关系。</li><li> 通知 (NOTIFICATION) 报文：用来发送检测到的差错。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200414175219726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="六、简单网络管理协议（SNMP）"><a href="#六、简单网络管理协议（SNMP）" class="headerlink" title="六、简单网络管理协议（SNMP）"></a>六、简单网络管理协议（SNMP）</h2><p>基于T C P / I P的网络管理包含两个部分：网络管理站（也叫管理进程， m a n a g e r）和被管的网络单元（也叫被管设备）。被管设备端和管理相关的软件叫做代理程序( a g e n t )或代理进程。</p><p>管理进程和代理进程之间的通信可以有两种方式。一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的 I C M P端口？）。另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生。</p><p>基于T C P / I P的网络管理包含3个组成部分：</p><ol><li><p> 一个管理信息库M I B（Management Information Base）。管理信息库包含所有代理进程的所有可被查询和修改的参数。</p></li><li><p> 关于M I B的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。</p></li><li><p> 管理进程和代理进程之间的通信协议，叫做简单网络管理协议 S N M P（Simple Network Management Protocol）。</p></li></ol><p>协议<br>关于管理进程和代理进程之间的交互信息， S N M P定义了5种报文：</p><ol><li><p> get - r e q u e s t操作：从代理进程处提取一个或多个参数值。</p></li><li><p> get - n e x t - r e q u e s t操作：从代理进程处提取一个或多个参数的下一个参数值</p></li><li><p> set - r e q u e s t操作：设置代理进程的一个或多个参数值。</p></li><li><p> get - r e s p o n s e操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</p></li><li><p>t r a p 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</p></li></ol><p>前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的。</p><p>管理信息结构<br>SNMP中，数据类型不多，只有INTEGER，OCTER STRING，IPAddress等</p><p>对象标识符<br>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</p><p>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于 D N S或U n i x的文件系统</p><p> 管理信息库介绍<br>所谓管理信息库，或者M I B，就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p><p>M I B组：s y s t e m（系统标识）、i f（接口）、a t（地址转换）、i p、i c m p和t c p。</p><p>s y s t e m组非常简单，它包含7个简单变量</p><p>interface组只定义了一个简单变量，那就是系统的接口数量</p><p>i p组定义了很多简单变量和3个表格变量</p><p>i c m p组包含4个普通计数器变量（ I C M P报文的输出和输入数量以及 I C M P差错报文的输入和输出数量）和2 2个其他I C M P报文数量的计数器：11个是输出计数器，另外11个是输入计数器。</p><p>t c p组中的简单变量几乎都和T C P状态有关。</p><h2 id="七、SDN-控制平面"><a href="#七、SDN-控制平面" class="headerlink" title="七、SDN 控制平面"></a>七、SDN 控制平面</h2>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network summery  应用层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-06-20T12:01:24.000Z</published>
    <updated>2021-11-08T15:59:56.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-summery-应用层"><a href="#Computer-Network-summery-应用层" class="headerlink" title="Computer Network summery  应用层"></a>Computer Network summery  应用层</h1><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><h3 id="1-协议原理"><a href="#1-协议原理" class="headerlink" title="1.协议原理"></a>1.协议原理</h3><ul><li><p>常见的网络应用程序： Web 、电子邮件、 DNS 、对等文件分发</p></li><li><p>主要概念：应用程序的网络服务、客户和服务器、进程、运输层接口</p></li><li><p>应用软件在端系统上运行 </p></li></ul><h3 id="2-应用程序体系结构"><a href="#2-应用程序体系结构" class="headerlink" title="2.应用程序体系结构"></a>2.应用程序体系结构</h3><ul><li><p>网络应用程序体系结构：</p><ul><li><p>客户-服务器体系结构：（配备大量数据中心，创建虚拟服务器）</p><p>​                常见应用程序Telnet 、电子邮件、Web/FTP</p></li><li><p>对等P2P体系结构</p><ul><li>当前流行的、流量密集型应用  包括文件共享(例如 BitTorrenl) 、对等方协助下载加速器(例如迅雷)、因特网电话(例如 Skype) IPTV</li><li>P2P 的自扩展性 self- scalab i1 ity)</li></ul></li></ul></li></ul><h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3.进程"></a>3.进程</h3><ul><li><p>进行通信的实际上是进程，而不是程序</p></li><li><p>客户和服务器进程</p><ul><li>客户进程/服务器进程   例：web服务中，浏览器：客户进程；web服务器：服务进程</li></ul></li><li><p>API</p><ul><li><p>进程通过一个称为<strong>套接字</strong> (socket)的软件接口向网络发送报文和从网络接收报文 </p></li><li><p>套接字是建立网络应用程序的可编程接口，也称为应用程序和网络之间的<strong>应用程序编程接口</strong> (Application Programming Interface , API)</p></li><li><p>可以控制套接字在<strong>应用层端</strong>，对套接字的<strong>运输层端</strong>几乎没有控制权 </p><p>应用程序开发者对于运输层的控制仅限于：</p><p>①选择运输层协议;</p><p>②几个运输层参数</p></li></ul></li><li><p>进程寻址</p><ul><li>标识进程：目的地端口号(port number)：用来标识 运行在主机上的进程</li></ul></li></ul><h3 id="4-运输服务"><a href="#4-运输服务" class="headerlink" title="4.运输服务"></a>4.运输服务</h3><h4 id="4-1应用程序"><a href="#4-1应用程序" class="headerlink" title="4.1应用程序"></a>4.1应用程序</h4><ul><li><p>可靠数据传输：一端发送的应用数据正确、完全地交付给该应用程序的另一端</p><ul><li><p>容忍丢失的应用：能够接受不可靠传输的应用进程</p><p>例如 多媒体应用</p></li></ul></li><li><p>吞吐量：运输层协议能够以某种特定的速率提供确保的可用吞吐量</p><ul><li><p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong> (bandwidth- sensitive applicaLi on)</p></li><li><p><strong>弹性应用</strong>( el皑白 applicaLi on) 能够根据情况或多或少地利用可供使用的吞吐量</p><p>例如：电子邮件、文件传输以及 Web 传送 </p></li></ul></li><li><p>定时 </p><ul><li><p>某些服务为了有效性 ，要求数据交付有严格的时间限制</p><p>例如 :交互式实时应用程序</p></li></ul></li><li><p>安全性</p></li></ul><h4 id="4-2因特网"><a href="#4-2因特网" class="headerlink" title="4.2因特网"></a>4.2因特网</h4><ul><li><p>因特网(更一般的是 TCP/IP 网络)为应用程序提供两个运输层协议，即 UDP和 TCP</p></li><li><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527112725518.png" alt="image-20210527112725518"></p></li><li><p><strong>TCP</strong></p></li><li><p><strong>UDP</strong></p></li><li><p>互联网运输协议不能提供任何<strong>定时</strong>或<strong>带宽保证</strong></p></li><li><p>流行的因特网应用及其应用层协议和支撑的运输协议</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527113131403.png" alt="image-20210527113131403"></p></li></ul><h4 id="5-应用层协议"><a href="#5-应用层协议" class="headerlink" title="5.应用层协议"></a>5.应用层协议</h4><ul><li><p>作用：定义了运行在不同端系统上的应用程序进程如何相互传递报文：</p><ul><li>交换的报文类型，</li><li>各种报文类型的语法，</li><li>字段的语义</li><li>一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul></li><li><p>应用层协议只是网络应用的一部分</p></li><li><p>讨论几种重要的应用: Web 、文件传输、电子邮件、目录服务和P2P</p><p>以及他们的相关协议。</p></li></ul><h2 id="二、Web与HTTP"><a href="#二、Web与HTTP" class="headerlink" title="二、Web与HTTP"></a>二、Web与HTTP</h2><h3 id="1-http"><a href="#1-http" class="headerlink" title="1.http"></a>1.http</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><ul><li><p>Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) </p></li><li><p>由两个程序实现：客户端程序和服务器程序</p></li><li><p>使用TCP 作为支撑运输协议</p></li><li><p>无状态协议：不保存关于客户的任何信息</p></li><li><p>HTTP 既能够使用非持续连接，也能够使用持续连接，默认状态是持续性连接</p><ul><li>持续性连接</li><li>非持续性连接</li></ul></li></ul><h4 id="1-2报文格式"><a href="#1-2报文格式" class="headerlink" title="1.2报文格式"></a>1.2报文格式</h4><p>​    分类:请求报文和响应报文</p><ul><li><p>请求报文</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527201409324.png" alt="image-20210527201409324"></p></li></ul><p>HTTP 请求报文的第一行 <strong>请求行</strong> (request line) ，</p><p>后继的行叫做<strong>首部行</strong>( header line) </p><p>请求行有3个字段:方法字段、 URL 字段和 HTTP 版本字段 </p><p>方法宇段可以取几种不同的值，包括 GET OST HEAD PUT DELETE</p><p>Connec Li on: close 首部行</p><p>User- agent: 首部行</p><p>Accept -language 首部行</p><p>首部行 Host: www. someschool. edu</p><ul><li>请求报文通用首部格式</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202001957.png" alt="image-20210527202001957"></p><ul><li>响应报文</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202207984.png" alt="image-20210527202207984"></p><p>​                组成：一个初始状态行 (sLatus line) 、首部行 (header 1ine) 、实体体                 (enLity body)—–报文的主要部分</p><p>​                Connection: close 首部行</p><p>​                Date: 首部行</p><p>​                Server: 首部行</p><p>​                Last- Moclified: 首部行</p><p>​                Conlenl- Length: 首部行</p><p>​                Conlent- Type: 首部行</p><ul><li>响应报文通用格式：</li></ul><p>​    <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202521768.png" alt="image-20210527202521768"></p><ul><li>响应报文常见的状态码和相关的短语:</li></ul><p> 200 OK: 请求成功信息在返回的响应报文中</p><p>• 301 Movecl Pennanenùy: 请求的对象已经被永久转移了，新的 URL 定义在响应报文的LocaLi oD: 首部行中 客户软件将自动获取新的 URL</p><p>• 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解72 </p><p>• 404 Not FO lll1 d: 被请求的文档不在服务器上</p><p>• 505 HTTP Version Not Supported: 服务器不支持请求报文使用的 HTTP 协议版本</p><h4 id="1-3Cookie"><a href="#1-3Cookie" class="headerlink" title="1.3Cookie"></a>1.3Cookie</h4><ul><li><p>cookie 技术的4个组件:</p><ul><li>①在 HTTP 响应报文中的 cookie 首部行;</li><li>②在 HTTP 请求报文中的一个 cookie 首部行;</li><li>③在用户端系统中保留有 cookie件，并由用户的浏览器进行管理;</li><li>④位于 Web 站点的一个后端数据库</li></ul></li><li><p>流程：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527203342657.png" alt="image-20210527203342657"></p></li></ul><ul><li><hr></li></ul><ol><li><p>用户首次访问 个站点时，可能需要提供 个用户标识(可能是名字)</p></li><li><p>在后继会话中，浏览器向服务器传递cookie 首部，从而向该服务器标识了用户</p></li><li><p>因此 cookie 可以在无状态的 HTTP 之上建立个用户会话层 </p></li></ol><ul><li>注:它的使用仍具有争议，因为它们被认为是对用户隐私的一种侵害</li></ul><h4 id="1-4Web缓存"><a href="#1-4Web缓存" class="headerlink" title="1.4Web缓存"></a>1.4Web缓存</h4><ul><li><p><strong>Web 缓存器</strong>也叫<strong>代理服务器</strong></p></li><li><p>拥有自己的存储空间；</p></li><li><p>Web 缓存器是服务器同时又是客户（可以发送和接收响应）</p></li><li><p>部署 Web 缓存器有两个原因：</p><ul><li><p>大大减少对客户请求的响应时间</p><ul><li><p>是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之</p><p>间的瓶颈带宽时更是如此</p></li></ul></li><li><p>大大减少一个机构的接入链路到闲特网的通信量</p><ul><li>减少通信量， 不必急于增加带宽，降低了费用。</li></ul></li></ul></li></ul><p>具体详见 图解http</p><h2 id="三、文件传输协议：FTP"><a href="#三、文件传输协议：FTP" class="headerlink" title="三、文件传输协议：FTP"></a>三、文件传输协议：FTP</h2><h4 id="1-协议运行"><a href="#1-协议运行" class="headerlink" title="1. 协议运行"></a>1. 协议运行</h4><p>，用户通过一个阿?用户代理与阿?交五 该用</p><p>户首先提供远程主机的主机名，使本地主机的归?客户进程建立一个到远程主机凹?服务</p><p>器进程的 TCP 连接。该用户接着提供用户标识和口令，作为 FTP 命令的一部分在该 TCP</p><p>连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者</p><p>多个文件复制到远程文件系统(反之亦然)。</p><h4 id="2-FTP-和HTTP-的区别"><a href="#2-FTP-和HTTP-的区别" class="headerlink" title="2. FTP 和HTTP 的区别"></a>2. FTP 和HTTP 的区别</h4><h5 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1 连接"></a>2.1 连接</h5><ul><li>FTP 使用了两个并行的 TCP 连接来传输文件<ul><li>控制连接 (control connection)：在两主机之间传输控制信息</li><li>数据连接( data connection)：实际发送一个文件</li><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527205305119.png" alt="image-20210527205305119"></li></ul></li><li>HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行</li></ul><h5 id="2-2-状态"><a href="#2-2-状态" class="headerlink" title="2.2 状态"></a>2.2 状态</h5><ul><li>FTP 服务器必须在整个会话期间保留用户的状态( state)；</li><li>HTTP 是无状态的，即它不必对任何用户状态进行追踪</li></ul><h4 id="3-常见命令和回答"><a href="#3-常见命令和回答" class="headerlink" title="3.常见命令和回答"></a>3.常见命令和回答</h4><ul><li>命令和回答都是7比特 ASCII格式在控制连接上传送</li></ul><h5 id="3-1-命令"><a href="#3-1-命令" class="headerlink" title="3.1 命令"></a>3.1 命令</h5><ul><li><p>每个命令由 个大写字母 ASCII 字符组成，有些还具有可选参数</p></li><li><p>为常见的命令如下:</p><ul><li><p>USER usemame: 用于向服务器传送用户标识</p></li><li><p>P ASS password: 用于向服务器发送用户口令</p></li><li><p>UST: 用于请求服务器回送当前远程目录中的所有文件列表 该文件列表是经一个(新建且非持续连接)数据连接传送的，而不是在控制 TCP 连接上传送。</p></li><li><p>RETR filename: 用于从远程主机当前目录检索(自 gel) 文件 该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件</p></li><li><p>STOR filename: 用于在远程主机的当前目录上存放(即 put) 文件</p></li></ul></li><li><p>每个命令都对应着一个从服务器发向客户的回答。</p></li></ul><h5 id="3-2-回答"><a href="#3-2-回答" class="headerlink" title="3.2 回答"></a>3.2 回答</h5><ul><li><p>回答是一个三位数字，加上可选信息。</p></li><li><p>一些典型的回答连同它们可能的报文：</p><ul><li>331 Usemame OK , Password requüed (用户名 OK ，需要口令)</li><li>125 Dala connection already open; transfer starting (数据连接已经打开，开始传送)</li><li>425 Can’ L open daLa connection (无法打开数据连接)</li><li>452 Error writing (写文件差错)</li></ul></li></ul><h2 id="四、电子邮件"><a href="#四、电子邮件" class="headerlink" title="四、电子邮件"></a>四、电子邮件</h2><h2 id="五、DNS"><a href="#五、DNS" class="headerlink" title="五、DNS"></a>五、DNS</h2><p>因特网的目录服务</p><h2 id="六、P2P"><a href="#六、P2P" class="headerlink" title="六、P2P"></a>六、P2P</h2>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network  summery：运输层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-06-20T11:59:58.000Z</published>
    <updated>2021-11-08T15:59:56.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-summery：运输层"><a href="#Computer-Network-summery：运输层" class="headerlink" title="Computer Network  summery：运输层"></a>Computer Network  summery：运输层</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul><li><p>为运行在不同主机上的进程提供服务（逻辑通信）</p></li><li><p>运输层协议在端系统中实现，不是在路由器中实现。</p></li><li><p>应用层报文段 ：将应用层报文分块，添加运输层首部</p></li><li><p>应用层协议：TCP  / UDP</p><ul><li>TCP :面向连接的，可靠的服务</li><li>UDP：无连接的，不可靠服务</li></ul></li><li><p>网络层可能会使分组丢失，篡改，冗余，运输层可以提供可靠数据传输</p></li><li><p>多路复用和多路分解</p><ul><li><p>多路分解：运输层报文段正确交付到相应 套接字</p></li><li><p>多路复用：主机收集套接字信息，生成运输层报文，并传输到网络层中</p></li><li><p>UDP 的多路复用和分解</p><ul><li>一个UDP套接字：二元组（目的IP，目的端口号）</li></ul></li></ul></li><li><ul><li>tcp的多路复用和分解<ul><li>TCP套接字（目的IP，目的端口号，源IP，源端口号）<ul><li>后续报文段与之匹配，发送到该端口</li></ul></li><li>服务器主机支持很多并行套接字，每个与一个进程相连</li></ul></li></ul></li><li><p>== 端口扫描技术 == </p></li></ul><h2 id="二、UDP协议"><a href="#二、UDP协议" class="headerlink" title="二、UDP协议"></a>二、UDP协议</h2><p>  1.概述</p><ul><li>特点<ul><li>无需建立连接：无连接传输</li><li>分组首部开销小: 首部8个字节</li><li>控制更加精细（与应用层相比）</li><li>无连接的状态：无连接状态参数</li></ul></li><li>用于承载网络管理数据SNMP</li><li>运行的协议和服务：DNS、</li></ul><ol start="2"><li><p>报文结构‘</p><p>2.1 报文结构:</p></li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526194949625.png" alt="image-20210526194949625"></p><p>​     2.2 检验和：检测传输比特是否改变  </p><ul><li>方法：</li></ul><ul><li>原因：端到端服务需要差错检测，各链路情况不同，无法逐链路确保可靠性   即:</li></ul><h2 id="三、可靠传输原理"><a href="#三、可靠传输原理" class="headerlink" title="三、可靠传输原理"></a>三、可靠传输原理</h2><ol><li><p>流水线可靠数据传输协议</p><ul><li>不使用停等方式运行，允许发送方发送多个分组而无需等待确认， 许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，这种技术被称为流水线( pipelining)</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526195644330.png" alt="image-20210526195644330"></p><ul><li><p>流水线可靠传输协议带来的问题：</p><ul><li><p>必须增加序号范围</p></li><li><p>发送方和接收方两端也许必须缓存多个分组</p></li><li><p>解决流水线的差错恢复有两种基本方法是:回退 (Go- Back- N)</p><p>GBN) 和选择重传 (Selective Repeat. SR)</p></li></ul></li></ul></li><li><p>回退N步</p></li></ol><ol start="3"><li>选择重传</li></ol><h2 id="四、TCP协议"><a href="#四、TCP协议" class="headerlink" title="四、TCP协议"></a>四、TCP协议</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>提供的是全双工服务(full- duplex service)</li><li>TCP 连接是点对点( point-to-point) 的</li><li>连接的建立：三次握手</li><li>连接的断开：四次挥手</li><li>TCP  最大报文段长度 (Maximum Segmenl Size , MSS) ， MSS 的典型值为 1460 字节</li><li>TCP/IP 首部字段长度20字节</li><li>TCP 数据发送和接收依赖两端主机维护的接收缓存和发送缓存。应用程序从此缓存中读取数据流。（每一端都有各自的发送缓存和接收缓存）</li></ul><h3 id="2-报文结构"><a href="#2-报文结构" class="headerlink" title="2.报文结构"></a>2.报文结构</h3><p>：通常是20个字节（选项部分可变长，平常是0）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526201119908.png" alt="image-20210526201119908"></p><ul><li>32 比特的序号字段 (sequence number field) <ul><li>标记发送方数据报文段首字节的字节流编号</li></ul></li><li>32 比特的确认号字段( acknowledgment number field) <ul><li>主机 期望从主机 收到的下一字节的序号</li></ul></li><li>16 比特的接收窗口字段 (receive window field)<ul><li>用于流量控制</li></ul></li><li>可选与变长的选项字段（options field) </li><li>4 比特的首部长度字段 (header length field)</li><li>6 比特的标志字段 (fLag field) <ul><li>RST SYN FIN 比特用于连接建立和拆除</li><li>PSH ： 指示接收方应立即尽可能得将数据交给上层</li><li>URG ：指示报文段存在着被发送端的上层实体置为”紧急”的数据 紧急数据的最后一个字节由 16 比特的数据指针字段指出。</li></ul></li><li>接收窗口</li></ul><h3 id="3-累计确认"><a href="#3-累计确认" class="headerlink" title="3.累计确认"></a>3.累计确认</h3><p>对客户到服务器的数据的确认被装载在</p><p>个承载服务器到客户的数据的报文段中;这种确认被称为是被捎带( piggybacked )在服务器到客户的数据报文段中的</p><h3 id="4-超时重传"><a href="#4-超时重传" class="headerlink" title="4.超时重传"></a>4.超时重传</h3><p>4.1往返时间的估计</p><ul><li><p>样本RTT:某报文段的确认被收到之间的时间量</p><ul><li>为已发送，未确认的报文段估计 SampleRTT</li><li>不为已被重传的报文段计算 SampleRTT; </li></ul></li><li><p>SampleRTT 均值  (称为 EstimatedRTT)</p><ul><li><p>计算方法：</p><p>EstÌmatedRTT = (1 -α) . EstimatedRTT +α. SampleRTT </p></li><li><p>α的 参考值是α=0.125 </p></li></ul></li><li><p>RTT 偏差DevRTT</p><ul><li>DevRTT = (1 -β) . DevRTT +β. I SampleRTT matedRTT I </li><li>β 的推荐值为 0.25</li></ul></li><li><p>重传超时间隔</p><ul><li>算法：TimeoutInterval = EstimatedRTI +4 . DevRTT</li><li>推荐的初始 TimeoutInterval 值为1 秒</li></ul></li></ul><h3 id="5-可靠数据传输："><a href="#5-可靠数据传输：" class="headerlink" title="5.可靠数据传输："></a>5.可靠数据传输：</h3><ul><li><p>TCP 发送方与发送和重传有关的主要事件:从应用程序接收数据;定时器超时和收到 ACK </p><ul><li>定时器：当报文段被传给 IP时， TCP 启动定时器</li><li>超时：重传报文段，TCP重启定时器</li><li>ACK：包含了有效 ACK 字段值的报文段的接受和比较</li></ul></li><li><h2 id="一些特殊情况："><a href="#一些特殊情况：" class="headerlink" title="一些特殊情况："></a>一些特殊情况：</h2></li><li><p>超时间隔加倍</p></li><li><p>快速重传：一旦收到 个冗余 ACK ，TCP 就执行快速重传(fast retransmil) </p><ul><li>超时重传超时周期长，增加了端到端时延</li><li>冗余 ACK(duplicate ACK)   （出现在报文丢失）对相同数据的 ACK</li></ul></li><li><p>TCP 确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的</p></li></ul><h3 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6.流量控制"></a>6.流量控制</h3><p>6.1概念：</p><p>流量控制服务( fl0w- control service) 以消除发送方使接收方缓存溢出的可能性。</p><ul><li><p>接收缓存</p><ul><li><p>用RcvBuffer 来表示其大小</p></li><li><p>• LastByteReacl: 主机 上的应用进程从发送缓存读出的数据流的最后 个字节的编号</p><p>• LastByteRcvd:  到达的并已放入主机 接收缓存中的数据流的最后字节编号</p></li><li><p>算法：LasLByteRcvd - LastByteRead ~ RcvBuffer </p></li></ul></li><li><p>接收窗口用：rwnd </p><ul><li>根据缓存可用空间的数量来设置:</li><li>rwnd = RcvBuffer - [LastByteRcvd - LastßyteRead ] </li><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211048201.png" alt="image-20210526211048201"></li></ul></li><li><p>主机在该连接的整个生命周期应保证:</p><p>​                LastByteSent - LastByteAcked &lt;=rwnd</p></li></ul><h3 id="7-TCP连接"><a href="#7-TCP连接" class="headerlink" title="7.TCP连接"></a>7.TCP连接</h3><p>7.1建立连接</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211607326.png" alt="image-20210526211607326"></p><p>7.2 连接的断开</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211636290.png" alt="image-20210526211636290"></p><p>7.3 状态的变迁</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211720656.png" alt="image-20210526211720656"></p><p>7.4 SYN泛洪攻击</p><h3 id="8-拥塞控制"><a href="#8-拥塞控制" class="headerlink" title="8.拥塞控制"></a>8.拥塞控制</h3><p>7.1 概念：TCP 发送方因 网络的拥塞而被遏制;这种形式的发送方的控制被称为拥塞控制 (congestion control)</p><ul><li><p>在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥塞窗口</p><p>(congeslion window) 。</p><ul><li><p>拥塞窗口表示为 cwnd  对 TCP 发送方 发送流量的速率进行了限制 </p></li><li><p>在一个发送方中未被确认的数据量不会超过 cwnd rwnd 中的最小值，即：</p><p>LastyleSent - LastByteAcked&lt;= min { cwnd ，rwnd }</p></li></ul></li></ul><p>7.2拥塞控制：</p><ul><li><p>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率</p></li><li><p>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此 ，当对先前未确认报文段的确认到达时，增加发送方的速率。</p></li><li><p>带宽探测：为探测拥塞开始出现的速率， TCP 发送方增加它的</p><p>传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化</p></li></ul><p>7.3拥塞控制算法</p><p>该算法包括 个主要部分 ①慢启动;②拥塞避免;③快速恢复</p><p>如图所示：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526213509588.png" alt="image-20210526213509588"></p><ol><li><p>慢启动</p><p>TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据包的数量</p><p>慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 <strong>ACK</strong>，拥塞窗⼝ <strong>cwnd</strong> 的⼤⼩就会加 <strong>1</strong>。</p><p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</p><p>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</p><p>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</p><p>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发</p><p>4 个，所以这⼀次能够发送 8 个。</p></li><li><p>拥塞避免算法</p></li></ol><ul><li><p>当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。</p></li><li><p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。</p></li><li><p>规则：每当收到⼀个 <strong>ACK</strong> 时，<strong>cwnd</strong> 增加 <strong>1/cwnd</strong>。</p></li><li><p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ： </p></li></ul><p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9</p><p>个 MSS ⼤⼩的数据，变成了线性增⻓。</p><ul><li>拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶段，但是增⻓速度缓慢了。</li></ul><p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」。</p><p>拥塞发⽣</p><p>当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：</p><p>超时重传</p><p>快速重传</p><p>这两种使⽤的拥塞发送算法是不同的， </p><ol><li>发⽣超时重传的拥塞发⽣算法</li></ol><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。</p><ul><li><p>ssthresh 和 cwnd 的值会发⽣变化：</p><p>​                ssthresh 设为 cwnd/2 ，cwnd 重置为 1</p></li></ul><p>2.发⽣快速重传的拥塞发⽣算法</p><p>还有更好的⽅式，前⾯我们讲过「快速重传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地᯿传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：</p><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p><p>ssthresh = cwnd ;进⼊快速恢复算法</p><p>3.快速恢复</p><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也不那么糟</p><p>糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：</p><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p><p>ssthresh = cwnd ;</p><p>然后，进⼊快速恢复算法如下：</p><p>拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</p><p>重传丢失的数据包；</p><p>如果再收到重复的 ACK，那么 cwnd 增加 1；</p><p>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说</p><p>明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进</p><p>⼊拥塞避免状态；也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。</p><ol start="4"><li><p>回顾</p><p>TCP 的拥塞控制是:</p></li></ol><p>每个 RTT cwnd 线性(加性)增加 lMSS ，然后出现 个冗余ACK 事件时 cwnd 减半(乘性减) 。</p><p>因此， TCP 拥塞控制常常被称为加性增、乘性减(Additive-lncrease , Multiplicati 吨- Decrease , AIMD) 拥塞控制方式 </p><ul><li><p>整体流程</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526214305050.png" alt="image-20210526214305050"></p></li><li><p>其他算法：Reno 算法、TCPVegas 算法</p></li></ul><p>参考文献  :计算机网络自顶向下方法</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Computer network Summery 数据链路层</title>
    <link href="http://example.com/2021/06/02/Computer-network-Summery-of-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/06/02/Computer-network-Summery-of-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-06-02T02:31:55.000Z</published>
    <updated>2021-11-08T15:59:56.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="network-Summery-of-数据链路层"><a href="#network-Summery-of-数据链路层" class="headerlink" title="network Summery of 数据链路层"></a>network Summery of 数据链路层</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><ul><li><p>数据链路层设备的关系及作用</p></li><li><p>两种通信：点对点通信；广播通信</p></li><li><p>三种基本问题：透明传输；差错检测；封装成帧</p></li><li><p>以太网以及MAC地址</p></li></ul><h2 id="二-三种问题"><a href="#二-三种问题" class="headerlink" title="二.三种问题"></a>二.三种问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1.封装成帧"></a>1.封装成帧</h3><ul><li><p>帧长加上帧首部和帧尾部的长度</p></li><li><p>采用特殊的帧定界符，确定帧的启始和结束：SOH,EOT</p></li><li><p>数据部分传输上限：MTU（以太网：46~1500）</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626103006101.png" alt="image-20210626103006101"></p></li></ul><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2.透明传输"></a>2.透明传输</h3><ul><li><p>尽可能将出现的SOH,EOT在接收端不被看成控制字符</p><ul><li>字节填充法：在两个控制字符前加上ESC转义字符，如果转义字符也出现在数据中，则在ecs前也加上ECS，由接收端进行删除第一个ECS</li></ul></li></ul><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3.差错检测"></a>3.差错检测</h3><ul><li><p>实现的是误比特差错传输，不是可靠传输</p><ul><li>没有比特差错但是可能出现：帧丢失；帧重复；帧失序</li></ul></li><li><p>循环冗余检测CRC</p><ul><li><a href="https://blog.csdn.net/wenqiang1208/article/details/71641414?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162467580116780271519343%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162467580116780271519343&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-71641414.first_rank_v2_pc_rank_v29_1&utm_term=%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E6%B5%8B&spm=1018.2226.3001.4187">具体参见</a></li><li>FCS是冗余码，CRC是循环冗余算法，不要混淆</li></ul></li><li><p>凡是链路层接收的数据在传输的过程均无产生差错</p></li></ul><h2 id="三-点对点通信"><a href="#三-点对点通信" class="headerlink" title="三. 点对点通信"></a>三. 点对点通信</h2><h3 id="1-链路和数据链路的区别"><a href="#1-链路和数据链路的区别" class="headerlink" title="1.链路和数据链路的区别"></a>1.链路和数据链路的区别</h3><ul><li><p>链路（物理链路）：相邻节点之间的物理线路</p></li><li><p>数据链路（逻辑链路）：实现控制一条线路数据传输的协议的硬件和软件与链路共同组成了数据链路</p></li><li><p>基本数据单元：（数据）帧</p></li></ul><h3 id="2-点对点协议PPP"><a href="#2-点对点协议PPP" class="headerlink" title="2.点对点协议PPP"></a>2.点对点协议PPP</h3><p>1.特点：【RFC 1661】</p><ul><li>数据链路层协议</li><li>用户计算机和ISP通信的协议</li></ul><p>2.要求</p><ul><li>简单：相对IP简单很多</li><li>封装成帧：添加收首部，尾部添加FCS差错检测帧；添加帧定界符，确认帧的起始和结束</li><li>多种链路类型：可以使用多种链路类型</li><li>多种网络层协议：同一条链路支持多种网络协议（IP ,IPx）</li><li>透明性：避免帧定界符与数据中一样的比特组合出现混淆</li><li>差错检测：丢弃由差错的帧</li><li>检测连接状态：每隔几分钟查看链路工作状态</li><li>最大传输单元：MTU（数据链路层最大传输的<strong>数据</strong>长度）</li></ul><p>3.组成</p><ul><li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626100122931.png" alt="image-20210626100122931"></p></li><li><p>以一个标志字节起始和结束的，该字节为0x7E （区分出每个PPP帧）</p></li><li><p>标志字节后的一个字节是 地址域，该字节为 0x FF。 （ <!--PPP协议是被运用在点对点的链路上的，点对点的链路就可以唯一标示对方，因此使用PPP协议互连的通信设备的两端无须知道对方的数据链路层地址，所以该字节已无任何意义，按照协议的规定将该字节填充为全1的广播地址。-->）</p></li><li><p>同地址域一样，PPP数据帧的控制域也没有实际意义，按照协议的规定通信双方将该字节的内容填充为0x03。 </p></li><li><p>协议域可用来区分PPP数据帧中信息域所承载的数据报文的内容。协议域的内容必须依据ISO 3309的地址扩展机制所给出的规定。该机制规定协议域所填充的内容必须为奇数，也即是要求低字节的最低位为“1”，高字节的最低位为“0”。如果当发送端发送的PPP数据帧的协议域字段不符合上述规定，则接收端会认为此数据帧是不可识别的，那么接收端会向发送端发送一个Protocol-Reject报文，在该报文尾部将完整地填充被拒绝的报文。</p></li><li><p><strong>信息域缺省时最大长度不能超过1500字节</strong>，（<!--其中包括填充域的内容，1500字节大小等于PPP协议中配置参数选项MRU（Maximum Receive Unit）的缺省值，在实际应用当中可根据实际需要进行信息域最大封装长度选项的协商。信息域如果不足1500字节时可被填充，但不是必须的，如果填充则需通信双方的两端能辨认出有用与无用的信息方可正常通信。-->）</p></li><li><p>协议域和信息域是需要合在一起看的 ，主要用到的协议类型有LCP、NCP和普通的IP协议，而他们相对应的协议域字段则为0×C021、0×8021和0×0021 </p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626100950995.png" alt="image-20210626100950995"></p></li><li><p>尾部FCS（帧检验序列）差错检测，</p></li></ul><p>4.字节填充：信息字段出现和标志字段相同的比特组合时进行比特填充</p><ul><li>方法<ul><li>信息字段出现的每一个0x7E转变成(0x7D,0x5e)</li></ul></li></ul><p>5.零比特填充：同步传输时，采用零比特传输的方式实现透明传输（避免与标志字段混淆）</p><ul><li>发送端：扫描，出现连续的五个1，立即填入一个0</li><li>接收端：接受，出现连续五个1，把下一个0删除</li></ul><h2 id="四-局域网通信"><a href="#四-局域网通信" class="headerlink" title="四.局域网通信"></a>四.局域网通信</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h3><ul><li>局域网的优点<ul><li>具有广播功能</li><li>实现了系统的可靠性，可用性和生存性</li><li>系统扩展方便灵活</li></ul></li><li>局域网的分类<ul><li>总线网</li><li>星形网</li><li>环形网</li></ul></li><li>传输设备:双绞线（适用于10Mbit/s~~~10Gbit/s）</li><li>两个标准：Ethernet2；802.3</li><li>信道的划分采用动态媒体接入控制（多点接入），又分为：<ul><li>随机接入（常见）</li><li>控制接入</li></ul></li></ul><h3 id="2-以太网"><a href="#2-以太网" class="headerlink" title="2.以太网"></a>2.以太网</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li><p>两个标准：Ethernet2；802.3</p></li><li><p>CSMA/CD协议：</p><p><a href="https://blog.csdn.net/lucyxiaomeng/article/details/80563845?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162469137716780366575772%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162469137716780366575772&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80563845.first_rank_v2_pc_rank_v29_1&utm_term=CSMA/CD%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187">CSMA/CD协议</a></p></li></ul><h4 id="2-以太网帧"><a href="#2-以太网帧" class="headerlink" title="2.以太网帧"></a>2.以太网帧</h4><p>以太网帧字节的范围应该是72~1526。<br>以太网帧格式如下图：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626111904849.png" alt="image-20210626111904849"></p><p>Preamble：前导同步码7个字节+帧开始定界符1个字节，共计8个字节；<br>Destination MAC address：目的MAC地址，占用6个字节；<br>Source MAC address：源MAC地址，占用6个字节；<br>Type/Length：帧类型，占用2个字节；<br>User Data：数据信息，最少46个字节，最大1500字节；<br>Frame Check Sequence（FCS）：帧校验序列，占用4个字节；<br>从帧结构可以看出</p><p>，<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210626111922033.png" alt="image-20210626111922033" style="zoom:80%;" /></p><p>8+6+6+2+（46<del>1500）+4=72</del>1526<br>因此以太网帧字节的范围是应该是72~1526，</p><p>以太网帧字节的范围是64~1518</p><h4 id="3-MAC"><a href="#3-MAC" class="headerlink" title="3.MAC"></a>3.MAC</h4><ul><li>也叫物理地址，硬件地址 16进制表示</li><li>48位，6字节（全球唯一）；前三字节代表<strong>组织唯一标识符OUI</strong>；后三位：<strong>扩展唯一标识符EUI</strong></li><li>固化在适配器的ROM 中</li></ul><h4 id="4-通道利用率"><a href="#4-通道利用率" class="headerlink" title="4.通道利用率"></a>4.通道利用率</h4><ul><li><p>假设┏ 是以太网单程端的传播时延。则争用期长度为2┏ ，即端到端传播时延的两倍；检测到碰撞后不发送干扰信号；<br>设帧长为L（bit），数据发送速率为C（bit/s）,则帧的发送时间To=L/C(s);<br>成功发送一个帧需要占用信道的时间为To+┏ ,比这个帧的发送时间To还要多一个单程端到端时延</p></li><li><p>参数a和利用率<br>参数a越小，以太网的信道利用率就越高————a=┏ /To;</p><ul><li>a趋向0时，表示一发生碰撞就可以立即检测出来，并立即停止发送，因而信道利用率很高；</li><li>a越大，表明争用期所占的比列增大，每发生一次碰撞就浪费许多信道资源，使信道利用率明显降低；</li></ul></li><li><p>对参数a的要求：</p><p>当数据率一定时，以太网的连线长度受到限制，否则┏ 的数值会变大；<br>以太网的帧长不能太短，否则To的值会太小，使a的值太大</p></li><li><p>信道利用率的最大值Smax = To/(To+┏ )=1/（1+a）;</p><ol><li><p>To为帧本身的发送时间，To+┏ 是发送一帧占用线路的时间；</p></li><li><p>当参数a远小于1才能得到尽可能高的极限信道利用率；</p></li><li><p>当以太网的信道利用率达到30%时 ，处于重载的情况 </p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注：数据帧能够重传的一个条件：以太网要实现重传，必须保证这个站在收到冲突信号的时候这个帧没有传完。</span><br><span class="line">所以基于这种情况，以太网规定了一个最短帧的长度为64个字节，即512bit。因为64字节正好是争用期长度，如果在争用期内没有发生碰撞，那么就不会发生碰撞了。因此，凡长度小于64字节的帧都是由于冲突而异常停止的无效帧。接收端收到这种帧会直接丢弃。（对于10Mb/s传统以太网而言）--&gt;</span><br></pre></td></tr></table></figure><h2 id="五-常见设备"><a href="#五-常见设备" class="headerlink" title="五.常见设备"></a>五.常见设备</h2><h3 id="1-集线器（hub）"><a href="#1-集线器（hub）" class="headerlink" title="1.集线器（hub）"></a>1.集线器（hub）</h3><ul><li>物理层</li><li>有多个接口的中继器</li><li>总线型结构（逻辑总线），使用CSMA/CD协议</li><li>同一时刻只允许一个站发送数据</li><li>只能处于半双工的工作状态，不能分割冲突域，网络的吞吐率会受到限制</li><li>逐渐被交换式集线器取代</li></ul><h3 id="2-适配器"><a href="#2-适配器" class="headerlink" title="2.适配器"></a>2.适配器</h3><ul><li><p>网卡NIC</p></li><li><p>物理层</p></li><li><p>数据串行传输和并行传输转换</p></li><li><p>实现以太网协议</p></li><li><p>搭载计算机硬件地址MAC</p></li></ul><h3 id="3-网关"><a href="#3-网关" class="headerlink" title="3.网关"></a>3.网关</h3><ul><li><p>一个虚拟概念</p></li><li><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，</p></li><li><p>用于两个高层协议不同的网络互连。</p></li><li><p>网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。 </p></li><li><p>网关也可以提供过滤和安全功能。大多数网关运行在OSI 7层协议的顶层–应用层</p></li></ul><h3 id="4-以太网交换机"><a href="#4-以太网交换机" class="headerlink" title="4.以太网交换机"></a>4.以太网交换机</h3><ul><li><p>数据链路层</p></li><li><p>也叫交换式集线器，第二层交换机</p></li><li><p>实质上是<strong>多接口</strong>的网桥</p></li><li><p>即插即用，内部包含交换表（通过自学习的方式）</p></li></ul><h3 id="5-路由器"><a href="#5-路由器" class="headerlink" title="5.路由器"></a>5.路由器</h3><ul><li>第三层交换机 </li><li>网络层</li><li>主要进行分组转发，网络层核心设备</li><li>实现路由选择协议，同时具有将网络地址（IP地址）到下层链路层地址（mac）的转换能力：ARP</li></ul><h3 id="6-调制解调器"><a href="#6-调制解调器" class="headerlink" title="6.调制解调器"></a>6.调制解调器</h3><ul><li>物理层</li><li>将<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字信号</a><a href="https://zh.wikipedia.org/wiki/%E8%AA%BF%E8%AE%8A">调变</a>到<a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E4%BF%A1%E8%99%9F">模拟信号</a>上进行传输，并<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E8%AA%BF">解调</a>收到的模拟信号以得到数字信号 的电子设备</li></ul><h3 id="7-网桥"><a href="#7-网桥" class="headerlink" title="7.网桥"></a>7.网桥</h3><ul><li><p>网桥又称桥接器，英文名Network Bridge，</p></li><li><p>数据链路层设备。 </p></li><li><p>网桥能从发来的数据包中提取MAC信息，并且根据MAC信息对数据包进行有目的的转发，而不采用广播的方式</p></li><li><p>高级（避免广播）的集线器</p></li><li><p>只有两个端口，MAC表记录的是MAC-PortNum</p><p>​        HUB 所有端口都在同一个广播域，冲突域内。<br>　　Switch所有端口都在同一个广播域内，而每一个端口就是一个冲突域。<br>　　Router的每个端口属于不同的广播域。 </p></li></ul><h3 id="8-中继器"><a href="#8-中继器" class="headerlink" title="8.中继器"></a>8.中继器</h3><ul><li><p>物理层</p></li><li><p>将信号整形再放大转发出去，消除信号经过长段电缆而产生的失真和衰减</p></li><li><p>有两个端口</p><ul><li>输入端口</li><li>输出端口</li></ul></li><li><p>连接同一网络，具有相同速率，相同协议。</p></li></ul><h2 id="六-高速以太网"><a href="#六-高速以太网" class="headerlink" title="六.高速以太网"></a>六.高速以太网</h2><p>速率达到或超过100Mb/s的以太网称为高速以太网。</p><ul><li><p>100BASE-T：（快速以太网）</p><ul><li>双绞线传输</li><li>100Mbit/s</li><li>使用802.3的CSMA/CD</li></ul></li><li><p>吉比特以太网——千兆以太网</p><ul><li><p>吉比特以太网可用作现有网络的主干网，也可在高带宽(即高速率)的应用场合中用来连接工作站和服务器。</p></li><li><p>吉比特以太网的物理层使用以下两种成熟的技术：<br>(1)来自现有的以太网。<br>(2)ANSI制定的光纤通道FC(Fibre Channel)。</p></li><li><p>吉比特以太网的标准IEEE802.3z有以下几个特点：</p><ol><li><p>允许在1Gb/s下全双工和半双工两种工作方式。</p></li><li><p>使用IEEE802.3协议规定的帧格式。</p></li><li><p>在半双工方式下使用CSMA/CD协议，而在全双工方式下不需要使用CSMA/CD协议</p></li><li><p>与10BASE-T和100BASE-T技术向后兼容。</p></li></ol></li></ul></li><li><p>10吉比特以太网——万兆以太网</p><ul><li>由于10GE的出现，以太网的工作范围已经从局域网扩大到城域网和广域网，从而实现了端到端的以太网传输。 </li></ul></li><li><p>以太网是：</p><ol><li>可扩展的</li><li>灵活的</li><li>易于安装的</li><li>稳健性好的</li></ol></li></ul><p><strong>参考文献：</strong><br>[1]《计算机网络(第5版)》谢希仁</p><p>[2]《计算机网络自顶向下方法》</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="network" scheme="http://example.com/categories/network/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
</feed>
