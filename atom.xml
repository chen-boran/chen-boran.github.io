<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-28T09:34:16.729Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL常见问题</title>
    <link href="http://example.com/2021/04/28/SQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/04/28/SQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-28T09:16:53.000Z</published>
    <updated>2021-04-28T09:34:16.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="delete-truncate-drop-的区别"><a href="#delete-truncate-drop-的区别" class="headerlink" title="delete truncate drop 的区别"></a>delete truncate drop 的区别</h2><p>TRUNCATE TABLE 在功能上与不带 Where 子句的 Delete 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 Delete 速度快，且使用的系统和事务日志资源少。</p><p> Delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p> TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 Delete。</p><p> 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 Where 子句的 Delete 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><p> TRUNCATE TABLE 不能用于参与了索引视图的表。</p><p> truncate,delete,drop的异同点：<br> 注意:这里说的delete是指不带where子句的delete语句</p><p>相同点:truncate和不带where子句的delete, 以及drop都会删除表内的数据 </p><p>不同点:<br>   1.truncate和 delete只删除数据不删除表的结构(定义)<br>    drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.</p><p>   2.delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.<br>    truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p><p>   3.delete语句不影响表所占用的extent, 高水线(high w2atermark)保持原位置不动<br>    显然drop语句将表所占用的空间全部释放<br>    truncate 语句缺省情况下将空间释放到 minextents个 extent,除非使用reuse storage;  truncate会将高水线复位(回到最开始).</p><p>   4.速度,一般来说: drop&gt; truncate &gt; delete</p><p>   5.安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及</p><p>   使用上：<br>   想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.</p><p>   想删除表,当然用drop</p><p>   想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.</p><p>   如果是整理表内部的碎片,可以用truncate跟上reuse stroage,再重新导入/插入数据</p><h2 id="sql基本组成"><a href="#sql基本组成" class="headerlink" title="sql基本组成"></a>sql基本组成</h2><p><strong>DDL****（Data</strong> <strong>Definition Language</strong>）<strong>数据库<strong><strong>定义</strong></strong>语言</strong></p><p>  DDL不需要commit. eg. CREATE ALTER DROP TRUNCATE COMMENT RENAME</p><p>****DML**（*<em>Data Manipulation Language*<em>）*<em>数据操纵语言*</em></em></em></p><p>  DML需要commit. eg. SELECT INSERT UPDATE DELETE MERGE CALL EXPLAIN PLAN LOCK TABLE</p><p><strong>DCL<strong><strong>（</strong></strong>Data Control Language<strong><strong>）</strong></strong>数据库控制语言</strong> <strong>授权，角色控制等</strong><br>  GRANT 授权, REVOKE 取消授权<br><strong>TCL<strong><strong>（</strong></strong>Transaction Control Language<strong><strong>）</strong></strong>事务控制语言</strong><br>  SAVEPOINT 设置保存点, ROLLBACK 回滚, SET TRANSACTION</p><h2 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h2><p>sql执行顺序<br>(1)from<br>(3) join<br>(2) on<br>(4) where<br>(5)group by(开始使用select中的别名，后面的语句中都可以使用)<br>(6) avg,sum….<br>(7)having<br>(8) select<br>(9) distinct<br>(10) order by</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Knolege Point SQL</title>
    <link href="http://example.com/2021/04/28/Knolege-Point-SQL/"/>
    <id>http://example.com/2021/04/28/Knolege-Point-SQL/</id>
    <published>2021-04-28T09:14:52.000Z</published>
    <updated>2021-04-28T09:35:58.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>​    一、为什么要学习数据库<br>​    二、数据库的相关概念<br>​        DBMS、DB、SQL<br>​    三、数据库存储数据的特点<br>​    四、初始MySQL<br>​        MySQL产品的介绍<br>​        MySQL产品的安装          ★<br>​        MySQL服务的启动和停止     ★<br>​        MySQL服务的登录和退出     ★<br>​        MySQL的常见命令和语法规范<br>​    五、DQL语言的学习   ★<br>​        基础查询        ★<br>​        条件查询         ★<br>​        排序查询         ★<br>​        常见函数        ★<br>​        分组函数        ★<br>​        分组查询           ★<br>​        连接查询         ★<br>​        子查询       √<br>​        分页查询       ★<br>​        union联合查询    √<br>​        </p><pre><code>六、DML语言的学习    ★                 插入语句                            修改语句                            删除语句                        七、DDL语言的学习      库和表的管理     √                    常见数据类型介绍  √              常见约束        √            八、TCL语言的学习    事务和事务处理                 九、视图的讲解           √十、变量                      十一、存储过程和函数   十二、流程控制结构       </code></pre><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><p>​    1.持久化数据到本地<br>​    2.可以实现结构化查询，方便管理<br>​    </p><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p><p>##数据库存储数据的特点<br>    1、将数据放到表中，表再放到库中<br>    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><p>###MySQL服务的启动和停止<br>    方式一：计算机——右击管理——服务<br>    方式二：通过管理员身份运行<br>    net start 服务名（启动服务）<br>    net stop 服务名（停止服务）</p><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>​    方式一：通过mysql自带的客户端<br>​    只限于root用户</p><pre><code>方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C</code></pre><p>​<br>​    </p><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写<br>​    2.每条命令最好用分号结尾<br>​    3.每条命令根据需要，可以进行缩进 或换行<br>​    4.注释<br>​        单行注释：#注释文字<br>​        单行注释：– 注释文字<br>​        多行注释：/* 注释文字  */<br>​<br>​<br>​    </p><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><p>​    DQL（Data Query Language）：数据查询语言<br>​        select<br>​    DML(Data Manipulate Language):数据操作语言<br>​        insert 、update、delete<br>​    DDL（Data Define Languge）：数据定义语言<br>​        create、drop、alter<br>​    TCL（Transaction Control Language）：事务控制语言<br>​        commit、rollback<br>​    </p><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><p>​    语法：<br>​    SELECT 要查询的东西<br>​    【FROM 表名】;</p><pre><code>类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><p>​    条件查询：根据条件过滤原始表的数据，查询到想要的数据<br>​    语法：<br>​    select<br>​        要查询的字段|表达式|常量值|函数<br>​    from<br>​        表<br>​    where<br>​        条件 ;</p><pre><code>分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><p>​    一、单行函数<br>​    1、字符函数<br>​        concat拼接<br>​        substr截取子串<br>​        upper转换成大写<br>​        lower转换成小写<br>​        trim去前后指定的空格和字符<br>​        ltrim去左边空格<br>​        rtrim去右边空格<br>​        replace替换<br>​        lpad左填充<br>​        rpad右填充<br>​        instr返回子串第一次出现的索引<br>​        length 获取字节个数<br>​        </p><pre><code>2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断    5、其他函数    version版本    database当前库    user当前连接用户</code></pre><p>​    </p><p>二、分组函数</p><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><p>​    语法：<br>​    select 查询的字段，分组函数<br>​    from 表<br>​    group by 分组的字段<br>​<br>​    </p><pre><code>特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选        针对的表    位置            关键字分组前筛选：    原始表        group by的前面        where分组后筛选：    分组后的结果集    group by的后面        having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名</code></pre><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空    ② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><p>表的管理：<br>    1.创建表</p><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME</code></pre><p>​<br>​    );<br>​    </p><pre><code>DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO]  studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;</code></pre><p>​<br>​    #3.删除表<br>​    </p><pre><code>DROP TABLE [IF EXISTS] studentinfo;</code></pre><p>​    </p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：    小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    （ACID）<br>​    原子性：要么都执行，要么都回滚<br>​    一致性：保证数据的状态操作前和操作后保持一致<br>​    隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰<br>​    持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</p><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>    1、开启事务    取消自动提交事务的功能        2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete        3、提交事务或回滚事务</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p><p>视图和表的区别：</p><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表    完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>​    语法：<br>​    CREATE VIEW  视图名<br>​    AS<br>​    查询语句;</p><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><p>​    1、查看视图的数据 ★<br>​    </p><pre><code>SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;</code></pre><p>​<br>​    4、删除视图的数据<br>​    DELETE FROM my_v4;</p><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><p>​    #方式一：<br>​    CREATE OR REPLACE VIEW test_v7<br>​    AS<br>​    SELECT last_name FROM employees<br>​    WHERE employee_id&gt;100;<br>​    </p><pre><code>#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>​    DROP VIEW test_v1,test_v2,test_v3;</p><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><p>​    DESC test_v7;<br>​    SHOW CREATE VIEW test_v7;</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><p>​    call 存储过程名(实参列表)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>​    SELECT 函数名（实参列表）</p><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><p>二、局部变量</p><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><p>二者的区别：</p><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p>三、if elseif语句</p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
  </entry>
  
  <entry>
    <title>Summery of SQL Basic</title>
    <link href="http://example.com/2021/04/28/Summery-of-SQL-Basic/"/>
    <id>http://example.com/2021/04/28/Summery-of-SQL-Basic/</id>
    <published>2021-04-28T09:05:48.000Z</published>
    <updated>2021-04-28T09:34:59.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1：基础查询"><a href="#1：基础查询" class="headerlink" title="1：基础查询"></a>1：基础查询</h3><p>语法：<br>select 查询列表 from 表名;</p><p>类似于：System.out.println(打印东西);</p><p>特点：</p><p>1、查询列表可以是：表中的字段、常量值、表达式、函数<br>2、查询的结果是一个虚拟的表格</p><p>USE myemployees;</p><h5 id="1-查询表中的单个字段"><a href="#1-查询表中的单个字段" class="headerlink" title="1.查询表中的单个字段"></a>1.查询表中的单个字段</h5><p>​                SELECT last_name FROM employees;</p><h5 id="2-查询表中的多个字段"><a href="#2-查询表中的多个字段" class="headerlink" title="2.查询表中的多个字段"></a>2.查询表中的多个字段</h5><p>​                SELECT last_name,salary,email FROM employees;</p><h5 id="3-查询表中的所有字段"><a href="#3-查询表中的所有字段" class="headerlink" title="3.查询表中的所有字段"></a>3.查询表中的所有字段</h5><h6 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h6><p>SELECT<br>    <code>employee_id</code>,<br>    <code>first_name</code>,<br>    <code>last_name</code>,<br>    <code>phone_number</code>,<br>    <code>last_name</code>,<br>    <code>job_id</code>,<br>    <code>phone_number</code>,<br>    <code>job_id</code>,<br>    <code>salary</code>,<br>    <code>commission_pct</code>,<br>    <code>manager_id</code>,<br>    <code>department_id</code>,<br>    <code>hiredate</code><br>FROM<br>    employees ;</p><h6 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h6><p> SELECT * FROM employees;</p><h5 id="4-查询常量值"><a href="#4-查询常量值" class="headerlink" title="4.查询常量值"></a>4.查询常量值</h5><p> SELECT 100;<br> SELECT ‘john’;</p><h5 id="5-查询表达式"><a href="#5-查询表达式" class="headerlink" title="5.查询表达式"></a>5.查询表达式</h5><p> SELECT 100%98;</p><h5 id="6-查询函数"><a href="#6-查询函数" class="headerlink" title="6.查询函数"></a>6.查询函数</h5><p> SELECT VERSION();</p><h5 id="7-起别名"><a href="#7-起别名" class="headerlink" title="7.起别名"></a>7.起别名</h5><p> ①便于理解<br> ②如果要查询的字段有重名的情况，使用别名可以区分开来</p><h6 id="方式一：使用as"><a href="#方式一：使用as" class="headerlink" title="方式一：使用as"></a>方式一：使用as</h6><p>SELECT 100%98 AS 结果;<br>SELECT last_name AS 姓,first_name AS 名 FROM employees;</p><h6 id="方式二：使用空格"><a href="#方式二：使用空格" class="headerlink" title="方式二：使用空格"></a>方式二：使用空格</h6><p>SELECT last_name 姓,first_name 名 FROM employees;</p><h6 id="案例：查询salary，显示结果为-out-put"><a href="#案例：查询salary，显示结果为-out-put" class="headerlink" title="案例：查询salary，显示结果为 out put"></a>案例：查询salary，显示结果为 out put</h6><p>SELECT salary AS “out put” FROM employees;</p><h5 id="8-去重"><a href="#8-去重" class="headerlink" title="8.去重"></a>8.去重</h5><h6 id="案例：查询员工表中涉及到的所有的部门编号"><a href="#案例：查询员工表中涉及到的所有的部门编号" class="headerlink" title="案例：查询员工表中涉及到的所有的部门编号"></a>案例：查询员工表中涉及到的所有的部门编号</h6><p>SELECT DISTINCT department_id FROM employees;</p><h5 id="9-号的作用"><a href="#9-号的作用" class="headerlink" title="9.+号的作用"></a>9.+号的作用</h5><p> java中的+号：<br>①运算符，两个操作数都为数值型<br>②连接符，只要有一个操作数为字符串</p><p>mysql中的+号：<br>仅仅只有一个功能：运算符</p><p>select 100+90; 两个操作数都为数值型，则做加法运算<br>select ‘123’+90;只要其中一方为字符型，试图将字符型数值转换成数值型<br>            如果转换成功，则继续做加法运算<br>select ‘john’+90;    如果转换失败，则将字符型数值转换成0</p><p>select null+10; 只要其中一方为null，则结果肯定为null</p><h5 id="案例：查询员工名和姓连接成一个字段，并显示为-姓名"><a href="#案例：查询员工名和姓连接成一个字段，并显示为-姓名" class="headerlink" title="案例：查询员工名和姓连接成一个字段，并显示为 姓名"></a>案例：查询员工名和姓连接成一个字段，并显示为 姓名</h5><p>SELECT CONCAT(‘a’,’b’,’c’) AS 结果;</p><p>SELECT<br>    CONCAT(last_name,first_name) AS 姓名<br>FROM<br>    employees;</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>​    </p><pre><code>  1.    下面的语句是否可以执行成功  </code></pre><p>SELECT last_name , job_id , salary AS sal<br>FROM employees; </p><h5 id="2-下面的语句是否可以执行成功"><a href="#2-下面的语句是否可以执行成功" class="headerlink" title="2.下面的语句是否可以执行成功"></a>2.下面的语句是否可以执行成功</h5><p>SELECT  *  FROM employees; </p><h5 id="3-找出下面语句中的错误"><a href="#3-找出下面语句中的错误" class="headerlink" title="3.找出下面语句中的错误"></a>3.找出下面语句中的错误</h5><p>SELECT employee_id , last_name,<br>salary * 12 AS “ANNUAL  SALARY”<br>FROM employees;</p><h5 id="4-显示表departments的结构，并查询其中的全部数据"><a href="#4-显示表departments的结构，并查询其中的全部数据" class="headerlink" title="4.显示表departments的结构，并查询其中的全部数据"></a>4.显示表departments的结构，并查询其中的全部数据</h5><p>DESC departments;<br>SELECT * FROM <code>departments</code>;</p><h5 id="5-显示出表employees中的全部job-id（不能重复）"><a href="#5-显示出表employees中的全部job-id（不能重复）" class="headerlink" title="5.显示出表employees中的全部job_id（不能重复）"></a>5.显示出表employees中的全部job_id（不能重复）</h5><p>SELECT DISTINCT job_id FROM employees;</p><h5 id="6-显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT-PUT"><a href="#6-显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT-PUT" class="headerlink" title="6.显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT"></a>6.显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</h5><p>SELECT<br>    IFNULL(commission_pct,0) AS 奖金率,<br>    commission_pct<br>FROM<br>    employees;</p><p>#——————————————-</p><p>SELECT<br>    CONCAT(<code>first_name</code>,’,’,<code>last_name</code>,’,’,<code>job_id</code>,’,’,IFNULL(commission_pct,0)) AS out_put<br>FROM<br>    employees;</p><h3 id="2：条件查询"><a href="#2：条件查询" class="headerlink" title="2：条件查询"></a>2：条件查询</h3><p>语法：<br>    select<br>        查询列表<br>    from<br>        表名<br>    where<br>        筛选条件;</p><p>分类：<br>    一、按条件表达式筛选</p><pre><code>简单条件运算符：&gt; &lt; = != &lt;&gt; &gt;= &lt;=二、按逻辑表达式筛选逻辑运算符：作用：用于连接条件表达式    &amp;&amp; || !    and or not    &amp;&amp;和and：两个条件都为true，结果为true，反之为false||或or： 只要有一个条件为true，结果为true，反之为false!或not： 如果连接的条件本身为false，结果为true，反之为false三、模糊查询    like    between and    in    is null</code></pre><h4 id="一、按条件表达式筛选"><a href="#一、按条件表达式筛选" class="headerlink" title="一、按条件表达式筛选"></a>一、按条件表达式筛选</h4><h6 id="案例1：查询工资-gt-12000的员工信息"><a href="#案例1：查询工资-gt-12000的员工信息" class="headerlink" title="案例1：查询工资&gt;12000的员工信息"></a>案例1：查询工资&gt;12000的员工信息</h6><p>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    salary&gt;12000;</p><h6 id="案例2：查询部门编号不等于90号的员工名和部门编号"><a href="#案例2：查询部门编号不等于90号的员工名和部门编号" class="headerlink" title="案例2：查询部门编号不等于90号的员工名和部门编号"></a>案例2：查询部门编号不等于90号的员工名和部门编号</h6><p>SELECT<br>    last_name,<br>    department_id<br>FROM<br>    employees<br>WHERE<br>    department_id&lt;&gt;90;</p><h4 id="二、按逻辑表达式筛选"><a href="#二、按逻辑表达式筛选" class="headerlink" title="二、按逻辑表达式筛选"></a>二、按逻辑表达式筛选</h4><p>#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金<br>SELECT<br>    last_name,<br>    salary,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    salary&gt;=10000 AND salary&lt;=20000;<br>#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息<br>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    NOT(department_id&gt;=90 AND  department_id&lt;=110) OR salary&gt;15000;</p><h4 id="三、模糊查询"><a href="#三、模糊查询" class="headerlink" title="三、模糊查询"></a>三、模糊查询</h4><p>like<br>between and<br>in<br>is null|is not null</p><h4 id="1-like"><a href="#1-like" class="headerlink" title="1.like"></a>1.like</h4><p>特点：<br>①一般和通配符搭配使用<br>    通配符：<br>    % 任意多个字符,包含0个字符<br>    _ 任意单个字符<br>*、</p><h5 id="案例1：查询员工名中包含字符a的员工信息"><a href="#案例1：查询员工名中包含字符a的员工信息" class="headerlink" title="案例1：查询员工名中包含字符a的员工信息"></a>案例1：查询员工名中包含字符a的员工信息</h5><p>select<br>    *<br>from<br>    employees<br>where<br>    last_name like ‘%a%’;#abc</p><h5 id="案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资"><a href="#案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资" class="headerlink" title="案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资"></a>案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资</h5><p>select<br>    last_name,<br>    salary<br>FROM<br>    employees<br>WHERE<br>    last_name LIKE ‘__n_l%’;</p><h5 id="案例3：查询员工名中第二个字符为-的员工名"><a href="#案例3：查询员工名中第二个字符为-的员工名" class="headerlink" title="案例3：查询员工名中第二个字符为_的员工名"></a>案例3：查询员工名中第二个字符为_的员工名</h5><p>SELECT<br>    last_name<br>FROM<br>    employees<br>WHERE<br>    last_name LIKE ‘<em>$</em>%’ ESCAPE ‘$’;</p><h4 id="2-between-and"><a href="#2-between-and" class="headerlink" title="2.between and"></a>2.between and</h4><p>①使用between and 可以提高语句的简洁度<br>②包含临界值<br>③两个临界值不要调换顺序</p><h5 id="案例1：查询员工编号在100到120之间的员工信息"><a href="#案例1：查询员工编号在100到120之间的员工信息" class="headerlink" title="案例1：查询员工编号在100到120之间的员工信息"></a>案例1：查询员工编号在100到120之间的员工信息</h5><p>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    employee_id &gt;= 120 AND employee_id&lt;=100;<br>#———————-<br>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    employee_id BETWEEN 120 AND 100;</p><h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a>3.in</h4><p>含义：判断某字段的值是否属于in列表中的某一项<br>特点：<br>    ①使用in提高语句简洁度<br>    ②in列表的值类型必须一致或兼容<br>    ③in列表中不支持通配符</p><h5 id="案例：查询员工的工种编号是-IT-PROG、AD-VP、AD-PRES中的一个员工名和工种编号"><a href="#案例：查询员工的工种编号是-IT-PROG、AD-VP、AD-PRES中的一个员工名和工种编号" class="headerlink" title="案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号"></a>案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</h5><p>SELECT<br>    last_name,<br>    job_id<br>FROM<br>    employees<br>WHERE<br>    job_id = ‘IT_PROT’ OR job_id = ‘AD_VP’ OR JOB_ID =’AD_PRES’;</p><p>#——————</p><p>SELECT<br>    last_name,<br>    job_id<br>FROM<br>    employees<br>WHERE<br>    job_id IN( ‘IT_PROT’ ,’AD_VP’,’AD_PRES’);</p><h4 id="4、is-null"><a href="#4、is-null" class="headerlink" title="4、is null"></a>4、is null</h4><p>=或&lt;&gt;不能用于判断null值<br>is null或is not null 可以判断null值</p><h5 id="案例1：查询没有奖金的员工名和奖金率"><a href="#案例1：查询没有奖金的员工名和奖金率" class="headerlink" title="案例1：查询没有奖金的员工名和奖金率"></a>案例1：查询没有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct IS NULL;</p><h5 id="案例1：查询有奖金的员工名和奖金率"><a href="#案例1：查询有奖金的员工名和奖金率" class="headerlink" title="案例1：查询有奖金的员工名和奖金率"></a>案例1：查询有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct IS NOT NULL;</p><p>#———-以下为×<br>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees</p><p>WHERE<br>    salary IS 12000;</p><h4 id="安全等于-lt-gt"><a href="#安全等于-lt-gt" class="headerlink" title="安全等于  &lt;=&gt;"></a>安全等于  &lt;=&gt;</h4><h5 id="案例1：查询没有奖金的员工名和奖金率-1"><a href="#案例1：查询没有奖金的员工名和奖金率-1" class="headerlink" title="案例1：查询没有奖金的员工名和奖金率"></a>案例1：查询没有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct &lt;=&gt;NULL;</p><h5 id="案例2：查询工资为12000的员工信息"><a href="#案例2：查询工资为12000的员工信息" class="headerlink" title="案例2：查询工资为12000的员工信息"></a>案例2：查询工资为12000的员工信息</h5><p>SELECT<br>    last_name,<br>    salary<br>FROM<br>    employees</p><p>WHERE<br>    salary &lt;=&gt; 12000;</p><p>#is null pk &lt;=&gt;</p><p>IS NULL:仅仅可以判断NULL值，可读性较高，建议使用<br>&lt;=&gt;    :既可以判断NULL值，又可以判断普通的数值，可读性较低</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><h5 id="1-显示系统时间-注：日期-时间"><a href="#1-显示系统时间-注：日期-时间" class="headerlink" title="1.显示系统时间(注：日期+时间)"></a>1.显示系统时间(注：日期+时间)</h5><p>SELECT NOW();</p><h5 id="2-查询员工号，姓名，工资，以及工资提高百分之20-后的结果（new-salary）"><a href="#2-查询员工号，姓名，工资，以及工资提高百分之20-后的结果（new-salary）" class="headerlink" title="2.    查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）"></a>2.    查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</h5><p>SELECT employee_id,last_name,salary,salary*1.2 “new salary”<br>FROM employees;</p><h5 id="3-将员工的姓名按首字母排序，并写出姓名的长度（length）"><a href="#3-将员工的姓名按首字母排序，并写出姓名的长度（length）" class="headerlink" title="3.    将员工的姓名按首字母排序，并写出姓名的长度（length）"></a>3.    将员工的姓名按首字母排序，并写出姓名的长度（length）</h5><p>SELECT LENGTH(last_name) 长度,SUBSTR(last_name,1,1) 首字符,last_name<br>FROM employees<br>ORDER BY 首字符;</p><h5 id="4-做一个查询，产生下面的结果"><a href="#4-做一个查询，产生下面的结果" class="headerlink" title="4.    做一个查询，产生下面的结果"></a>4.    做一个查询，产生下面的结果</h5><p><last_name> earns <salary> monthly but wants &lt;salary*3&gt;<br>Dream Salary<br>King earns 24000 monthly but wants 72000</p><p>SELECT CONCAT(last_name,’ earns ‘,salary,’ monthly but wants ‘,salary*3) AS “Dream Salary”<br>FROM employees<br>WHERE salary=24000;</p><h5 id="5-使用case-when，按照下面的条件："><a href="#5-使用case-when，按照下面的条件：" class="headerlink" title="5.    使用case-when，按照下面的条件："></a>5.    使用case-when，按照下面的条件：</h5><p>job                  grade<br>AD_PRES            A<br>ST_MAN             B<br>IT_PROG             C<br>SA_REP              D<br>ST_CLERK           E<br>产生下面的结果<br>Last_name    Job_id    Grade<br>king    AD_PRES    A</p><p>SELECT last_name,job_id AS  job,<br>CASE job_id<br>WHEN ‘AD_PRES’ THEN ‘A’<br>WHEN ‘ST_MAN’ THEN ‘B’<br>WHEN ‘IT_PROG’ THEN ‘C’<br>WHEN ‘SA_PRE’ THEN ‘D’<br>WHEN ‘ST_CLERK’ THEN ‘E’<br>END AS Grade<br>FROM employees<br>WHERE job_id = ‘AD_PRES’;</p><h3 id="3排序查询"><a href="#3排序查询" class="headerlink" title="3排序查询"></a>3排序查询</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>select 查询列表<br>from 表名<br>【where  筛选条件】<br>order by 排序的字段或表达式;</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1、asc代表的是升序，可以省略<br>desc代表的是降序</p><p>2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段</p><p>3、order by子句在查询语句的最后面，除了limit子句</p><h5 id="1、按单个字段排序"><a href="#1、按单个字段排序" class="headerlink" title="1、按单个字段排序"></a>1、按单个字段排序</h5><p>SELECT * FROM employees ORDER BY salary DESC;</p><h5 id="2、添加筛选条件再排序"><a href="#2、添加筛选条件再排序" class="headerlink" title="2、添加筛选条件再排序"></a>2、添加筛选条件再排序</h5><h6 id="案例：查询部门编号-gt-90的员工信息，并按员工编号降序"><a href="#案例：查询部门编号-gt-90的员工信息，并按员工编号降序" class="headerlink" title="案例：查询部门编号&gt;=90的员工信息，并按员工编号降序"></a>案例：查询部门编号&gt;=90的员工信息，并按员工编号降序</h6><p>SELECT *<br>FROM employees<br>WHERE department_id&gt;=90<br>ORDER BY employee_id DESC;</p><h5 id="3、按表达式排序"><a href="#3、按表达式排序" class="headerlink" title="3、按表达式排序"></a>3、按表达式排序</h5><h6 id="案例：查询员工信息-按年薪降序"><a href="#案例：查询员工信息-按年薪降序" class="headerlink" title="案例：查询员工信息 按年薪降序"></a>案例：查询员工信息 按年薪降序</h6><p>SELECT <em>,salary</em>12*(1+IFNULL(commission_pct,0))<br>FROM employees<br>ORDER BY salary<em>12</em>(1+IFNULL(commission_pct,0)) DESC;</p><h5 id="4、按别名排序"><a href="#4、按别名排序" class="headerlink" title="4、按别名排序"></a>4、按别名排序</h5><h6 id="案例：查询员工信息-按年薪升序"><a href="#案例：查询员工信息-按年薪升序" class="headerlink" title="案例：查询员工信息 按年薪升序"></a>案例：查询员工信息 按年薪升序</h6><p>SELECT <em>,salary</em>12*(1+IFNULL(commission_pct,0)) 年薪<br>FROM employees<br>ORDER BY 年薪 ASC;</p><h5 id="5、按函数排序"><a href="#5、按函数排序" class="headerlink" title="5、按函数排序"></a>5、按函数排序</h5><h6 id="案例：查询员工名，并且按名字的长度降序"><a href="#案例：查询员工名，并且按名字的长度降序" class="headerlink" title="案例：查询员工名，并且按名字的长度降序"></a>案例：查询员工名，并且按名字的长度降序</h6><p>SELECT LENGTH(last_name),last_name<br>FROM employees<br>ORDER BY LENGTH(last_name) DESC;</p><h5 id="6、按多个字段排序"><a href="#6、按多个字段排序" class="headerlink" title="6、按多个字段排序"></a>6、按多个字段排序</h5><h6 id="案例：查询员工信息，要求先按工资降序，再按employee-id升序"><a href="#案例：查询员工信息，要求先按工资降序，再按employee-id升序" class="headerlink" title="案例：查询员工信息，要求先按工资降序，再按employee_id升序"></a>案例：查询员工信息，要求先按工资降序，再按employee_id升序</h6><p>SELECT *<br>FROM employees<br>ORDER BY salary DESC,employee_id ASC;</p><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><h6 id="1-查询员工的姓名和部门号和年薪，按年薪降序-按姓名升序"><a href="#1-查询员工的姓名和部门号和年薪，按年薪降序-按姓名升序" class="headerlink" title="1.查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序"></a>1.查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序</h6><p>SELECT last_name,department_id,salary<em>12</em>(1+IFNULL(commission_pct,0)) 年薪<br>FROM employees<br>ORDER BY 年薪 DESC,last_name ASC;</p><h6 id="2-选择工资不在8000到17000的员工的姓名和工资，按工资降序"><a href="#2-选择工资不在8000到17000的员工的姓名和工资，按工资降序" class="headerlink" title="2.选择工资不在8000到17000的员工的姓名和工资，按工资降序"></a>2.选择工资不在8000到17000的员工的姓名和工资，按工资降序</h6><p>SELECT last_name,salary<br>FROM employees</p><p>WHERE salary NOT BETWEEN 8000 AND 17000<br>ORDER BY salary DESC;</p><h6 id="3-查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序"><a href="#3-查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序" class="headerlink" title="3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序"></a>3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</h6><p>SELECT *,LENGTH(email)<br>FROM employees<br>WHERE email LIKE ‘%e%’<br>ORDER BY LENGTH(email) DESC,department_id ASC;</p><h3 id="4：常见函数"><a href="#4：常见函数" class="headerlink" title="4：常见函数"></a>4：常见函数</h3><h4 id="概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名"><a href="#概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名" class="headerlink" title="概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名"></a>概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</h4><p>好处：1、隐藏了实现细节  2、提高代码的重用性<br> 调用：select 函数名(实参列表) 【from 表】;<br> 特点：<br>    ①叫什么（函数名）<br>    ②干什么（函数功能）</p><p>分类：<br>    1、单行函数<br>    如 concat、length、ifnull等<br>    2、分组函数</p><pre><code>功能：做统计使用，又称为统计函数、聚合函数、组函数</code></pre><h4 id="常见函数："><a href="#常见函数：" class="headerlink" title="常见函数："></a>常见函数：</h4><p>​    一、单行函数<br>​    字符函数：<br>​    length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节)<br>​    concat<br>​    substr<br>​    instr<br>​    trim<br>​    upper<br>​    lower<br>​    lpad<br>​    rpad<br>​    replace<br>​    </p><pre><code>数学函数：roundceilfloortruncatemod日期函数：nowcurdatecurtimeyearmonthmonthnamedayhourminutesecondstr_to_datedate_format其他函数：versiondatabaseuser控制函数ifcase</code></pre><p>​    </p><h4 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h4><p>#1.length 获取参数值的字节个数<br>SELECT LENGTH(‘john’);<br>SELECT LENGTH(‘张三丰hahaha’);</p><p>SHOW VARIABLES LIKE ‘%char%’</p><h4 id="2-concat-拼接字符串"><a href="#2-concat-拼接字符串" class="headerlink" title="2.concat 拼接字符串"></a>2.concat 拼接字符串</h4><p>SELECT CONCAT(last_name,’_’,first_name) 姓名 FROM employees;</p><h4 id="3-upper、lower"><a href="#3-upper、lower" class="headerlink" title="3.upper、lower"></a>3.upper、lower</h4><p>SELECT UPPER(‘john’);<br>SELECT LOWER(‘joHn’);</p><h5 id="示例：将姓变大写，名变小写，然后拼接"><a href="#示例：将姓变大写，名变小写，然后拼接" class="headerlink" title="示例：将姓变大写，名变小写，然后拼接"></a>示例：将姓变大写，名变小写，然后拼接</h5><p>SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</p><h4 id="4-substr、substring"><a href="#4-substr、substring" class="headerlink" title="4.substr、substring"></a>4.substr、substring</h4><p>注意：索引从1开始</p><h5 id="截取从指定索引处后面所有字符"><a href="#截取从指定索引处后面所有字符" class="headerlink" title="截取从指定索引处后面所有字符"></a>截取从指定索引处后面所有字符</h5><p>SELECT SUBSTR(‘李莫愁爱上了陆展元’,7)  out_put;</p><h5 id="截取从指定索引处指定字符长度的字符"><a href="#截取从指定索引处指定字符长度的字符" class="headerlink" title="截取从指定索引处指定字符长度的字符"></a>截取从指定索引处指定字符长度的字符</h5><p>SELECT SUBSTR(‘李莫愁爱上了陆展元’,1,3) out_put;</p><h6 id="案例：姓名中首字符大写，其他字符小写然后用-拼接，显示出来"><a href="#案例：姓名中首字符大写，其他字符小写然后用-拼接，显示出来" class="headerlink" title="案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来"></a>案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</h6><p>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),’_’,LOWER(SUBSTR(last_name,2)))  out_put<br>FROM employees;</p><h4 id="5-instr-返回子串第一次出现的索引，如果找不到返回0"><a href="#5-instr-返回子串第一次出现的索引，如果找不到返回0" class="headerlink" title="5.instr 返回子串第一次出现的索引，如果找不到返回0"></a>5.instr 返回子串第一次出现的索引，如果找不到返回0</h4><p>SELECT INSTR(‘杨不殷六侠悔爱上了殷六侠’,’殷八侠’) AS out_put;</p><h4 id="6-trim"><a href="#6-trim" class="headerlink" title="6.trim"></a>6.trim</h4><p>SELECT LENGTH(TRIM(‘    张翠山    ‘)) AS out_put;</p><p>SELECT TRIM(‘aa’ FROM ‘aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’)  AS out_put;</p><h4 id="7-lpad-用指定的字符实现左填充指定长度"><a href="#7-lpad-用指定的字符实现左填充指定长度" class="headerlink" title="7.lpad 用指定的字符实现左填充指定长度"></a>7.lpad 用指定的字符实现左填充指定长度</h4><p>SELECT LPAD(‘殷素素’,2,’*’) AS out_put;</p><h4 id="8-rpad-用指定的字符实现右填充指定长度"><a href="#8-rpad-用指定的字符实现右填充指定长度" class="headerlink" title="8.rpad 用指定的字符实现右填充指定长度"></a>8.rpad 用指定的字符实现右填充指定长度</h4><p>SELECT RPAD(‘殷素素’,12,’ab’) AS out_put;</p><h4 id="9-replace-替换"><a href="#9-replace-替换" class="headerlink" title="9.replace 替换"></a>9.replace 替换</h4><p>SELECT REPLACE(‘周芷若周芷若周芷若周芷若张无忌爱上了周芷若’,’周芷若’,’赵敏’) AS out_put;</p><h4 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h4><h5 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round 四舍五入"></a>round 四舍五入</h5><p>SELECT ROUND(-1.55);<br>SELECT ROUND(1.567,2);</p><h5 id="ceil-向上取整-返回-gt-该参数的最小整数"><a href="#ceil-向上取整-返回-gt-该参数的最小整数" class="headerlink" title="ceil 向上取整,返回&gt;=该参数的最小整数"></a>ceil 向上取整,返回&gt;=该参数的最小整数</h5><p>SELECT CEIL(-1.02);</p><h5 id="floor-向下取整，返回-lt-该参数的最大整数"><a href="#floor-向下取整，返回-lt-该参数的最大整数" class="headerlink" title="floor 向下取整，返回&lt;=该参数的最大整数"></a>floor 向下取整，返回&lt;=该参数的最大整数</h5><p>SELECT FLOOR(-9.99);</p><h5 id="truncate-截断"><a href="#truncate-截断" class="headerlink" title="truncate 截断"></a>truncate 截断</h5><p>SELECT TRUNCATE(1.69999,1);</p><h5 id="mod取余"><a href="#mod取余" class="headerlink" title="mod取余"></a>mod取余</h5><p>mod(a,b) ：  a-a/b*b</p><p>mod(-10,-3):-10- (-10)/(-3)*（-3）=-1</p><p>SELECT MOD(10,-3);<br>SELECT 10%3;</p><h4 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h4><h5 id="now-返回当前系统日期-时间"><a href="#now-返回当前系统日期-时间" class="headerlink" title="now 返回当前系统日期+时间"></a>now 返回当前系统日期+时间</h5><p>SELECT NOW();</p><h5 id="curdate-返回当前系统日期，不包含时间"><a href="#curdate-返回当前系统日期，不包含时间" class="headerlink" title="curdate 返回当前系统日期，不包含时间"></a>curdate 返回当前系统日期，不包含时间</h5><p>SELECT CURDATE();</p><h5 id="curtime-返回当前时间，不包含日期"><a href="#curtime-返回当前时间，不包含日期" class="headerlink" title="curtime 返回当前时间，不包含日期"></a>curtime 返回当前时间，不包含日期</h5><p>SELECT CURTIME();</p><h5 id="可以获取指定的部分，年、月、日、小时、分钟、秒"><a href="#可以获取指定的部分，年、月、日、小时、分钟、秒" class="headerlink" title="可以获取指定的部分，年、月、日、小时、分钟、秒"></a>可以获取指定的部分，年、月、日、小时、分钟、秒</h5><p>SELECT YEAR(NOW()) 年;<br>SELECT YEAR(‘1998-1-1’) 年;</p><p>SELECT  YEAR(hiredate) 年 FROM employees;</p><p>SELECT MONTH(NOW()) 月;<br>SELECT MONTHNAME(NOW()) 月;</p><h5 id="str-to-date-将字符通过指定的格式转换成日期"><a href="#str-to-date-将字符通过指定的格式转换成日期" class="headerlink" title="str_to_date 将字符通过指定的格式转换成日期"></a>str_to_date 将字符通过指定的格式转换成日期</h5><p>SELECT STR_TO_DATE(‘1998-3-2’,’%Y-%c-%d’) AS out_put;</p><h5 id="查询入职日期为1992–4-3的员工信息"><a href="#查询入职日期为1992–4-3的员工信息" class="headerlink" title="查询入职日期为1992–4-3的员工信息"></a>查询入职日期为1992–4-3的员工信息</h5><p>SELECT * FROM employees WHERE hiredate = ‘1992-4-3’;</p><p>SELECT * FROM employees WHERE hiredate = STR_TO_DATE(‘4-3 1992’,’%c-%d %Y’);</p><h5 id="date-format-将日期转换成字符"><a href="#date-format-将日期转换成字符" class="headerlink" title="date_format 将日期转换成字符"></a>date_format 将日期转换成字符</h5><p>SELECT DATE_FORMAT(NOW(),’%y年%m月%d日’) AS out_put;</p><h5 id="查询有奖金的员工名和入职日期-xx月-xx日-xx年"><a href="#查询有奖金的员工名和入职日期-xx月-xx日-xx年" class="headerlink" title="查询有奖金的员工名和入职日期(xx月/xx日 xx年)"></a>查询有奖金的员工名和入职日期(xx月/xx日 xx年)</h5><p>SELECT last_name,DATE_FORMAT(hiredate,’%m月/%d日 %y年’) 入职日期<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p><h4 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h4><p>SELECT VERSION();<br>SELECT DATABASE();<br>SELECT USER();</p><h4 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h4><h5 id="1-if函数：-if-else-的效果"><a href="#1-if函数：-if-else-的效果" class="headerlink" title="1.if函数： if else 的效果"></a>1.if函数： if else 的效果</h5><p>SELECT IF(10&lt;5,’大’,’小’);</p><p>SELECT last_name,commission_pct,IF(commission_pct IS NULL,’没奖金，呵呵’,’有奖金，嘻嘻’) 备注<br>FROM employees;</p><h5 id="2-case函数的使用一：-switch-case-的效果"><a href="#2-case函数的使用一：-switch-case-的效果" class="headerlink" title="2.case函数的使用一： switch case 的效果"></a>2.case函数的使用一： switch case 的效果</h5><p>java中<br>switch(变量或表达式){<br>    case 常量1：语句1;break;<br>    …<br>    default:语句n;break;</p><p>}</p><p>mysql中</p><p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p><h4 id="案例：查询员工的工资，要求"><a href="#案例：查询员工的工资，要求" class="headerlink" title="案例：查询员工的工资，要求"></a>案例：查询员工的工资，要求</h4><p>部门号=30，显示的工资为1.1倍<br>部门号=40，显示的工资为1.2倍<br>部门号=50，显示的工资为1.3倍<br>其他部门，显示的工资为原工资</p><p>SELECT salary 原始工资,department_id,<br>CASE department_id<br>WHEN 30 THEN salary<em>1.1<br>WHEN 40 THEN salary</em>1.2<br>WHEN 50 THEN salary*1.3<br>ELSE salary<br>END AS 新工资<br>FROM employees;</p><h5 id="3-case-函数的使用二：类似于-多重if"><a href="#3-case-函数的使用二：类似于-多重if" class="headerlink" title="3.case 函数的使用二：类似于 多重if"></a>3.case 函数的使用二：类似于 多重if</h5><p>java中：<br>if(条件1){<br>    语句1；<br>}else if(条件2){<br>    语句2；<br>}<br>…<br>else{<br>    语句n;<br>}</p><p>mysql中：</p><p>case<br>when 条件1 then 要显示的值1或语句1<br>when 条件2 then 要显示的值2或语句2<br>。。。<br>else 要显示的值n或语句n<br>end</p><h5 id="案例：查询员工的工资的情况"><a href="#案例：查询员工的工资的情况" class="headerlink" title="案例：查询员工的工资的情况"></a>案例：查询员工的工资的情况</h5><p>如果工资&gt;20000,显示A级别<br>如果工资&gt;15000,显示B级别<br>如果工资&gt;10000，显示C级别<br>否则，显示D级别</p><p>SELECT salary,<br>CASE<br>WHEN salary&gt;20000 THEN ‘A’<br>WHEN salary&gt;15000 THEN ‘B’<br>WHEN salary&gt;10000 THEN ‘C’<br>ELSE ‘D’<br>END AS 工资级别<br>FROM employees;</p><h3 id="5：分组查询"><a href="#5：分组查询" class="headerlink" title="5：分组查询"></a>5：分组查询</h3><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><p>select 查询列表<br>from 表<br>【where 筛选条件】<br>group by 分组的字段<br>【order by 排序的字段】;</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><p>1、和分组函数一同查询的字段必须是group by后出现的字段<br>2、筛选分为两类：分组前筛选和分组后筛选<br>        针对的表            位置        连接的关键字<br>分组前筛选    原始表                group by前    where</p><p>分组后筛选    group by后的结果集            group by后    having</p><p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p><p>问题2：where——group by——having</p><p>一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</p><p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p><h4 id="引入：查询每个部门的员工个数"><a href="#引入：查询每个部门的员工个数" class="headerlink" title="引入：查询每个部门的员工个数"></a>引入：查询每个部门的员工个数</h4><p>SELECT COUNT(*) FROM employees WHERE department_id=90;</p><h5 id="1-简单的分组"><a href="#1-简单的分组" class="headerlink" title="1.简单的分组"></a>1.简单的分组</h5><h5 id="案例1：查询每个工种的员工平均工资"><a href="#案例1：查询每个工种的员工平均工资" class="headerlink" title="案例1：查询每个工种的员工平均工资"></a>案例1：查询每个工种的员工平均工资</h5><p>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p><h5 id="案例2：查询每个位置的部门个数"><a href="#案例2：查询每个位置的部门个数" class="headerlink" title="案例2：查询每个位置的部门个数"></a>案例2：查询每个位置的部门个数</h5><p>SELECT COUNT(*),location_id<br>FROM departments<br>GROUP BY location_id;</p><h5 id="2、可以实现分组前的筛选"><a href="#2、可以实现分组前的筛选" class="headerlink" title="2、可以实现分组前的筛选"></a>2、可以实现分组前的筛选</h5><h5 id="案例1：查询邮箱中包含a字符的-每个部门的最高工资"><a href="#案例1：查询邮箱中包含a字符的-每个部门的最高工资" class="headerlink" title="案例1：查询邮箱中包含a字符的 每个部门的最高工资"></a>案例1：查询邮箱中包含a字符的 每个部门的最高工资</h5><p>SELECT MAX(salary),department_id<br>FROM employees<br>WHERE email LIKE ‘%a%’<br>GROUP BY department_id;</p><h5 id="案例2：查询有奖金的每个领导手下员工的平均工资"><a href="#案例2：查询有奖金的每个领导手下员工的平均工资" class="headerlink" title="案例2：查询有奖金的每个领导手下员工的平均工资"></a>案例2：查询有奖金的每个领导手下员工的平均工资</h5><p>SELECT AVG(salary),manager_id<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY manager_id;</p><h5 id="3、分组后筛选"><a href="#3、分组后筛选" class="headerlink" title="3、分组后筛选"></a>3、分组后筛选</h5><p>#案例：查询哪个部门的员工个数&gt;5</p><h5 id="①查询每个部门的员工个数"><a href="#①查询每个部门的员工个数" class="headerlink" title="①查询每个部门的员工个数"></a>①查询每个部门的员工个数</h5><p>SELECT COUNT(*),department_id<br>FROM employees<br>GROUP BY department_id;</p><h5 id="②-筛选刚才①结果"><a href="#②-筛选刚才①结果" class="headerlink" title="② 筛选刚才①结果"></a>② 筛选刚才①结果</h5><p>SELECT COUNT(*),department_id<br>FROM employees</p><p>GROUP BY department_id</p><p>HAVING COUNT(*)&gt;5;</p><h5 id="案例2：每个工种有奖金的员工的最高工资-gt-12000的工种编号和最高工资"><a href="#案例2：每个工种有奖金的员工的最高工资-gt-12000的工种编号和最高工资" class="headerlink" title="案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资"></a>案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</h5><p>SELECT job_id,MAX(salary)<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING MAX(salary)&gt;12000;</p><h5 id="案例3：领导编号-gt-102的每个领导手下的最低工资大于5000的领导编号和最低工资"><a href="#案例3：领导编号-gt-102的每个领导手下的最低工资大于5000的领导编号和最低工资" class="headerlink" title="案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资"></a>案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</h5><p>manager_id&gt;102</p><p>SELECT manager_id,MIN(salary)<br>FROM employees<br>GROUP BY manager_id<br>HAVING MIN(salary)&gt;5000;</p><h5 id="4-添加排序"><a href="#4-添加排序" class="headerlink" title="4.添加排序"></a>4.添加排序</h5><h5 id="案例：每个工种有奖金的员工的最高工资-gt-6000的工种编号和最高工资-按最高工资升序"><a href="#案例：每个工种有奖金的员工的最高工资-gt-6000的工种编号和最高工资-按最高工资升序" class="headerlink" title="案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序"></a>案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</h5><p>SELECT job_id,MAX(salary) m<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING m&gt;6000<br>ORDER BY m ;</p><h5 id="5-按多个字段分组"><a href="#5-按多个字段分组" class="headerlink" title="5.按多个字段分组"></a>5.按多个字段分组</h5><h5 id="案例：查询每个工种每个部门的最低工资-并按最低工资降序"><a href="#案例：查询每个工种每个部门的最低工资-并按最低工资降序" class="headerlink" title="案例：查询每个工种每个部门的最低工资,并按最低工资降序"></a>案例：查询每个工种每个部门的最低工资,并按最低工资降序</h5><p>SELECT MIN(salary),job_id,department_id<br>FROM employees<br>GROUP BY department_id,job_id<br>ORDER BY MIN(salary) DESC;</p><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><h5 id="1-查询各job-id的员工工资的最大值，最小值，平均值，总和，并按job-id升序"><a href="#1-查询各job-id的员工工资的最大值，最小值，平均值，总和，并按job-id升序" class="headerlink" title="1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序"></a>1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序</h5><p>SELECT MAX(salary),MIN(salary),AVG(salary),SUM(salary),job_id<br>FROM employees<br>GROUP BY job_id<br>ORDER BY job_id;</p><h5 id="2-查询员工最高工资和最低工资的差距（DIFFERENCE）"><a href="#2-查询员工最高工资和最低工资的差距（DIFFERENCE）" class="headerlink" title="2.查询员工最高工资和最低工资的差距（DIFFERENCE）"></a>2.查询员工最高工资和最低工资的差距（DIFFERENCE）</h5><p>SELECT MAX(salary)-MIN(salary) DIFFRENCE<br>FROM employees;</p><h5 id="3-查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内"><a href="#3-查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内" class="headerlink" title="3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内"></a>3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</h5><p>SELECT MIN(salary),manager_id<br>FROM employees<br>WHERE manager_id IS NOT NULL<br>GROUP BY manager_id<br>HAVING MIN(salary)&gt;=6000;</p><h5 id="4-查询所有部门的编号，员工数量和工资平均值-并按平均工资降序"><a href="#4-查询所有部门的编号，员工数量和工资平均值-并按平均工资降序" class="headerlink" title="4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序"></a>4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序</h5><p>SELECT department_id,COUNT(*),AVG(salary) a<br>FROM employees<br>GROUP BY department_id<br>ORDER BY a DESC;</p><h5 id="5-选择具有各个job-id的员工人数"><a href="#5-选择具有各个job-id的员工人数" class="headerlink" title="5.选择具有各个job_id的员工人数"></a>5.选择具有各个job_id的员工人数</h5><p>SELECT COUNT(*) 个数,job_id<br>FROM employees<br>GROUP BY job_id;</p><h4 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h4><h5 id="功能：用作统计使用，又称为聚合函数或统计函数或组函数"><a href="#功能：用作统计使用，又称为聚合函数或统计函数或组函数" class="headerlink" title="功能：用作统计使用，又称为聚合函数或统计函数或组函数"></a>功能：用作统计使用，又称为聚合函数或统计函数或组函数</h5><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</p><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><p>1、sum、avg一般用于处理数值型<br>   max、min、count可以处理任何类型<br>2、以上分组函数都忽略null值</p><p>3、可以和distinct搭配实现去重的运算</p><p>4、count函数的单独介绍<br>一般使用count(*)用作统计行数</p><p>5、和分组函数一同查询的字段要求是group by后的字段</p><h4 id="1、简单-的使用"><a href="#1、简单-的使用" class="headerlink" title="1、简单 的使用"></a>1、简单 的使用</h4><p>SELECT SUM(salary) FROM employees;<br>SELECT AVG(salary) FROM employees;<br>SELECT MIN(salary) FROM employees;<br>SELECT MAX(salary) FROM employees;<br>SELECT COUNT(salary) FROM employees;</p><p>SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;</p><p>SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;</p><h4 id="2、参数支持哪些类型"><a href="#2、参数支持哪些类型" class="headerlink" title="2、参数支持哪些类型"></a>2、参数支持哪些类型</h4><p>SELECT SUM(last_name) ,AVG(last_name) FROM employees;<br>SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;</p><p>SELECT MAX(last_name),MIN(last_name) FROM employees;</p><p>SELECT MAX(hiredate),MIN(hiredate) FROM employees;</p><p>SELECT COUNT(commission_pct) FROM employees;<br>SELECT COUNT(last_name) FROM employees;</p><h4 id="3、是否忽略null"><a href="#3、是否忽略null" class="headerlink" title="3、是否忽略null"></a>3、是否忽略null</h4><p>SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;</p><p>SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;</p><p>SELECT COUNT(commission_pct) FROM employees;<br>SELECT commission_pct FROM employees;</p><h4 id="4、和distinct搭配"><a href="#4、和distinct搭配" class="headerlink" title="4、和distinct搭配"></a>4、和distinct搭配</h4><p>SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</p><p>SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</p><h4 id="5、count函数的详细介绍"><a href="#5、count函数的详细介绍" class="headerlink" title="5、count函数的详细介绍"></a>5、count函数的详细介绍</h4><p>SELECT COUNT(salary) FROM employees;</p><p>SELECT COUNT(*) FROM employees;</p><p>SELECT COUNT(1) FROM employees;</p><h5 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h5><p>MYISAM存储引擎下  ，COUNT(<em>)的效率高<br>INNODB存储引擎下，COUNT(</em>)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</p><h5 id="6、和分组函数一同查询的字段有限制"><a href="#6、和分组函数一同查询的字段有限制" class="headerlink" title="6、和分组函数一同查询的字段有限制"></a>6、和分组函数一同查询的字段有限制</h5><p>SELECT AVG(salary),employee_id  FROM employees;</p><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><h5 id="1-查询公司员工工资的最大值，最小值，平均值，总和"><a href="#1-查询公司员工工资的最大值，最小值，平均值，总和" class="headerlink" title="1.查询公司员工工资的最大值，最小值，平均值，总和"></a>1.查询公司员工工资的最大值，最小值，平均值，总和</h5><p>SELECT MAX(salary) 最大值,MIN(salary) 最小值,AVG(salary) 平均值,SUM(salary) 和<br>FROM employees;</p><h4 id="2-查询员工表中的最大入职时间和最小入职时间的相差天数-（DIFFRENCE）"><a href="#2-查询员工表中的最大入职时间和最小入职时间的相差天数-（DIFFRENCE）" class="headerlink" title="#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）"></a>#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）</h4><p>SELECT MAX(hiredate) 最大,MIN(hiredate) 最小,(MAX(hiredate)-MIN(hiredate))/1000/3600/24 DIFFRENCE<br>FROM employees;</p><p>SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE<br>FROM employees;</p><p>SELECT DATEDIFF(‘1995-2-7’,’1995-2-6’);</p><h5 id="3-查询部门编号为90的员工个数"><a href="#3-查询部门编号为90的员工个数" class="headerlink" title="3.查询部门编号为90的员工个数"></a>3.查询部门编号为90的员工个数</h5><p>SELECT COUNT(*) FROM employees WHERE department_id = 90;</p><h3 id="6：连接查询"><a href="#6：连接查询" class="headerlink" title="6：连接查询"></a>6：连接查询</h3><p>/*<br>含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p><p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p><p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p><p>分类：</p><pre><code>按年代分类：sql92标准:仅仅支持内连接sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接按功能分类：    内连接：        等值连接        非等值连接        自连接    外连接：        左外连接        右外连接        全外连接        交叉连接</code></pre><p>*/</p><p>SELECT * FROM beauty;</p><p>SELECT * FROM boys;</p><p>SELECT NAME,boyName FROM boys,beauty<br>WHERE beauty.boyfriend_id= boys.id;</p><p>#一、sql92标准<br>#1、等值连接<br>/*</p><p>① 多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③ 多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p><p>*/</p><p>#案例1：查询女神名和对应的男神名<br>SELECT NAME,boyName<br>FROM boys,beauty<br>WHERE beauty.boyfriend_id= boys.id;</p><p>#案例2：查询员工名和对应的部门名</p><p>SELECT last_name,department_name<br>FROM employees,departments<br>WHERE employees.<code>department_id</code>=departments.<code>department_id</code>;</p><p>#2、为表起别名<br>/*<br>①提高语句的简洁度<br>②区分多个重名的字段</p><p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</p><p>*/<br>#查询员工名、工种号、工种名</p><p>SELECT e.last_name,e.job_id,j.job_title<br>FROM employees  e,jobs j<br>WHERE e.<code>job_id</code>=j.<code>job_id</code>;</p><p>#3、两个表的顺序是否可以调换</p><p>#查询员工名、工种号、工种名</p><p>SELECT e.last_name,e.job_id,j.job_title<br>FROM jobs j,employees e<br>WHERE e.<code>job_id</code>=j.<code>job_id</code>;</p><p>#4、可以加筛选</p><p>#案例：查询有奖金的员工名、部门名</p><p>SELECT last_name,department_name,commission_pct</p><p>FROM employees e,departments d<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND e.<code>commission_pct</code> IS NOT NULL;</p><p>#案例2：查询城市名中第二个字符为o的部门名和城市名</p><p>SELECT department_name,city<br>FROM departments d,locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>AND city LIKE ‘_o%’;</p><p>#5、可以加分组</p><p>#案例1：查询每个城市的部门个数</p><p>SELECT COUNT(*) 个数,city<br>FROM departments d,locations l<br>WHERE d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city;</p><p>#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资<br>SELECT department_name,d.<code>manager_id</code>,MIN(salary)<br>FROM departments d,employees e<br>WHERE d.<code>department_id</code>=e.<code>department_id</code><br>AND commission_pct IS NOT NULL<br>GROUP BY department_name,d.<code>manager_id</code>;<br>#6、可以加排序</p><p>#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</p><p>SELECT job_title,COUNT(<em>)<br>FROM employees e,jobs j<br>WHERE e.<code>job_id</code>=j.<code>job_id</code><br>GROUP BY job_title<br>ORDER BY COUNT(</em>) DESC;</p><p>#7、可以实现三表连接？</p><p>#案例：查询员工名、部门名和所在的城市</p><p>SELECT last_name,department_name,city<br>FROM employees e,departments d,locations l<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND d.<code>location_id</code>=l.<code>location_id</code><br>AND city LIKE ‘s%’</p><p>ORDER BY department_name DESC;</p><p>#2、非等值连接</p><p>#案例1：查询员工的工资和工资级别</p><p>SELECT salary,grade_level<br>FROM employees e,job_grades g<br>WHERE salary BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code><br>AND g.<code>grade_level</code>=’A’;</p><p>/*<br>select salary,employee_id from employees;<br>select * from job_grades;<br>CREATE TABLE job_grades<br>(grade_level VARCHAR(3),<br> lowest_sal  int,<br> highest_sal int);</p><p>INSERT INTO job_grades<br>VALUES (‘A’, 1000, 2999);</p><p>INSERT INTO job_grades<br>VALUES (‘B’, 3000, 5999);</p><p>INSERT INTO job_grades<br>VALUES(‘C’, 6000, 9999);</p><p>INSERT INTO job_grades<br>VALUES(‘D’, 10000, 14999);</p><p>INSERT INTO job_grades<br>VALUES(‘E’, 15000, 24999);</p><p>INSERT INTO job_grades<br>VALUES(‘F’, 25000, 40000);</p><p>*/</p><p>#3、自连接</p><p>#案例：查询 员工名和上级的名称</p><p>SELECT e.employee_id,e.last_name,m.employee_id,m.last_name<br>FROM employees e,employees m<br>WHERE e.<code>manager_id</code>=m.<code>employee_id</code>;</p><h4 id="外查询案例"><a href="#外查询案例" class="headerlink" title="外查询案例"></a>外查询案例</h4><p>一、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</p><p>SELECT b.id,b.name,bo.*<br>FROM beauty b<br>LEFT OUTER JOIN boys bo<br>ON b.<code>boyfriend_id</code> = bo.<code>id</code><br>WHERE b.<code>id</code>&gt;3;<br>#二、查询哪个城市没有部门</p><p>SELECT city<br>FROM departments d<br>RIGHT OUTER JOIN locations l<br>ON d.<code>location_id</code>=l.<code>location_id</code><br>WHERE  d.<code>department_id</code> IS NULL;</p><p>#三、查询部门名为SAL或IT的员工信息</p><p>SELECT e.*,d.department_name,d.<code>department_id</code><br>FROM departments  d<br>LEFT JOIN employees e<br>ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE d.<code>department_name</code> IN(‘SAL’,’IT’);</p><p>SELECT * FROM departments<br>WHERE <code>department_name</code> IN(‘SAL’,’IT’);</p><h3 id="连接查询-sql99语法"><a href="#连接查询-sql99语法" class="headerlink" title="连接查询  sql99语法"></a>连接查询  sql99语法</h3><p>/*<br>语法：<br>    select 查询列表<br>    from 表1 别名 【连接类型】<br>    join 表2 别名<br>    on 连接条件<br>    【where 筛选条件】<br>    【group by 分组】<br>    【having 筛选条件】<br>    【order by 排序列表】</p><p>分类：<br>内连接（★）：inner<br>外连接<br>    左外(★):left 【outer】<br>    右外(★)：right 【outer】<br>    全外：full【outer】<br>交叉连接：cross </p><p>*/</p><p>#一）内连接<br>/*<br>语法：</p><p>select 查询列表<br>from 表1 别名<br>inner join 表2 别名<br>on 连接条件;</p><p>分类：<br>等值<br>非等值<br>自连接</p><p>特点：<br>①添加排序、分组、筛选<br>②inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p><p>*/</p><p>#1、等值连接<br>#案例1.查询员工名、部门名</p><p>SELECT last_name,department_name<br>FROM departments d<br> JOIN  employees e<br>ON e.<code>department_id</code> = d.<code>department_id</code>;</p><p>#案例2.查询名字中包含e的员工名和工种名（添加筛选）<br>SELECT last_name,job_title<br>FROM employees e<br>INNER JOIN jobs j<br>ON e.<code>job_id</code>=  j.<code>job_id</code><br>WHERE e.<code>last_name</code> LIKE ‘%e%’;</p><p>#3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</p><p>#①查询每个城市的部门个数<br>#②在①结果上筛选满足条件的<br>SELECT city,COUNT(<em>) 部门个数<br>FROM departments d<br>INNER JOIN locations l<br>ON d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city<br>HAVING COUNT(</em>)&gt;3;</p><p>#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</p><p>#①查询每个部门的员工个数<br>SELECT COUNT(*),department_name<br>FROM employees e<br>INNER JOIN departments d<br>ON e.<code>department_id</code>=d.<code>department_id</code><br>GROUP BY department_name</p><p>#② 在①结果上筛选员工个数&gt;3的记录，并排序</p><p>SELECT COUNT(<em>) 个数,department_name<br>FROM employees e<br>INNER JOIN departments d<br>ON e.<code>department_id</code>=d.<code>department_id</code><br>GROUP BY department_name<br>HAVING COUNT(</em>)&gt;3<br>ORDER BY COUNT(*) DESC;</p><p>#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</p><p>SELECT last_name,department_name,job_title<br>FROM employees e<br>INNER JOIN departments d ON e.<code>department_id</code>=d.<code>department_id</code><br>INNER JOIN jobs j ON e.<code>job_id</code> = j.<code>job_id</code></p><p>ORDER BY department_name DESC;</p><p>#二）非等值连接</p><p>#查询员工的工资级别</p><p>SELECT salary,grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p><p> #查询工资级别的个数&gt;20的个数，并且按工资级别降序<br> SELECT COUNT(<em>),grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code><br> GROUP BY grade_level<br> HAVING COUNT(</em>)&gt;20<br> ORDER BY grade_level DESC;</p><p> #三）自连接</p><p> #查询员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.<code>manager_id</code>= m.<code>employee_id</code>;</p><p>  #查询姓名中包含字符k的员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.<code>manager_id</code>= m.<code>employee_id</code><br> WHERE e.<code>last_name</code> LIKE ‘%k%’;</p><p> #二、外连接</p><p> /*<br> 应用场景：用于查询一个表中有，另一个表没有的记录</p><p> 特点：<br> 1、外连接的查询结果为主表中的所有记录<br>    如果从表中有和它匹配的，则显示匹配的值<br>    如果从表中没有和它匹配的，则显示null<br>    外连接查询结果=内连接结果+主表中有而从表没有的记录<br> 2、左外连接，left join左边的是主表<br>    右外连接，right join右边的是主表<br> 3、左外和右外交换两个表的顺序，可以实现同样的效果<br> 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的<br> */<br> #引入：查询男朋友 不在男神表的的女神名</p><p> SELECT * FROM beauty;<br> SELECT * FROM boys;</p><p> #左外连接<br> SELECT b.<em>,bo.</em><br> FROM boys bo<br> LEFT OUTER JOIN beauty b<br> ON b.<code>boyfriend_id</code> = bo.<code>id</code><br> WHERE b.<code>id</code> IS NULL;</p><p> #案例1：查询哪个部门没有员工<br> #左外<br> SELECT d.*,e.employee_id<br> FROM departments d<br> LEFT OUTER JOIN employees e<br> ON d.<code>department_id</code> = e.<code>department_id</code><br> WHERE e.<code>employee_id</code> IS NULL;</p><p> #右外</p><p>  SELECT d.*,e.employee_id<br> FROM employees e<br> RIGHT OUTER JOIN departments d<br> ON d.<code>department_id</code> = e.<code>department_id</code><br> WHERE e.<code>employee_id</code> IS NULL;</p><p> #全外</p><p> USE girls;<br> SELECT b.<em>,bo.</em><br> FROM beauty b<br> FULL OUTER JOIN boys bo<br> ON b.<code>boyfriend_id</code> = bo.id;</p><p> #交叉连接</p><p> SELECT b.<em>,bo.</em><br> FROM beauty b<br> CROSS JOIN boys bo;</p><p> #sql92和 sql99pk<br> /*<br> 功能：sql99支持的较多<br> 可读性：sql99实现连接条件和筛选条件的分离，可读性较高<br> */</p><h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><p>#1.显示所有员工的姓名，部门号和部门名称。<br>USE myemployees;</p><p>SELECT last_name,d.department_id,department_name<br>FROM employees e,departments d<br>WHERE e.<code>department_id</code> = d.<code>department_id</code>;</p><p>#2.查询90号部门员工的job_id和90号部门的location_id</p><p>SELECT job_id,location_id<br>FROM employees e,departments d<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND e.<code>department_id</code>=90;</p><p>#3.    选择所有有奖金的员工的<br>last_name , department_name , location_id , city</p><p>SELECT last_name , department_name , l.location_id , city<br>FROM employees e,departments d,locations l<br>WHERE e.department_id = d.department_id<br>AND d.location_id=l.location_id<br>AND e.commission_pct IS NOT NULL;</p><p>#4.选择city在Toronto工作的员工的<br>last_name , job_id , department_id , department_name </p><p>SELECT last_name , job_id , d.department_id , department_name<br>FROM employees e,departments d ,locations l<br>WHERE e.department_id = d.department_id<br>AND d.location_id=l.location_id<br>AND city = ‘Toronto’;</p><p>#5.查询每个工种、每个部门的部门名、工种名和最低工资</p><p>SELECT department_name,job_title,MIN(salary) 最低工资<br>FROM employees e,departments d,jobs j<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND e.<code>job_id</code>=j.<code>job_id</code><br>GROUP BY department_name,job_title;</p><p>#6.查询每个国家下的部门个数大于2的国家编号</p><p>SELECT country_id,COUNT(*) 部门个数<br>FROM departments d,locations l<br>WHERE d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY country_id<br>HAVING 部门个数&gt;2;</p><p>#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式<br>employees    Emp#    manager    Mgr#<br>kochhar        101    king    100</p><p>SELECT e.last_name employees,e.employee_id “Emp#”,m.last_name manager,m.employee_id “Mgr#”<br>FROM employees e,employees m<br>WHERE e.manager_id = m.employee_id<br>AND e.last_name=’kochhar’;</p><h3 id="分页查询-★"><a href="#分页查询-★" class="headerlink" title="分页查询 ★"></a>分页查询 ★</h3><p>/*</p><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求<br>语法：<br>    select 查询列表<br>    from 表<br>    【join type join 表2<br>    on 连接条件<br>    where 筛选条件<br>    group by 分组字段<br>    having 分组后的筛选<br>    order by 排序的字段】<br>    limit 【offset,】size;</p><pre><code>offset要显示条目的起始索引（起始索引从0开始）size 要显示的条目个数</code></pre><p>特点：<br>    ①limit语句放在查询语句的最后<br>    ②公式<br>    要显示的页数 page，每页的条目数size</p><pre><code>select 查询列表from 表limit (page-1)*size,size;size=10page  1    02      103    20</code></pre><p>*/<br>#案例1：查询前五条员工信息</p><p>SELECT * FROM  employees LIMIT 0,5;<br>SELECT * FROM  employees LIMIT 5;</p><p>#案例2：查询第11条——第25条<br>SELECT * FROM  employees LIMIT 10,15;</p><p>#案例3：有奖金的员工信息，并且工资较高的前10名显示出来<br>SELECT<br>    *<br>FROM<br>        employees<br>WHERE commission_pct IS NOT NULL<br>ORDER BY salary DESC<br>LIMIT 10 ;</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>/*<br>含义：<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询</p><p>分类：<br>按子查询出现的位置：<br>    select后面：<br>        仅仅支持标量子查询</p><pre><code>from后面：    支持表子查询where或having后面：★    标量子查询（单行） √    列子查询  （多行） √        行子查询    exists后面（相关子查询）    表子查询</code></pre><p>按结果集的行列数不同：<br>    标量子查询（结果集只有一行一列）<br>    列子查询（结果集只有一列多行）<br>    行子查询（结果集有一行多列）<br>    表子查询（结果集一般为多行多列）</p><p>*/</p><p>#一、where或having后面<br>/*<br>1、标量子查询（单行子查询）<br>2、列子查询（多行子查询）</p><p>3、行子查询（多列多行）</p><p>特点：<br>①子查询放在小括号内<br>②子查询一般放在条件的右侧<br>③标量子查询，一般搭配着单行操作符使用</p><blockquote><p>&lt; &gt;= &lt;= = &lt;&gt;</p></blockquote><p>列子查询，一般搭配着多行操作符使用<br>in、any/some、all</p><p>④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</p><p>*/<br>#1.标量子查询★</p><p>#案例1：谁的工资比 Abel 高?</p><p>#①查询Abel的工资<br>SELECT salary<br>FROM employees<br>WHERE last_name = ‘Abel’</p><p>#②查询员工的信息，满足 salary&gt;①结果<br>SELECT *<br>FROM employees<br>WHERE salary&gt;(</p><pre><code>SELECT salaryFROM employeesWHERE last_name = &#39;Abel&#39;</code></pre><p>);</p><p>#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</p><p>#①查询141号员工的job_id<br>SELECT job_id<br>FROM employees<br>WHERE employee_id = 141</p><p>#②查询143号员工的salary<br>SELECT salary<br>FROM employees<br>WHERE employee_id = 143</p><p>#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</p><p>SELECT last_name,job_id,salary<br>FROM employees<br>WHERE job_id = (<br>    SELECT job_id<br>    FROM employees<br>    WHERE employee_id = 141<br>) AND salary&gt;(<br>    SELECT salary<br>    FROM employees<br>    WHERE employee_id = 143</p><p>);</p><p>#案例3：返回公司工资最少的员工的last_name,job_id和salary</p><p>#①查询公司的 最低工资<br>SELECT MIN(salary)<br>FROM employees</p><p>#②查询last_name,job_id和salary，要求salary=①<br>SELECT last_name,job_id,salary<br>FROM employees<br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM employees<br>);</p><p>#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</p><p>#①查询50号部门的最低工资<br>SELECT  MIN(salary)<br>FROM employees<br>WHERE department_id = 50</p><p>#②查询每个部门的最低工资</p><p>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#③ 在②基础上筛选，满足min(salary)&gt;①<br>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>    SELECT  MIN(salary)<br>    FROM employees<br>    WHERE department_id = 50</p><p>);</p><p>#非法使用标量子查询</p><p>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>    SELECT  salary<br>    FROM employees<br>    WHERE department_id = 250</p><p>);</p><p>#2.列子查询（多行子查询）★<br>#案例1：返回location_id是1400或1700的部门中的所有员工姓名</p><p>#①查询location_id是1400或1700的部门编号<br>SELECT DISTINCT department_id<br>FROM departments<br>WHERE location_id IN(1400,1700)</p><p>#②查询员工姓名，要求部门号是①列表中的某一个</p><p>SELECT last_name<br>FROM employees<br>WHERE department_id  &lt;&gt;ALL(<br>    SELECT DISTINCT department_id<br>    FROM departments<br>    WHERE location_id IN(1400,1700)</p><p>);</p><p>#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</p><p>#①查询job_id为‘IT_PROG’部门任一工资</p><p>SELECT DISTINCT salary<br>FROM employees<br>WHERE job_id = ‘IT_PROG’</p><p>#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个<br>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ANY(<br>    SELECT DISTINCT salary<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#或<br>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>    SELECT MAX(salary)<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</p><p>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ALL(<br>    SELECT DISTINCT salary<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#或</p><p>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>    SELECT MIN( salary)<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#3、行子查询（结果集一行多列或多行多列）</p><p>#案例：查询员工编号最小并且工资最高的员工信息</p><p>SELECT *<br>FROM employees<br>WHERE (employee_id,salary)=(<br>    SELECT MIN(employee_id),MAX(salary)<br>    FROM employees<br>);</p><p>#①查询最小的员工编号<br>SELECT MIN(employee_id)<br>FROM employees</p><p>#②查询最高工资<br>SELECT MAX(salary)<br>FROM employees</p><p>#③查询员工信息<br>SELECT *<br>FROM employees<br>WHERE employee_id=(<br>    SELECT MIN(employee_id)<br>    FROM employees</p><p>)AND salary=(<br>    SELECT MAX(salary)<br>    FROM employees</p><p>);</p><p>#二、select后面<br>/*<br>仅仅支持标量子查询<br>*/</p><p>#案例：查询每个部门的员工个数</p><p>SELECT d.*,(</p><pre><code>SELECT COUNT(*)FROM employees eWHERE e.department_id = d.`department_id`</code></pre><p> ) 个数<br> FROM departments d;</p><p> #案例2：查询员工号=102的部门名</p><p>SELECT (<br>    SELECT department_name,e.department_id<br>    FROM departments d<br>    INNER JOIN employees e<br>    ON d.department_id=e.department_id<br>    WHERE e.employee_id=102</p><p>) 部门名;</p><p>#三、from后面<br>/*<br>将子查询结果充当一张表，要求必须起别名<br>*/</p><p>#案例：查询每个部门的平均工资的工资等级<br>#①查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>SELECT * FROM job_grades;</p><p>#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</p><p>SELECT  ag_dep.*,g.<code>grade_level</code><br>FROM (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>) ag_dep<br>INNER JOIN job_grades g<br>ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</p><p>#四、exists后面（相关子查询）</p><p>/*<br>语法：<br>exists(完整的查询语句)<br>结果：<br>1或0</p><p>*/</p><p>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);</p><p>#案例1：查询有员工的部门名</p><p>#in<br>SELECT department_name<br>FROM departments d<br>WHERE d.<code>department_id</code> IN(<br>    SELECT department_id<br>    FROM employees</p><p>)</p><p>#exists</p><p>SELECT department_name<br>FROM departments d<br>WHERE EXISTS(<br>    SELECT *<br>    FROM employees e<br>    WHERE d.<code>department_id</code>=e.<code>department_id</code></p><p>);</p><p>#案例2：查询没有女朋友的男神信息</p><p>#in</p><p>SELECT bo.*<br>FROM boys bo<br>WHERE bo.id NOT IN(<br>    SELECT boyfriend_id<br>    FROM beauty<br>)</p><p>#exists<br>SELECT bo.*<br>FROM boys bo<br>WHERE NOT EXISTS(<br>    SELECT boyfriend_id<br>    FROM beauty b<br>    WHERE bo.<code>id</code>=b.<code>boyfriend_id</code></p><p>);</p><p>#1.    查询和Zlotkey相同部门的员工姓名和工资</p><p>#①查询Zlotkey的部门<br>SELECT department_id<br>FROM employees<br>WHERE last_name = ‘Zlotkey’</p><p>#②查询部门号=①的姓名和工资<br>SELECT last_name,salary<br>FROM employees<br>WHERE department_id = (<br>    SELECT department_id<br>    FROM employees<br>    WHERE last_name = ‘Zlotkey’</p><p>)</p><p>#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</p><p>#①查询平均工资<br>SELECT AVG(salary)<br>FROM employees</p><p>#②查询工资&gt;①的员工号，姓名和工资。</p><p>SELECT last_name,employee_id,salary<br>FROM employees<br>WHERE salary&gt;(</p><pre><code>SELECT AVG(salary)FROM employees</code></pre><p>);</p><p>#3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资<br>#①查询各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#②连接①结果集和employees表，进行筛选<br>SELECT employee_id,last_name,salary,e.department_id<br>FROM employees e<br>INNER JOIN (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id</p><p>) ag_dep<br>ON e.department_id = ag_dep.department_id<br>WHERE salary&gt;ag_dep.ag ;</p><p>#4.    查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名<br>#①查询姓名中包含字母u的员工的部门</p><p>SELECT  DISTINCT department_id<br>FROM employees<br>WHERE last_name LIKE ‘%u%’</p><p>#②查询部门号=①中的任意一个的员工号和姓名<br>SELECT last_name,employee_id<br>FROM employees<br>WHERE department_id IN(<br>    SELECT  DISTINCT department_id<br>    FROM employees<br>    WHERE last_name LIKE ‘%u%’<br>);</p><p>#5. 查询在部门的location_id为1700的部门工作的员工的员工号</p><p>#①查询location_id为1700的部门</p><p>SELECT DISTINCT department_id<br>FROM departments<br>WHERE location_id  = 1700</p><p>#②查询部门号=①中的任意一个的员工号<br>SELECT employee_id<br>FROM employees<br>WHERE department_id =ANY(<br>    SELECT DISTINCT department_id<br>    FROM departments<br>    WHERE location_id  = 1700</p><p>);<br>#6.查询管理者是King的员工姓名和工资</p><p>#①查询姓名为king的员工编号<br>SELECT employee_id<br>FROM employees<br>WHERE last_name  = ‘K_ing’</p><p>#②查询哪个员工的manager_id = ①<br>SELECT last_name,salary<br>FROM employees<br>WHERE manager_id IN(<br>    SELECT employee_id<br>    FROM employees<br>    WHERE last_name  = ‘K_ing’</p><p>);</p><p>#7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</p><p>#①查询最高工资<br>SELECT MAX(salary)<br>FROM employees</p><p>#②查询工资=①的姓.名</p><p>SELECT CONCAT(first_name,last_name) “姓.名”<br>FROM employees<br>WHERE salary=(<br>    SELECT MAX(salary)<br>    FROM employees</p><p>);</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>/*</p><p>数据定义语言</p><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><hr><p>一、库的管理<br>创建、修改、删除<br>二、表的管理<br>创建、修改、删除</p><p>创建： create<br>修改： alter<br>删除： drop</p><p>*/</p><p>#一、库的管理<br>#1、库的创建<br>/*<br>语法：<br>create database  [if not exists]库名;<br>*/</p><p>#案例：创建库Books</p><p>CREATE DATABASE IF NOT EXISTS books ;</p><p>#2、库的修改</p><p>RENAME DATABASE books TO 新库名;</p><p>#更改库的字符集</p><p>ALTER DATABASE books CHARACTER SET gbk;</p><p>#3、库的删除</p><p>DROP DATABASE IF EXISTS books;</p><p>#二、表的管理<br>#1.表的创建 ★</p><p>/*<br>语法：<br>create table 表名(<br>    列名 列的类型【(长度) 约束】,<br>    列名 列的类型【(长度) 约束】,<br>    列名 列的类型【(长度) 约束】,<br>    …<br>    列名 列的类型【(长度) 约束】</p><p>)</p><p>*/<br>#案例：创建表Book</p><p>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId  INT,#作者编号<br>    publishDate DATETIME#出版日期</p><p>);</p><p>DESC book;</p><p>#案例：创建表author<br>CREATE TABLE IF NOT EXISTS author(<br>    id INT,<br>    au_name VARCHAR(20),<br>    nation VARCHAR(10)</p><p>)<br>DESC author;</p><p>#2.表的修改</p><p>/*<br>语法<br>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</p><p>*/</p><p>#①修改列名</p><p>ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</p><p>#②修改列的类型或约束<br>ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</p><p>#③添加新列<br>ALTER TABLE author ADD COLUMN annual DOUBLE; </p><p>#④删除列</p><p>ALTER TABLE book_author DROP COLUMN  annual;<br>#⑤修改表名</p><p>ALTER TABLE author RENAME TO book_author;</p><p>DESC book;</p><p>#3.表的删除</p><p>DROP TABLE IF EXISTS book_author;</p><p>SHOW TABLES;</p><p>#通用的写法：</p><p>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;</p><p>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE  表名();</p><p>#4.表的复制</p><p>INSERT INTO author VALUES<br>(1,’村上春树’,’日本’),<br>(2,’莫言’,’中国’),<br>(3,’冯唐’,’中国’),<br>(4,’金庸’,’中国’);</p><p>SELECT * FROM Author;<br>SELECT * FROM copy2;<br>#1.仅仅复制表的结构</p><p>CREATE TABLE copy LIKE author;</p><p>#2.复制表的结构+数据<br>CREATE TABLE copy2<br>SELECT * FROM author;</p><p>#只复制部分数据<br>CREATE TABLE copy3<br>SELECT id,au_name<br>FROM author<br>WHERE nation=’中国’;</p><p>#仅仅复制某些字段</p><p>CREATE TABLE copy4<br>SELECT id,au_name<br>FROM author<br>WHERE 0;</p><h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><ol><li>创建表dept1<br>NAME    NULL?    TYPE<br>id        INT(7)<br>NAME        VARCHAR(25)</li></ol><p>USE test;</p><p>CREATE TABLE dept1(<br>    id INT(7),<br>    NAME VARCHAR(25)</p><p>);</p><ol start="2"><li>将表departments中的数据插入新表dept2中</li></ol><p>CREATE TABLE dept2<br>SELECT department_id,department_name<br>FROM myemployees.departments;</p><p>#3.    创建表emp5<br>NAME    NULL?    TYPE<br>id        INT(7)<br>First_name    VARCHAR (25)<br>Last_name    VARCHAR(25)<br>Dept_id        INT(7)</p><p>CREATE TABLE emp5(<br>id INT(7),<br>first_name VARCHAR(25),<br>last_name VARCHAR(25),<br>dept_id INT(7)</p><p>);</p><p>#4.    将列Last_name的长度增加到50</p><p>ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);<br>#5.    根据表employees创建employees2</p><p>CREATE TABLE employees2 LIKE myemployees.employees;</p><p>#6.    删除表emp5<br>DROP TABLE IF EXISTS emp5;</p><p>#7.    将表employees2重命名为emp5</p><p>ALTER TABLE employees2 RENAME TO emp5;</p><p>#8.在表dept和emp5中添加新列test_column，并检查所作的操作</p><p>ALTER TABLE emp5 ADD COLUMN test_column INT;<br>#9.直接删除表emp5中的列 dept_id<br>DESC emp5;<br>ALTER TABLE emp5 DROP COLUMN test_column;</p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><hr><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p><p>语法：<br>查询语句1<br>union<br>查询语句2<br>union<br>…</p><p>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p><p>特点：★<br>1、要求多条查询语句的查询列数是一致的！<br>2、要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3、union关键字默认去重，如果使用union all 可以包含重复项</p><p>*/</p><p>#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</p><p>SELECT * FROM employees WHERE email LIKE ‘%a%’ OR department_id&gt;90;;</p><p>SELECT * FROM employees  WHERE email LIKE ‘%a%’<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;</p><p>#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</p><p>SELECT id,cname FROM t_ca WHERE csex=’男’<br>UNION ALL<br>SELECT t_id,tname FROM t_ua WHERE tGender=’male’;</p><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><p>/*</p><p>数据操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p><p>*/</p><p>#一、插入语句<br>#方式一：经典的插入<br>/*<br>语法：<br>insert into 表名(列名,…) values(值1,…);</p><p>*/<br>SELECT * FROM beauty;<br>#1.插入的值的类型要与列的类型一致或兼容<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,’唐艺昕’,’女’,’1990-4-23’,’1898888888’,NULL,2);</p><p>#2.不可以为null的列必须插入值。可以为null的列如何插入值？<br>#方式一：<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,’唐艺昕’,’女’,’1990-4-23’,’1898888888’,NULL,2);</p><p>#方式二：</p><p>INSERT INTO beauty(id,NAME,sex,phone)<br>VALUES(15,’娜扎’,’女’,’1388888888’);</p><p>#3.列的顺序是否可以调换<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(‘蒋欣’,’女’,16,’110’);</p><p>#4.列数和值的个数必须一致</p><p>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(‘关晓彤’,’女’,17,’110’);</p><p>#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</p><p>INSERT INTO beauty<br>VALUES(18,’张飞’,’男’,NULL,’119’,NULL,NULL);</p><p>#方式二：<br>/*</p><p>语法：<br>insert into 表名<br>set 列名=值,列名=值,…<br>*/</p><p>INSERT INTO beauty<br>SET id=19,NAME=’刘涛’,phone=’999’;</p><p>#两种方式大pk ★</p><p>#1、方式一支持插入多行,方式二不支持</p><p>INSERT INTO beauty<br>VALUES(23,’唐艺昕1’,’女’,’1990-4-23’,’1898888888’,NULL,2)<br>,(24,’唐艺昕2’,’女’,’1990-4-23’,’1898888888’,NULL,2)<br>,(25,’唐艺昕3’,’女’,’1990-4-23’,’1898888888’,NULL,2);</p><p>#2、方式一支持子查询，方式二不支持</p><p>INSERT INTO beauty(id,NAME,phone)<br>SELECT 26,’宋茜’,’11809866’;</p><p>INSERT INTO beauty(id,NAME,phone)<br>SELECT id,boyname,’1234567’<br>FROM boys WHERE id&lt;3;</p><p>#二、修改语句</p><p>/*</p><p>1.修改单表的记录★</p><p>语法：<br>update 表名<br>set 列=新值,列=新值,…<br>where 筛选条件;</p><p>2.修改多表的记录【补充】</p><p>语法：<br>sql92语法：<br>update 表1 别名,表2 别名<br>set 列=值,…<br>where 连接条件<br>and 筛选条件;</p><p>sql99语法：<br>update 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br>set 列=值,…<br>where 筛选条件;</p><p>*/</p><p>#1.修改单表的记录<br>#案例1：修改beauty表中姓唐的女神的电话为13899888899</p><p>UPDATE beauty SET phone = ‘13899888899’<br>WHERE NAME LIKE ‘唐%’;</p><p>#案例2：修改boys表中id好为2的名称为张飞，魅力值 10<br>UPDATE boys SET boyname=’张飞’,usercp=10<br>WHERE id=2;</p><p>#2.修改多表的记录</p><p>#案例 1：修改张无忌的女朋友的手机号为114</p><p>UPDATE boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>SET b.<code>phone</code>=’119’,bo.<code>userCP</code>=1000<br>WHERE bo.<code>boyName</code>=’张无忌’;</p><p>#案例2：修改没有男朋友的女神的男朋友编号都为2号</p><p>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>SET b.<code>boyfriend_id</code>=2<br>WHERE bo.<code>id</code> IS NULL;</p><p>SELECT * FROM boys;</p><p>#三、删除语句<br>/*</p><p>方式一：delete<br>语法：</p><p>1、单表的删除【★】<br>delete from 表名 where 筛选条件</p><p>2、多表的删除【补充】</p><p>sql92语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名,表2 别名<br>where 连接条件<br>and 筛选条件;</p><p>sql99语法：</p><p>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;</p><p>方式二：truncate<br>语法：truncate table 表名;</p><p>*/</p><p>#方式一：delete<br>#1.单表的删除<br>#案例：删除手机号以9结尾的女神信息</p><p>DELETE FROM beauty WHERE phone LIKE ‘%9’;<br>SELECT * FROM beauty;</p><p>#2.多表的删除</p><p>#案例：删除张无忌的女朋友的信息</p><p>DELETE b<br>FROM beauty b<br>INNER JOIN boys bo ON b.<code>boyfriend_id</code> = bo.<code>id</code><br>WHERE bo.<code>boyName</code>=’张无忌’;</p><p>#案例：删除黄晓明的信息以及他女朋友的信息<br>DELETE b,bo<br>FROM beauty b<br>INNER JOIN boys bo ON b.<code>boyfriend_id</code>=bo.<code>id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p><p>#方式二：truncate语句</p><p>#案例：将魅力值&gt;100的男神信息删除<br>TRUNCATE TABLE boys ;</p><p>#delete pk truncate【面试题★】</p><p>/*</p><p>1.delete 可以加where 条件，truncate不能加</p><p>2.truncate删除，效率高一丢丢<br>3.假如要删除的表中有自增长列，<br>如果用delete删除后，再插入数据，自增长列的值从断点开始，<br>而truncate删除后，再插入数据，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值</p><p>5.truncate删除不能回滚，delete删除可以回滚.</p><p>*/</p><p>SELECT * FROM boys;</p><p>DELETE FROM boys;<br>TRUNCATE TABLE boys;<br>INSERT INTO boys (boyname,usercp)<br>VALUES(‘张飞’,100),(‘刘备’,100),(‘关云长’,100);</p><h4 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h4><ol><li>运行以下脚本创建表my_employees</li></ol><p>USE myemployees;<br>CREATE TABLE my_employees(<br>    Id INT(10),<br>    First_name VARCHAR(10),<br>    Last_name VARCHAR(10),<br>    Userid VARCHAR(10),<br>    Salary DOUBLE(10,2)<br>);<br>CREATE TABLE users(<br>    id INT,<br>    userid VARCHAR(10),<br>    department_id INT</p><p>);<br>#2.    显示表my_employees的结构<br>DESC my_employees;</p><p>#3.    向my_employees表中插入下列数据<br>ID    FIRST_NAME    LAST_NAME    USERID    SALARY<br>1    patel        Ralph        Rpatel    895<br>2    Dancs        Betty        Bdancs    860<br>3    Biri        Ben        Bbiri    1100<br>4    Newman        Chad        Cnewman    750<br>5    Ropeburn    Audrey        Aropebur    1550</p><p>#方式一：<br>INSERT INTO my_employees<br>VALUES(1,’patel’,’Ralph’,’Rpatel’,895),<br>(2,’Dancs’,’Betty’,’Bdancs’,860),<br>(3,’Biri’,’Ben’,’Bbiri’,1100),<br>(4,’Newman’,’Chad’,’Cnewman’,750),<br>(5,’Ropeburn’,’Audrey’,’Aropebur’,1550);<br>DELETE FROM my_employees;<br>#方式二：</p><p>INSERT INTO my_employees<br>SELECT 1,’patel’,’Ralph’,’Rpatel’,895 UNION<br>SELECT 2,’Dancs’,’Betty’,’Bdancs’,860 UNION<br>SELECT 3,’Biri’,’Ben’,’Bbiri’,1100 UNION<br>SELECT 4,’Newman’,’Chad’,’Cnewman’,750 UNION<br>SELECT 5,’Ropeburn’,’Audrey’,’Aropebur’,1550;</p><p>#4.     向users表中插入数据<br>1    Rpatel    10<br>2    Bdancs    10<br>3    Bbiri    20<br>4    Cnewman    30<br>5    Aropebur    40</p><p>INSERT INTO users<br>VALUES(1,’Rpatel’,10),<br>(2,’Bdancs’,10),<br>(3,’Bbiri’,20);</p><p>#5.将3号员工的last_name修改为“drelxer”<br>UPDATE my_employees SET last_name=’drelxer’ WHERE id = 3;</p><p>#6.将所有工资少于900的员工的工资修改为1000<br>UPDATE my_employees SET salary=1000 WHERE salary&lt;900;</p><p>#7.将userid 为Bbiri的user表和my_employees表的记录全部删除</p><p>DELETE u,e<br>FROM users u<br>JOIN my_employees e ON u.<code>userid</code>=e.<code>Userid</code><br>WHERE u.<code>userid</code>=’Bbiri’;</p><p>#8.删除所有数据</p><p>DELETE FROM my_employees;<br>DELETE FROM users;<br>#9.检查所作的修正</p><p>SELECT * FROM my_employees;<br>SELECT * FROM users;</p><p>#10.清空表my_employees<br>TRUNCATE TABLE my_employees;</p><h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><hr><p>/*<br>数值型：<br>    整型<br>    小数：<br>        定点数<br>        浮点数<br>字符型：<br>    较短的文本：char、varchar<br>    较长的文本：text、blob（较长的二进制数据）</p><p>日期型：</p><p>*/</p><p>#一、整型<br>/*<br>分类：<br>tinyint、smallint、mediumint、int/integer、bigint<br>1     2        3    4        8</p><p>特点：<br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p><p>*/</p><p>#1.如何设置无符号和有符号</p><p>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>    t1 INT(7) ZEROFILL,<br>    t2 INT(7) ZEROFILL </p><p>);</p><p>DESC tab_int;</p><p>INSERT INTO tab_int VALUES(-123456);<br>INSERT INTO tab_int VALUES(-123456,-123456);<br>INSERT INTO tab_int VALUES(2147483648,4294967296);</p><p>INSERT INTO tab_int VALUES(123,123);</p><p>SELECT * FROM tab_int;</p><p>#二、小数<br>/*<br>分类：<br>1.浮点型<br>float(M,D)<br>double(M,D)<br>2.定点型<br>dec(M，D)<br>decimal(M,D)</p><p>特点：</p><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p><p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p><p>*/<br>#测试M和D</p><p>DROP TABLE tab_float;<br>CREATE TABLE tab_float(<br>    f1 FLOAT,<br>    f2 DOUBLE,<br>    f3 DECIMAL<br>);<br>SELECT * FROM tab_float;<br>DESC tab_float;</p><p>INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);<br>INSERT INTO tab_float VALUES(123.456,123.456,123.456);<br>INSERT INTO tab_float VALUES(123.4,123.4,123.4);<br>INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);</p><p>#原则：<br>/*<br>所选择的类型越简单越好，能保存数值的类型越小越好</p><p>*/</p><p>#三、字符型<br>/*<br>较短的文本：</p><p>char<br>varchar</p><p>其他：</p><p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p><p>较长的文本：<br>text<br>blob(较大的二进制)</p><p>特点：</p><pre><code>写法        M的意思                    特点            空间的耗费    效率</code></pre><p>char    char(M)        最大的字符数，可以省略，默认为1        固定长度的字符        比较耗费    高</p><p>varchar varchar(M)    最大的字符数，不可以省略        可变长度的字符        比较节省    低<br>*/</p><p>CREATE TABLE tab_char(<br>    c1 ENUM(‘a’,’b’,’c’)</p><p>);</p><p>INSERT INTO tab_char VALUES(‘a’);<br>INSERT INTO tab_char VALUES(‘b’);<br>INSERT INTO tab_char VALUES(‘c’);<br>INSERT INTO tab_char VALUES(‘m’);<br>INSERT INTO tab_char VALUES(‘A’);</p><p>SELECT * FROM tab_set;</p><p>CREATE TABLE tab_set(</p><pre><code>s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</code></pre><p>);<br>INSERT INTO tab_set VALUES(‘a’);<br>INSERT INTO tab_set VALUES(‘A,B’);<br>INSERT INTO tab_set VALUES(‘a,c,d’);</p><p>#四、日期型</p><p>/*</p><p>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</p><p>datetime保存日期+时间<br>timestamp保存日期+时间</p><p>特点：</p><pre><code>    字节        范围        时区等的影响</code></pre><p>datetime                   8        1000——9999                      不受<br>timestamp    4                   1970-2038                        受</p><p>*/</p><p>CREATE TABLE tab_date(<br>    t1 DATETIME,<br>    t2 TIMESTAMP</p><p>);</p><p>INSERT INTO tab_date VALUES(NOW(),NOW());</p><p>SELECT * FROM tab_date;</p><p>SHOW VARIABLES LIKE ‘time_zone’;</p><p>SET time_zone=’+9:00’;</p><h3 id="子查询案例"><a href="#子查询案例" class="headerlink" title="子查询案例"></a>子查询案例</h3><hr><h4 id="1-查询工资最低的员工信息-last-name-salary"><a href="#1-查询工资最低的员工信息-last-name-salary" class="headerlink" title="1. 查询工资最低的员工信息: last_name, salary"></a>1. 查询工资最低的员工信息: last_name, salary</h4><p>#①查询最低的工资<br>SELECT MIN(salary)<br>FROM employees</p><p>#②查询last_name,salary，要求salary=①<br>SELECT last_name,salary<br>FROM employees<br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM employees<br>);</p><h4 id="2-查询平均工资最低的部门信息"><a href="#2-查询平均工资最低的部门信息" class="headerlink" title="2. 查询平均工资最低的部门信息"></a>2. 查询平均工资最低的部门信息</h4><p>#方式一：<br>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>#②查询①结果上的最低平均工资<br>SELECT MIN(ag)<br>FROM (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>) ag_dep</p><p>#③查询哪个部门的平均工资=②</p><p>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary)=(<br>    SELECT MIN(ag)<br>    FROM (<br>        SELECT AVG(salary) ag,department_id<br>        FROM employees<br>        GROUP BY department_id<br>    ) ag_dep</p><p>);</p><p>#④查询部门信息</p><p>SELECT d.*<br>FROM departments d<br>WHERE d.<code>department_id</code>=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    HAVING AVG(salary)=(<br>        SELECT MIN(ag)<br>        FROM (<br>            SELECT AVG(salary) ag,department_id<br>            FROM employees<br>            GROUP BY department_id<br>        ) ag_dep</p><pre><code>)</code></pre><p>);</p><p>#方式二：<br>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#②求出最低平均工资的部门编号<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY AVG(salary)<br>LIMIT 1;</p><p>#③查询部门信息<br>SELECT *<br>FROM departments<br>WHERE department_id=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary)<br>    LIMIT 1<br>);</p><h4 id="3-查询平均工资最低的部门信息和该部门的平均工资"><a href="#3-查询平均工资最低的部门信息和该部门的平均工资" class="headerlink" title="3. 查询平均工资最低的部门信息和该部门的平均工资"></a>3. 查询平均工资最低的部门信息和该部门的平均工资</h4><p>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>#②求出最低平均工资的部门编号<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY AVG(salary)<br>LIMIT 1;<br>#③查询部门信息<br>SELECT d.*,ag<br>FROM departments d<br>JOIN (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary)<br>    LIMIT 1</p><p>) ag_dep<br>ON d.<code>department_id</code>=ag_dep.department_id;</p><h4 id="4-查询平均工资最高的-job-信息"><a href="#4-查询平均工资最高的-job-信息" class="headerlink" title="4. 查询平均工资最高的 job 信息"></a>4. 查询平均工资最高的 job 信息</h4><p>#①查询最高的job的平均工资<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1</p><p>#②查询job信息<br>SELECT *<br>FROM jobs<br>WHERE job_id=(<br>    SELECT job_id<br>    FROM employees<br>    GROUP BY job_id<br>    ORDER BY AVG(salary) DESC<br>    LIMIT 1</p><p>);</p><h4 id="5-查询平均工资高于公司平均工资的部门有哪些"><a href="#5-查询平均工资高于公司平均工资的部门有哪些" class="headerlink" title="5. 查询平均工资高于公司平均工资的部门有哪些?"></a>5. 查询平均工资高于公司平均工资的部门有哪些?</h4><p>#①查询平均工资<br>SELECT AVG(salary)<br>FROM employees</p><p>#②查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#③筛选②结果集，满足平均工资&gt;①</p><p>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary)&gt;(<br>    SELECT AVG(salary)<br>    FROM employees</p><p>);</p><h4 id="6-查询出公司中所有-manager-的详细信息"><a href="#6-查询出公司中所有-manager-的详细信息" class="headerlink" title="6. 查询出公司中所有 manager 的详细信息."></a>6. 查询出公司中所有 manager 的详细信息.</h4><p>#①查询所有manager的员工编号<br>SELECT DISTINCT manager_id<br>FROM employees</p><p>#②查询详细信息，满足employee_id=①<br>SELECT *<br>FROM employees<br>WHERE employee_id =ANY(<br>    SELECT DISTINCT manager_id<br>    FROM employees</p><p>);</p><h4 id="7-各个部门中-最高工资中最低的那个部门的-最低工资是多少"><a href="#7-各个部门中-最高工资中最低的那个部门的-最低工资是多少" class="headerlink" title="7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少"></a>7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</h4><p>#①查询各部门的最高工资中最低的部门编号<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY MAX(salary)<br>LIMIT 1</p><p>#②查询①结果的那个部门的最低工资</p><p>SELECT MIN(salary) ,department_id<br>FROM employees<br>WHERE department_id=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY MAX(salary)<br>    LIMIT 1</p><p>);</p><h4 id="8-查询平均工资最高的部门的-manager-的详细信息-last-name-department-id-email-salary"><a href="#8-查询平均工资最高的部门的-manager-的详细信息-last-name-department-id-email-salary" class="headerlink" title="8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary"></a>8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</h4><p>#①查询平均工资最高的部门编号<br>SELECT<br>    department_id<br>FROM<br>    employees<br>GROUP BY department_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1 </p><p>#②将employees和departments连接查询，筛选条件是①<br>    SELECT<br>        last_name, d.department_id, email, salary<br>    FROM<br>        employees e<br>        INNER JOIN departments d<br>            ON d.manager_id = e.employee_id<br>    WHERE d.department_id =<br>        (SELECT<br>            department_id<br>        FROM<br>            employees<br>        GROUP BY department_id<br>        ORDER BY AVG(salary) DESC<br>        LIMIT 1) ;</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>#常见约束</p><p>/*</p><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><p>分类：六大约束<br>    NOT NULL：非空，用于保证该字段的值不能为空<br>    比如姓名、学号等<br>    DEFAULT:默认，用于保证该字段有默认值<br>    比如性别<br>    PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空<br>    比如学号、员工编号等<br>    UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空<br>    比如座位号<br>    CHECK:检查约束【mysql中不支持】<br>    比如年龄、性别<br>    FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值<br>        在从表添加外键约束，用于引用主表中某列的值<br>    比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p><p>添加约束的时机：<br>    1.创建表时<br>    2.修改表时</p><p>约束的添加分类：<br>    列级约束：<br>        六大约束语法上都支持，但外键约束没有效果</p><pre><code>表级约束：        除了非空、默认，其他的都支持</code></pre><p>​<br>主键和唯一的大对比：</p><pre><code>    保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合主键    √        ×        至多有1个           √，但不推荐唯一    √        √        可以有多个          √，但不推荐</code></pre><p>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表<br>    删除数据时，先删除从表，再删除主表</p><p>*/</p><p>CREATE TABLE 表名(<br>    字段名 字段类型 列级约束,<br>    字段名 字段类型,<br>    表级约束</p><p>)<br>CREATE DATABASE students;<br>#一、创建表时添加约束</p><p>#1.添加列级约束<br>/*<br>语法：</p><p>直接在字段名和类型后面追加 约束类型即可。</p><p>只支持：默认、非空、主键、唯一</p><p>*/</p><p>USE students;<br>DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT PRIMARY KEY,#主键<br>    stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>    gender CHAR(1) CHECK(gender=’男’ OR gender =’女’),#检查<br>    seat INT UNIQUE,#唯一<br>    age INT DEFAULT  18,#默认约束<br>    majorId INT REFERENCES major(id)#外键</p><p>);</p><p>CREATE TABLE major(<br>    id INT PRIMARY KEY,<br>    majorName VARCHAR(20)<br>);</p><p>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;</p><p>#2.添加表级约束<br>/*</p><p>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名)<br>*/</p><p>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT,</p><pre><code>CONSTRAINT pk PRIMARY KEY(id),#主键CONSTRAINT uq UNIQUE(seat),#唯一键CONSTRAINT ck CHECK(gender =&#39;男&#39; OR gender  = &#39;女&#39;),#检查CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</code></pre><p>);</p><p>SHOW INDEX FROM stuinfo;</p><p>#通用的写法：★</p><p>CREATE TABLE IF NOT EXISTS stuinfo(<br>    id INT PRIMARY KEY,<br>    stuname VARCHAR(20),<br>    sex CHAR(1),<br>    age INT DEFAULT 18,<br>    seat INT UNIQUE,<br>    majorid INT,<br>    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</p><p>);</p><p>#二、修改表时添加约束</p><p>/*<br>1、添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;</p><p>2、添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</p><p>*/<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT<br>)<br>DESC stuinfo;<br>#1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;<br>#2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br>#3.添加主键<br>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;<br>#②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p><p>#4.添加唯一</p><p>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;<br>#②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);</p><p>#5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </p><p>#三、修改表时删除约束</p><p>#1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</p><p>#2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;</p><p>#3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;</p><p>#4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;</p><p>#5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</p><p>SHOW INDEX FROM stuinfo;</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）</p><p>ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;<br>ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);</p><p>#2.    向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）</p><p>#3.    向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。<br>ALTER TABLE emp2 ADD COLUMN dept_id INT;<br>ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);</p><pre><code>    位置        支持的约束类型            是否可以起约束名</code></pre><p>列级约束：    列的后面    语法都支持，但外键没有效果    不可以<br>表级约束：    所有列的下面    默认和非空不支持，其他支持    可以（主键没有效果）</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>#视图<br>/*<br>含义：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据</p><p>比如：舞蹈班和普通班级的对比<br>    创建语法的关键字    是否实际占用物理空间    使用</p><p>视图    create view        只是保存了sql逻辑    增删改查，只是一般不能增删改</p><p>表    create table        保存了数据        增删改查</p><p>*/</p><p>#案例：查询姓张的学生名和专业名<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.<code>majorid</code>= m.<code>id</code><br>WHERE s.<code>stuname</code> LIKE ‘张%’;</p><p>CREATE VIEW v1<br>AS<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.<code>majorid</code>= m.<code>id</code>;</p><p>SELECT * FROM v1 WHERE stuname LIKE ‘张%’;</p><p>#一、创建视图<br>/*<br>语法：<br>create view 视图名<br>as<br>查询语句;</p><p>*/<br>USE myemployees;</p><p>#1.查询姓名中包含a字符的员工名、部门名和工种信息<br>#①创建<br>CREATE VIEW myv1<br>AS</p><p>SELECT last_name,department_name,job_title<br>FROM employees e<br>JOIN departments d ON e.department_id  = d.department_id<br>JOIN jobs j ON j.job_id  = e.job_id;</p><p>#②使用<br>SELECT * FROM myv1 WHERE last_name LIKE ‘%a%’;</p><p>#2.查询各部门的平均工资级别</p><p>#①创建视图查看每个部门的平均工资<br>CREATE VIEW myv2<br>AS<br>SELECT AVG(salary) ag,department_id<br>FROM employees<br>GROUP BY department_id;</p><p>#②使用<br>SELECT myv2.<code>ag</code>,g.grade_level<br>FROM myv2<br>JOIN job_grades g<br>ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p><p>#3.查询平均工资最低的部门信息</p><p>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p><p>#4.查询平均工资最低的部门名和工资</p><p>CREATE VIEW myv3<br>AS<br>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p><p>SELECT d.*,m.ag<br>FROM myv3 m<br>JOIN departments d<br>ON m.<code>department_id</code>=d.<code>department_id</code>;</p><p>#二、视图的修改</p><p>#方式一：<br>/*<br>create or replace view  视图名<br>as<br>查询语句;</p><p>*/<br>SELECT * FROM myv3 </p><p>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p><p>#方式二：<br>/*<br>语法：<br>alter view 视图名<br>as<br>查询语句;</p><p>*/<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;</p><p>#三、删除视图</p><p>/*</p><p>语法：drop view 视图名,视图名,…;<br>*/</p><p>DROP VIEW emp_v1,emp_v2,myv3;</p><p>#四、查看视图</p><p>DESC myv3;</p><p>SHOW CREATE VIEW myv3;</p><p>#五、视图的更新</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email,salary<em>12</em>(1+IFNULL(commission_pct,0)) “annual salary”<br>FROM employees;</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;</p><p>SELECT * FROM myv1;<br>SELECT * FROM employees;<br>#1.插入</p><p>INSERT INTO myv1 VALUES(‘张飞’,‘zf@qq.com’);</p><p>#2.修改<br>UPDATE myv1 SET last_name = ‘张无忌’ WHERE last_name=’张飞’;</p><p>#3.删除<br>DELETE FROM myv1 WHERE last_name = ‘张无忌’;</p><p>#具备以下特点的视图不允许更新</p><p>#①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT MAX(salary) m,department_id<br>FROM employees<br>GROUP BY department_id;</p><p>SELECT * FROM myv1;</p><p>#更新<br>UPDATE myv1 SET m=9000 WHERE department_id=10;</p><p>#②常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS</p><p>SELECT ‘john’ NAME;</p><p>SELECT * FROM myv2;</p><p>#更新<br>UPDATE myv2 SET NAME=’lucy’;</p><p>#③Select中包含子查询</p><p>CREATE OR REPLACE VIEW myv3<br>AS</p><p>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;</p><p>#更新<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资=100000;</p><p>#④join<br>CREATE OR REPLACE VIEW myv4<br>AS</p><p>SELECT last_name,department_name<br>FROM employees e<br>JOIN departments d<br>ON e.department_id  = d.department_id;</p><p>#更新</p><p>SELECT * FROM myv4;<br>UPDATE myv4 SET last_name  = ‘张飞’ WHERE last_name=’Whalen’;<br>INSERT INTO myv4 VALUES(‘陈真’,’xxxx’);</p><p>#⑤from一个不能更新的视图<br>CREATE OR REPLACE VIEW myv5<br>AS</p><p>SELECT * FROM myv3;</p><p>#更新</p><p>SELECT * FROM myv5;</p><p>UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;</p><p>#⑥where子句的子查询引用了from子句中的表</p><p>CREATE OR REPLACE VIEW myv6<br>AS</p><p>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>    SELECT  manager_id<br>    FROM employees<br>    WHERE manager_id IS NOT NULL<br>);</p><p>#更新<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary=10000 WHERE last_name = ‘k_ing’;</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p><p>CREATE OR REPLACE VIEW emp_v1<br>AS<br>SELECT last_name,salary,email<br>FROM employees<br>WHERE phone_number LIKE ‘011%’;</p><p>#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p><p>CREATE OR REPLACE VIEW emp_v2<br>AS<br>SELECT MAX(salary) mx_dep,department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MAX(salary)&gt;12000;</p><p>SELECT d.*,m.mx_dep<br>FROM departments d<br>JOIN emp_v2 m<br>ON m.department_id = d.<code>department_id</code>;</p><h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><p>/*<br>又称为自增长列<br>含义：可以不用手动的插入值，系统提供默认的序列值</p><p>特点：<br>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 SET auto_increment_increment=3;设置步长<br>可以通过 手动插入值，设置起始值</p><p>*/</p><p>#一、创建表时设置标识列</p><p>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>    id INT  ,<br>    NAME FLOAT UNIQUE AUTO_INCREMENT,<br>    seat INT </p><p>);<br>TRUNCATE TABLE tab_identity;</p><p>INSERT INTO tab_identity(id,NAME) VALUES(NULL,’john’);<br>INSERT INTO tab_identity(NAME) VALUES(‘lucy’);<br>SELECT * FROM tab_identity;</p><p>SHOW VARIABLES LIKE ‘%auto_increment%’;</p><p>SET auto_increment_increment=3;</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>/*<br>系统变量：<br>    全局变量<br>    会话变量</p><p>自定义变量：<br>    用户变量<br>    局部变量</p><p><em>/<br>#一、系统变量<br>/</em><br>说明：变量由系统定义，不是用户定义，属于服务器层面<br>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br>使用步骤：<br>1、查看所有系统变量<br>show global|【session】variables;<br>2、查看满足条件的部分系统变量<br>show global|【session】 variables like ‘%char%’;<br>3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br>4、为某个系统变量赋值<br>方式一：<br>set global|【session】系统变量名=值;<br>方式二：<br>set @@global|【session】系统变量名=值;</p><p><em>/<br>#1》全局变量<br>/</em><br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>*/<br>#①查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br>#②查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>#③查看指定的系统变量的值<br>SELECT @@global.autocommit;<br>#④为某个系统变量赋值<br>SET @@global.autocommit=0;<br>SET GLOBAL autocommit=0;</p><p>#2》会话变量<br>/*<br>作用域：针对于当前会话（连接）有效<br>*/<br>#①查看所有会话变量<br>SHOW SESSION VARIABLES;<br>#②查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE ‘%char%’;<br>#③查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;<br>#④为某个会话变量赋值<br>SET @@session.tx_isolation=’read-uncommitted’;<br>SET SESSION tx_isolation=’read-committed’;</p><p>#二、自定义变量<br>/*<br>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）<br>*/</p><p>#1》用户变量<br>/*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*/</p><p>#赋值操作符：=或:=<br>#①声明并初始化<br>SET @变量名=值;<br>SET @变量名:=值;<br>SELECT @变量名:=值;</p><p>#②赋值（更新变量的值）<br>#方式一：<br>    SET @变量名=值;<br>    SET @变量名:=值;<br>    SELECT @变量名:=值;<br>#方式二：<br>    SELECT 字段 INTO @变量名<br>    FROM 表;<br>#③使用（查看变量的值）<br>SELECT @变量名;</p><p>#2》局部变量<br>/*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*/</p><p>#①声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】;</p><p>#②赋值（更新变量的值）</p><p>#方式一：<br>    SET 局部变量名=值;<br>    SET 局部变量名:=值;<br>    SELECT 局部变量名:=值;<br>#方式二：<br>    SELECT 字段 INTO 具备变量名<br>    FROM 表;<br>#③使用（查看变量的值）<br>SELECT 局部变量名;</p><p>#案例：声明两个变量，求和并打印</p><p>#用户变量<br>SET @m=1;<br>SET @n=1;<br>SET @sum=@m+@n;<br>SELECT @sum;</p><p>#局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p><p>#用户变量和局部变量的对比</p><pre><code>    作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><p>局部变量定义 只能在 begin 和end之间 定义 否则会有语法错误</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>#TCL<br>/*<br>Transaction Control Language 事务控制语言</p><p>事务：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><p>案例：转账</p><p>张三丰  1000<br>郭襄    1000</p><p>update 表 set 张三丰的余额=500 where name=’张三丰’<br>意外<br>update 表 set 郭襄的余额=1500 where name=’郭襄’</p><p>事务的特性：<br>ACID<br>原子性：一个事务不可再分割，要么都执行要么都不执行<br>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态<br>隔离性：一个事务的执行不受其他事务的干扰<br>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</p><p>事务的创建<br>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p><p>delete from 表 where id =1;</p><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</p><p>set autocommit=0;</p><p>步骤1：开启事务<br>set autocommit=0;<br>start transaction;可选的<br>步骤2：编写事务中的sql语句(select insert update delete)<br>语句1;<br>语句2;<br>…</p><p>步骤3：结束事务<br>commit;提交事务<br>rollback;回滚事务</p><p>savepoint 节点名;设置保存点</p><p>事务的隔离级别：<br>          脏读        不可重复读    幻读<br>read uncommitted：√        √        √<br>read committed：  ×        √        √<br>repeatable read： ×        ×        √<br>serializable      ×             ×               ×</p><p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed<br>查看隔离级别<br>select @@tx_isolation;<br>设置隔离级别<br>set session|global transaction isolation level 隔离级别;</p><p>开启事务的语句;<br>update 表 set 张三丰的余额=500 where name=’张三丰’</p><p>update 表 set 郭襄的余额=1500 where name=’郭襄’<br>结束事务的语句;</p><p>*/</p><p>SHOW VARIABLES LIKE ‘autocommit’;<br>SHOW ENGINES;</p><p>#1.演示事务的使用步骤</p><p>#开启事务<br>SET autocommit=0;<br>START TRANSACTION;<br>#编写一组事务的语句<br>UPDATE account SET balance = 1000 WHERE username=’张无忌’;<br>UPDATE account SET balance = 1000 WHERE username=’赵敏’;</p><p>#结束事务<br>ROLLBACK;<br>#commit;</p><p>SELECT * FROM account;</p><p>#2.演示事务对于delete和truncate的处理的区别</p><p>SET autocommit=0;<br>START TRANSACTION;</p><p>DELETE FROM account;<br>ROLLBACK;</p><p>#3.演示savepoint 的使用<br>SET autocommit=0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id=28;<br>ROLLBACK TO a;#回滚到保存点</p><p>SELECT * FROM account;</p><h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><p>/*<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p><p><em>/<br>#存储过程<br>/</em><br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p>*/</p><p>#一、创建语法</p><p>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN</p><pre><code>存储过程体（一组合法的SQL语句）</code></pre><p>END</p><p>#注意：<br>/*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p><p>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*/</p><p>#二、调用语法</p><p>CALL 存储过程名(实参列表);</p><p>#——————————–案例演示———————————–<br>#1.空参列表<br>#案例：插入到admin表中五条记录</p><p>SELECT * FROM admin;</p><p>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>    INSERT INTO admin(username,<code>password</code>)<br>    VALUES(‘john1’,’0000’),(‘lily’,’0000’),(‘rose’,’0000’),(‘jack’,’0000’),(‘tom’,’0000’);<br>END $</p><p>#调用<br>CALL myp1()$</p><p>#2.创建带in模式参数的存储过程</p><p>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息</p><p>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.*<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>    WHERE b.name=beautyName;</p><p>END $</p><p>#调用<br>CALL myp2(‘柳岩’)$</p><p>#案例2 ：创建存储过程实现，用户是否登录成功</p><p>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>    DECLARE result INT DEFAULT 0;#声明并初始化</p><pre><code>SELECT COUNT(*) INTO result#赋值FROM adminWHERE admin.username = usernameAND admin.password = PASSWORD;SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用</code></pre><p>END $</p><p>#调用<br>CALL myp3(‘张飞’,’8888’)$</p><p>#3.创建out 模式参数的存储过程<br>#案例1：根据输入的女神名，返回对应的男神名<br>注意：默认是 in类型<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.boyname INTO boyname<br>    FROM boys bo<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName ;</p><p>END $</p><p>#案例2：根据输入的女神名，返回对应的男神名和魅力值</p><p>CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT)<br>BEGIN<br>    SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>    FROM boys<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = boys.id<br>    WHERE b.name=beautyName ;</p><p>END $</p><p>#调用<br>CALL myp7(‘小昭’,@name,@cp)$<br>SELECT @name,@cp$</p><p>#4.创建带inout模式参数的存储过程<br>#案例1：传入a和b两个值，最终a和b都翻倍并返回</p><p>CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)<br>BEGIN<br>    SET a=a<em>2;<br>    SET b=b</em>2;<br>END $</p><p>#调用<br>SET @m=10$<br>SET @n=20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$</p><p>#三、删除存储过程<br>#语法：drop procedure 存储过程名<br>DROP PROCEDURE p1;<br>DROP PROCEDURE p2,p3;#×</p><p>#四、查看存储过程的信息<br>DESC myp2;×<br>SHOW CREATE PROCEDURE  myp2;</p><p>#一、创建存储过程实现传入用户名和密码，插入到admin表中</p><p>CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))<br>BEGIN<br>    INSERT INTO admin(admin.username,PASSWORD)<br>    VALUES(username,loginpwd);<br>END $</p><p>#二、创建存储过程实现传入女神编号，返回女神名称和女神电话</p><p>CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))</p><p>BEGIN<br>    SELECT b.name ,b.phone INTO NAME,phone<br>    FROM beauty b<br>    WHERE b.id = id;</p><p>END $<br>#三、创建存储存储过程或函数实现传入两个女神生日，返回大小</p><p>CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)<br>BEGIN<br>    SELECT DATEDIFF(birth1,birth2) INTO result;<br>END $<br>#四、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回<br>CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))<br>BEGIN<br>    SELECT DATE_FORMAT(mydate,’%y年%m月%d日’) INTO strDate;<br>END $</p><p>CALL test_pro4(NOW(),@str)$<br>SELECT @str $</p><p>#五、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串<br>如 传入 ：小昭<br>返回： 小昭 AND 张无忌<br>DROP PROCEDURE test_pro5 $<br>CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))<br>BEGIN<br>    SELECT CONCAT(beautyName,’ and ‘,IFNULL(boyName,’null’)) INTO str<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName;</p><pre><code>SET str=</code></pre><p>END $</p><p>CALL test_pro5(‘柳岩’,@str)$<br>SELECT @str $</p><p>#六、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录<br>DROP PROCEDURE test_pro6$<br>CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)<br>BEGIN<br>    SELECT * FROM beauty LIMIT startIndex,size;<br>END $</p><p>CALL test_pro6(3,5)$</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>/*<br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p>区别：</p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p>*/</p><p>#一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>    函数体<br>END<br>/*</p><p>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型</p><p>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p><p>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记</p><p>*/</p><p>#二、调用语法<br>SELECT 函数名(参数列表)</p><p>#——————————案例演示—————————-<br>#1.无参有返回<br>#案例：返回公司的员工个数<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN</p><pre><code>DECLARE c INT DEFAULT 0;#定义局部变量SELECT COUNT(*) INTO c#赋值FROM employees;RETURN c;</code></pre><p>END $</p><p>SELECT myf1()$</p><p>#2.有参有返回<br>#案例1：根据员工名，返回它的工资</p><p>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    SET @sal=0;#定义用户变量<br>    SELECT salary INTO @sal   #赋值<br>    FROM employees<br>    WHERE last_name = empName;</p><pre><code>RETURN @sal;</code></pre><p>END $</p><p>SELECT myf2(‘k_ing’) $</p><p>#案例2：根据部门名，返回该部门的平均工资</p><p>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    DECLARE sal DOUBLE ;<br>    SELECT AVG(salary) INTO sal<br>    FROM employees e<br>    JOIN departments d ON e.department_id = d.department_id<br>    WHERE d.department_name=deptName;<br>    RETURN sal;<br>END $</p><p>SELECT myf3(‘IT’)$</p><p>#三、查看函数</p><p>SHOW CREATE FUNCTION myf3;</p><p>#四、删除函数<br>DROP FUNCTION myf3;</p><p>#案例<br>#一、创建函数，实现传入两个float，返回二者之和</p><p>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>    DECLARE SUM FLOAT DEFAULT 0;<br>    SET SUM=num1+num2;<br>    RETURN SUM;<br>END $</p><p>SELECT test_fun1(1,2)$</p><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><p>/*<br>顺序、分支、循环</p><p>*/</p><p>#一、分支结构<br>#1.if函数<br>/*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面</p><p>*/</p><p>#2.case结构<br>/*<br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>…<br>else 语句n;<br>end </p><p>情况2：<br>case<br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>…<br>else 语句n;<br>end </p><p>应用在begin end 中或外面</p><p>*/</p><p>#3.if结构</p><p>/*<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>….<br>else 语句n;<br>end if;<br>功能：类似于多重if</p><p>只能应用在begin end 中</p><p>*/</p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p><p>CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;<br>    IF score&gt;90 THEN SET ch=’A’;<br>    ELSEIF score&gt;80 THEN SET ch=’B’;<br>    ELSEIF score&gt;60 THEN SET ch=’C’;<br>    ELSE SET ch=’D’;<br>    END IF;<br>    RETURN ch;</p><p>END $</p><p>SELECT test_if(87)$</p><p>#案例2：创建存储过程，如果工资&lt;2000,则删除，如果5000&gt;工资&gt;2000,则涨工资1000，否则涨工资500</p><p>CREATE PROCEDURE test_if_pro(IN sal DOUBLE)<br>BEGIN<br>    IF sal&lt;2000 THEN DELETE FROM employees WHERE employees.salary=sal;<br>    ELSEIF sal&gt;=2000 AND sal&lt;5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.<code>salary</code>=sal;<br>    ELSE UPDATE employees SET salary=salary+500 WHERE employees.<code>salary</code>=sal;<br>    END IF;</p><p>END $</p><p>CALL test_if_pro(2100)$</p><p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p><p>CREATE FUNCTION test_case(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;</p><pre><code>CASE WHEN score&gt;90 THEN SET ch=&#39;A&#39;;WHEN score&gt;80 THEN SET ch=&#39;B&#39;;WHEN score&gt;60 THEN SET ch=&#39;C&#39;;ELSE SET ch=&#39;D&#39;;END CASE;RETURN ch;</code></pre><p>END $</p><p>SELECT test_case(56)$</p><p>#二、循环结构<br>/*<br>分类：<br>while、loop、repeat</p><p>循环控制：</p><p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p><p>*/</p><p>#1.while<br>/*</p><p>语法：</p><p>【标签:】while 循环条件 do<br>    循环体;<br>end while【 标签】;</p><p>联想：</p><p>while(循环条件){</p><pre><code>循环体;</code></pre><p>}</p><p>*/</p><p>#2.loop<br>/*</p><p>语法：<br>【标签:】loop<br>    循环体;<br>end loop 【标签】;</p><p>可以用来模拟简单的死循环</p><p>*/</p><p>#3.repeat<br>/*<br>语法：<br>【标签：】repeat<br>    循环体;<br>until 结束循环的条件<br>end repeat 【标签】;</p><p>*/</p><p>#1.没有添加循环控制语句<br>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘Rose’,i),’666’);<br>        SET i=i+1;<br>    END WHILE;</p><p>END $</p><p>CALL pro_while1(100)$</p><p>/*</p><p>int i=1;<br>while(i&lt;=insertcount){</p><pre><code>//插入i++;</code></pre><p>}</p><p>*/</p><p>#2.添加leave语句</p><p>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    a:WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘xiaohua’,i),’0000’);<br>        IF i&gt;=20 THEN LEAVE a;<br>        END IF;<br>        SET i=i+1;<br>    END WHILE a;<br>END $</p><p>CALL test_while1(100)$</p><p>#3.添加iterate语句</p><p>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    a:WHILE i&lt;=insertCount DO<br>        SET i=i+1;<br>        IF MOD(i,2)!=0 THEN ITERATE a;<br>        END IF;</p><pre><code>    INSERT INTO admin(username,`password`) VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);    END WHILE a;</code></pre><p>END $</p><p>CALL test_while1(100)$</p><p>/*</p><p>int i=0;<br>while(i&lt;=insertCount){<br>    i++;<br>    if(i%2==0){<br>        continue;<br>    }<br>    插入</p><p>}</p><p>*/</p><p>/*一、已知表stringcontent<br>其中字段：<br>id 自增长<br>content varchar(20)</p><p>向该表插入指定个数的，随机的字符串<br>*/<br>DROP TABLE IF EXISTS stringcontent;<br>CREATE TABLE stringcontent(<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    content VARCHAR(20)</p><p>);<br>DELIMITER $<br>CREATE PROCEDURE test_randstr_insert(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    DECLARE str VARCHAR(26) DEFAULT ‘abcdefghijklmnopqrstuvwxyz’;<br>    DECLARE startIndex INT;#代表初始索引<br>    DECLARE len INT;#代表截取的字符长度<br>    WHILE i&lt;=insertcount DO<br>        SET startIndex=FLOOR(RAND()<em>26+1);#代表初始索引，随机范围1-26<br>        SET len=FLOOR(RAND()</em>(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）<br>        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));<br>        SET i=i+1;<br>    END WHILE;</p><p>END $</p><p>CALL test_randstr_insert(10)$</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>TCP@IP</title>
    <link href="http://example.com/2021/04/28/TCP-IP/"/>
    <id>http://example.com/2021/04/28/TCP-IP/</id>
    <published>2021-04-28T08:56:27.000Z</published>
    <updated>2021-04-28T09:35:13.616Z</updated>
    
    <content type="html"><![CDATA[<p>CWR：拥塞窗口减少标志（显示拥塞通知 加在tcp首部保留位）<br>ECE:ECN-Echo（显示拥塞通知 加在tcp首部保留位）</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>TCP:可靠传输通信<br>UDP：尽力而为传输协议，（细节控制交给应用层）<br>1<br>6.2端口号<br>识别同一台计算机中进行通信的不同应用程序（程序地址）<br>根据端口号识别应用<br>tcp/ip或UDP/IP通信中通常都用五个信息来识别一个通信：<br>源IP地址，源IP地址，协议号，源端口号，目的端口号<br>路由协议通过在路由器之间共享路由信息来支持可路由协议。路由信息在相邻路由器之间传递，确保所有路由器知道到其它路由器的路径。总之，路由协议创建了路由表，描述了网络拓扑结构；路由协议与路由器协同工作，执行路由选择和数据包转发功能。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>路由协议主要运行于路由器上，路由协议是用来确定到达路径的起到一个地图导航，负责找路的作用。它工作在网络层。它包括RIP，IGRP（Cisco私有协议），EIGRP（Cisco私有协议），OSPF，IS-IS，BGP。<br>路由协议作为TCP/IP协议族中重要成员之一，其选路过程实现的好坏会影响整个Internet网络的效率。按应用范围的不同，路由协议可分为两类：<br>1、在一个AS内的路由协议称为内部网关协议（interior gateway protocol）。<br>备注：Autonomous System，自治系统，指一个互连网络，就是把整个Internet划分为许多较小的网络单位，这些小的网络有权自主地决定在本系统中应采用何种路由协议。一般由一个ISP运营的网络如移动/联通的网络位于一个AS（自治系统）内，有统一的AS number（自治系统号）。<br>2、AS之间的路由协议称为外部网关协议（exterior gateway protocol）。这里网关是路由器的旧称。<br><strong>常见的路由协议*</strong><br>有RIP、IGRP（Cisco私有协议）、EIGRP（Cisco私有协议）、OSPF、IS-IS、[BGP](<a href="https://baike.baidu.com/item/BGP">https://baike.baidu.com/item/BGP</a><br><strong>OSPF****<br>OSPF协议是“开放式最短路径优先(Open Shortest Path First)”的缩写，属于链路状态路由协议。OSPF提出了“区域（area）”的概念，每个区域中所有路由器维护着一个相同的链路状态数据库 （LSDB）。OSPF利用所维护的链路状态数据 库，通过最短生成树算法（SPF算法）计算得到路由表。OSPF的收敛速度较快。由于其特有的开放性以及良好的扩展性，目前OSPF协议在各种网络中广泛部署。<br>BGP</strong>****<br>为了维护各个ISP的独立利益，标准化组织制定了ISP间的路由协议BGP。BGP是“边界网关协议（Border Gateway Protocol）”的缩写，处理各ISP之间的路由传递。但是BGP运行在相对核心的地位，需要用户对网络的结构有相当的了解，否则可能会造成较大损失</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会</title>
    <link href="http://example.com/2021/04/22/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://example.com/2021/04/22/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id>
    <published>2021-04-22T15:49:22.000Z</published>
    <updated>2021-04-28T09:35:38.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-SQL"><a href="#第一章-SQL" class="headerlink" title="第一章 SQL"></a>第一章 SQL</h3><h4 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h4><ul><li><p>数据库软件应称为DBMS（数据库管理系统）。</p></li><li><p>表（table） 某种特定类型数据的结构化清单。</p><ul><li>表名 表名具有唯一性 ， 在相同数据库中不能两次使用相同的表名。</li><li>模式（schema） 关于数据库和表的布局及特性的信息。</li></ul></li><li><p>列 </p><ul><li><p>表由列组成。列中存储着表中某部分的信息</p></li><li><p>列（column） 表中的一个字段。所有表都是由一个或多个列组</p><p>成的。</p></li></ul></li><li><p>数据类型（datatype）</p><ul><li>数据类型  所容许的数据的类型。限制（或容许）列中存储的数据。</li></ul></li><li><p>行（row） 表中的一个记录。</p><ul><li><p>表中的数据是按行存储</p></li><li><p>主键（primary key）列（或一组列），其值能够唯一区分表</p><p>中每个行。</p><ul><li><p>大多数数据库应保证创建的每个表具有一个主键。</p></li><li><p> 任意两行都不具有相同的主键值；</p><p> 每个行都必须具有一个主键值（主键列不允许NULL值）。</p></li><li><p>主键的最好习惯 ：</p><p>不更新主键列中的值；</p><p>不重用主键列的值；</p><p> 不在主键列中使用可能会更改的值。 </p></li></ul></li></ul></li></ul><h4 id="2-SQL-：结构化查询语言"><a href="#2-SQL-：结构化查询语言" class="headerlink" title="2.SQL    ：结构化查询语言"></a>2.SQL    ：结构化查询语言</h4><ul><li><p>优点：SQL不是某个特定数据库供应商专有的语言。 </p><p> SQL简单易学 </p><p> 它 是一种强有力的语言， 可以进行非常复杂和高级的数据库操作。</p></li><li><p>事实上任意两个DBMS实现的SQL都不完全相同</p></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    介绍了什么是SQL以及它为什么很有用</p><h3 id="第二章MYSQL-简介"><a href="#第二章MYSQL-简介" class="headerlink" title="第二章MYSQL 简介"></a>第二章MYSQL 简介</h3><h4 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h4><p>​    一种DBMS，即它是一种数据库软件。</p><ul><li><p>客户机是与用户打交道的软件。</p><p>服务器部分是负责所有数据访问和处理的一个软件。</p></li><li><p>版本： 4——InnoDB引擎，增加事务处理（第26章）、并（第17章）、改</p><p>​            进全文本搜索（第18章）等的支持。</p><p>​             4.1——对函数库、子查询（第14章）、集成帮助等的重要增加。</p><p>​             5——存储过程 、触发器 、游标 、视图 </p></li></ul><h4 id="2-MySQL工具"><a href="#2-MySQL工具" class="headerlink" title="2.MySQL工具"></a>2.MySQL工具</h4><p>​        mysql命令行实用程序；图形交互客户机</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>本章介绍了什么是MySQL，并引入了几个客户机实用程序（一个命</p><p>令行实用程序，两个可选但强烈建议使用的图形实用程序）。</p><h3 id="第三章-使用mysql"><a href="#第三章-使用mysql" class="headerlink" title="第三章 使用mysql"></a>第三章 使用mysql</h3><h4 id="1-链接"><a href="#1-链接" class="headerlink" title="1.链接"></a>1.链接</h4><h4 id="2-选择数据库"><a href="#2-选择数据库" class="headerlink" title="2.选择数据库"></a>2.选择数据库</h4><h4 id="3-了解数据库和表"><a href="#3-了解数据库和表" class="headerlink" title="3.了解数据库和表"></a>3.了解数据库和表</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="第四章-检索数据"><a href="#第四章-检索数据" class="headerlink" title="第四章 检索数据"></a>第四章 检索数据</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h4 id="检索单列"><a href="#检索单列" class="headerlink" title="检索单列"></a>检索单列</h4><h4 id="检所多列"><a href="#检所多列" class="headerlink" title="检所多列"></a>检所多列</h4><h4 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h4><h4 id="检索所有行"><a href="#检索所有行" class="headerlink" title="检索所有行"></a>检索所有行</h4><h4 id="检所不同的行"><a href="#检所不同的行" class="headerlink" title="检所不同的行"></a>检所不同的行</h4><h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><h4 id="完全限制表名"><a href="#完全限制表名" class="headerlink" title="完全限制表名"></a>完全限制表名</h4><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><h3 id="第五章-排序检索数据"><a href="#第五章-排序检索数据" class="headerlink" title="第五章 排序检索数据"></a>第五章 排序检索数据</h3><h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><h4 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h4><h4 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h4><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><h3 id="第六章-过滤数据"><a href="#第六章-过滤数据" class="headerlink" title="第六章 过滤数据"></a>第六章 过滤数据</h3><h4 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h4><h4 id="where子句操作符"><a href="#where子句操作符" class="headerlink" title="where子句操作符"></a>where子句操作符</h4><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h3 id="第七章-数据过滤"><a href="#第七章-数据过滤" class="headerlink" title="第七章 数据过滤"></a>第七章 数据过滤</h3><h4 id="组合where子句"><a href="#组合where子句" class="headerlink" title="组合where子句"></a>组合where子句</h4><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><h3 id="第八章-使用通配符过滤数据"><a href="#第八章-使用通配符过滤数据" class="headerlink" title="第八章 使用通配符过滤数据"></a>第八章 使用通配符过滤数据</h3><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><h3 id="第九章-正则表达式进行搜索"><a href="#第九章-正则表达式进行搜索" class="headerlink" title="第九章 正则表达式进行搜索"></a>第九章 正则表达式进行搜索</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h4 id="MYSQL-正则表达式"><a href="#MYSQL-正则表达式" class="headerlink" title="MYSQL 正则表达式"></a>MYSQL 正则表达式</h4><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><h3 id="第十章计算字段"><a href="#第十章计算字段" class="headerlink" title="第十章计算字段"></a>第十章计算字段</h3><h4 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h4><h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><h4 id="算术计算"><a href="#算术计算" class="headerlink" title="算术计算"></a>算术计算</h4><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><h3 id="11章-计算字段"><a href="#11章-计算字段" class="headerlink" title="11章 计算字段"></a>11章 计算字段</h3><h4 id="计算字段-1"><a href="#计算字段-1" class="headerlink" title="计算字段"></a>计算字段</h4><h4 id="2-拼接字段"><a href="#2-拼接字段" class="headerlink" title="2.拼接字段"></a>2.拼接字段</h4><ul><li>别名<ul><li>其他用途</li><li></li></ul></li><li>  拼接</li><li>  去空格</li><li>  算术运算</li></ul><h3 id="11章-数据处理函数"><a href="#11章-数据处理函数" class="headerlink" title="11章 数据处理函数"></a>11章 数据处理函数</h3><p>1.函数：文本函数；数值函数；日期时间函数；系统函数</p><p>2.文本函数</p><ul><li></li></ul><p>3.数值函数</p><ul><li></li></ul><p>4.日期时间函数</p><ul><li></li><li></li><li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210421183227715.png" alt="image-20210421183227715"></p></li></ul><p>5.系统函数</p><ul><li></li></ul><h3 id="12章-汇总数据"><a href="#12章-汇总数据" class="headerlink" title="12章 汇总数据"></a>12章 汇总数据</h3><h3 id="13章-分组数据"><a href="#13章-分组数据" class="headerlink" title="13章 分组数据"></a>13章 分组数据</h3><h4 id="1-数据分组"><a href="#1-数据分组" class="headerlink" title="1.数据分组"></a>1.数据分组</h4><h4 id="2-创建分组"><a href="#2-创建分组" class="headerlink" title="2.创建分组"></a>2.创建分组</h4><h4 id="3-过滤分组"><a href="#3-过滤分组" class="headerlink" title="3.过滤分组"></a>3.过滤分组</h4><h4 id="4-分组和和排序"><a href="#4-分组和和排序" class="headerlink" title="4.分组和和排序"></a>4.分组和和排序</h4><h4 id="5-select子句顺序"><a href="#5-select子句顺序" class="headerlink" title="5.select子句顺序"></a>5.select子句顺序</h4><h3 id="14章-子查询"><a href="#14章-子查询" class="headerlink" title="14章 子查询"></a>14章 子查询</h3><p>1.子查询</p><ol start="2"><li></li></ol><h3 id="第十五章-连结表"><a href="#第十五章-连结表" class="headerlink" title="第十五章 连结表"></a>第十五章 连结表</h3><h4 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h4><h4 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h4><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="第十六章-创建高级联结"><a href="#第十六章-创建高级联结" class="headerlink" title="第十六章 创建高级联结"></a>第十六章 创建高级联结</h3><h4 id="表别名"><a href="#表别名" class="headerlink" title="表别名"></a>表别名</h4><h4 id="不同类型联结"><a href="#不同类型联结" class="headerlink" title="不同类型联结"></a>不同类型联结</h4><h4 id="带聚集函数的联结"><a href="#带聚集函数的联结" class="headerlink" title="带聚集函数的联结"></a>带聚集函数的联结</h4><h4 id="联结和连接条件"><a href="#联结和连接条件" class="headerlink" title="联结和连接条件"></a>联结和连接条件</h4><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><h3 id="第十七章-组合查询"><a href="#第十七章-组合查询" class="headerlink" title="第十七章 组合查询"></a>第十七章 组合查询</h3><h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><h4 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h4><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h3 id="第十八章-全文本搜索"><a href="#第十八章-全文本搜索" class="headerlink" title="第十八章 全文本搜索"></a>第十八章 全文本搜索</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="第十九章-插入数据"><a href="#第十九章-插入数据" class="headerlink" title="第十九章 插入数据"></a>第十九章 插入数据</h3><h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><h4 id="插入完整行"><a href="#插入完整行" class="headerlink" title="插入完整行"></a>插入完整行</h4><h4 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h4><h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十章-更新和删除数据"><a href="#第二十章-更新和删除数据" class="headerlink" title="第二十章 更新和删除数据"></a>第二十章 更新和删除数据</h3><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h4 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h4><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><h3 id="第二-十一章-创建和操纵表"><a href="#第二-十一章-创建和操纵表" class="headerlink" title="第二 十一章 创建和操纵表"></a>第二 十一章 创建和操纵表</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><h4 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十二章-使用视图"><a href="#第二十二章-使用视图" class="headerlink" title="第二十二章 使用视图"></a>第二十二章 使用视图</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><h4 id="-6"><a href="#-6" class="headerlink" title=""></a></h4><h3 id="第二十三章-存储过程"><a href="#第二十三章-存储过程" class="headerlink" title="第二十三章 存储过程"></a>第二十三章 存储过程</h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><h4 id="优点：简单，安全，高性能；"><a href="#优点：简单，安全，高性能；" class="headerlink" title="优点：简单，安全，高性能；"></a>优点：简单，安全，高性能；</h4><ul><li></li><li>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </li><li></li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十四章-游标"><a href="#第二十四章-游标" class="headerlink" title="第二十四章 游标"></a>第二十四章 游标</h3><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h4><h4 id="-7"><a href="#-7" class="headerlink" title=""></a></h4><h3 id="第二十五章-触发器"><a href="#第二十五章-触发器" class="headerlink" title="第二十五章 触发器"></a>第二十五章 触发器</h3><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十六章-管理事务处理"><a href="#第二十六章-管理事务处理" class="headerlink" title="第二十六章 管理事务处理"></a>第二十六章 管理事务处理</h3><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><h4 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h4><h4 id="-8"><a href="#-8" class="headerlink" title=""></a></h4><h3 id="第二十七章-全球化和本地化"><a href="#第二十七章-全球化和本地化" class="headerlink" title="第二十七章 全球化和本地化"></a>第二十七章 全球化和本地化</h3><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><h4 id="校对顺序"><a href="#校对顺序" class="headerlink" title="校对顺序"></a>校对顺序</h4><h4 id="使用字符集和校对顺序"><a href="#使用字符集和校对顺序" class="headerlink" title="使用字符集和校对顺序"></a>使用字符集和校对顺序</h4><h4 id="小结-18"><a href="#小结-18" class="headerlink" title="小结"></a>小结</h4><h4 id="-9"><a href="#-9" class="headerlink" title=""></a></h4><h3 id="第二十八章-安全管理"><a href="#第二十八章-安全管理" class="headerlink" title="第二十八章 安全管理"></a>第二十八章 安全管理</h3><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><h4 id="-10"><a href="#-10" class="headerlink" title=""></a></h4><h4 id="小结-19"><a href="#小结-19" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十九章-数据库维护"><a href="#第二十九章-数据库维护" class="headerlink" title="第二十九章 数据库维护"></a>第二十九章 数据库维护</h3><h4 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h4><h4 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h4><h4 id="诊断启动"><a href="#诊断启动" class="headerlink" title="诊断启动"></a>诊断启动</h4><h4 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h4><h3 id="第三十章-改善性能"><a href="#第三十章-改善性能" class="headerlink" title="第三十章 改善性能"></a>第三十章 改善性能</h3><h4 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h4><h4 id="小结-20"><a href="#小结-20" class="headerlink" title="小结"></a>小结</h4><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
  </entry>
  
  <entry>
    <title>First of my blog</title>
    <link href="http://example.com/2021/04/07/First-of-my-blog/"/>
    <id>http://example.com/2021/04/07/First-of-my-blog/</id>
    <published>2021-04-07T06:29:30.000Z</published>
    <updated>2021-04-24T15:40:37.734Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
</feed>
