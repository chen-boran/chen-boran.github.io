<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-20T12:13:38.684Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初步理解JAVA 虚拟机（黑马）</title>
    <link href="http://example.com/2021/06/20/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E9%BB%91%E9%A9%AC%EF%BC%89/"/>
    <id>http://example.com/2021/06/20/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E9%BB%91%E9%A9%AC%EF%BC%89/</id>
    <published>2021-06-20T12:12:56.000Z</published>
    <updated>2021-06-20T12:13:38.684Z</updated>
    
    <content type="html"><![CDATA[<p> 定义：java Virtural Machine  （java二进制代码<strong>运行环境</strong>）</p><p>优点：</p><ul><li><p>一次编写，到处运行</p></li><li><p>自动内存管理，垃圾回收机制</p></li><li><p>数组下标越界检查</p></li><li><p>多态机制</p></li></ul><p>JVM屏蔽java和底层操作系统的差异：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618122158873.png" alt="image-20210618122158873"></p><p>常见JVM：</p><p>学习路线：<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618122633191.png" alt="image-20210618122633191"></p><h1 id="一-内存结构"><a href="#一-内存结构" class="headerlink" title="一.内存结构"></a>一.内存结构</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps1.png" alt="img"></p><p>\1. 程序计数器</p><p>\2. 虚拟机栈</p><p>\3. 本地方法栈</p><p>\4. 堆</p><p>\5. 方法区</p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器     "></a>1. 程序计数器    <a href="af://n31/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps2.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps3.png" alt="img"> </p><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><ul><li><p>特点：</p><p>Program Counter Register 程序计数器（寄存器</p><ul><li><p>作用：记住下一条jvm指令的执行地址</p></li><li><p>是线程私有的</p></li><li><p><strong>不会存在内存溢出</strong> </p></li></ul></li></ul><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><p> 线程私有的，每个线程都有自身计数器</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618131139123.png" alt="image-20210618131139123">  </p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li><p>（虚拟机）栈：每个线程运行时所需要的内存   </p></li><li><p>每个栈由多个栈帧（Frame）组成</p></li><li><p>栈帧（Frame）：一个方法运行时需要的内存</p></li><li><p>每个线程只能有一个活动栈帧（正在执行的方法）</p></li></ul><p><strong>问题辨析</strong></p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>-栈内存自动清除，垃圾是对堆得数据进行回收 </p></li><li><p>栈内存分配越大越好吗？</p><p>栈内存越大，可同时运行的线程会减少，一般不建议增大内存</p></li><li><p>方法内的局部变量是否线程安全？</p><p>取决于使用的局部变量是否共享</p></li></ol><ul><li><p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围（return 返回），需要考虑线程安全 </p></li></ul><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p>报错显示 <strong>java.lang.StackOverflowError</strong></p><ul><li><p>栈帧过多导致栈内存溢出</p><p>例：方法递归调用</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618133324333.png" alt="image-20210618133324333" style="zoom:25%;" /></li><li><p>栈帧过大导致栈内存溢出</p> <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210618133359416.png" alt="image-20210618133359416" style="zoom:25%;" /></li></ul><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><p>案例1： cpu 占用过多定位</p><p>用top定位哪个进程对cpu的占用过高</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps10.png" alt="img">ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） jstack 进程id</p><p>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>案例2：程序运行很长时间没有结果</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps11.png" alt="img"></p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps12.png" alt="img"></p><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存特点</li></ul><p>它是线程共享的，堆中对象都需要考虑线程安全的问题  </p><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><ol><li>jps 工具</li></ol><ul><li> 查看当前系统中有哪些 java 进程</li></ul><ol start="2"><li><p>jmap 工具 <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps16.png" alt="img"> 查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具</p><p>图形界面的，多功能的监测工具，可以连续监测</p></li></ol><p>案例 ： 垃圾回收后，内存占用仍然很高</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps19.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps20.png" alt="img"> </p><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">J</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">VM</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">规范</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">-</a><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">方法区定义</a></p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成     "></a>5.2 组成    <a href="af://n248/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps21.png" alt="img"></p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出     "></a>5.3 方法区内存溢出    <a href="af://n265/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps22.png" alt="img">    1.8 以前会导致永久代内存溢出</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps23.png" alt="img"></p><p> 场景</p><p>​    mybatis</p><p>​    spring </p><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池     "></a>5.4 运行时常量池    <a href="af://n325/"> </a></h3><ul><li><p>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p></li><li><p>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p></li></ul><h3 id="5-5-StringTable-先看几道面试题："><a href="#5-5-StringTable-先看几道面试题：" class="headerlink" title="5.5 StringTable     先看几道面试题："></a>5.5 StringTable    <a href="af://n350/"> </a>先看几道面试题：</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps26.png" alt="img"></p><h3 id="5-5-StringTable-特性"><a href="#5-5-StringTable-特性" class="headerlink" title="5.5 StringTable 特性     "></a>5.5 StringTable 特性    <a href="af://n353/"> </a></h3><p>常量池中的字符串仅是符号，第一次用到时才变为对象利用串池的机制，来避免重复创建字符串对象</p><ul><li><p>字符串变量拼接的原理是 StringBuilder （1.8)字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用 <strong>intern</strong> 方法，主动将串池中还没有的字符串对象放入串池</p></li></ul><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</p><p>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回</p><h3 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置     "></a>5.6 StringTable 位置    <a href="af://n375/"> </a></h3><h3 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收     "></a>5.7 StringTable 垃圾回收    <a href="af://n388/"> </a></h3><h3 id="5-8-StringTable-性能调优"><a href="#5-8-StringTable-性能调优" class="headerlink" title="5.8 StringTable 性能调优     "></a>5.8 StringTable 性能调优    <a href="af://n401/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps28.png" alt="img"> 调整 -XX:StringTableSize=桶个数</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps29.png" alt="img"> 考虑将字符串对象是否入池</p><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h2 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义     "></a>6.1 定义    <a href="af://n432/"> </a></h2><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区分配回收成本较高，但读写性能高不受 JVM 内存回收管理</li></ul><h3 id="6-2-分配和回收原理"><a href="#6-2-分配和回收原理" class="headerlink" title="6.2 分配和回收原理     "></a>6.2 分配和回收原理    <a href="af://n452/"> </a></h3><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，</li><li>使用了 Cleaner （虚引用)来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><h1 id="二-垃圾回收"><a href="#二-垃圾回收" class="headerlink" title="二.垃圾回收"></a>二.垃圾回收</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps33.png" alt="img"></p><ol><li><p> 如何判断对象可以回收</p></li><li><p> 垃圾回收算法</p></li><li><p> 分代垃圾回收</p></li><li><p> 垃圾回收器</p></li><li><p> 垃圾回收调优</p></li></ol><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps34.png" alt="img"> </p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><ol><li><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收</p></li><li><p>哪些对象可以作为 GC Root ?</p></li></ol><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><ol><li> 强引用</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps38.png" alt="img"> 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><ol start="2"><li><p>软引用（SoftReference）</p><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</p></li></ol><p>可以配合引用队列来释放软引用自身</p><ol start="3"><li><p>弱引用（WeakReference）</p><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象可以配合引用队列来释放弱引用自身</p></li><li><p>虚引用（PhantomReference）</p><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li><li><p>终结器引用（FinalReference）</p><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p></li></ol><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1标记回收"><a href="#2-1标记回收" class="headerlink" title="2.1标记回收"></a>2.1标记回收</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps43.png" alt="img"></p><ol><li>标记可回收垃圾</li><li>回收垃圾</li></ol><ul><li>优点：速度快效率高</li><li>缺点：造成内存碎片（内存空间不连续）</li></ul><h2 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理     "></a>2.2 标记整理    <a href="af://n170/"> </a></h2><p>定义：Mark Compact <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps44.png" alt="img"> 速度慢</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps45.png" alt="img"></p><ol><li>标记可回收垃圾（存活多）</li><li>回收垃圾（内存空间向前移动）</li></ol><ul><li>优点：速度较慢（设计地址的变化等操作）</li><li>缺点：不会造成内存碎片 </li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制     "></a>2.3 复制    <a href="af://n188/"> </a></h3><p>定义：Copy</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps46.png" alt="img"></p><p>把可以保存的对象复制到另一份内存空间，并交换from和to</p><ul><li><p>优点：没有内存碎片</p></li><li><p>占用双倍的内存空间 </p></li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收     "></a>3. 分代垃圾回收    <a href="af://n207/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps47.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps48.png" alt="img"> </p><ol><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中（其他对象空间 被回收），存活的对象年龄加 1并且交换 from to</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215049838.png" alt="image-20210619215049838"></p></li><li><p>minor gc 会引发 stop the world（避免线程混乱，涉及地质改变），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215117828.png" alt="image-20210619215117828"></p></li><li><p>当老年代空间不足，会先尝试触发 minor gc（初级垃圾清除），如果之后空间仍不足，那么触发 full gc，STW的时间更长</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210619215139218.png" alt="image-20210619215139218"></p></li></ol><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数     "></a>3.1 相关 VM 参数    <a href="af://n224/"> </a></h3><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><p> <strong>大对象直接送到老年代机制</strong></p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器    @@@@@"></a>4. 垃圾回收器    @@@@@</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps50.png" alt="img"></p><ol><li><p>串行</p><ul><li>底层是单线程，- </li><li>适用于堆内存较小，适合个人电脑</li></ul></li><li><p>吞吐量优先</p><ul><li>多线程</li><li>适用于堆内存较大，多核 cpu </li><li>让<strong>单位时间</strong>内，STW 的时间最短 0.2 0.2 = 4，垃圾回收时间占比最低，这样就称吞吐量高</li></ul></li><li><p>响应时间优先</p><ul><li><p>多线程</p></li><li><p>适用于堆内存较大，</p></li><li><p>多核 cpu</p></li><li><p>尽可能让单次 STW 的单次时间最短     0.1 0.1 0.1 0.1 0.1 = 0.5</p></li></ul></li></ol><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行     "></a>4.1 串行    <a href="af://n311/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps54.png" alt="img"></p><ol><li>空间不足</li><li>在安全点暂停（阻塞）——-》开启单个垃圾回收线程</li><li>垃圾回收完成————》线程继续</li></ol><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><p>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps56.png" alt="img"></p><ol><li> 内存空间不足</li><li> 在安全点暂停（阻塞）——-》开启多个垃圾回收线程（）</li><li> 垃圾回收完成————》线程继续</li></ol><h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先     "></a>4.3 响应时间优先    <a href="af://n341/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps57.png" alt="img"></p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1     "></a>4.4 G1    <a href="af://n363/"> </a></h3><p>定义：Garbage First</p><ul><li><p>2004 论文发布</p></li><li><p>2009 JDK 6u14 体验</p></li><li><p>2012 JDK 7u4 官方支持 </p></li><li><p>2017 JDK 9 默认成为垃圾回收器</p></li></ul><p>适用场景</p><ul><li><p>同时注重吞吐量（Throughput）和低延迟（Low latency)，默认的暂停目标是 200 ms</p></li><li><p>超大堆内存，会将堆划分为多个大小相等的 Region </p></li><li><p>整体上是<strong>标记+整理算法</strong>，两个区域之间是<strong>复制算法</strong></p></li><li><p>相关 JVM 参数</p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize=size</p><p>-XX:MaxGCPauseMillis=time</p></li></ul><h4 id="1-G1-垃圾回收阶段"><a href="#1-G1-垃圾回收阶段" class="headerlink" title="1) G1 垃圾回收阶段"></a>1) G1 垃圾回收阶段</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps63.png" alt="img"> </p><h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection     "></a>2) Young Collection    <a href="af://n406/"> </a></h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps64.png" alt="img"> 会 STW</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps65.png" alt="img"> </p><p> S:幸存区</p><p>O:老年代</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps66.png" alt="img"> </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps67.png" alt="img"> </p><h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM     "></a>3) Young Collection + CM    <a href="af://n436/"> </a></h4><ul><li><p>在 Young GC 时会进行 GC Root 的初始标记</p></li><li><p>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定 </p></li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps69.png" alt="img"></p><h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>混合收集阶段</p><ul><li>会对 E、S、O 进行全面垃圾回收最终标记（Remark）会 STW </li><li>拷贝存活（Evacuation）会 STW </li><li>不是所有老年代都被回收，优先回收垃圾最多的标记，</li></ul><p>-XX:MaxGCPauseMillis=ms</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps71.png" alt="img"> </p><h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC     "></a>5) Full GC    <a href="af://n459/"> </a></h4><ul><li><p>SerialGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p></li><li><p>ParallelGC </p><p>新生代内存不足发生的垃圾收集 - minor gc </p><p>老年代内存不足发生的垃圾收集- </p></li><li><p>full gc</p><p>新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足</p><p>新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足</p></li></ul><h4 id="6）Young-Collection跨代引用"><a href="#6）Young-Collection跨代引用" class="headerlink" title="6）Young Collection跨代引用"></a>6）Young Collection跨代引用</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps73.png" alt="img"></p><p> 老年代引用了新生代被标记成脏卡区</p><p> 垃圾回收时，对脏卡去进行查找，加快垃圾回收速度</p><ul><li><p>卡表与 Remembered Set</p></li><li><p>在引用变更时通过 <strong>post-write barrier</strong> （标记脏卡）+ dirty card queue </p></li><li><p>concurrent refinement threads 更新 Remembered Set</p></li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps75.png" alt="img"> </p><h4 id="7-Remark"><a href="#7-Remark" class="headerlink" title="7) Remark     "></a>7) Remark    <a href="af://n530/"> </a></h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps76.png" alt="img"></p><p> 注：黑色处理完；    灰色正在处理；    白色尚未处理</p><p>并发标记阶段，如果回收期间引用关系发生了改变：</p><ol><li><p>C被A 引用（A是根引用）</p></li><li><p>C就会被添加<strong>写屏障</strong>，进入队列中，被<strong>重新标记</strong>成灰色</p></li><li><p>并发标记结束，进入重新标记阶段（remark），其他线程结束</p></li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620100531126.png" alt="image-20210620100531126"></p><h4 id="8-JDK-8u20-字符串去重"><a href="#8-JDK-8u20-字符串去重" class="headerlink" title="8) JDK 8u20 字符串去重"></a>8) JDK 8u20 字符串去重</h4><p>优点：节省大量内存</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps77.png" alt="img">优点：节省大量内存</p><h4 id="9-JDK-8u40-并发标记类卸载"><a href="#9-JDK-8u40-并发标记类卸载" class="headerlink" title="9) JDK 8u40 并发标记类卸载"></a>9) JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4 id="10-JDK-8u60-回收巨型对象"><a href="#10-JDK-8u60-回收巨型对象" class="headerlink" title="10) JDK 8u60 回收巨型对象     "></a>10) JDK 8u60 回收巨型对象    <a href="af://n587/"> </a></h4><ul><li><p>一个对象大于 region 的一半时，称之为巨型对象 </p></li><li><p>G1 不会对巨型对象进行拷贝</p></li><li><p>回收时被优先考虑</p></li><li><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉(回收得越早越好)</p></li></ul><h4 id="11-JDK-9-并发标记起始时间的调整"><a href="#11-JDK-9-并发标记起始时间的调整" class="headerlink" title="11) JDK 9 并发标记起始时间的调整     "></a>11) JDK 9 并发标记起始时间的调整    <a href="af://n614/"> </a></h4><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p><ul><li><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent（默认45%)</p></li><li><p>JDK 9 可以动态调整</p></li><li><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p></li><li><p>进行数据采样并动态调整</p></li><li><p>总会添加一个安全的空档空间</p></li><li></li></ul><h4 id="12-JDK-9-更高效的回收"><a href="#12-JDK-9-更高效的回收" class="headerlink" title="12) JDK 9 更高效的回收     "></a>12) JDK 9 更高效的回收    <a href="af://n645/"> </a></h4><p>250+增强</p><p>180+bug修复</p><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">j</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">ava/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">j</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">avase/12/</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">g</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">ctunin</a><a href="https://docs.oracle.com/en/java/javase/12/gctuning">g</a></p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优     "></a>5. 垃圾回收调优    <a href="af://n670/"> </a></h2><p>预备知识</p><ul><li><p>掌握 GC 相关的 VM 参数，会基本的空间调整掌握相关工具</p></li><li><p>知识点：调优跟应用、环境有关，没有放之四海而皆准的法则</p></li></ul><h3 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps85.png" alt="img">内存锁竞争</p><p>cpu 占用 io</p><h3 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h3><p>【低延迟】还是【高吞吐量】，选择合适的回收器</p><p>CMS，G1，ZGC</p><p>ParallelGC</p><h3 id="5-3-最快的-GC"><a href="#5-3-最快的-GC" class="headerlink" title="5.3 最快的 GC     "></a>5.3 最快的 GC    <a href="af://n742/"> </a></h3><p>答案是不发生 GC 查看 FullGC 前后的内存占用，考虑下面几个问题</p><p>数据是不是太多？</p><p>resultSet = statement.executeQuery(“select * from 大表 limit n”) 数据表示是否太臃肿？</p><p>对象图</p><p>对象大小 16 Integer 24 int 4 是否存在内存泄漏？</p><p>static Map map =</p><p>软弱第三方缓存实现</p><h3 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优     "></a>5.4 新生代调优    <a href="af://n798/"> </a></h3><p>新生代的特点所有的 new 操作的内存分配非常廉价</p><p>TLAB thread-local allocation buffer 死亡对象的回收代价是零大部分对象用过即死</p><p>Minor GC 的时间远远低于 Full GC</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps89.png" alt="img"> 越大越好吗？</p><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps90.png" alt="img">新生代能容纳所有【并发量 * (请求-响应)】的数据幸存区大到能保留【当前活跃对象+需要晋升对象】</p><h3 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优     "></a>5.5 老年代调优    <a href="af://n860/"> </a></h3><p>以 CMS 为例</p><p>CMS 的老年代内存越大越好</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps91.png" alt="img">先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</p><p>-XX:CMSInitiatingOccupancyFraction=percent</p><h3 id="5-6-案例"><a href="#5-6-案例" class="headerlink" title="5.6 案例     "></a>5.6 案例    <a href="af://n882/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps92.png" alt="img">案例1 Full GC 和 Minor GC频繁</p><p>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</p><h1 id="三-类加载与字节码技术"><a href="#三-类加载与字节码技术" class="headerlink" title="三. 类加载与字节码技术"></a>三. 类加载与字节码技术</h1><p> 类加载与字节码技术     </p><ol><li>类文件结构 </li><li>字节码指令 </li><li>编译期处理</li><li>类加载阶</li><li>类加载器</li><li>运行期优化</li></ol><h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h2><p>一个简单的 HelloWorld.java</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620123640244.png" alt="image-20210620123640244"></p><p>编译为 HelloWorld.class 后是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# od -t xC HelloWorld.class </span><br><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00</span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00</span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><p>根据 JVM 规范，类文件结构如下：<br> <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620123750334.png" alt="image-20210620123750334"></p><p>下面分别进行解释：</p><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><p>表示文件类型</p><p>0~3 字节，表示它是否是【class】类型的文件<br>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h3 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h3><p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8<br>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池     @@@@"></a>1.3 常量池     @@@@</h3><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td>CONSTANT_Class</td><td>7</td></tr><tr><td>CONSTANT_Fieldref</td><td>9</td></tr><tr><td>CONSTANT_Methodref</td><td>10</td></tr><tr><td>CONSTANT_InterfaceMethodref</td><td>11</td></tr><tr><td>CONSTANT_String</td><td>8</td></tr><tr><td>CONSTANT_Integer</td><td>3</td></tr><tr><td>CONSTANT_Float</td><td>4</td></tr><tr><td>CONSTANT_Long</td><td>5</td></tr><tr><td>CONSTANT_Double</td><td>6</td></tr><tr><td>CONSTANT_NameAndType</td><td>12</td></tr><tr><td>CONSTANT_Utf8</td><td>1</td></tr><tr><td>CONSTANT_MethodHandle</td><td>15</td></tr><tr><td>CONSTANT_MethodType</td><td>16</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>8<del>9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1</del>#34项，注意 #0 项不计入，也没有值<br>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09##</li></ul><p>第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得这个方法的【所属类】和【方法名】<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p><p>第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的【所属类】和【成员变量名】<br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26 项来获得这个方法的【所属类】和【方法名】<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07<br>第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【<init>】<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p><p>第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p><p>第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】<br>0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e<br>0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</p><p>第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】<br>0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63<br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</p><p>第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】<br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01<br>0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</p><p>第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】<br>0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63<br>0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p><p>第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p><p>第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16<br>0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p><p>第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p><p>第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】<br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e<br>67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</p><p>第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】<br>0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61<br>0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</p><p>第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】<br>0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46<br>0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</p><p>第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】<br>0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p><p>第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e<br>第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e<br>0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】<br>0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p><p>第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p><p>第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】<br>0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74<br>0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c<br>0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</p><p>第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】<br>0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61<br>0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</p><p>第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】<br>0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</p><p>第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】<br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f<br>0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p><p>第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】<br>0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72<br>0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76<br>第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】<br>0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76<br>0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</p><p>第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】<br>0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</p><p>第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】<br>0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a<br>0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h3 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h3><p>21 表示该 class 是一个类，公共的<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>05表示根据常量池中 #5 找到本类全限定名<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>06表示根据常量池中 #6 找到父类全限定名<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>表示接口的数量，本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br>Flag Name    Value    Interpretation<br>ACC_PUBLIC    0x0001    Declared public ; may be accessed from outside its package.<br>ACC_FINAL    0x0010    Declared final ; no subclasses allowed.<br>ACC_SUPER    0x0020    Treat superclass methods specially when invoked by the invokespecial instruction.<br>ACC_INTERFACE    0x0200    Is an interface, not a class.<br>ACC_ABSTRACT    0x0400    Declared abstract ; must not be instantiated.<br>ACC_SYNTHETIC    0x1000    Declared synthetic; not present in the source code.<br>ACC_ANNOTATION    0x2000    Declared as an annotation type.<br>ACC_ENUM    0x4000    Declared as an enum type.</p><h3 id="1-5-Field-信息"><a href="#1-5-Field-信息" class="headerlink" title="1.5 Field 信息"></a>1.5 Field 信息</h3><p>表示成员变量数量，本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><table><thead><tr><th>FieldType</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L ClassName</td><td>reference</td><td>an instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><h3 id="1-6-Method-信息"><a href="#1-6-Method-信息" class="headerlink" title="1.6 Method 信息"></a>1.6 Method 信息</h3><p>表示方法数量，本类为 2<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><ul><li><p>一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成<br>红色代表访问修饰符（本类中是 public）<br>蓝色代表引用了常量池 #07 项作为方法名称<br>绿色代表引用了常量池 #08 项作为方法参数描述黄色代表方法属性数量，本方法是 1 红色代表方法属性<br>00 09 表示引用了常量池 #09 项，发现是【Code】属性<br>00 00 00 2f 表示此属性的长度是 47<br>00 01 表示【操作数栈】 大深度<br>00 01 表示【局部变量表】 大槽（slot）数<br>00 00 00 05 表示字节码长度，本例是 5</p></li><li><p>2a b7 00 01 b1 是字节码指令</p></li><li><p>00 00 00 02 表示方法细节属性数量，本例是 2</p></li><li><p>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<br>00 00 00 06 表示此属性的总长度，本例是 6<br>00 01 表示【LineNumberTable】长度<br>00 00 表示【字节码】行号 00 04 表示【java 源码】行号</p></li><li><p>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<br>00 00 00 0c 表示此属性的总长度，本例是 12<br>00 01 表示【LocalVariableTable】长度<br>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<br>00 05 表示局部变量覆盖的范围长度<br>00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】<br>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是<br>【Lcn/itcast/jvm/t5/HelloWorld;】<br>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</p></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line"></span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br></pre></td></tr></table></figure><p>红色代表访问修饰符（本类中是 public static）蓝色代表引用了常量池 #14 项作为方法名称绿色代表引用了常量池 #15 项作为方法参数描述黄色代表方法属性数量，本方法是 2 红色代表方法属性（属性1）<br>00 09 表示引用了常量池 #09 项，发现是【Code】属性<br>00 00 00 37 表示此属性的长度是 55<br>00 02 表示【操作数栈】 大深度<br>00 01 表示【局部变量表】 大槽（slot）数 00 00 00 05 表示字节码长度，本例是 9<br>b2 00 02 12 03 b6 00 04 b1 是字节码指令<br>00 00 00 02 表示方法细节属性数量，本例是 2<br>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性<br>00 00 00 0a 表示此属性的总长度，本例是 10<br>00 02 表示【LineNumberTable】长度<br>00 00 表示【字节码】行号 00 06 表示【java 源码】行号<br>00 08 表示【字节码】行号 00 07 表示【java 源码】行号<br>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性<br>00 00 00 0c 表示此属性的总长度，本例是 12<br>00 01 表示【LocalVariableTable】长度<br>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<br>00 09 表示局部变量覆盖的范围长度<br>00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】<br>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】<br>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</p><p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00<br>0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00<br>0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a<br>0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b<br>0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</p><p>红色代表方法属性（属性2）<br>00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性<br>0000 00 05 表示此属性的总长度，本例是 5<br>01参数数量<br>00 10 表示引用了常量池 #16 项，是【args】<br>00 00 访问修饰符<br>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00<br>0001120 00 00 02 00 14<br>1.7 附加属性<br>00 01 表示附加属性数量<br>00 13 表示引用了常量池 #19 项，即【SourceFile】<br>00 00 00 02 表示此属性的长度<br>00 14 表示引用了常量池 #20 项，即【HelloWorld.java】<br>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00<br>0001120 00 00 02 00 14</p><p>参考文献<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2.字节码指令"></a>2.字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是<br>public cn.itcast.jvm.t5.HelloWorld(); 构造方法的字节码指令</p><p>1.2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数<br>2.b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</p><ol start="3"><li>00 01 引用常量池中 #1 项，即【Method java/lang/Object.”<init>“:()V】</li><li>b1 表示返回</li></ol><p>1.b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？<br>2.00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】<br>3.12 =&gt; ldc 加载参数，哪个参数呢？<br>4.03 引用常量池中 #3 项，即 【String hello world】<br>5.b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？<br>6.00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】<br>7.b1 表示返回</p><p>请参考<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件<br>[root@localhost ~]# javap -v HelloWorld.class<br>Classfile /root/HelloWorld.class<br>  Last modified Jul 7, 2019; size 597 bytes<br>  MD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbc   Compiled from “HelloWorld.java” public class cn.itcast.jvm.t5.HelloWorld   minor version: 0   major version: 52   flags: ACC_PUBLIC, ACC_SUPER Constant pool:<br>   #1 = Methodref          #6.#21         // java/lang/Object.”<init>“:()V<br>   #2 = Fieldref           #22.#23        // java/lang/System.out:Ljava/io/PrintStream;    #3 = String             #24            // hello world    #4 = Methodref          #25.#26        // java/io/PrintStream.println:<br>(Ljava/lang/String;)V<br>   #5 = Class              #27            // cn/itcast/jvm/t5/HelloWorld<br>   #6 = Class              #28            // java/lang/Object<br>   #7 = Utf8               <init><br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               LocalVariableTable<br>  #12 = Utf8               this<br>  #13 = Utf8               Lcn/itcast/jvm/t5/HelloWorld;</p><p>  #14 = Utf8               main   #15 = Utf8               ([Ljava/lang/String;)V<br>  #16 = Utf8               args<br>  #17 = Utf8               [Ljava/lang/String;<br>  #18 = Utf8               MethodParameters<br>  #19 = Utf8               SourceFile<br>  #20 = Utf8               HelloWorld.java<br>  #21 = NameAndType        #7:#8          // “<init>“:()V<br>  #22 = Class              #29            // java/lang/System<br>  #23 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;<br>  #24 = Utf8               hello world<br>  #25 = Class              #32            // java/io/PrintStream<br>  #26 = NameAndType        #33:#34        // println:(Ljava/lang/String;)V<br>  #27 = Utf8               cn/itcast/jvm/t5/HelloWorld<br>  #28 = Utf8               java/lang/Object<br>  #29 = Utf8               java/lang/System<br>  #30 = Utf8               out<br>  #31 = Utf8               Ljava/io/PrintStream;<br>  #32 = Utf8               java/io/PrintStream<br>  #33 = Utf8               println   #34 = Utf8               (Ljava/lang/String;)V<br>{   public cn.itcast.jvm.t5.HelloWorld();     descriptor: ()V<br>    flags: ACC_PUBLIC     Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0          1: invokespecial #1                  // Method java/lang/Object.”<br><init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 4: 0       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature             0       5     0  this   Lcn/itcast/jvm/t5/HelloWorld;<br>  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=2, locals=1, args_size=1<br>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;          3: ldc           #3                  // String hello world<br>         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V          8: return<br>      LineNumberTable:<br>        line 6: 0<br>        line 7: 8       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       9     0  args   [Ljava/lang/String;     MethodParameters:       Name                           Flags<br>      args<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090</p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><p> 1）原始 java 代码     </p><p>2）编译后的字节码文件<br>[root@localhost ~]# javap -v Demo3_1.class Classfile /root/Demo3_1.class<br>  Last modified Jul 7, 2019; size 665 bytes<br>  MD5 checksum a2c29a22421e218d4924d31e6990cfc5   Compiled from “Demo3_1.java” public class cn.itcast.jvm.t3.bytecode.Demo3_1   minor version: 0   major version: 52   flags: ACC_PUBLIC, ACC_SUPER Constant pool:<br>   #1 = Methodref          #7.#26         // java/lang/Object.”<init>“:()V    #2 = Class              #27            // java/lang/Short<br>   #3 = Integer            32768<br>   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;    #5 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V<br>   #6 = Class              #32            // cn/itcast/jvm/t3/bytecode/Demo3_1<br>   #7 = Class              #33            // java/lang/Object<br>   #8 = Utf8               <init><br>   #9 = Utf8               ()V<br>  #10 = Utf8               Code<br>  #11 = Utf8               LineNumberTable<br>  #12 = Utf8               LocalVariableTable<br>  #13 = Utf8               this   #14 = Utf8               Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>  #15 = Utf8               main   #16 = Utf8               ([Ljava/lang/String;)V<br>  #17 = Utf8               args   #18 = Utf8               [Ljava/lang/String;<br>  #19 = Utf8               a</p><p>  #20 = Utf8               I<br>  #21 = Utf8               b<br>  #22 = Utf8               c<br>  #23 = Utf8               MethodParameters<br>  #24 = Utf8               SourceFile<br>  #25 = Utf8               Demo3_1.java<br>  #26 = NameAndType        #8:#9          // “<init>“:()V<br>  #27 = Utf8               java/lang/Short<br>  #28 = Class              #34            // java/lang/System<br>  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;<br>  #30 = Class              #37            // java/io/PrintStream<br>  #31 = NameAndType        #38:#39        // println:(I)V   #32 = Utf8               cn/itcast/jvm/t3/bytecode/Demo3_1<br>  #33 = Utf8               java/lang/Object<br>  #34 = Utf8               java/lang/System<br>  #35 = Utf8               out<br>  #36 = Utf8               Ljava/io/PrintStream;<br>  #37 = Utf8               java/io/PrintStream<br>  #38 = Utf8               println<br>  #39 = Utf8               (I)V {   public cn.itcast.jvm.t3.bytecode.Demo3_1();     descriptor: ()V<br>    flags: ACC_PUBLIC     Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0          1: invokespecial #1                  // Method java/lang/Object.”<br><init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 6: 0       LocalVariableTable:<br>        Start  Length  Slot  Name   Signature             0       5     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_1;<br>  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=2, locals=4, args_size=1<br>         0: bipush        10<br>         2: istore_1<br>         3: ldc           #3                  // int 32768<br>         5: istore_2<br>         6: iload_1<br>         7: iload_2<br>         8: iadd<br>         9: istore_3<br>        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;         13: iload_3<br>        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br>        17: return<br>      LineNumberTable:<br>        line 8: 0<br>        line 9: 3</p><p>3）常量池载入运行时常量池     </p><p>4）方法字节码载入方法区     </p><p>5）main 线程开始运行，分配栈帧内存<br>（stack=2，locals=4）</p><p>6）执行引擎开始执行字节码     </p><p>bipush 10<br>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） ldc 将一个 int 压入操作数栈 ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）<br>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><p>istore_1      将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p>istore_2     </p><p>iload_1     </p><p>iload_2     </p><p>iadd     </p><p>istore_3     </p><p>getstatic #4     </p><p>iload_3     </p><p>invokevirtual #5<br>va/io/PrintStream.println:(I)V 方法<br>生成新的栈帧（分配 locals、stack等）<br>传递参数，执行新栈帧中的字节码</p><p>完成 main 方法调用，弹出 main 栈帧程序结束</p><h3 id="2-4-练习-分析-i"><a href="#2-4-练习-分析-i" class="headerlink" title="2.4 练习 - 分析 i++"></a>2.4 练习 - 分析 i++</h3><p>目的：从字节码角度分析 a++ 相关题目源码：</p><p>字节码：</p><p>分析：</p><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p>指令    助记符    含义<br>0x99    ifeq    判断是否 == 0<br>0x9a    ifne    判断是否 != 0<br>0x9b    iflt    判断是否 &lt; 0<br>0x9c    ifge    判断是否 &gt;= 0<br>0x9d    ifgt    判断是否 &gt; 0<br>0x9e    ifle    判断是否 &lt;= 0<br>0x9f    if_icmpeq    两个int是否 ==<br>0xa0    if_icmpne    两个int是否 !=<br>0xa1    if_icmplt    两个int是否 &lt;<br>0xa2    if_icmpge    两个int是否 &gt;=<br>0xa3    if_icmpgt    两个int是否 &gt;<br>0xa4    if_icmple    两个int是否 &lt;=<br>0xa5    if_acmpeq    两个引用是否 ==<br>0xa6    if_acmpne    两个引用是否 !=<br>0xc6    ifnull    判断是否 == null<br>0xc7    ifnonnull    判断是否 != null<br>几点说明：<br>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节 goto 用来进行跳转到指定行号的字节码源码：</p><p>字节码：</p><h3 id="2-6-循环控制指令-其实循环控制还是前面介绍的那些指令，例如-while-循环："><a href="#2-6-循环控制指令-其实循环控制还是前面介绍的那些指令，例如-while-循环：" class="headerlink" title="2.6 循环控制指令     其实循环控制还是前面介绍的那些指令，例如 while 循环："></a>2.6 循环控制指令     其实循环控制还是前面介绍的那些指令，例如 while 循环：</h3><p>字节码是：</p><p>再比如 do while 循环：</p><p>字节码是：<br>0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return<br>后再看看 for 循环：</p><p>字节码是：</p><h3 id="2-7-练习-判断结果"><a href="#2-7-练习-判断结果" class="headerlink" title="2.7 练习 - 判断结果"></a>2.7 练习 - 判断结果</h3><p>请从字节码角度分析，下列代码运行的结果：</p><h3 id="2-8-构造方法"><a href="#2-8-构造方法" class="headerlink" title="2.8 构造方法"></a>2.8 构造方法</h3><p>1）<cinit>()V     </p><p>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方</p><p>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在 后<br>public cn.itcast.jvm.t3.bytecode.Demo3_8_2(java.lang.String, int);<br>    descriptor: (Ljava/lang/String;I)V<br>    flags: ACC_PUBLIC     Code:<br>      stack=2, locals=3, args_size=3<br>         0: aload_0<br>         1: invokespecial #1    // super.<init>()V<br>         4: aload_0<br>         5: ldc           #2    // &lt;- “s1”<br>         7: putfield      #3    // -&gt; this.a<br>        10: aload_0<br>        11: bipush        20    // &lt;- 20<br>        13: putfield      #4    // -&gt; this.b<br>        16: aload_0<br>        17: bipush        10    // &lt;- 10<br>        19: putfield      #4    // -&gt; this.b<br>        22: aload_0<br>        23: ldc           #5    // &lt;- “s2”<br>        25: putfield      #3    // -&gt; this.a<br>        28: aload_0             // ——————————<br>        29: aload_1             // &lt;- slot 1(a) “s3”            |         30: putfield      #3    // -&gt; this.a                    |         33: aload_0                                             |         34: iload_2             // &lt;- slot 2(b) 30              |         35: putfield      #4    // -&gt; this.b ——————–<br>        38: return<br>      LineNumberTable: …<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0      39     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_8_2;<br>            0      39     1     a   Ljava/lang/String;<br>            0      39     2     b   I     MethodParameters: …</p><h3 id="2-9-方法调用"><a href="#2-9-方法调用" class="headerlink" title="2.9 方法调用"></a>2.9 方法调用</h3><p>看一下几种不同的方法调用对应的字节码指令</p><p>字节码：<br>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈<br>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “<init>“:()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量<br>终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定<br>普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态<br>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了还有一个执行 invokespecial 的情况是通过 super 调用父类方法</p><h3 id="2-10-多态的原理"><a href="#2-10-多态的原理" class="headerlink" title="2.10 多态的原理"></a>2.10 多态的原理</h3><p>1）运行代码<br>停在 System.in.read() 方法上，这时运行 jps 获取进程 id<br>2）运行 HSDB 工具<br>进入 JDK 安装目录，执行</p><p>进入图形界面 attach 进程 id<br>3）查找某个对象     </p><p>4）查看对象内存结构<br>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br>MarkWord，后 8 字节就是对象的 Class 指针但目前看不到它的实际地址</p><p>5）查看对象 Class 的内存地址<br>可以通过 Windows -&gt; Console 进入命令行模式，执行</p><p>mem 有两个参数，参数 1 是对象地址，参数 2 是查看 2 行（即 16 字节）结果中第二行 0x000000001b7d4028 即为 Class 的内存地址</p><p>6）查看类的 vtable<br> 方法1：Alt+R 进入 Inspector 工具，输入刚才的 Class 内存地址，看到如下界面</p><p>无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法（多态相关的，final，static 不会列入）<br>那么这 6 个方法都是谁呢？从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到：</p><p>通过 Windows -&gt; Console 进入命令行模式，执行</p><p>就得到了 6 个虚方法的入口地址<br>7）验证方法地址<br>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知<br>Dog - public void eat() @0x000000001b7d3fa8<br>Animal - public java.lang.String toString() @0x000000001b7d35e8;<br>Object - protected void finalize() @0x000000001b3d1b10;<br>Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;<br>Object - public native int hashCode() @0x000000001b3d1540; Object - protected native java.lang.Object clone() @0x000000001b3d1678;<br>对号入座，发现<br>    eat() 方法是 Dog 类自己的<br>toString() 方法是继承 String 类的<br>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的<br>8）小结<br>当执行 invokevirtual 指令时，<br>1.先通过栈帧中的对象引用找到对象<br>2.分析对象头，找到对象的实际 Class<br>3.Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了<br>4.查表得到方法的具体地址<br>5.执行方法的字节码</p><h3 id="2-11-异常处理-try-catch"><a href="#2-11-异常处理-try-catch" class="headerlink" title="2.11 异常处理     try-catch"></a>2.11 异常处理     try-catch</h3><pre><code>    11: istore_1    12: return  Exception table:     from    to  target type         2     5     8   Class java/lang/Exception  LineNumberTable: ...              LocalVariableTable:    Start  Length  Slot  Name   Signature        9       3     2     e   Ljava/lang/Exception;        0      13     0  args   [Ljava/lang/String;        2      11     1     i   I       StackMapTable: ...MethodParameters: ...</code></pre><p>}<br>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号<br>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置</p><p>多个 single-catch 块的情况     </p><p>multi-catch 的情况     </p><p>finally     </p><p>public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC     Code:<br>      stack=1, locals=4, args_size=1<br>         0: iconst_0<br>1istore_1            // 0 -&gt; i<br>2bipush        10    // try ————————————-         4 istore_1            // 10 -&gt; i                                  |          5 bipush        30    // finally                                  |          7 istore_1            // 30 -&gt; i                                  |<br>         8 goto          27    // return ———————————-11 astore_2            // catch Exceptin -&gt; e ———————-</p><pre><code>    12: bipush        20    //                                          |         14: istore_1            // 20 -&gt; i                                  |         15: bipush        30    // finally                                  |         17: istore_1            // 30 -&gt; i                                  |         18: goto          27    // return ----------------------------------        21: astore_3            // catch any -&gt; slot 3 ---------------------        22: bipush        30    // finally                                  |         24: istore_1            // 30 -&gt; i                                  |    25: aload_3             // &lt;- slot 3                                |    26: athrow              // throw ------------------------------------    27: return  Exception table:     from    to  target type         2     5    11   Class java/lang/Exception         2     5    21   any    // 剩余的异常类型，比如 Error</code></pre><p>1115    21   any    // 剩余的异常类型，比如 Error       LineNumberTable: …<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>123     2     e   Ljava/lang/Exception;<br>            0      28     0  args   [Ljava/lang/String;<br>            2      26     1     i   I       StackMapTable: …<br>    MethodParameters: …<br>可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</p><h3 id="2-12-练习-finally-面试题"><a href="#2-12-练习-finally-面试题" class="headerlink" title="2.12 练习 - finally 面试题"></a>2.12 练习 - finally 面试题</h3><p>finally 出现了 return<br>先问问自己，下面的题目输出什么？</p><pre><code>     2: istore_0            // 10 -&gt; slot 0 (从栈顶移除了)     3: bipush        20    // &lt;- 20 放入栈顶     5: ireturn             // 返回栈顶 int(20)     6: astore_1            // catch any -&gt; slot 1     7: bipush        20    // &lt;- 20 放入栈顶          9: ireturn             // 返回栈顶 int(20)       Exception table:     from    to  target type              0     3     6   any       LineNumberTable: ...  StackMapTable: ...</code></pre><p>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子<br>跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常 ，可以试一下下面的代码</p><p>finally 对返回值影响<br>同样问问自己，下面的题目输出什么？</p><h3 id="2-13-synchronized"><a href="#2-13-synchronized" class="headerlink" title="2.13 synchronized"></a>2.13 synchronized</h3><h2 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3. 编译期处理"></a>3. 编译期处理</h2><p>所谓的 语法糖，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）<br>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h3><p>编译成class后的代码：</p><h3 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h3><p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 代码片段1 都会在编译阶段被转换为 代码片段2</p><h3 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：<br>public class Candy3 {<br>    public static void main(String[] args) {<br>        List<Integer> list = new ArrayList&lt;&gt;();<br>        list.add(10); // 实际调用的是 List.add(Object e)<br>        Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);<br>    }<br>}<br>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><p>如果前面的 x 变量类型修改为 int 基本类型那么 终生成的字节码是：</p><p>还好这些麻烦事都不用自己做。</p><p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p><p>使用反射，仍然能够获得这些信息：</p><p>输出</p><h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><h3 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 foreach 循环</h3><p>会被编译器转换为：</p><p>而集合的循环：</p><p>实际被编译器转换为对迭代器的调用：</p><h3 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 switch 字符串</h3><p>可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。</p><p>会被编译器转换为：</p><h3 id="3-7-switch-枚举-switch-枚举的例子，原始代码："><a href="#3-7-switch-枚举-switch-枚举的例子，原始代码：" class="headerlink" title="3.7 switch 枚举     switch 枚举的例子，原始代码："></a>3.7 switch 枚举     switch 枚举的例子，原始代码：</h3><p>转换后代码：</p><h3 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h3><h3 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h3><p>息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：</p><p>输出：</p><p>如以上代码所示，两个异常信息都不会丢。</p><h3 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：父子类的返回值完全一致</p><p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证：</p><p>会输出：</p><h3 id="3-11-匿名内部类-源代码："><a href="#3-11-匿名内部类-源代码：" class="headerlink" title="3.11 匿名内部类     源代码："></a>3.11 匿名内部类     源代码：</h3><p>转换后代码：</p><p>引用局部变量的匿名内部类，源代码：</p><p>转换后代码：</p><h2 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4 . 类加载阶段"></a>4 . 类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><p>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有：<br>_java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴露给 java 使用 _super 即父类<br>_fields 即成员变量<br>_methods 即方法<br>_constants 即常量池<br>_class_loader 即类加载器<br>_vtable 虚方法表<br>_itable 接口方法表<br>如果这个类还有父类没有加载，先加载父类加载和链接可能是交替运行的<br>instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中可以通过前面介绍的 HSDB 工具查看</p><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>验证<br>验证类是否符合 JVM规范，安全性检查<br>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行<br>E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld<br>Error: A JNI error has occurred, please check your installation and try again<br>Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value<br>3405691578 in class file cn/itcast/jvm/t5/HelloWorld<br>        at java.lang.ClassLoader.defineClass1(Native Method)<br>        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)<br>        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)         at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)<br>        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)<br>        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)<br>        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)<br>        at java.security.AccessController.doPrivileged(Native Method)<br>        at java.net.URLClassLoader.findClass(URLClassLoader.java:361)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)<br>        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)         at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)<br>准备<br>为 static 变量分配空间，设置默认值<br>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成<br>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成</p><p>解析     将常量池中的符号引用解析为直接引用</p><h3 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h3><p><cinit>()V 方法<br>初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全<br>发生的时机<br>概括得说，类初始化是【懒惰的】<br>main 方法所在的类，总会被首先初始化首次访问这个类的静态变量或静态方法时子类初始化，如果父类还没初始化，会引发子类访问父类的静态变量，只会触发父类的初始化<br>Class.forName<br>new 会导致初始化不会导致类初始化的情况<br>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化<br>类对象.class 不会触发初始化<br>创建该类的数组不会触发初始化<br>类加载器的 loadClass 方法<br>Class.forName 的参数 2 为 false 时</p><p>实验</p><p>验证（实验时请先全部注释，每次只执行其中一个）</p><h3 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p><p>典型应用 - 完成懒惰初始化单例模式</p><p>以上的实现特点是：懒惰实例化<br>初始化时的线程安全是有保障的</p><h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h2><p>以 JDK 8 为例：<br>名称    加载哪的类    说明<br>Bootstrap ClassLoader    JAVA_HOME/jre/lib    无法直接访问<br>Extension ClassLoader    JAVA_HOME/jre/lib/ext    上级为 Bootstrap，显示为 null<br>Application ClassLoader    classpath    上级为 Extension<br>自定义类加载器    自定义    上级为 Application</p><h3 id="5-1-启动类加载器-用-Bootstrap-类加载器加载类："><a href="#5-1-启动类加载器-用-Bootstrap-类加载器加载类：" class="headerlink" title="5.1 启动类加载器     用 Bootstrap 类加载器加载类："></a>5.1 启动类加载器     用 Bootstrap 类加载器加载类：</h3><p>执行</p><p>输出</p><h3 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h3><p>执行</p><p>输出</p><p>写一个同名的类</p><p>打个 jar 包<br>E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class 已添加清单<br>正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%) 将 jar 包拷贝到 JAVA_HOME/jre/lib/ext 重新执行 Load5_2 输出</p><h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则<br> 注意</p><p>执行流程为：</p><ol><li>sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有<br>2.sun.misc.Launcher$AppClassLoader // 2 处，委派上级 sun.misc.Launcher$ExtClassLoader.loadClass()<br>3.sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有<br>4.sun.misc.Launcher$ExtClassLoader // 3 处，没有上级了，则委派 BootstrapClassLoader 查找<br>5.BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有</li><li>sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在<br>JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader</li><li>到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在 classpath 下查找，找到了</li></ol><h3 id="5-4-线程上下文类加载器"><a href="#5-4-线程上下文类加载器" class="headerlink" title="5.4 线程上下文类加载器"></a>5.4 线程上下文类加载器</h3><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p><p>让我们追踪一下源码：</p><p>先不看别的，看看 DriverManager 的类加载器：</p><p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但<br>JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？继续看 loadInitialDrivers() 方法：</p><p>先看 2）发现它 后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载<br>再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI）<br>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称</p><p>这样就可以使用</p><p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：<br>JDBC<br>Servlet 初始化器<br>Spring 容器<br>Dubbo（对 SPI 进行了扩展）接着看 ServiceLoader.load 方法：</p><p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类<br>LazyIterator 中：</p><h3 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h3><p>问问自己，什么时候需要自定义类加载器<br>1）想加载非 classpath 随意路径中的类文件<br>2）都是通过接口来使用实现，希望解耦时，常用在框架设计<br>3）这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</p><p>步骤：<br>1.继承 ClassLoader 父类<br>2.要遵从双亲委派机制，重写 findClass 方法<br> 注意不是重写 loadClass 方法，否则不会走双亲委派机制<br>3.读取类文件的字节码<br>4.调用父类的 defineClass 方法来加载类<br>5.使用者调用该类加载器的 loadClass 方法示例：<br>准备好两个类文件放入 E:\myclasspath，它实现了 java.util.Map 接口，可以先反编译看一下：</p><h2 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6. 运行期优化"></a>6. 运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><p>分层编译<br>（TieredCompilation）<br>先来个例子</p><p>2357173<br>2450346<br>2552906<br>2650346<br>2747786<br>2849920<br>2964000<br>3049067<br>3163574<br>3263147<br>3356746<br>3449494<br>3564853<br>36107520<br>3746933<br>3851627<br>3945653<br>40103680<br>4151626<br>4260160<br>4349067<br>4445653<br>4549493<br>4651626<br>4749066<br>4847360<br>4950774<br>5070827<br>5164000<br>5272107<br>5349066<br>5446080<br>5544800<br>5646507<br>5773813<br>5861013<br>5957600<br>6083200<br>617024204<br>6249493<br>6320907<br>6420907<br>6520053<br>6620906<br>6720907<br>6821333<br>6922187<br>7020480<br>7121760<br>7219200<br>7315360<br>7418347<br>7519627<br>7617067<br>7734134<br>7819200<br>7918347<br>8017493</p><p>8115360<br>8218774<br>8317067<br>8421760<br>8523467<br>8617920<br>8717920<br>8818774<br>8918773<br>9019200<br>9120053<br>9218347<br>9322187<br>9417920<br>9518774<br>9619626<br>9733280<br>9820480<br>9920480<br>10018773<br>10147786<br>10217493<br>10322614<br>10464427<br>10518347<br>10619200<br>10726027<br>10821333<br>10920480<br>11024747<br>11132426<br>11221333<br>11317920<br>11417920<br>11519200<br>11618346<br>11715360<br>11824320<br>11919200<br>12020053<br>12117920<br>12218773<br>12320053<br>12418347<br>12518347<br>12622613<br>12718773<br>12819627<br>12920053<br>13020480<br>13119627<br>13220053<br>13315360<br>134136533<br>13543093<br>136853<br>137853<br>138853</p><p>139853<br>140854<br>141853<br>142853<br>143853<br>144853<br>145853<br>146853<br>147854<br>148853<br>149853<br>150854<br>151853<br>152853<br>153853<br>1541280<br>155853<br>156853<br>157854<br>158853<br>159853<br>160854<br>161854<br>162853<br>163854<br>164854<br>165854<br>166854<br>167853<br>168853<br>169854<br>170853<br>171853<br>172853<br>1731280 174 853<br>1751280<br>176853<br>177854<br>178854<br>179427<br>180853<br>181854<br>182854<br>183854<br>184853<br>185853<br>186854<br>187853<br>188853<br>189854<br>1901280<br>191853<br>192853<br>193853<br>194853<br>195854<br>196853</p><p>原因是什么呢？<br>JVM 将执行状态分成了 5 个层次：<br>0层，解释执行（Interpreter）<br>1层，使用 C1 即时编译器编译执行（不带 profiling）<br>2层，使用 C1 即时编译器编译执行（带基本的 profiling）<br>3层，使用 C1 即时编译器编译执行（带完全的 profiling）<br>4层，使用 C2 即时编译器编译执行<br>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等<br>即时编译器（JIT）与解释器的区别<br>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释<br>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译<br>解释器是将字节码解释为针对所有平台都通用的机器码<br>JIT 会根据平台类型，生成平台特定的机器码<br>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），优化之</p><p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:-<br>DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p><p>参考资料：<a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</a> 方法内联<br>（Inlining）</p><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p><p>还能够进行常量折叠（constant folding）的优化</p><p>实验：</p><p>字段优化<br>JMH 基准测试请参考：<a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a> 创建 maven 工程，添加依赖如下</p><p>编写基准测试代码：</p><p>import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder;<br>import java.util.Random; import java.util.concurrent.ThreadLocalRandom;<br>@Warmup(iterations = 2, time = 1)<br>@Measurement(iterations = 5, time = 1)<br>@State(Scope.Benchmark) public class Benchmark1 {<br>    int[] elements = randomInts(1_000);<br>    private static int[] randomInts(int size) {<br>        Random random = ThreadLocalRandom.current();<br>        int[] values = new int[size];<br>        for (int i = 0; i &lt; size; i++) {<br>            values[i] = random.nextInt();<br>        }<br>        return values;<br>    }<br>    @Benchmark<br>    public void test1() {<br>        for (int i = 0; i &lt; elements.length; i++) {<br>            doSum(elements[i]);<br>        }<br>    }<br>    @Benchmark<br>    public void test2() {<br>        int[] local = this.elements;<br>        for (int i = 0; i &lt; local.length; i++) {<br>            doSum(local[i]);<br>        }<br>    }<br>    @Benchmark<br>    public void test3() {<br>        for (int element : elements) {<br>            doSum(element);<br>        }<br>    }<br>    static int sum = 0;<br>    @CompilerControl(CompilerControl.Mode.INLINE)<br>    static void doSum(int x) {<br>        sum += x;<br>    }<br>    public static void main(String[] args) throws RunnerException {<br>        Options opt = new OptionsBuilder()<br>                .include(Benchmark1.class.getSimpleName())<br>                .forks(1)                 .build();<br>        new Runner(opt).run();<br>北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090</p><p>首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：<br>Benchmark              Mode  Samples        Score  Score error  Units t.Benchmark1.test1    thrpt        5  2420286.539   390747.467  ops/s<br>t.Benchmark1.test2    thrpt        5  2544313.594    91304.136  ops/s<br>t.Benchmark1.test3    thrpt        5  2469176.697   450570.647  ops/s<br>接下来禁用 doSum 方法内联</p><p>测试结果如下：<br>Benchmark              Mode  Samples       Score  Score error  Units t.Benchmark1.test1    thrpt        5  296141.478    63649.220  ops/s<br>t.Benchmark1.test2    thrpt        5  371262.351    83890.984  ops/s<br>t.Benchmark1.test3    thrpt        5  368960.847    60163.391  ops/s<br>分析：<br>在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化：如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：</p><p>可以节省 1999 次 Field 读取操作<br>但如果 doSum 方法没有内联，则不会进行上面的优化</p><p>练习：在内联情况下将 elements 添加 volatile 修饰符，观察测试结果</p><h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉 初的实现，可以通过 debug 得到类名为 sun.reflect.GeneratedMethodAccessor1 可以使用阿里的 arthas 工具：</p><p>选择 1 回车表示分析该进程</p><p>1 [INFO] arthas home: /root/.arthas/lib/3.1.1/arthas<br>[INFO] Try to attach process 13065 [INFO] Attach process 13065 success.<br>[INFO] arthas-client connect 127.0.0.1 3658<br>  ,—.  ,——. ,——–.,–.  ,–.  ,—.   ,—.                            /  O  \ |  .–. ‘’–.  .–’|  ‘–’  | /  O  \ ‘   .-‘<br>|  .-.  ||  ‘–’.’   |  |   |  .–.  ||  .-.  |<code>.  </code>-.                          |  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-‘    |                         <code>--&#39; </code>–’<code>--&#39; &#39;--&#39;   </code>–’   <code>--&#39;  </code>–’<code>--&#39; </code>–’`—–’<br>wiki      <a href="https://alibaba.github.io/arthas">https://alibaba.github.io/arthas</a>                                      tutorials <a href="https://alibaba.github.io/arthas/arthas-tutorials">https://alibaba.github.io/arthas/arthas-tutorials</a>                     version   3.1.1                                                                 pid       13065                                                                 time      2019-06-10 12:23:54<br>再输入【jad + 类名】来进行反编译<br>$ jad sun.reflect.GeneratedMethodAccessor1<br>ClassLoader:<br>+-sun.reflect.DelegatingClassLoader@15db9742                                     </p><p>  +-sun.misc.Launcher$AppClassLoader@4e0e2f2a<br>    +-sun.misc.Launcher$ExtClassLoader@2fdb006e<br>Location:                                                                       </p><p>/*<br>*Decompiled with CFR 0_132.</p><ul><li>*Could not load the following classes:<br>*cn.itcast.jvm.t3.reflect.Reflect1<br> <em>/<br>package sun.reflect;<br>import cn.itcast.jvm.t3.reflect.Reflect1; import java.lang.reflect.InvocationTargetException; import sun.reflect.MethodAccessorImpl;<br>public class GeneratedMethodAccessor1 extends MethodAccessorImpl {<br> /</em><br>*Loose catch block<br>*Enabled aggressive block sorting<br>*Enabled unnecessary exception pruning<br>*Enabled aggressive exception aggregation<br>*Lifted jumps to return sites<br>  */</li></ul><h1 id="四-内存模型"><a href="#四-内存模型" class="headerlink" title="四.内存模型"></a>四.内存模型</h1><h2 id="1-java-内存模型"><a href="#1-java-内存模型" class="headerlink" title="1. java 内存模型"></a>1. java 内存模型</h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p><p><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b">关于它的权威解释，请参考</a></p><p>简单的说，JMM 定义了一套在<strong>多线程读写</strong>共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性     "></a>1.1 原子性    <a href="af://n13/"> </a></h3><p>原子性在学习线程时讲过，下面来个例子简单回顾一下：</p><p>问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><h3 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps95.png" alt="img"></p><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps96.png" alt="img"> </p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps97.png" alt="img"></p><p>但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps98.png" alt="img"></p><p>出现正数的情况：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps99.png" alt="img"></p><h3 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法     "></a>1.3 解决方法    <a href="af://n29/"> </a></h3><p>synchronized（同步关键字)</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps101.png" alt="img"></p><p>如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。</p><ol><li><p>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。</p></li><li><p>这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。</p></li><li><p>当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count– 代码。</p></li></ol><p>注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps104.png" alt="img"></p><p>为什么呢？ </p><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps105.png" alt="img"> </p><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps106.png" alt="img"> </p><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps107.png" alt="img"> </p><h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h3><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以*<!--避免线程从自己的工作缓存中查找变量的值-->*，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620131455851.png" alt="image-20210620131455851" style="zoom:80%;" /><h3 id="2-3-可见性"><a href="#2-3-可见性" class="headerlink" title="2.3 可见性     "></a>2.3 可见性    <strong><a href="af://n71/"> </a></strong></h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， <u><em>不能保证原子性</em></u>，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true </span><br><span class="line">getstatic   run  &#x2F;&#x2F; 线程 t 获取 run true</span><br><span class="line"></span><br><span class="line">putstatic   run  &#x2F;&#x2F;  线程 main 修改 run 为 false， 仅此一次 getstatic   run  &#x2F;&#x2F; 线程 t 获取 run false</span><br></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到 新值，不能解决指令交错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设i的初始值为0 getstatic   i  </span><br><span class="line">&#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;0 getstatic   i  </span><br><span class="line">&#x2F;&#x2F; 线程2-获取静态变量i的值 线程内i&#x3D;0 iconst_1     </span><br><span class="line">&#x2F;&#x2F; 线程1-准备常量1 iadd       </span><br><span class="line">&#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 putstatic   i </span><br><span class="line">&#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1 iconst_1     </span><br><span class="line">&#x2F;&#x2F; 线程2-准备常量1 isub       </span><br><span class="line">&#x2F;&#x2F; 线程2-自减 线程内i&#x3D;-1</span><br><span class="line"></span><br><span class="line">putstatic   i  &#x2F;&#x2F; 线程2-将修改后的值存入静态变量i 静态变量i&#x3D;-1</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><p>​    <u>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性</u>。但缺点是synchronized是属于重量级操作，性能相对更低</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性     "></a>3. 有序性    <a href="af://n81/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps110.png" alt="img"></p><h3 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3.1 诡异的结果     "></a>3.1 诡异的结果    <a href="af://n82/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps111.png" alt="img"></p><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？有同学这么分析</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>但我告诉你，结果还有可能是 0 ，信不信吧！</p><p>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2</p><p>相信很多人已经晕了 </p><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p><p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.open</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">dk</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">.j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">ava.net/displa</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">y</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">/CodeTools/</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">j</a><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">cstress</a></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps112.png" alt="img">mvn archetype:generate  -DinteractiveMode=false DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-testarchetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0</p><p>创建 maven 项目，提供如下测试类</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps113.png" alt="img"></p><p>执行</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps114.png" alt="img"></p><p>会输出我们感兴趣的结果，摘录其中一次结果：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps115.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0   1,729  ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">1   42,617,915        ACCEPTABLE  ok</span><br><span class="line">4   5,146,627        ACCEPTABLE  ok</span><br><span class="line">[OK] test.ConcurrencyTest</span><br><span class="line"></span><br><span class="line">(JVM args: [])</span><br><span class="line"> Observed state  Occurrences        Expectation  Interpretation         0     1,652  ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line"></span><br><span class="line">​        1   46,460,657        ACCEPTABLE  ok</span><br><span class="line"></span><br><span class="line">​        4   4,571,072        ACCEPTABLE  ok</span><br></pre></td></tr></table></figure><p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法     "></a>3.2 解决方法    <a href="af://n104/"> </a></h3><p>volatile 修饰的变量，可以禁用指令重排</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps117.png" alt="img"></p><p>结果为：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps118.png" alt="img"></p><h3 id="3-3-有序性理解"><a href="#3-3-有序性理解" class="headerlink" title="3.3 有序性理解     "></a>3.3 有序性理解    <a href="af://n111/"> </a></h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps119.png" alt="img"></p><p>可以看到，至于是先执行 i 还是 先执行 j ，对 终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps120.png" alt="img"></p><p>也可以是</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps121.png" alt="img"></p><p>这种特性称之为<strong>『指令重排』</strong>，</p><p> 单线程不会产生问题；多线程下『指令重排』会影响正确性。</p><p>例如著名的 double-checked locking 模式实现单例</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps122.png" alt="img"></p><p>以上的实现特点是：</p><ul><li><p>懒惰实例化</p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p><p>但在多线程环境下，上面的代码是有问题的，INSTANCE = new Singleton() 对应的字节码为：</p></li></ul><p>0: new      #2          // class cn/itcast/jvm/t4/Singleton</p><p>3: dup</p><p>4: invokespecial #3          // Method “<init>“:()V</p><p>7: putstatic   #4          // Field </p><p>INSTANCE:Lcn/itcast/jvm/t4/Singleton;</p><p>其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1，t2 按如下时间序列执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间1  t1 线程执行到 INSTANCE &#x3D; new Singleton(); 时间2  t1 线程分配空间，为Singleton对象生成了引用地址（0 处）时间3  t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE !&#x3D; null（7 处）时间4  t2 线程进入getInstance() 方法，发现 INSTANCE !&#x3D; null（synchronized块外），直接返回 INSTANCE时间5  t1 线程执行Singleton的构造方法（4 处）</span><br></pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 <strong>JDK 5 以上</strong>的版本的 volatile 才会真正有效</p><h3 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3.4 happens-before     "></a>3.4 happens-before    <a href="af://n133/"> </a></h3><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，</p><p>抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps126.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps127.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps128.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps129.png" alt="img"> 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps130.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps131.png" alt="img"> 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps132.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps133.png" alt="img"></p><ul><li><p>对变量默认值（0，false，null)的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z 变量都是指成员变量或静态成员变量参考： 第17页</p></li></ul><h2 id="4-CAS-与-原子类"><a href="#4-CAS-与-原子类" class="headerlink" title="4. CAS 与 原子类     "></a>4. CAS 与 原子类    <a href="af://n168/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps135.png" alt="img"></p><h3 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4.1 CAS     "></a>4.1 CAS    <a href="af://n169/"> </a></h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps136.png" alt="img"></p><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps137.png" alt="img">因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps138.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(() -&gt; &#123;      for (int i &#x3D; 0; i &lt; count; i++) &#123;     dc.increase();      &#125;    &#125;);          t1.start();    t1.join();    System.out.println(dc.getData());  &#125; &#125;class DataContainer &#123;  private volatile int data;  static final Unsafe unsafe; static final long DATA_OFFSET;  static &#123;   try &#123;      &#x2F;&#x2F; Unsafe 对象不能直接调用，只能通过反射获得      Field theUnsafe &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);      theUnsafe.setAccessible(true);      unsafe &#x3D; (Unsafe) theUnsafe.get(null);    &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;      throw new Error(e);    &#125;    try &#123;      &#x2F;&#x2F; data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性      DATA_OFFSET &#x3D; unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(&quot;data&quot;));    &#125; catch (NoSuchFieldException e) &#123;      throw new Error(e);    &#125;  &#125;  </span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210620141319373.png" alt="image-20210620141319373"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps139.png" alt="img"></p><h3 id="4-2-乐观锁与悲观锁"><a href="#4-2-乐观锁与悲观锁" class="headerlink" title="4.2 乐观锁与悲观锁     "></a>4.2 乐观锁与悲观锁    <a href="af://n180/"> </a></h3><p>CAS 是基于乐观锁的思想： 乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p><p>synchronized 是基于悲观锁的思想： 悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p><h3 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4.3 原子操作类     "></a>4.3 原子操作类    <a href="af://n201/"> </a></h3><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，</p><p>例如：AtomicInteger、AtomicBoolean等，</p><p>它们底层就是采用 CAS 技术 + volatile 来实现的。</p><p>可以使用 AtomicInteger 改写之前的例子：</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps141.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps142.png" alt="img"></p><h2 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5. synchronized 优化     "></a>5. synchronized 优化    <a href="af://n220/"> </a></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps143.png" alt="img"></p><ul><li>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word)。Mark Word 平时存储这个对象的 哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为 标记位、线程锁记录指针、重量级锁指针、线程ID 等内容</li></ul><h3 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁     "></a>5.1 轻量级锁    <a href="af://n233/"> </a></h3><p>*<!--如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化-->*。</p><p>这就好比：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即升级为重量级锁(锁膨胀)，进入重量级锁的流程。而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁</span><br></pre></td></tr></table></figure><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps146.png" alt="img"></p><p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p><table><thead><tr><th>线程 1</th><th>对象 Mark Word</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块 A，把 Mark 复制到线程 1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 A</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>访问同步块 B，把 Mark 复制到线程 1 的锁记录</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>失败（发现是自己的锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>锁重入</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 B</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 B 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 A 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>-</td></tr><tr><td>-</td><td>01（无锁）</td><td>访问同步块 A，把 Mark 复制到线程 2 的锁记录</td></tr><tr><td>-</td><td>01（无锁）</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>-</td><td>00（轻量锁）线程 2 锁记录地址</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5.2 锁膨胀     "></a>5.2 锁膨胀    <a href="af://n310/"> </a></h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps147.png" alt="img"></p><table><thead><tr><th>线程 1</th><th>对象 Mark</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块，把 Mark 复制到线程1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>访问同步块，把 Mark 复制到线程 2</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>失败（发现别人已经占了锁）</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>失败（解锁）</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争</td><td>01（无锁）</td><td>阻塞中</td></tr><tr><td>-</td><td>10（重量锁）</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10（重量锁）</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5.3 重量锁     "></a>5.3 重量锁    <a href="af://n378/"> </a></h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><ul><li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p></li><li><p><strong>自旋会占用 CPU 时间</strong>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p><p>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）</p></li><li><p>Java 7 之后不能控制是否开启自旋功能 </p></li></ul><p>自旋重试成功的情况</p><table><thead><tr><th>线程 1 （cpu 1 上）</th><th>对象 Mark</th><th>线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况</p><table><thead><tr><th>线程 1（cpu 1 上）</th><th>对象 Mark</th><th>线程 2（cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="5-4-偏向锁"><a href="#5-4-偏向锁" class="headerlink" title="5.4 偏向锁"></a>5.4 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</p><ul><li><p>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW)</p></li><li><p>访问对象的 hashCode 也会撤销偏向锁</p></li><li><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p></li><li><p>撤销偏向和重偏向都是批量进行的，以类为单位</p></li><li><p>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</p></li><li><p>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</p></li></ul><p><a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">可以参考这篇论文：</a></p><p>假设有两个方法同步块，利用同一个对象加锁</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps150.png" alt="img"></p><table><thead><tr><th>线程 1</th><th>对象 Mark</th></tr></thead><tbody><tr><td>访问同步块 A，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）</td></tr><tr><td>尝试加偏向锁</td><td>101（无锁可偏向）对象 hashCode</td></tr><tr><td>成功</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 A</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>访问同步块 B，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>是自己的线程 ID，锁是自己的，无需做更多操作</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 B</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行完毕</td><td>101（无锁可偏向）对象 hashCode</td></tr></tbody></table><h3 id="5-5-其它优化"><a href="#5-5-其它优化" class="headerlink" title="5.5 其它优化"></a>5.5 其它优化</h3><ol><li>减少上锁时间    </li></ol><p>同步代码块中尽量短</p><ol start="2"><li><p>减少锁的粒度    </p><p>将一个锁拆分为多个锁提高并发度，例如：</p></li></ol><ul><li><p>ConcurrentHashMap</p></li><li><p>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改， 后将数组中每个 cell 累加，再加上 base 就是 终的值</p></li><li><p>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</p></li></ul><ol start="3"><li>锁粗化    <a href="af://n542/"> </a></li></ol><p>多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml57648\wps153.png" alt="img"></p><ol start="4"><li>锁消除    </li></ol><p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p><ol start="5"><li>读写分离    </li></ol><p>CopyOnWriteArrayList ConyOnWriteSet</p><p>参考：</p><p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.open</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">j</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">dk</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">.j</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">ava.net/displa</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">y</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">/HotSpot/S</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">y</a><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">nchronization </a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luo</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">j</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">inpin</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">g</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">.com/2015/07/09/</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">j</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">ava</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">锁优化</a><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">/ </a><a href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">j</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">ava-se-16-s</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">y</a><a href="https://www.infoq.cn/article/java-se-16-synchronized">nchronized </a><a href="https://www.jianshu.com/p/9932047a89be">https://www</a><a href="https://www.jianshu.com/p/9932047a89be">.j</a><a href="https://www.jianshu.com/p/9932047a89be">ianshu.com/p/9932047a89be </a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblo</a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">g</a><a href="https://www.cnblogs.com/sheeva/p/6366782.html">s.com/sheeva/p/6366782.html</a></p><p><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-</a><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">j</a><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">ava-ever-rebias-an-individual-lock</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 定义：java Virtural Machine  （java二进制代码&lt;strong&gt;运行环境&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一次编写，到处运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动内存管理，垃圾回收机制&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/20/keymap-win-mac/"/>
    <id>http://example.com/2021/06/20/keymap-win-mac/</id>
    <published>2021-06-20T12:11:53.555Z</published>
    <updated>2017-08-05T12:49:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-Windows-过度到-Mac-必备快捷键对照表"><a href="#从-Windows-过度到-Mac-必备快捷键对照表" class="headerlink" title="从 Windows 过度到 Mac 必备快捷键对照表"></a>从 Windows 过度到 Mac 必备快捷键对照表</h1><h2 id="Mac-键盘符号说明"><a href="#Mac-键盘符号说明" class="headerlink" title="Mac 键盘符号说明"></a>Mac 键盘符号说明</h2><ul><li><code>⌘</code> == <code>Command</code></li><li><code>⇧</code> == <code>Shift</code></li><li><code>⇪</code> == <code>Caps Lock</code></li><li><code>⌥</code> == <code>Option</code></li><li><code>⌃</code> == <code>Control</code></li><li><code>↩</code> == <code>Return/Enter</code></li><li><code>⌫</code> == <code>Delete</code></li><li><code>⌦</code> == <code>向前删除键（Fn+Delete）</code></li><li><code>↑</code> == <code>上箭头</code></li><li><code>↓</code> == <code>下箭头</code></li><li><code>←</code> == <code>左箭头</code></li><li><code>→</code> == <code>右箭头</code></li><li><code>⇞</code> == <code>Page Up（Fn+↑）</code></li><li><code>⇟</code> == <code>Page Down（Fn+↓）</code></li><li><code>Home</code> == <code>Fn + ←</code></li><li><code>End</code> == <code>Fn + →</code></li><li><code>⇥</code> == <code>右制表符（Tab键）</code></li><li><code>⇤</code> == <code>左制表符（Shift+Tab）</code></li><li><code>⎋</code> == <code>Escape (Esc)</code></li><li><code>⏏</code> == <code>电源开关键</code></li></ul><h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>F</kbd></td><td align="left">在当前文件进行文本查找</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>R</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>R</kbd></td><td align="left">在当前文件进行文本替换</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Z</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Z</kbd></td><td align="left">撤销</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Y</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Delete</kbd></td><td align="left">删除光标所在行 或 删除选中的行</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>D</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>D</kbd></td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>W</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>方向键上</kbd></td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>E</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>E</kbd></td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>N</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>O</kbd></td><td align="left">根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>J</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>J</kbd></td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>P</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>P</kbd></td><td align="left">方法参数提示显示</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>U</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>U</kbd></td><td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>B</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>B</kbd></td><td align="left">进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>/</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>/</kbd></td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F1</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>F1</kbd></td><td align="left">在光标所在的错误代码处显示错误信息</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F11</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>F3</kbd></td><td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F12</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>F12</kbd></td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Space</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>Space</kbd></td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Delete</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Fn</kbd>+ Delete</td><td align="left">删除光标后面的单词或是中文句</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>BackSpace</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Delete</kbd></td><td align="left">删除光标前面的单词或是中文句</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>1,2,3...9</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>1,2,3...9</kbd></td><td align="left">定位到对应数值的书签位置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>加号</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>加号</kbd></td><td align="left">展开代码</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>减号</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>减号</kbd></td><td align="left">折叠代码</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>左键单击</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>左键单击</kbd></td><td align="left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>左方向键</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>左方向键</kbd></td><td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>右方向键</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>右方向键</kbd></td><td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>前方向键</kbd></td><td align="left">预设中没有该快捷键</td><td align="left">等效于鼠标滚轮向前效果</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>后方向键</kbd></td><td align="left">预设中没有该快捷键</td><td align="left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Alt</kbd> + <kbd>`</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>V</kbd></td><td align="left">显示版本控制常用操作菜单弹出层</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>F1</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>F1</kbd></td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>F7</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>F7</kbd></td><td align="left">查询所选对象/变量被引用</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Enter</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Enter</kbd></td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Insert</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>N</kbd></td><td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>左方向键</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>左方向键</kbd></td><td align="left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>右方向键</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>右方向键</kbd></td><td align="left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>前方向键</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>前方向键</kbd></td><td align="left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>后方向键</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>后方向键</kbd></td><td align="left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>1,2,3...9</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>1,2,3...9</kbd></td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Shift</kbd> + <kbd>F11</kbd></td><td align="left"><kbd>Command + F3</kbd></td><td align="left">弹出书签显示层</td></tr><tr><td align="left"><kbd>Shift</kbd> + <kbd>Tab</kbd></td><td align="left"><kbd>Shift + Tab</kbd></td><td align="left">取消缩进</td></tr><tr><td align="left"><kbd>Shift</kbd> + <kbd>Enter</kbd></td><td align="left"><kbd>Shift + Enter</kbd></td><td align="left">开始新一行。光标所在行下空出一行，光标定位到新行位置</td></tr><tr><td align="left"><kbd>Shift</kbd> + <kbd>左键单击</kbd></td><td align="left"><kbd>Shift + 左键单击</kbd></td><td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr></tbody></table><h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>L</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>L</kbd></td><td align="left">格式化代码，可以对当前文件和整个包目录使用</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>O</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>Option</kbd> + <kbd>O</kbd></td><td align="left">优化导入的类，可以对当前文件和整个包目录使用</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>T</kbd></td><td align="left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>逗号</kbd></td><td align="left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Enter</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>Enter</kbd></td><td align="left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>左方向键</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>左方向键</kbd></td><td align="left">退回到上一个操作的地方</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>右方向键</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>右方向键</kbd></td><td align="left">前进到上一个操作的地方</td></tr></tbody></table><h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td><td align="left">根据输入内容查找整个项目 或 指定目录内文件</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td><td align="left">自动将下一行合并到当前行末尾</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td><td align="left">取消撤销</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>W</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>方向键下</kbd></td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd></td><td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td><td align="left">对选中的代码进行大 / 小写轮流转换</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td><td align="left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td><td align="left">跳转到类型声明处</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>/</kbd></td><td align="left">代码块注释</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td><td align="left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td><td align="left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>加号</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>加号</kbd></td><td align="left">展开所有代码</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>减号</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>减号</kbd></td><td align="left">折叠所有代码</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F7</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F7</kbd></td><td align="left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td><td align="left">编辑器最大化</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td><td align="left">自动结束代码，行末自动添加分号</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Backspace</kbd></td><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Backspace</kbd></td><td align="left">退回到上次修改的地方</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>1,2,3...9</kbd></td><td align="left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>1,2,3...9</kbd></td><td align="left">快速添加指定数值的书签</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>左键单击</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>左键单击</kbd></td><td align="left">把光标放在某个类变量上，按此快捷键可以直接定位到该类中</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>左方向键</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>左方向键</kbd></td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>右方向键</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>右方向键</kbd></td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td><td align="left">选择 / 添加 task</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>左键双击</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>左键双击</kbd></td><td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td align="left">移动光标所在行向上移动</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td align="left">移动光标所在行向下移动</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>V</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Option</kbd> + <kbd>V</kbd></td><td align="left">无格式黏贴</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td><td align="left"><kbd>Command</kbd> + <kbd>;</kbd></td><td align="left">打开当前项目设置</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th align="left">Win 快捷键</th><th align="left">Mac 快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>F2</kbd></td><td align="left"><kbd>F2</kbd></td><td align="left">跳转到下一个高亮错误 或 警告位置</td></tr><tr><td align="left"><kbd>F4</kbd></td><td align="left"><kbd>F4</kbd></td><td align="left">编辑源</td></tr><tr><td align="left"><kbd>F11</kbd></td><td align="left"><kbd>F3</kbd></td><td align="left">添加书签</td></tr><tr><td align="left"><kbd>F12</kbd></td><td align="left"><kbd>F12</kbd></td><td align="left">回到前一个工具窗口</td></tr><tr><td align="left"><kbd>Tab</kbd></td><td align="left"><kbd>Tab</kbd></td><td align="left">缩进</td></tr><tr><td align="left"><kbd>ESC</kbd></td><td align="left"><kbd>ESC</kbd></td><td align="left">从工具窗口进入代码文件窗口</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从-Windows-过度到-Mac-必备快捷键对照表&quot;&gt;&lt;a href=&quot;#从-Windows-过度到-Mac-必备快捷键对照表&quot; class=&quot;headerlink&quot; title=&quot;从 Windows 过度到 Mac 必备快捷键对照表&quot;&gt;&lt;/a&gt;从 Window</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Markdown格式解析</title>
    <link href="http://example.com/2021/06/20/Markdown%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/20/Markdown%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-20T12:05:48.000Z</published>
    <updated>2021-06-20T12:08:37.603Z</updated>
    
    <content type="html"><![CDATA[<p>————-正文开始———————–</p><p>==（1）标题==</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>==（2）字体==</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><em><strong>斜体加粗</strong></em></p><p><del>删除线</del></p><p>==高亮==</p><p>我是^上标^</p><p>我是<del>下标</del></p><p>==（3）列表==</p><ul><li><p>一二三四五</p><ul><li><p>上山打老虎</p><ul><li><p>老虎没打到</p><ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><ol><li><p>一二三四五</p></li><li><p>上山打老虎</p></li><li><p>老虎没打到</p></li><li><p>打到小松鼠</p></li></ol><p>==（4）表格==</p><table><thead><tr><th>Mon</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>——</th><th>——</th><th>——</th><th>——</th><th>——</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>上山</th><th>上山</th><th>上山</th><th>上山</th><th>上山</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>打老虎</th><th>打老虎</th><th>打老虎</th><th>打老虎</th><th>打老虎</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>==（5）引用 ==</p><blockquote><p>一二三四五</p></blockquote><blockquote><blockquote><p>上山打老虎</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>老虎没打到</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>打到小松鼠</p></blockquote></blockquote></blockquote></blockquote><p>==（6）分割线==</p><hr><p>==（7）代码==</p><p><code>我是代码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是代码框</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;————-正文开始———————–&lt;/p&gt;
&lt;p&gt;==（1）标题==&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven尚硅谷复习总结</title>
    <link href="http://example.com/2021/06/20/Maven%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/06/20/Maven%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-20T12:04:56.000Z</published>
    <updated>2021-06-20T12:09:01.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven尚硅谷复习总结"><a href="#Maven尚硅谷复习总结" class="headerlink" title="Maven尚硅谷复习总结"></a>Maven尚硅谷复习总结</h1><p>导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创建一个工程，而多个模块整合在一起就需要使用到像 Maven 这样的构建工具。 </p><p>1 Why? </p><p>1.1 真的需要吗？ </p><p>Maven 是干什么用的？这是很多同学在刚开始接触 Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用 Maven 我们仍然可以进行 B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用 Maven 我们一样可以开发项目啊？ </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps1.jpg" alt="img"> </p><p>这里给大家纠正一个误区，Maven 并不是直接用来辅助编码的，它战斗的岗位并不是以上各层。所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。 </p><p>1.2 究竟为什么？ </p><p>为什么要使用 Maven？它能帮助我们解决什么问题？ </p><p>①添加第三方 jar 包 </p><p>在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。 </p><p>而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。 </p><p>  ②jar 包之间的依赖关系 </p><p>jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。 </p><p>那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar 包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。 </p><p>而引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.3.jar 后，commons-io-2.0.1.jar 会被自动导入，程序员不必了解这个依赖关系。 </p><p>下图是 Spring 所需 jar 包的部分依赖关系 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps2.png" alt="img"> </p><p>③获取第三方 jar 包 </p><p>JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。 </p><p>使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载，并同时下载这个 jar 包所依赖的其他 jar 包 ——规范、完整、准确！一次性解决所有问题！ </p><p>Tips：在这里我们顺便说一下，统一的规范几乎可以说成是程序员的最高信仰。如果没有统一的规范，就意味着每个具体的技术都各自为政，需要以诸多不同的特殊的方式加入到项目中；好不容易加入进来还会和其他技术格格不入，最终受苦的是我们。而任何一个领域的统一规范都能够极大的降低程序员的工作难度，减少工作量。例如：USB 接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备对应的接口，无疑是非常繁琐的。 </p><p>④将项目拆分成多个工程模块 </p><p>随着 JavaEE 项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 JavaEE 项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 Java 工程，有的是 Web 工程。 </p><p>那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。大家请看我们的 Survey 调查项目拆分的情况： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps3.png" alt="img"> 上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。 </p><p>2 What? </p><p>2.1 Maven 简介 </p><p>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps4.jpg" alt="img"> </p><p>2.2 什么是构建 </p><p>构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看： </p><p>①纯 Java 代码 </p><p>大家都知道，我们 Java 是一门编译型语言，.java 扩展名的源文件需要编译成.class 扩展名的字节码文件才能够执行。所以编写任何 Java 代码想要执行的话就必须经过编译得到对应的.class 文件。 </p><p>②Web 工程 </p><p>当我们需要通过浏览器访问 Java 程序时就必须将包含 Java 程序的 Web 工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。 </p><p>我们可以将未编译的 Web 工程比喻为一只生的鸡，编译好的 Web 工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。 </p><p>Web 工程和其编译结果的目录结构对比见下图： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps5.png" alt="img"> </p><p>③实际项目 </p><p>在实际项目中整合第三方框架，Web 工程中除了 Java 程序和 JSP 页面、图片等静态资源之外，还包括第三方框架的 jar 包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。 </p><p>所以综上所述：构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 </p><p>那么项目构建的全过程中都包含哪些环节呢？ </p><p>2.3 构建过程的几个主要环节 </p><p>①清理：删除以前的编译结果，为重新编译做好准备。 </p><p>②编译：将 Java 源程序编译为字节码文件。 </p><p>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 </p><p>④报告：在每一次测试后以标准的格式记录和展示测试结果。 </p><p>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 </p><p>⑥安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 </p><p>⑦部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 </p><p>2.4 自动化构建 </p><p>其实上述环节我们在 Eclipse 中都可以找到对应的操作，只是不太标准。那么既然 IDE 已经可以进行构建了我们为什么还要使用 Maven 这样的构建工具呢？我们来看一个小故事：这是阳光明媚的一天。托马斯向往常一样早早的来到了公司，冲好一杯咖啡，进入了自己的邮箱——很不幸，QA 小组发来了一封邮件，报告了他昨天提交的模块的测试结果——有 BUG。“好吧，反正也不是第一次”，托马斯摇摇头，进入 IDE，运行自己的程序，编译、打包、部署到服务器上，然后按照邮件中的操作路径进行测试。“嗯，没错，这个地方确实有问题”，托马斯说道。于是托马斯开始尝试修复这个 BUG，当他差不多有眉目的时候已经到了午饭时间。 </p><p>下午继续工作。BUG 很快被修正了，接着托马斯对模块重新进行了编译、打包、部署，测试之后确认没有问题了，回复了 QA 小组的邮件。 </p><p>一天就这样过去了，明媚的阳光化作了美丽的晚霞，托马斯却觉得生活并不像晚霞那样美好啊。 </p><p>让我们来梳理一下托马斯这一天中的工作内容 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps6.jpg" alt="img"> </p><p>从中我们发现，托马斯的很大一部分时间花在了“编译、打包、部署、测试”这些程式化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps7.jpg" alt="img"> 能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps8.jpg" alt="img"> </p><p>此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps9.png" alt="img"> </p><p>2.5 Maven 核心概念 </p><p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，看看 Maven 是如何实现自动化构建的 </p><p>①POM </p><p>②约定的目录结构 </p><p>③坐标 </p><p>④依赖管理 </p><p>⑤仓库管理 </p><p>⑥生命周期 </p><p>⑦插件和目标 </p><p>⑧继承 </p><p>⑨聚合 </p><p>3 How? </p><p>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是</p><p>Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 </p><p>下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。 </p><p>如果不能联网可以使用我们提供的 RepMaven.zip 解压得到。具体操作参见“Maven 操作指南.txt”。 </p><p>4 约定的目录结构 </p><p>约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。 </p><p>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式： </p><p>①通过配置的形式明确告诉它 </p><p>②基于第三方工具或框架的约定 </p><p>Maven 对工程目录结构的要求就属于后面的一种。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps10.jpg" alt="img"> </p><p>现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。 </p><p>5 POM </p><p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。 Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。 </p><p>6 坐标 </p><p>6.1 几何中的坐标 </p><p>[1]在一个平面中使用 x、y 两个向量可以唯一的确定平面中的一个点。 </p><p>[2]在空间中使用 x、y、z 三个向量可以唯一的确定空间中的一个点。 </p><p>6.2 Maven 的坐标 </p><p>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。 </p><p>[1]groupid：公司或组织的域名倒序+当前项目名称 </p><p>[2]artifactId：当前项目的模块名称 </p><p>[3]version：当前模块的版本 </p><p> &lt;****g****roupId&gt;com.atguigu.maven</groupId> </p><p> &lt;****a****rtifactId&gt;Hello</artifactId> </p><p> &lt;****v****ersion&gt;0.0.1-SNAPSHOT</version> </p><p>6.3 如何通过坐标到仓库中查找 jar 包？ </p><p>[1]将 gav 三个向量连起来 </p><p>com.atguigu.maven+Hello+0.0.1-SNAPSHOT </p><p>[2]以连起来的字符串作为目录结构到仓库中查找 </p><p>com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar </p><p>※注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install </p><p>7 依赖 </p><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决一下几个问题： </p><p>①依赖的目的是什么 </p><p>当A jar包用到了B jar包中的某些类时，A就对B产生了依赖，这是概念上的描述。那么如何在项目</p><p>中以依赖的方式引入一个我们需要的jar包呢？答案非常简单，就是使用dependency标签指定被依赖jar包的坐标就可以了。 </p><dependency> <p> <groupId>com.atguigu.maven</groupId> </p><p> <artifactId>Hello</artifactId> </p><p> <version>0.0.1-SNAPSHOT</version> </p><p> <scope>compile</scope> </dependency> </p><p>②依赖的范围大家注意到上面的依赖信息中除了目标jar包的坐标还有一个scope设置，这是依赖的范围。依赖的范围有几个可选值，我们用得到的是：compile、test、provided三个。 </p><p>[1]从项目结构角度理解compile和test的区别 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps11.jpg" alt="img"> </p><p>结合具体例子：对于HelloFriend来说，Hello就是服务于主程序的，junit是服务于测试程序的。 </p><p>HelloFriend 主程序需要 Hello 是非常明显的，测试程序由于要调用主程序所以也需要 Hello，所以 compile范围依赖对主程序和测试程序都应该有效。 </p><p>HelloFriend的测试程序部分需要junit也是非常明显的，而主程序是不需要的，所以test范围依赖仅仅对于主程序有效。 </p><p>[2]从开发和运行这两个不同阶段理解compile和provided的区别 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps12.jpg" alt="img"> </p><p>[3]有效性总结 </p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th></tr></thead><tbody><tr><td>主程序</td><td>√</td><td>×</td><td>√</td></tr><tr><td>测试程序</td><td>√</td><td>√</td><td>√</td></tr><tr><td>参与部署</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><p>③依赖的传递性 </p><p>A依赖B，B依赖C，A能否使用C呢？那要看B依赖C的范围是不是compile，如果是则可用，否则不可用。 </p><table><thead><tr><th>Maven 工程</th><th></th><th>依赖范围</th><th>对 A 的可见性</th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>compile</td><td>√</td></tr><tr><td>D</td><td>test</td><td>×</td><td></td><td></td></tr><tr><td>E</td><td>provided</td><td>×</td><td></td><td></td></tr></tbody></table><p>④依赖的排除 </p><p>如果我们在当前工程中引入了一个依赖是A，而A又依赖了B，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。 </p><p>[1]情景举例 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps13.png" alt="img"> </p><p>[2]配置方式 </p><dependency> <p>   <groupId>com.atguigu.maven</groupId> </p><p>   <artifactId>HelloFriend</artifactId> </p><p>   <version>0.0.1-SNAPSHOT</version> </p><p>   <type>jar</type> </p><p>   <scope>compile</scope> </p>   <exclusions> <p>​     <exclusion> </p><p>​       <groupId>commons-logging</groupId> </p><p>​       <artifactId>commons-logging</artifactId> </p><p>​     </exclusion> </p>   </exclusions> </dependency> <p>[3]排除后的效果 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps14.png" alt="img"> </p><p>⑤统一管理所依赖jar包的版本 </p><p>对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将jar包的版本信息统一提</p><p>取出来 </p><p>[1]统一声明版本号 </p><properties> <p>   &lt;atguigu.spring.version&gt;4.1.1.RELEASE&lt;/atguigu.spring.version&gt; </p></properties> <p>其中atguigu.spring.version部分是自定义标签。 </p><p>[2]引用前面声明的版本号 </p><dependencies>    <dependency> <p>​     <groupId>org.springframework</groupId> </p><p>​     <artifactId>spring-core</artifactId> </p><p>​     <version>${atguigu.spring.version}</version> </p>   </dependency> <p>…… </p></dependencies> <p>[3]其他用法 </p><properties> <p>   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; </p></properties> <p>⑥依赖的原则：解决 jar 包冲突 </p><p>[1]路径最短者优先 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps15.png" alt="img"> </p><p>[2]路径相同时先声明者优先 </p><p>  <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps16.png" alt="img"> 这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 </p><p>8 仓库 </p><p>8.1 分类 </p><p>[1]本地仓库：为当前本机电脑上的所有 Maven 工程服务。 </p><p>[2]远程仓库 </p><p>(1)私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml10360\wps17.png" alt="img"> </p><p>(2)中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。 </p><p>(3)中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 </p><p>8.2 仓库中的文件 </p><p>[1]Maven 的插件 </p><p>[2]我们自己开发的项目的模块 </p><p>[3]第三方框架或工具的 jar 包 </p><p>※不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。 </p><p>9 生命周期 </p><p>9.1 什么是 Maven 的生命周期？ </p><p>●Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 </p><p>●Maven 有三套相互独立的生命周期，分别是： </p><p>①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 </p><p>②Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 </p><p>③Site Lifecycle 生成项目报告，站点，发布站点。 </p><p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 </p><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 </p><p>9.2 Clean 生命周期 </p><p>Clean 生命周期一共包含了三个阶段： </p><p>①pre-clean 执行一些需要在 clean 之前完成的工作 </p><p>②clean 移除所有上一次构建生成的文件 </p><p>③post-clean 执行一些需要在 clean 之后立刻完成的工作 </p><p>9.3 Site 生命周期 </p><p>①pre-site 执行一些需要在生成站点文档之前完成的工作 </p><p>②site 生成项目的站点文档 </p><p>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 </p><p>④site-deploy 将生成的站点文档部署到特定的服务器上 </p><p>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 </p><p>9.4 Default 生命周期 </p><p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段： validate generate-sources process-sources </p><p>generate-resources </p><p>process-resources 复制并处理资源文件，至目标目录，准备打包。 </p><p>compile 编译项目的源代码。 </p><p>process-classes generate-test-sources process-test-sources </p><p>generate-test-resources </p><p>process-test-resources 复制并处理资源文件，至目标测试目录。 </p><p>test-compile 编译测试源代码。 </p><p>process-test-classes </p><p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 </p><p>prepare-package </p><p>package 接受编译好的代码，打包成可发布的格式，如 JAR。 </p><p>pre-integration-test integration-test post-integration-test verify </p><p>install 将包安装至本地仓库，以让其它项目依赖。 </p><p>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 </p><p>9.5 生命周期与自动化构建 </p><p>运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。 </p><p>10 插件和目标 </p><p>●Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。 </p><p>●每个插件都能实现多个功能，每个功能就是一个插件目标。 </p><p>●Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。 </p><p>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 </p><p>11 继承 </p><p>11.1 为什么需要继承机制？由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如： </p><table><thead><tr><th>Hello</th><th><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version> <scope>test</scope> </dependency></th></tr></thead><tbody><tr><td>HelloFriend</td><td><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version></td></tr><tr><td></td><td><scope>test</scope> </dependency></td></tr><tr><td>MakeFriend</td><td><dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.0</version> <scope>test</scope> </dependency></td></tr></tbody></table><p>此时如果项目需要将各个模块的junit版本统一为 4.9，那么到各个工程中手动修改无疑是非常不可取的。</p><p>使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。 </p><p>11.2 创建父工程创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是：打包方式处要设置为 pom。 </p><p>11.3 在子工程中引用父工程 </p><parent> <p>​     <!-- 父工程坐标 --> </p><p><groupId>…</groupId> </p><p>​     <artifactId>…</artifactId> </p><p>​     <version>…</version> </p><p>​     <relativePath>从当前目录到父项目的 pom.xml 文件的相对路径</relativePath> </p></parent> <parent> <p> <groupId>com.atguigu.maven</groupId> </p><p> <artifactId>Parent</artifactId> </p><h1 id="0-0-1-SNAPSHOT"><a href="#0-0-1-SNAPSHOT" class="headerlink" title="0.0.1-SNAPSHOT"></a><version>0.0.1-SNAPSHOT</version></h1> <!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --> <p> <relativePath>../Parent/pom.xml</relativePath> </p></parent> <p> 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 </p><p>11.4 在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来 </p><dependencyManagement>  <dependencies>  <dependency> <p>  <groupId>junit</groupId> </p><p>  <artifactId>junit</artifactId> </p><p>  <version>4.9</version> </p><p>  <scope>test</scope> </p> </dependency>  </dependencies> </dependencyManagement> <p>在子项目中重新指定需要的依赖，删除范围和版本号 </p><dependencies>  <dependency> <p> <groupId>junit</groupId> </p><p> <artifactId>junit</artifactId> </p> </dependency> </dependencies> <p>12 聚合 </p><p>12.1 为什么要使用聚合？ </p><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 </p><p>12.2 如何配置聚合？在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 </p><modules> <p> <module>../Hello</module> </p><h1 id="HelloFriend-MakeFriends"><a href="#HelloFriend-MakeFriends" class="headerlink" title="../HelloFriend ../MakeFriends"></a><module>../HelloFriend</module> <module>../MakeFriends</module></h1></modules> <p>13 Maven 酷站我们可以到 <a href="http://mvnrepository.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84">http://mvnrepository.com/搜索需要的</a> jar 包的依赖信息。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Maven尚硅谷复习总结&quot;&gt;&lt;a href=&quot;#Maven尚硅谷复习总结&quot; class=&quot;headerlink&quot; title=&quot;Maven尚硅谷复习总结&quot;&gt;&lt;/a&gt;Maven尚硅谷复习总结&lt;/h1&gt;&lt;p&gt;导言：生产环境下开发不再是一个项目一个工程，而是每一个模块创</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>尚硅谷_宋红康_JDBC</title>
    <link href="http://example.com/2021/06/20/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-JDBC/"/>
    <id>http://example.com/2021/06/20/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-JDBC/</id>
    <published>2021-06-20T12:04:28.000Z</published>
    <updated>2021-06-20T12:10:37.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><hr><h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul><li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p></li><li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566741430592.png" alt="1566741430592"> </p></li></ul><h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul><li><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p>JDO (Java Data Object )技术</p></li><li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p></li></ul></li><li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p></li></ul><h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul><li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555575760234.png" alt="1555575760234"></p><hr><ul><li>有了JDBC，Java程序访问数据库时是这样的：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555575981203.png" alt="1555575981203"></p><hr><ul><li>总结如下：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566741692804.png" alt="1566741692804"></p><h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p></blockquote><h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1565969323908.png" alt="1565969323908"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li><li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li></ul></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576157618.png" alt="1555576157618"></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576170074.png" alt="1555576170074"></p><ul><li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li></ul><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566134718955.png" alt="1566134718955"></p><p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566134781682.png" alt="1566134781682"></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p> <img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566135290460.png" alt="1566135290460"></p><h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li></ul></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566136831283.png" alt="1566136831283"></p></li></ul></li></ul><h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><ul><li><strong>jdbc:子协议:子名称</strong></li><li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li><li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li><li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li></ul></li><li><p>举例：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555576477107.png" alt="1555576477107"></p></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/atguigu</li><li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p></li><li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p></li></ul></li></ul></li></ul><h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul><li>user,password可以用“属性名=属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul><li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p></li><li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566573842140.png" alt="1566573842140"></p></li></ul><h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">String userName = scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">User user = get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line">String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566569819744.png" alt="1566569819744"></p><h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul><li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p></li><li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul><li><p>代码的可读性和可维护性。</p></li><li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li></ul></li><li><p>PreparedStatement 可以防止 SQL 注入 </p></li></ul><h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY  ,    VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123;Connection conn = null;PreparedStatement ps = null;try &#123;//1.获取数据库的连接conn = JDBCUtils.getConnection();//2.获取PreparedStatement的实例 (或：预编译sql语句)ps = conn.prepareStatement(sql);//3.填充占位符for(int i = 0;i &lt; args.length;i++)&#123;ps.setObject(i + 1, args[i]);&#125;//4.执行sql语句ps.execute();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;finally&#123;//5.关闭资源JDBCUtils.closeResource(conn, ps);&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;try &#123;// 1.获取数据库连接conn = JDBCUtils.getConnection();// 2.预编译sql语句，得到PreparedStatement对象ps = conn.prepareStatement(sql);// 3.填充占位符for (int i = 0; i &lt; args.length; i++) &#123;ps.setObject(i + 1, args[i]);&#125;// 4.执行executeQuery(),得到结果集：ResultSetrs = ps.executeQuery();// 5.得到结果集的元数据：ResultSetMetaDataResultSetMetaData rsmd = rs.getMetaData();// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值int columnCount = rsmd.getColumnCount();if (rs.next()) &#123;T t = clazz.newInstance();for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列// 获取列值Object columnVal = rs.getObject(i + 1);// 获取列的别名:列的别名，使用类的属性名充当String columnLabel = rsmd.getColumnLabel(i + 1);// 6.2使用反射，给对象的相应属性赋值Field field = clazz.getDeclaredField(columnLabel);field.setAccessible(true);field.set(t, columnVal);&#125;return t;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;// 7.关闭资源JDBCUtils.closeResource(conn, ps, rs);&#125;return null;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li><p>boolean next()</p></li><li><p>getString()</p></li><li><p>…</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580152530.png" alt="1555580152530"></p></li></ul><h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta = rs.getMetaData();</p><ul><li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p></li><li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p></li><li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p></li><li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p></li><li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p></li><li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p></li><li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p></li></ul></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555579494691.png" alt="1555579494691"></p><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li><li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555579816884.png" alt="1555579816884"></p><h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul><li><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。</p></blockquote></li><li><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><hr><h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580275036.png" alt="1555580275036"></p><p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580735377.png" alt="1555580735377"></p><p>向数据表中添加如下数据：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580763636.png" alt="1555580763636"></p><p><strong>代码实现1：插入一个新的student 信息</strong></p><p>请输入考生的详细信息</p><p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p><p>信息录入成功!</p><p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580937490.png" alt="1555580937490"></p><p><strong>代码实现3：完成学生信息的删除功能</strong></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555580965019.png" alt="1555580965019"></p><hr><h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555581069798.png" alt="1555581069798"></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接Connection conn = JDBCUtils.getConnection();String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="comment">// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;conn = getConnection();ps = conn.prepareStatement(sql);ps.setInt(<span class="number">1</span>, <span class="number">8</span>);rs = ps.executeQuery();<span class="keyword">if</span>(rs.next())&#123;Integer id = rs.getInt(<span class="number">1</span>);    String name = rs.getString(<span class="number">2</span>);String email = rs.getString(<span class="number">3</span>);    Date birth = rs.getDate(<span class="number">4</span>);Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);    System.out.println(cust);     <span class="comment">//读取Blob类型的字段Blob photo = rs.getBlob(5);InputStream is = photo.getBinaryStream();OutputStream os = new FileOutputStream(&quot;c.jpg&quot;);byte [] buffer = new byte[1024];int len = 0;while((len = is.read(buffer)) != -1)&#123;os.write(buffer, 0, len);&#125;    JDBCUtils.closeResource(conn, ps, rs);if(is != null)&#123;is.close();&#125;if(os !=  null)&#123;os.close();&#125;    &#125;</span></span><br></pre></td></tr></table></figure><h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li><li><strong>executeBatch()：执行批量处理语句；</strong></li><li><strong>clearBatch():清空缓存的数据</strong></li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li>数据库中提供一个goods表。创建如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,NAME <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;st.executeUpdate(sql);&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);ps.executeUpdate();&#125;<span class="keyword">long</span> end = System.currentTimeMillis();System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340JDBCUtils.closeResource(conn, ps);</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 *  ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar *  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;PreparedStatement ps = conn.prepareStatement(sql);<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);<span class="comment">//1.“攒”sqlps.addBatch();if(i % 500 == 0)&#123;//2.执行ps.executeBatch();//3.清空ps.clearBatch();&#125;&#125;long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625                                                                         //1000000条:14733  JDBCUtils.closeResource(conn, ps);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false)  /  commit()*/</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="keyword">long</span> start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();<span class="comment">//1.设置为不自动提交数据conn.setAutoCommit(false);String sql = &quot;insert into goods(name)values(?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);for(int i = 1;i &lt;= 1000000;i++)&#123;ps.setString(1, &quot;name_&quot; + i);//1.“攒”sqlps.addBatch();if(i % 500 == 0)&#123;//2.执行ps.executeBatch();//3.清空ps.clearBatch();&#125;&#125;//2.提交数据conn.commit();long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p></li><li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p></li><li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p></li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p><ul><li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li><li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;Connection conn = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;<span class="comment">// 1.获取数据库连接conn = JDBCUtils.getConnection();// 2.开启事务conn.setAutoCommit(false);// 3.进行数据库操作String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;update(conn, sql1, &quot;AA&quot;);// 模拟网络异常//System.out.println(10 / 0);String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;update(conn, sql2, &quot;BB&quot;);// 4.若没有异常，则提交事务conn.commit();&#125; catch (Exception e) &#123;e.printStackTrace();// 5.若有异常，则回滚事务try &#123;conn.rollback();&#125; catch (SQLException e1) &#123;e1.printStackTrace();&#125;    &#125; finally &#123;        try &#123;//6.恢复每次DML操作的自动提交功能conn.setAutoCommit(true);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125;        //7.关闭连接JDBCUtils.closeResource(conn, null, null);     &#125;  &#125;</span></span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123;PreparedStatement ps = null;try &#123;// 1.获取PreparedStatement的实例 (或：预编译sql语句)ps = conn.prepareStatement(sql);// 2.填充占位符for (int i = 0; i &lt; args.length; i++) &#123;ps.setObject(i + 1, args[i]);&#125;// 3.执行sql语句ps.execute();&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;// 4.关闭资源JDBCUtils.closeResource(null, ps);&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol><li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul><li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p></li><li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p></li></ul><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul><li><p>数据库提供的4种事务隔离级别：</p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555586275271.png" alt="1555586275271"></p></li><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li></ul><ul><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li><li><p>设置当前 mySQL 连接的隔离级别:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;;  #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566726681515.png" alt="1566726681515"></p><ul><li>层次结构：</li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1566745811244.png" alt="1566745811244"></p><h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.lang.reflect.ParameterizedType;<span class="keyword">import</span> java.lang.reflect.Type;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.sql.SQLException;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;<span class="comment">/** * 定义一个用来被继承的对数据库进行基本操作的Dao *  * <span class="doctag">@author</span> HanYanBing * * <span class="doctag">@param</span> &lt;T&gt; */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();<span class="comment">// 定义一个变量来接收泛型的类型private Class&lt;T&gt; type;// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定public BaseDao() &#123;// 获取子类的类型Class clazz = this.getClass();// 获取父类的类型// getGenericSuperclass()用来获取当前类的父类的类型// ParameterizedType表示的是带泛型的类型ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型// 这个方法会返回一个Type的数组Type[] types = parameterizedType.getActualTypeArguments();// 获取具体的泛型的类型·this.type = (Class&lt;T&gt;) types[0];&#125;/** * 通用的增删改操作 *  * @param sql * @param params * @return */public int update(Connection conn,String sql, Object... params) &#123;int count = 0;try &#123;count = queryRunner.update(conn, sql, params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return count;&#125;/** * 获取一个对象 *  * @param sql * @param params * @return */public T getBean(Connection conn,String sql, Object... params) &#123;T t = null;try &#123;t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return t;&#125;/** * 获取所有对象 *  * @param sql * @param params * @return */public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123;List&lt;T&gt; list = null;try &#123;list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return list;&#125;/** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 *  * @param sql * @param params * @return */public Object getValue(Connection conn,String sql, Object... params) &#123;Object count = null;try &#123;// 调用queryRunner的query方法获取一个单一的值count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params);&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; return count;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> com.atguigu.bookstore.beans.Book;<span class="keyword">import</span> com.atguigu.bookstore.beans.Page;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;<span class="comment">/** * 从数据库中查询出所有的记录 *  * <span class="doctag">@return</span> */</span><span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;<span class="comment">/** * 向数据库中插入一条记录 *  * <span class="doctag">@param</span> book */</span><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;<span class="comment">/** * 从数据库中根据图书的id删除一条记录 *  * <span class="doctag">@param</span> bookId */</span><span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;<span class="comment">/** * 根据图书的id从数据库中查询出一条记录 *  * <span class="doctag">@param</span> bookId * <span class="doctag">@return</span> */</span><span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;<span class="comment">/** * 根据图书的id从数据库中更新一条记录 *  * <span class="doctag">@param</span> book */</span><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;<span class="comment">/** * 获取带分页的图书信息 *  * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象 */</span><span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;<span class="comment">/** * 获取带分页和价格范围的图书信息 *  * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象 */</span><span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> com.atguigu.bookstore.beans.User;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;<span class="comment">/** * 根据User对象中的用户名和密码从数据库中获取一条记录 *  * <span class="doctag">@param</span> user * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录 */</span><span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;<span class="comment">/** * 根据User对象中的用户名从数据库中获取一条记录 *  * <span class="doctag">@param</span> user * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录 */</span><span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;<span class="comment">/** * 向数据库中插入User对象 *  * <span class="doctag">@param</span> user */</span><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> com.atguigu.bookstore.beans.Book;<span class="keyword">import</span> com.atguigu.bookstore.beans.Page;<span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;<span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;<span class="comment">// 调用BaseDao中得到一个List的方法List&lt;Book&gt; beanList = null;// 写sql语句String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;;beanList = getBeanList(conn,sql);return beanList;&#125;@Overridepublic void saveBook(Connection conn,Book book) &#123;// 写sql语句String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;// 调用BaseDao中通用的增删改的方法update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());&#125;@Overridepublic void deleteBookById(Connection conn,String bookId) &#123;// 写sql语句String sql = &quot;DELETE FROM books WHERE id = ?&quot;;// 调用BaseDao中通用增删改的方法update(conn,sql, bookId);&#125;@Overridepublic Book getBookById(Connection conn,String bookId) &#123;// 调用BaseDao中获取一个对象的方法Book book = null;// 写sql语句String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;book = getBean(conn,sql, bookId);return book;&#125;@Overridepublic void updateBook(Connection conn,Book book) &#123;// 写sql语句String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;;// 调用BaseDao中通用的增删改的方法update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());&#125;@Overridepublic Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123;// 获取数据库中图书的总记录数String sql = &quot;select count(*) from books&quot;;// 调用BaseDao中获取一个单一值的方法long totalRecord = (long) getValue(conn,sql);// 将总记录数设置都page对象中page.setTotalRecord((int) totalRecord);// 获取当前页中的记录存放的ListString sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;;// 调用BaseDao中获取一个集合的方法List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);// 将这个List设置到page对象中page.setList(beanList);return page;&#125;@Overridepublic Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123;// 获取数据库中图书的总记录数String sql = &quot;select count(*) from books where price between ? and ?&quot;;// 调用BaseDao中获取一个单一值的方法long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);// 将总记录数设置都page对象中page.setTotalRecord((int) totalRecord);// 获取当前页中的记录存放的ListString sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;;// 调用BaseDao中获取一个集合的方法List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);// 将这个List设置到page对象中page.setList(beanList);return page;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> com.atguigu.bookstore.beans.User;<span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;<span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;<span class="comment">// 调用BaseDao中获取一个对象的方法User bean = null;// 写sql语句String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;;bean = getBean(conn,sql, user.getUsername(), user.getPassword());return bean;&#125;@Overridepublic boolean checkUsername(Connection conn,User user) &#123;// 调用BaseDao中获取一个对象的方法User bean = null;// 写sql语句String sql = &quot;select id,username,password,email from users where username = ?&quot;;bean = getBean(conn,sql, user.getUsername());return bean != null;&#125;@Overridepublic void saveUser(Connection conn,User user) &#123;//写sql语句String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;//调用BaseDao中通用的增删改的方法update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="comment">/** * 图书类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;<span class="keyword">private</span> Integer id;<span class="keyword">private</span> String title; <span class="comment">// 书名private String author; // 作者private double price; // 价格private Integer sales; // 销量private Integer stock; // 库存private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径//构造器，get()，set()，toString()方法略&#125;</span></span><br></pre></td></tr></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="keyword">import</span> java.util.List;<span class="comment">/** * 页码类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合public static final int PAGE_SIZE = 4; // 每页显示的记录数private int pageNo; // 当前页//private int totalPageNo; // 总页数，通过计算得到private int totalRecord; // 总记录数，通过查询数据库得到</span></span><br></pre></td></tr></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;<span class="comment">/** * 用户类 * <span class="doctag">@author</span> songhongkang * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;<span class="keyword">private</span> Integer id;<span class="keyword">private</span> String username;<span class="keyword">private</span> String password;<span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p><ul><li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li><li><strong>进行sql操作</strong></li><li><strong>断开数据库连接</strong></li></ul></li><li><p>这种模式开发，存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li><li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p></li><li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p></li><li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p></li><li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555593464033.png" alt="1555593464033"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555593598606.png" alt="1555593598606"></p><ul><li><p><strong>数据库连接池技术的优点</strong></p><p><strong>1. 资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2. 更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><p><strong>3. 新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p><p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul><li>获取连接方式一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123;ComboPooledDataSource cpds = new ComboPooledDataSource();cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);cpds.setUser(&quot;root&quot;);cpds.setPassword(&quot;abc123&quot;);//cpds.setMaxPoolSize(100);Connection conn = cpds.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>获取连接方式二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123;Connection conn = cpds.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;BasicDataSource source = <span class="keyword">new</span> BasicDataSource();source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);source.setUsername(<span class="string">&quot;root&quot;</span>);source.setPassword(<span class="string">&quot;abc123&quot;</span>);<span class="comment">//source.setInitialSize(10);Connection conn = source.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123;try &#123;Properties pros = new Properties();InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);pros.load(is);//根据提供的BasicDataSourceFactory创建对应的DataSource对象source = BasicDataSourceFactory.createDataSource(pros);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;public static Connection getConnection4() throws Exception &#123;Connection conn = source.getConnection();return conn;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【dbcp.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#...</span></span><br></pre></td></tr></table></figure><h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;<span class="keyword">import</span> java.sql.Connection;<span class="keyword">import</span> java.util.Properties;<span class="keyword">import</span> javax.sql.DataSource;<span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;Properties pro = <span class="keyword">new</span> Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));DataSource ds = DruidDataSourceFactory.createDataSource(pro);Connection conn = ds.getConnection();System.out.println(conn);&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=123456driverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall</span></span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th><strong>配置</strong></th><th><strong>缺省</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils   </li></ul></li><li><p>API包说明：</p></li></ul><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555595163263.png" alt="1555595163263"></p><p><img src="C:/Users/ASUS/Desktop/Markdown文件/尚硅谷_宋红康_JDBC.assets/1555595198644.png" alt="1555595198644"></p><h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p><ul><li><strong>更新</strong><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul></li><li><strong>插入</strong><ul><li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li><li>….</li></ul></li><li><strong>批处理</strong><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>…..</li></ul></li><li><strong>查询</strong><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…… </li></ul></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加@Testpublic void testInsert() throws Exception &#123;QueryRunner runner = new QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;);System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除@Testpublic void testDelete() throws Exception &#123;QueryRunner runner = new QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = &quot;delete from customers where id &lt; ?&quot;;int count = runner.update(conn, sql,3);System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p></li><li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p></li><li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p></li><li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p></li><li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p></li><li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p></li><li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p></li><li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p></li><li><p><strong>ScalarHandler：</strong>查询单个值对象</p></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 测试查询:查询一条记录 *  * 使用ResultSetHandler的实现类：BeanHandler */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;<span class="comment">//BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class);Customer customer = runner.query(conn, sql, handler, 23);System.out.println(customer);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 测试查询:查询多条记录构成的集合 *  * 使用ResultSetHandler的实现类：BeanListHandler */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;<span class="comment">//BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class);List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23);list.forEach(System.out::println);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 自定义ResultSetHandler的实现类 */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;<span class="meta">@Override</span><span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;System.out.println(<span class="string">&quot;handle&quot;</span>);<span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));if(rs.next())&#123;int id = rs.getInt(&quot;id&quot;);String name = rs.getString(&quot;name&quot;);String email = rs.getString(&quot;email&quot;);Date birth = rs.getDate(&quot;birth&quot;);return new Customer(id, name, email, birth);&#125;return null;&#125;&#125;;Customer customer = runner.query(conn, sql, handler, 23);System.out.println(customer);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler *  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;QueryRunner runner = <span class="keyword">new</span> QueryRunner();Connection conn = JDBCUtils.getConnection3();<span class="comment">//测试一：//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;//ScalarHandler handler = new ScalarHandler();//long count = (long) runner.query(conn, sql, handler, 20);//System.out.println(count);//测试二：String sql = &quot;select max(birth) from customers&quot;;ScalarHandler handler = new ScalarHandler();Date birth = (Date) runner.query(conn, sql, handler);System.out.println(birth);JDBCUtils.closeResource(conn, null);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结<span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;Connection conn = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;<span class="comment">//1.获取连接的操作（//① 手写的连接：JDBCUtils.getConnection();//② 使用数据库连接池：C3P0;DBCP;Druid//2.对数据表进行一系列CRUD操作//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;//② 使用dbutils提供的jar包中提供的QueryRunner类//提交数据conn.commit();&#125; catch (Exception e) &#123;e.printStackTrace();try &#123;//回滚数据conn.rollback();&#125; catch (SQLException e1) &#123;e1.printStackTrace();&#125;&#125;finally&#123;//3.关闭连接等操作//① JDBCUtils.closeResource();//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC核心技术&quot;&gt;&lt;a href=&quot;#JDBC核心技术&quot; class=&quot;headerlink&quot; title=&quot;JDBC核心技术&quot;&gt;&lt;/a&gt;JDBC核心技术&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;第1章：JDBC概述&quot;&gt;&lt;a href=&quot;#第1章：JDBC概述&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>尚硅谷  Git、GitHub总结</title>
    <link href="http://example.com/2021/06/20/%E5%B0%9A%E7%A1%85%E8%B0%B7-Git%E3%80%81GitHub%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/06/20/%E5%B0%9A%E7%A1%85%E8%B0%B7-Git%E3%80%81GitHub%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-20T12:03:44.000Z</published>
    <updated>2021-06-20T12:10:15.752Z</updated>
    
    <content type="html"><![CDATA[<p>尚硅谷技术课程系列之 Git </p><p>（作者：尚硅谷大数据研发部） </p><p>版本：V2.0 </p><h1 id="第-1-章-Git-概述"><a href="#第-1-章-Git-概述" class="headerlink" title="第****1****章 *Git* 概述"></a>第****1****章 <em><strong>*Git*</strong></em> 概述</h1><p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。 </p><p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。 </p><h2 id="1-1-何为版本控制"><a href="#1-1-何为版本控制" class="headerlink" title="*1.1* 何为版本控制"></a><em><strong>*1.1*</strong></em> 何为版本控制</h2><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。 </p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps1.png" alt="img"></p><p>个人开发过渡到团队协作。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps2.png" alt="img"></p><h2 id="1-3-版本控制工具"><a href="#1-3-版本控制工具" class="headerlink" title="*1.3* 版本控制工具"></a><em><strong>*1.3*</strong></em> 版本控制工具</h2><p>➢ 集中式版本控制工具 </p><h3 id="CVS、SVN-Subversion-、VSS……"><a href="#CVS、SVN-Subversion-、VSS……" class="headerlink" title="CVS、SVN(Subversion)、VSS……"></a>CVS、SVN(Subversion)、VSS……</h3><p>集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。 </p><p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。 </p><p>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕</p><p>机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps3.png" alt="img"></p><p>Git、Mercurial、Bazaar、Darcs…… </p><p>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。 </p><p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷: </p><p>\1. 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的） </p><p>\2. 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全） </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps4.png" alt="img"></p><h2 id="1-4-Git-简史"><a href="#1-4-Git-简史" class="headerlink" title="*1.4 Git* 简史"></a><em><strong>*1.4 Git*</strong></em> 简史</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps5.png" alt="img"></p><h2 id="1-5-Git-工作机制"><a href="#1-5-Git-工作机制" class="headerlink" title="*1.5 Git* 工作机制"></a><em><strong>*1.5 Git*</strong></em> 工作机制</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps6.png" alt="img"></p><h3 id="1-6-Git-和代码托管中心"><a href="#1-6-Git-和代码托管中心" class="headerlink" title="*1.6 Git* 和代码托管中心"></a><em><strong>*1.6 Git*</strong></em> 和代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库。 </p><p>➢ 局域网 </p><p>✓ GitLab </p><p>➢ 互联网 </p><p>✓ GitHub（外网） </p><p>✓ Gitee 码云（国内网站） </p><h1 id="第-2-章-Git-安装"><a href="#第-2-章-Git-安装" class="headerlink" title="第****2****章 *Git* 安装"></a>第****2****章 <em><strong>*Git*</strong></em> 安装</h1><p>  官网地址： <a href="https://git-scm.com/">https://git-scm.com/</a> </p><p>  查看 GNU 协议，可以直接点击下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps7.png" alt="img"> 选择 Git 安装位置，要求是非中文并且没有空格的目录，然后下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps8.png" alt="img"> </p><p>Git 选项配置，推荐默认设置，然后下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps9.png" alt="img"> </p><p>Git 安装目录名，不用修改，直接点击下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps10.png" alt="img"> </p><p>Git 的默认编辑器，建议使用默认的 Vim 编辑器，然后点击下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps11.png" alt="img"> 默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps12.png" alt="img"> </p><p>修改 Git 的环境变量，选第一个，不修改环境变量，只在 Git Bash 里使用 Git。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps13.png" alt="img"> 选择后台客户端连接协议，选默认值 OpenSSL，然后下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps14.png" alt="img"> </p><p>配置 Git 文件的行末换行符，Windows 使用 CRLF，Linux 使用 LF，选择第一个自动转换，然后继续下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps15.png" alt="img"> 选择 Git 终端类型，选择默认的 Git Bash 终端，然后继续下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps16.png" alt="img"> 选择 Git pull 合并的模式，选择默认，然后下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps17.png" alt="img"> </p><p>选择 Git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps18.png" alt="img"> 其他配置，选择默认设置，然后下一步。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps19.png" alt="img"> </p><p>实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 Install 按钮，开始安装 Git。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps20.png" alt="img"> 点击 Finsh 按钮，Git 安装成功！ </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps21.png" alt="img"> </p><p>右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps22.png" alt="img"> </p><p>在 Git Bash 终端里输入 git –version 查看 git 版本，如图所示，说明 Git 安装成功。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps23.png" alt="img"> </p><h1 id="第-3-章-Git-常用命令"><a href="#第-3-章-Git-常用命令" class="headerlink" title="第 *3* 章 *Git* 常用命令"></a>第 <em><strong>*3*</strong></em> 章 <em><strong>*Git*</strong></em> 常用命令</h1><table><thead><tr><th>命令名称</th><th></th><th>作用</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>git config –global user.name 用户名</td><td></td><td></td><td>设置用户签名</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>git config –global user.email 邮箱</td><td></td><td>设置用户签名</td><td></td><td></td><td></td><td></td></tr><tr><td>git init</td><td></td><td>初始化本地库</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>git status</td><td></td><td></td><td></td><td>查看本地库状态</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>git add 文件名</td><td></td><td>添加到暂存区</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>git commit -m “日志信息” 文件名</td><td></td><td></td><td></td><td>提交到本地库</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>git reflog</td><td></td><td>查看历史记录</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>git reset –hard 版本号</td><td></td><td></td><td></td><td>版本穿梭</td><td></td></tr></tbody></table><h2 id="3-1-设置用户签名"><a href="#3-1-设置用户签名" class="headerlink" title="*3.1* 设置用户签名"></a><em><strong>*3.1*</strong></em> 设置用户签名</h2><p><strong>1）</strong> 基本语法 </p><p>git config –global user.name 用户名 git config –global user.email 邮箱 </p><p><strong>2）</strong> 案例实操全局范围的签名设置： </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git config –global user.name Layne*</strong></em> Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git config –global user.email <a href="mailto:&#76;&#x61;&#121;&#x6e;&#101;&#64;&#x61;&#116;&#x67;&#x75;&#105;&#x67;&#117;&#x2e;&#x63;&#111;&#x6d;">&#76;&#x61;&#121;&#x6e;&#101;&#64;&#x61;&#116;&#x67;&#x75;&#105;&#x67;&#117;&#x2e;&#x63;&#111;&#x6d;</a>*</strong></em> Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ cat ~/.gitconfig [user]  name = Layne  email = <a href="mailto:&#76;&#x61;&#x79;&#110;&#x65;&#x40;&#97;&#116;&#x67;&#117;&#105;&#x67;&#x75;&#46;&#x63;&#111;&#109;">&#76;&#x61;&#x79;&#110;&#x65;&#x40;&#97;&#116;&#x67;&#117;&#105;&#x67;&#x75;&#46;&#x63;&#111;&#109;</a> </p><p>说明： </p><p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。 </p><p>※注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。 </p><h2 id="3-2-初始化本地库"><a href="#3-2-初始化本地库" class="headerlink" title="*3.2* 初始化本地库"></a><em><strong>*3.2*</strong></em> 初始化本地库</h2><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git init*</strong></em> </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 $ <em><strong>*git init*</strong></em> Initialized empty Git repository in D:/Git-Space/SH0720/.git/  Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ ll -a total 4 drwxr-xr-x 1 Layne 197609 0 11月 25 14:07 ./ drwxr-xr-x 1 Layne 197609 0 11月 25 14:07 ../ drwxr-xr-x 1 Layne 197609 0 11月 25 14:07 .git/  （.git 初始化的效果，生成git） </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps24.png" alt="img"></p><h3 id="3-3-查看本地库状态"><a href="#3-3-查看本地库状态" class="headerlink" title="*3.3* 查看本地库状态"></a><em><strong>*3.3*</strong></em> 查看本地库状态</h3><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git status*</strong></em> </p><p><strong>2）</strong> 案例实操 </p><h4 id="3-3-1-首次查看（工作区没有任何文件）"><a href="#3-3-1-首次查看（工作区没有任何文件）" class="headerlink" title="*3.3.1* 首次查看（工作区没有任何文件）"></a><em><strong>*3.3.1*</strong></em> 首次查看（工作区没有任何文件）</h4><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git status*</strong></em> On branch master  No commits yet  nothing to commit (create/copy files and use “git add” to track) </p><h4 id="3-3-2-新增文件（-hello-txt-）"><a href="#3-3-2-新增文件（-hello-txt-）" class="headerlink" title="*3.3.2* 新增文件（****hello.txt****）"></a><em><strong>*3.3.2*</strong></em> 新增文件（****hello.txt****）</h4><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*vim hello.txt*</strong></em> hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu!  </p><h5 id="3-3-3-再次查看（检测到未追踪的文件）"><a href="#3-3-3-再次查看（检测到未追踪的文件）" class="headerlink" title="*3.3.3* 再次查看（检测到未追踪的文件）"></a><em><strong>*3.3.3*</strong></em> 再次查看（检测到未追踪的文件）</h5><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git status*</strong></em> On branch master  No commits yet  Untracked files:  (use “git add <file>…” to include in what will be committed)      hello.txt  nothing added to commit but untracked files present (use “git add” to track) </p><h3 id="3-4-添加暂存区"><a href="#3-4-添加暂存区" class="headerlink" title="*3.4* 添加暂存区"></a><em><strong>*3.4*</strong></em> 添加暂存区</h3><h4 id="3-4-1-将工作区的文件添加到暂存区"><a href="#3-4-1-将工作区的文件添加到暂存区" class="headerlink" title="*3.4.1* 将工作区的文件添加到暂存区"></a><em><strong>*3.4.1*</strong></em> 将工作区的文件添加到暂存区</h4><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git*</strong></em> <em><strong>*add*</strong></em> 文件名 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git add hello.txt*</strong></em> warning: LF will be replaced by CRLF in hello.txt. The file will have its original line endings in your working directory. </p><h4 id="3-4-2-查看状态（检测到暂存区有新文件）"><a href="#3-4-2-查看状态（检测到暂存区有新文件）" class="headerlink" title="*3.4.2* 查看状态（检测到暂存区有新文件）"></a><em><strong>*3.4.2*</strong></em> 查看状态（检测到暂存区有新文件）</h4><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git status*</strong></em> </p><p>On branch master </p><p>No commits yet </p><p>Changes to be committed: </p><p> (use “git rm –cached <file>…” to unstage) </p><p>​    new file:  hello.txt </p><h3 id="3-5-提交本地库"><a href="#3-5-提交本地库" class="headerlink" title="*3.5* 提交本地库"></a><em><strong>*3.5*</strong></em> 提交本地库</h3><h4 id="3-5-1-将暂存区的文件提交到本地库"><a href="#3-5-1-将暂存区的文件提交到本地库" class="headerlink" title="*3.5.1* 将暂存区的文件提交到本地库"></a><em><strong>*3.5.1*</strong></em> 将暂存区的文件提交到本地库</h4><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git*</strong></em> <em><strong>*commit*</strong></em> <em><strong>*-m “*<em><strong>日志信息</strong></em>*“*</strong></em> 文件名 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git commit -m “my first commit” hello.txt*</strong></em> warning: LF will be replaced by CRLF in hello.txt. The file will have its original line endings in your working directory. [master (root-commit) 86366fa] my first commit  1 file changed, 16 insertions(+)  create mode 100644 hello.txt </p><h4 id="3-5-2-查看状态（没有文件需要提交）"><a href="#3-5-2-查看状态（没有文件需要提交）" class="headerlink" title="*3.5.2* 查看状态（没有文件需要提交）"></a><em><strong>*3.5.2*</strong></em> 查看状态（没有文件需要提交）</h4><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p><em><strong>*$ git status*</strong></em> On branch master </p><p>nothing to commit, working tree clean </p><h2 id="3-6-修改文件（-hello-txt-）"><a href="#3-6-修改文件（-hello-txt-）" class="headerlink" title="*3.6* 修改文件（****hello.txt****）"></a><em><strong>*3.6*</strong></em> 修改文件（****hello.txt****）</h2><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*vim hello.txt*</strong></em> hello git! hello atguigu! 2222222222222 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! </p><h3 id="3-6-1-查看状态（检测到工作区有文件被修改）"><a href="#3-6-1-查看状态（检测到工作区有文件被修改）" class="headerlink" title="*3.6.1* 查看状态（检测到工作区有文件被修改）"></a><em><strong>*3.6.1*</strong></em> 查看状态（检测到工作区有文件被修改）</h3><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git status*</strong></em> On branch master Changes not staged for commit:  (use “git add <file>…” to update what will be committed)  (use “git checkout – <file>…” to discard changes in working directory)      modified:  hello.txt  no changes added to commit (use “git add” and/or “git commit -a”) </p><h3 id="3-6-2-将修改的文件再次添加暂存区"><a href="#3-6-2-将修改的文件再次添加暂存区" class="headerlink" title="*3.6.2* 将修改的文件再次添加暂存区"></a><em><strong>*3.6.2*</strong></em> 将修改的文件再次添加暂存区</h3><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git add hello.txt*</strong></em> warning: LF will be replaced by CRLF in hello.txt. The file will have its original line endings in your working directory. </p><h3 id="3-6-3-查看状态（工作区的修改添加到了暂存区）"><a href="#3-6-3-查看状态（工作区的修改添加到了暂存区）" class="headerlink" title="*3.6.3* 查看状态（工作区的修改添加到了暂存区）"></a><em><strong>*3.6.3*</strong></em> 查看状态（工作区的修改添加到了暂存区）</h3><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git status*</strong></em> </p><p>On branch master Changes to be committed: </p><p> (use “git reset HEAD <file>…” to unstage) </p><p>​    modified:  hello.txt </p><h3 id="3-7-历史版本"><a href="#3-7-历史版本" class="headerlink" title="*3.7* 历史版本"></a><em><strong>*3.7*</strong></em> 历史版本</h3><h4 id="3-7-1-查看历史版本"><a href="#3-7-1-查看历史版本" class="headerlink" title="*3.7.1* 查看历史版本"></a><em><strong>*3.7.1*</strong></em> 查看历史版本</h4><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git reflog*</strong></em>  查看版本信息 <em><strong>*git log*</strong></em>  查看版本详细信息 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git reflog*</strong></em> </p><p>087a1a7 (HEAD -&gt; master) HEAD@{0}: commit: my third commit ca8ded6 HEAD@{1}: commit: my second commit 86366fa HEAD@{2}: commit (initial): my first commit </p><h4 id="3-7-2-版本穿梭"><a href="#3-7-2-版本穿梭" class="headerlink" title="*3.7.2* 版本穿梭"></a><em><strong>*3.7.2*</strong></em> 版本穿梭</h4><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git reset –hard*</strong></em> 版本号 </p><p><strong>2）</strong> 案例实操 </p><p>–首先查看当前的历史记录，可以看到当前是在087a1a7这个版本 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git reflog*</strong></em> 087a1a7 (HEAD -&gt; master) HEAD@{0}: commit: my third commit ca8ded6 HEAD@{1}: commit: my second commit 86366fa HEAD@{2}: commit (initial): my first commit  –切换到86366fa版本，也就是我们第一次提交的版本 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git reset –hard 86366fa*</strong></em> HEAD is now at 86366fa my first commit  –切换完毕之后再查看历史记录，当前成功切换到了86366fa版本 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git reflog*</strong></em> 86366fa (HEAD -&gt; master) HEAD@{0}: reset: moving to 86366fa 087a1a7 HEAD@{1}: commit: my third commit ca8ded6 HEAD@{2}: commit: my second commit 86366fa (HEAD -&gt; master) HEAD@{3}: commit (initial): my first commit  –然后查看文件hello.txt，发现文件内容已经变化 $ cat hello.txt hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! </p><p>hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! </p><p>Git 切换版本，底层其实是移动的 HEAD 指针，具体原理如下图所示。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps25.png" alt="img"></p><h1 id="第-4-章-Git-分支操作"><a href="#第-4-章-Git-分支操作" class="headerlink" title="第 *4* 章 *Git* 分支操作"></a>第 <em><strong>*4*</strong></em> 章 <em><strong>*Git*</strong></em> 分支操作</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps26.png" alt="img"></p><h2 id="4-1-什么是分支"><a href="#4-1-什么是分支" class="headerlink" title="*4.1* 什么是分支"></a><em><strong>*4.1*</strong></em> 什么是分支</h2><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用） </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps27.png" alt="img"></p><p><em><strong>*4.2*</strong></em> 分支的好处同时并行推进多个功能开发，提高开发效率。 </p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。 </p><h2 id="4-3-分支的操作"><a href="#4-3-分支的操作" class="headerlink" title="*4.3* 分支的操作"></a><em><strong>*4.3*</strong></em> 分支的操作</h2><table><thead><tr><th>命令名称</th><th>作用</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>git branch -v</td><td></td><td></td><td>查看分支</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>git checkout 分支名</td><td>切换分支</td><td></td><td></td><td></td><td></td></tr><tr><td>git merge 分支名</td><td></td><td>把指定的分支合并到当前分支上</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="4-3-1-查看分支"><a href="#4-3-1-查看分支" class="headerlink" title="*4.3.1* 查看分支"></a><em><strong>*4.3.1*</strong></em> 查看分支</h3><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git branch -v*</strong></em> </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git branch -v*</strong></em> </p><p>* master 087a1a7 my third commit  （*代表当前所在的分区） </p><h3 id="4-3-2-创建分支"><a href="#4-3-2-创建分支" class="headerlink" title="*4.3.2* 创建分支"></a><em><strong>*4.3.2*</strong></em> 创建分支</h3><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git branch*</strong></em> 分支名 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$  <em><strong>*git branch hot-fix*</strong></em> </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git branch -v*</strong></em> </p><p> hot-fix 087a1a7 my third commit  （刚创建的新的分支，并将主分支master 的内容复制了一份） </p><p>* master  087a1a7 my third commit </p><h3 id="4-3-3-修改分支"><a href="#4-3-3-修改分支" class="headerlink" title="*4.3.3* 修改分支"></a><em><strong>*4.3.3*</strong></em> 修改分支</h3><p>–在maste分支上做修改 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*vim hello.txt*</strong></em> </p><p>–添加暂存区 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git add hello.txt*</strong></em> –提交本地库 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git commit -m “my forth commit” hello.txt*</strong></em> [master f363b4c] my forth commit  1 file changed, 1 insertion(+), 1 deletion(-) –查看分支 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git branch -v*</strong></em>  hot-fix 087a1a7 my third commit  （hot-fix分支并未做任何改变） * master  f363b4c my forth commit （当前master分支已更新为最新一次提交的版本） –查看master分支上的文件内容 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ cat hello.txt hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 3333333333333 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! master test hello git! hello atguigu!  </p><h3 id="4-3-4-切换分支"><a href="#4-3-4-切换分支" class="headerlink" title="*4.3.4* 切换分支"></a><em><strong>*4.3.4*</strong></em> 切换分支</h3><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git checkout*</strong></em> 分支名 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 <em><strong>*(master)*</strong></em> $ <em><strong>*git checkout hot-fix*</strong></em> Switched to branch ‘hot-fix’ –发现当先分支已由master改为hot-fix Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 <em><strong>*(hot-fix)*</strong></em> $ –查看hot-fix分支上的文件内容发现与master分支上的内容不同 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 <em><strong>*(hot-fix)*</strong></em> $ cat hello.txt hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 3333333333333 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! </p><p>hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! -在hot-fix分支上做修改 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 <em><strong>*(hot-fix)*</strong></em> $ cat hello.txt hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 3333333333333 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hot-fix test –添加暂存区 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 <em><strong>*(hot-fix)*</strong></em> <em><strong>*git add hello.txt*</strong></em> –提交本地库 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 <em><strong>*(hot-fix)*</strong></em> <em><strong>*git commit -m “hot-fix commit” hello.txt*</strong></em> </p><p>-</p><p>$ </p><p>$ </p><h3 id="4-3-5-合并分支"><a href="#4-3-5-合并分支" class="headerlink" title="*4.3.5* 合并分支"></a><em><strong>*4.3.5*</strong></em> 合并分支</h3><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git merge*</strong></em> 分支名 </p><p><strong>2）</strong> 案例实操 在 <em><strong>*master*</strong></em> 分支上合并 <em><strong>*hot-fix*</strong></em> 分支 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git merge hot-fix*</strong></em> Auto-merging hello.txt CONFLICT (content): Merge conflict in hello.txt Automatic merge failed; fix conflicts and then commit the result. </p><h3 id="4-3-6-产生冲突"><a href="#4-3-6-产生冲突" class="headerlink" title="*4.3.6* 产生冲突"></a><em><strong>*4.3.6*</strong></em> 产生冲突</h3><p>冲突产生的表现：后面状态为 MERGING </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master|MERGING) </p><p>$ cat hello.txt hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 3333333333333 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD hello git! hello atguigu! master test hello git! hello atguigu! ======= hello git! hello atguigu! hello git! hello atguigu! hot-fix test &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix </p><p>冲突产生的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须人为决定新代码内容。 </p><p>查看状态（检测到有文件有两处修改） </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master|MERGING) </p><p>$ <em><strong>*git status*</strong></em> </p><p>On branch master </p><p>You have unmerged paths. </p><p> (fix conflicts and run “git commit”) </p><p> (use “git merge –abort” to abort the merge) </p><p>Unmerged paths: </p><p> (use “git add <file>…” to mark resolution) </p><p>​    both modified:  hello.txt </p><p>no changes added to commit (use “git add” and/or “git commit -a”)  </p><h3 id="4-3-7-解决冲突"><a href="#4-3-7-解决冲突" class="headerlink" title="*4.3.7* 解决冲突"></a><em><strong>*4.3.7*</strong></em> 解决冲突</h3><p>1） 编辑有冲突的文件，删除特殊符号，决定要使用的内容 </p><p>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 =======  合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix </p><p>hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 3333333333333 hello git! hello atguigu! </p><p>hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! master test hello git! hello atguigu! hot-fix test </p><p>2） 添加到暂存区 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master|MERGING) </p><p>$ <em><strong>*git add hello.txt*</strong></em> </p><p>3） 执行提交（注意：此时使用 git commit 命令时不能带文件名） </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master|MERGING) $ <em><strong>*git commit -m “merge hot-fix”*</strong></em> [master 69ff88d] merge hot-fix –发现后面MERGING消失，变为正常 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ </p><h2 id="4-4-创建分支和切换分支图解"><a href="#4-4-创建分支和切换分支图解" class="headerlink" title="*4.4* 创建分支和切换分支图解"></a><em><strong>*4.4*</strong></em> 创建分支和切换分支图解</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps28.png" alt="img"></p><p>master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD</p><p>决定的。所以创建分支的本质就是多创建一个指针。 </p><p>HEAD 如果指向 master，那么我们现在就在 master 分支上。 </p><p>HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。 </p><p>所以切换分支的本质就是移动 HEAD 指针。 </p><h1 id="第-5-章-Git-团队协作机制"><a href="#第-5-章-Git-团队协作机制" class="headerlink" title="第 *5* 章 *Git* 团队协作机制"></a>第 <em><strong>*5*</strong></em> 章 <em><strong>*Git*</strong></em> 团队协作机制</h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps29.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps30.png" alt="img"></p><h1 id="第-6-章-GitHub-操作"><a href="#第-6-章-GitHub-操作" class="headerlink" title="第 *6* 章 *GitHub* 操作"></a>第 <em><strong>*6*</strong></em> 章 <em><strong>*GitHub*</strong></em> 操作</h1><p>GitHub 网址<a href="https://github.com/">：</a><a href="https://github.com/[">https://github.com/[</a> ](<a href="https://github.com/">https://github.com/</a>)</p><p>Ps:全球最大同性交友网站，技术宅男的天堂，新世界的大门，你还在等什么? </p><table><thead><tr><th>账号</th><th>姓名</th><th>验证邮箱</th></tr></thead><tbody><tr><td>atguiguyueyue</td><td>岳不群</td><td><a href="mailto:&#x61;&#x74;&#x67;&#x75;&#x69;&#x67;&#x75;&#121;&#x75;&#x65;&#121;&#117;&#x65;&#64;&#x61;&#108;&#105;&#x79;&#117;&#110;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#x74;&#x67;&#x75;&#x69;&#x67;&#x75;&#121;&#x75;&#x65;&#121;&#117;&#x65;&#64;&#x61;&#108;&#105;&#x79;&#117;&#110;&#x2e;&#99;&#x6f;&#x6d;</a></td></tr><tr><td>atguigulinghuchong</td><td>令狐冲</td><td><a href="mailto:&#97;&#x74;&#103;&#117;&#105;&#103;&#117;&#x6c;&#x69;&#110;&#x67;&#104;&#117;&#99;&#x68;&#111;&#110;&#x67;&#64;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;">&#97;&#x74;&#103;&#117;&#105;&#103;&#117;&#x6c;&#x69;&#110;&#x67;&#104;&#117;&#99;&#x68;&#111;&#110;&#x67;&#64;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></td></tr><tr><td>atguigudongfang1</td><td>东方不败</td><td><a href="mailto:&#97;&#x74;&#x67;&#x75;&#105;&#x67;&#x75;&#100;&#x6f;&#110;&#x67;&#x66;&#x61;&#x6e;&#103;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;">&#97;&#x74;&#x67;&#x75;&#105;&#x67;&#x75;&#100;&#x6f;&#110;&#x67;&#x66;&#x61;&#x6e;&#103;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></td></tr></tbody></table><p>注:此三个账号为讲师使用账号，同学请自行注册，然后三个同学为一组进行团队协作！ </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps31.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps32.png" alt="img"></p><table><thead><tr><th>命令名称</th><th></th><th>作用</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>git remote -v</td><td></td><td></td><td></td><td>查看当前所有远程地址别名</td><td></td></tr><tr><td></td><td>git remote add 别名 远程地址</td><td></td><td></td><td></td><td>起别名</td><td></td></tr><tr><td></td><td>git push 别名 分支</td><td></td><td></td><td></td><td>推送本地分支上的内容到远程仓库</td><td></td></tr><tr><td></td><td>git clone 远程地址</td><td></td><td></td><td></td><td>将远程仓库的内容克隆到本地</td><td></td></tr><tr><td></td><td>git pull 远程库地址别名 远程分支名</td><td></td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="6-2-1-创建远程仓库别名"><a href="#6-2-1-创建远程仓库别名" class="headerlink" title="*6.2.1* 创建远程仓库别名"></a><em><strong>*6.2.1*</strong></em> 创建远程仓库别名</h2><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git remote -v*</strong></em> 查看当前所有远程地址别名 <em><strong>*git remote add*</strong></em> 别名 远程地址 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git remote -v*</strong></em> Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git remote add ori <a href="https://github.com/atguiguyueyue/git-shTest.git/">https://github.com/atguiguyueyue/git-shTest.git\</a>*</strong></em>  Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git remote -v*</strong></em> ori   <a href="https://github.com/atguiguyueyue/git-shTest.git">https://github.com/atguiguyueyue/git-shTest.git</a> (fetch) ori   <a href="https://github.com/atguiguyueyue/git-shTest.git">https://github.com/atguiguyueyue/git-shTest.git</a> (push) </p><p><em><strong>*<a href="https://github.com/atguiguyueyue/git-shTest.git/">https://github.com/atguiguyueyue/git-shTest.git\</a>*</strong></em> </p><p>这个地址在创建完远程仓库后生成的连接，如图所示红框中 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps33.png" alt="img"></p><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git push*</strong></em> 别名 分支 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ <em><strong>*git push ori master*</strong></em> </p><p>Logon failed, use ctrl+c to cancel basic credential prompt. Username for ‘<a href="https://github.com&/#39;">https://github.com&#39;</a>: atguiguyueyue </p><p>Counting objects: 3, done. </p><p>Delta compression using up to 12 threads. </p><p>Compressing objects: 100% (2/2), done. </p><p>Writing objects: 100% (3/3), 276 bytes | 276.00 KiB/s, done. </p><p>Total 3 (delta 0), reused 0 (delta 0) </p><p>To <a href="https://github.com/atguiguyueyue/git-shTest.git">https://github.com/atguiguyueyue/git-shTest.git</a> </p><p> * [new branch]    master -&gt; master </p><p>此时发现已将我们 master 分支上的内容推送到 GitHub 创建的远程仓库。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps34.png" alt="img"></p><h2 id="6-2-3-克隆远程仓库到本地"><a href="#6-2-3-克隆远程仓库到本地" class="headerlink" title="*6.2.3* 克隆远程仓库到本地"></a><em><strong>*6.2.3*</strong></em> 克隆远程仓库到本地</h2><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git clone*</strong></em> 远程地址 </p><p><strong>2）</strong> 案例实操 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong $ <em><strong>*git clone <a href="https://github.com/atguiguyueyue/git-shTest.git/">https://github.com/atguiguyueyue/git-shTest.git\</a>*</strong></em> Cloning into ‘git-shTest’… remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. </p><p><em><strong>*<a href="https://github.com/atguiguyueyue/git-shTest.git/">https://github.com/atguiguyueyue/git-shTest.git\</a>*</strong></em> </p><p>–创建远程仓库别名 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong/git-shTest(master) $ git remote -v origin  <a href="https://github.com/atguiguyueyue/git-shTest.git">https://github.com/atguiguyueyue/git-shTest.git</a> (fetch) origin  <a href="https://github.com/atguiguyueyue/git-shTest.git">https://github.com/atguiguyueyue/git-shTest.git</a> (push) </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps35.png" alt="img">这个地址为远程仓库地址，克隆结果：初始化本地仓库 </p><p>小结：clone 会做如下操作。1、拉取代码。2、初始化本地仓库。3、创建别名 </p><h2 id="6-2-4-邀请加入团队"><a href="#6-2-4-邀请加入团队" class="headerlink" title="*6.2.4* 邀请加入团队"></a><em><strong>*6.2.4*</strong></em> 邀请加入团队</h2><p>****1****）选择邀请合作者 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps36.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps37.png" alt="img"></p><p><em><strong>*3*</strong></em> ）复制地址并通过微信钉钉等方式发送给该用户，复制内容如下：</p><p><em><strong>*<a href="https://github.com/atguiguyueyue/git-shTest/invitations/">https://github.com/atguiguyueyue/git-shTest/invitations\</a>*</strong></em> </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps38.png" alt="img"> </p><p><strong>4）</strong> 在 <em><strong>*atguigulinghuchong*</strong></em> 这个账号中的地址栏复制收到邀请的链接，点击接受邀请。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps39.png" alt="img"></p><p><strong>5）</strong> 成功之后可以在 <em><strong>*atguigulinghuchong*</strong></em> 这个账号上看到 <em><strong>*git-Test*</strong></em> 的远程仓库。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps40.png" alt="img"></p><p><strong>6）</strong> 令狐冲可以修改内容并 <em><strong>*push*</strong></em> 到远程仓库。 </p><p>–编辑clone下来的文件 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong/git-shTest(master) $ vim hello.txt  Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong/git-shTest(master) $ cat hello.txt hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 33333333333333 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! 我是最帅的，比岳不群还帅 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! master test hello git! hello atguigu! hot-fix test –将编辑好的文件添加到暂存区 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong/git-shTest</p><p>(master) </p><p>$ git add hello.txt </p><p>–将暂存区的文件上传到本地库 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong/git-shTest </p><p>(master) </p><p>$ git commit -m “lhc commit” hello.txt </p><p>[master 5dabe6b] lhc commit </p><p> 1 file changed, 1 insertion(+), 1 deletion(-) </p><p>–将本地库的内容push到远程仓库 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/pro-linghuchong/git-shTest </p><p>(master) </p><p>$ git push origin master </p><p>Logon failed, use ctrl+c to cancel basic credential prompt. Username for ‘<a href="https://github.com&/#39;">https://github.com&#39;</a>: atguigulinghuchong </p><p>Counting objects: 3, done. </p><p>Delta compression using up to 12 threads. </p><p>Compressing objects: 100% (2/2), done. </p><p>Writing objects: 100% (3/3), 309 bytes | 309.00 KiB/s, done. Total 3 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), completed with 1 local object. </p><p>To <a href="https://github.com/atguiguyueyue/git-shTest.git">https://github.com/atguiguyueyue/git-shTest.git</a>   7cb4d02..5dabe6b  master -&gt; master </p><p>****7****）回到 <em><strong>*atguiguyueyue*</strong></em> 的 <em><strong>*GitHub*</strong></em> 远程仓库中可以看到，最后一次是 <em><strong>*lhc*</strong></em> 提交的。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps41.png" alt="img"></p><h2 id="6-2-5-拉取远程库内容"><a href="#6-2-5-拉取远程库内容" class="headerlink" title="*6.2.5* 拉取远程库内容"></a><em><strong>*6.2.5*</strong></em> 拉取远程库内容</h2><p><strong>1）</strong> 基本语法 </p><p><em><strong>*git pull*</strong></em> 远程库地址别名 远程分支名 </p><p><strong>2）</strong> 案例实操 </p><p>–将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并 Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ <em><strong>*git pull ori master*</strong></em> remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (1/1), done. remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0 Unpacking objects: 100% (3/3), done. From <a href="https://github.com/atguiguyueyue/git-shTest">https://github.com/atguiguyueyue/git-shTest</a>  * branch       master   -&gt; FETCH_HEAD   7cb4d02..5dabe6b  master   -&gt; ori/master Updating 7cb4d02..5dabe6b Fast-forward  hello.txt | 2 +-  1 file changed, 1 insertion(+), 1 deletion(-) Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) $ cat hello.txt hello git! hello atguigu! 2222222222222 hello git! hello atguigu! 33333333333333 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! 我是最帅的，比岳不群还帅 hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! master test hello git! hello atguigu! hot-fix test </p><h2 id="6-3-跨团队协作"><a href="#6-3-跨团队协作" class="headerlink" title="*6.3* 跨团队协作"></a><em><strong>*6.3*</strong></em> 跨团队协作</h2><p><strong>1）</strong> 将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps42.png" alt="img"></p><p><strong>2）</strong> 在东方不败的 <em><strong>*GitHub*</strong></em> 账号里的地址栏复制收到的链接，然后点击 <em><strong>*Fork*</strong></em> 将项目叉到自己的本地仓库。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps43.png" alt="img"> </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps44.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps45.png" alt="img"></p><p><strong>3）</strong> 东方不败就可以在线编辑叉取过来的文件。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps46.png" alt="img"></p><p><strong>4）</strong> 编辑完毕后，填写描述信息并点击左下角绿色按钮提交。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps47.png" alt="img"></p><p><strong>5）</strong> 接下来点击上方的 <em><strong>*Pull*</strong></em> 请求，并创建一个新的请求。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps48.png" alt="img"> </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps49.png" alt="img"></p><p><strong>6）</strong> 回到岳岳 <em><strong>*GitHub*</strong></em> 账号可以看到有一个 <em><strong>*Pull request*</strong></em> 请求。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps50.png" alt="img"></p><p>进入到聊天室，可以讨论代码相关内容。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps51.png" alt="img"></p><p><strong>7）</strong> 如果代码没有问题，可以点击 <em><strong>*Merge pull reque*</strong></em> 合并代码。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps52.png" alt="img"></p><p>我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps53.png" alt="img"></p><p>–进入当前用户的家目录 </p><p>Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master) </p><p>$ cd </p><p>–删除.ssh目录 </p><p>Layne@LAPTOP-Layne MINGW64 ~ </p><p>$ rm -rvf .ssh removed ‘.ssh/known_hosts’ </p><p>removed directory ‘.ssh’ –运行命令生成.ssh秘钥目录[注意：这里-C这个参数是大写的C] Layne@LAPTOP-Layne MINGW64 ~ $ ssh-keygen -t rsa -C <a href="mailto:&#97;&#x74;&#103;&#117;&#105;&#103;&#x75;&#x79;&#x75;&#101;&#x79;&#117;&#101;&#x40;&#x61;&#108;&#x69;&#x79;&#117;&#110;&#x2e;&#x63;&#111;&#x6d;">&#97;&#x74;&#103;&#117;&#105;&#103;&#x75;&#x79;&#x75;&#101;&#x79;&#117;&#101;&#x40;&#x61;&#108;&#x69;&#x79;&#117;&#110;&#x2e;&#x63;&#111;&#x6d;</a> Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Layne/.ssh/id_rsa): Created directory ‘/c/Users/Layne/.ssh’. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/Layne/.ssh/id_rsa. Your public key has been saved in /c/Users/Layne/.ssh/id_rsa.pub. The key fingerprint is: SHA256:7CPfRLITKcYDhaqpEDeok7Atvwh2reRmpxxOC6dkY44 <a href="mailto:&#x61;&#x74;&#103;&#117;&#105;&#x67;&#117;&#x79;&#x75;&#x65;&#121;&#117;&#x65;&#x40;&#97;&#x6c;&#105;&#121;&#x75;&#x6e;&#46;&#99;&#111;&#109;">&#x61;&#x74;&#103;&#117;&#105;&#x67;&#117;&#x79;&#x75;&#x65;&#121;&#117;&#x65;&#x40;&#97;&#x6c;&#105;&#121;&#x75;&#x6e;&#46;&#99;&#111;&#109;</a> The key’s randomart image is: +—[RSA 2048]—-+ |   ..      | |   ..      | | . ..       | |+ +  o . .    | |oO .  = S .    | |X . .. + =    | |+@ * .. = .    | |X.&amp;o+. o =    | |Eo+Oo  . .    | +—-[SHA256]—–+ –进入.ssh目录查看文件列表 Layne@LAPTOP-Layne MINGW64 ~ $ cd .ssh Layne@LAPTOP-Layne MINGW64 ~/.ssh $ ll -a total 21 drwxr-xr-x 1 Layne 197609   0 11月 25 19:27 ./ drwxr-xr-x 1 Layne 197609   0 11月 25 19:27 ../ -rw-r–r– 1 Layne 197609 1679 11月 25 19:27 id_rsa -rw-r–r– 1 Layne 197609  406 11月 25 19:27 id_rsa.pub –查看id_rsa.pub文件内容 Layne@LAPTOP-Layne MINGW64 ~/.ssh $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDRXRsk9Ohtg1AXLltsuNRAGBsx3ypE1O1Rkdzpm l1woa6y6G62lZri3XtCH0F7GQvnMvQtPISJFXXWo+jFHZmqYQa/6kOIMv2sszcoj2Qtwl lGXTPn/4T2h/cHjSHfc+ks8OYP7OWOOefpOCbYY/7DWYrl89k7nQlfd+A1FV/vQmcsa1L P5ihqjpjms2CoUUen8kZHbjwHBAHQHWRE+Vc371MG/dwINvCi8n7ibI86o2k0dW0+8SL+ svPV/Y0G9m+RAqgec8b9U6DcSSAMH5uq4UWfnAcUNagb/aJQLytrH0pLa8nMv3XdSGNNoAGBFeW2+K81XrmkP27FrLI6lDef <a href="mailto:&#97;&#116;&#103;&#x75;&#x69;&#103;&#x75;&#x79;&#x75;&#101;&#x79;&#x75;&#x65;&#64;&#x61;&#108;&#105;&#x79;&#x75;&#x6e;&#x2e;&#99;&#111;&#109;">&#97;&#116;&#103;&#x75;&#x69;&#103;&#x75;&#x79;&#x75;&#101;&#x79;&#x75;&#x65;&#64;&#x61;&#108;&#105;&#x79;&#x75;&#x6e;&#x2e;&#99;&#111;&#109;</a> </p><p>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps54.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps55.png" alt="img"></p><p>接下来再往远程仓库 push 东西的时候使用 SSH 连接就不需要登录了。 </p><h1 id="第-7-章-IDEA-集成-Git"><a href="#第-7-章-IDEA-集成-Git" class="headerlink" title="第 *7* 章 *IDEA* 集成 *Git*"></a>第 <em><strong>*7*</strong></em> 章 <em><strong>*IDEA*</strong></em> 集成 <em><strong>*Git*</strong></em></h1><h2 id="7-1-配置-Git-忽略文件"><a href="#7-1-配置-Git-忽略文件" class="headerlink" title="*7.1* 配置 *Git* 忽略文件"></a><em><strong>*7.1*</strong></em> 配置 <em><strong>*Git*</strong></em> 忽略文件</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps56.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps57.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps58.png" alt="img"></p><p>问题 ****1:****为什么要忽略他们？答：与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。 </p><p>问题 ****2****：怎么忽略？ </p><h3 id="1）创建忽略规则文件-xxxx-ignore（前缀名随便起，建议是-git-ignore）"><a href="#1）创建忽略规则文件-xxxx-ignore（前缀名随便起，建议是-git-ignore）" class="headerlink" title="1）创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）"></a>1）创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）</h3><p>这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，建议也放在用户家目录下 </p><p>git.ignore 文件模版内容如下： </p><p># Compiled class file </p><p>*.class </p><table><thead><tr><th># Log file *.log  # BlueJ files *.ctxt  # Mobile Tools for Java (J2ME) .mtj.tmp/  # Package Files # *.jar *.war *.nar *.ear *.zip *.tar.gz <em>.rar  #     virtual     machine <a href="http://www.java.com/en/download/help/error_hotspot.xml">http://www.java.com/en/download/help/error_hotspot.xml</a> hs_err_pid</em>  .classpath .project .settings target .idea *.iml</th><th>crash</th><th>logs,</th><th>see</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>2）在.gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中） </p><p>[user]  name = Layne  email = <a href="mailto:&#76;&#x61;&#x79;&#x6e;&#101;&#x40;&#x61;&#116;&#x67;&#x75;&#105;&#103;&#117;&#x2e;&#99;&#x6f;&#x6d;">&#76;&#x61;&#x79;&#x6e;&#101;&#x40;&#x61;&#116;&#x67;&#x75;&#105;&#103;&#117;&#x2e;&#99;&#x6f;&#x6d;</a> [core]  excludesfile = C:/Users/asus/git.ignore 注意：这里要使用“正斜线（/）”，不要使用“反斜线（\）” </p><h2 id="7-2-定位-Git-程序"><a href="#7-2-定位-Git-程序" class="headerlink" title="*7.2* 定位 *Git* 程序"></a><em><strong>*7.2*</strong></em> 定位 <em><strong>*Git*</strong></em> 程序</h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps59.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps60.png" alt="img"></p><p>选择要创建 Git 本地仓库的工程。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps61.png" alt="img"></p><p>右键点击项目选择 Git -&gt; Add 将项目添加到暂存区。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps62.png" alt="img"></p><h3 id="7-5-提交到本地库"><a href="#7-5-提交到本地库" class="headerlink" title="*7.5* 提交到本地库"></a><em><strong>*7.5*</strong></em> 提交到本地库</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps63.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps64.png" alt="img"></p><p>在 IDEA 的左下角，点击 Version Control，然后点击 Log 查看版本 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps65.png" alt="img"></p><p>右键选择要切换的版本，然后在菜单里点击 Checkout Revision。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps66.png" alt="img"></p><h3 id="7-7-创建分支"><a href="#7-7-创建分支" class="headerlink" title="*7.7* 创建分支"></a><em><strong>*7.7*</strong></em> 创建分支</h3><p>选择 Git，在 Repository 里面，点击 Branches 按钮。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps67.png" alt="img"></p><p>在弹出的 Git Branches 框里，点击 New Branch 按钮。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps68.png" alt="img"></p><p>填写分支名称，创建 hot-fix 分支。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps69.png" alt="img"></p><p> 然后再 IDEA 的右下角看到 hot-fix，说明分支创建成功，并且当前已经切换成 hot-fix 分</p><p>支 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps70.png" alt="img"></p><p>在 IDEA 窗口的右下角，切换到 master 分支。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps71.png" alt="img"></p><p>然后在 IDEA 窗口的右下角看到了 master，说明 master 分支切换成功。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps72.png" alt="img"></p><h3 id="7-9-合并分支"><a href="#7-9-合并分支" class="headerlink" title="*7.9* 合并分支"></a><em><strong>*7.9*</strong></em> 合并分支</h3><p>在 IDEA 窗口的右下角，将 hot-fix 分支合并到当前 master 分支。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps73.png" alt="img"></p><p>如果代码没有冲突，分支直接合并成功，分支合并成功以后，代码自动提交，无需手动</p><p>提交本地库。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps74.png" alt="img"></p><p>如图所示，如果 master 分支和 hot-fix 分支都修改了代码，在合并分支的时候就会发生冲突。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps75.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps76.png" alt="img"></p><p>我们现在站在 master 分支上合并 hot-fix 分支，就会发生代码冲突。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps77.png" alt="img"></p><p> 点击 Conflicts 框里的 Merge 按钮，进行手动合并代码。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps78.png" alt="img"></p><p> 手动合并完代码以后，点击右下角的 Apply 按钮。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps79.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps80.png" alt="img"></p><h1 id="第-8-章-IDEA-集成-GitHub"><a href="#第-8-章-IDEA-集成-GitHub" class="headerlink" title="第 *8* 章 *IDEA* 集成 *GitHub*"></a>第 <em><strong>*8*</strong></em> 章 <em><strong>*IDEA*</strong></em> 集成 <em><strong>*GitHub*</strong></em></h1><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps81.png" alt="img"></p><p>如果出现 401 等情况连接不上的，是因为网络原因，可以使用以下方式连接： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps82.png" alt="img"></p><p>然后去 GitHub 账户上设置 token。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps83.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps84.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps85.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps86.png" alt="img"></p><p>点击登录。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps87.png" alt="img"></p><h2 id="8-2-分享工程到-GitHub"><a href="#8-2-分享工程到-GitHub" class="headerlink" title="*8.2* 分享工程到 *GitHub*"></a><em><strong>*8.2*</strong></em> 分享工程到 <em><strong>*GitHub*</strong></em></h2><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps88.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps89.png" alt="img"> </p><p>来到 GitHub 中发现已经帮我们创建好了 gitTest 的远程仓库。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps90.png" alt="img"></p><p>右键点击项目，可以将当前分支的内容 push 到 GitHub 的远程仓库中。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps91.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps92.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps93.png" alt="img"></p><p>注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致， push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高！因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地</p><p>代码更新到最新以后，然后再修改，提交，推送！ </p><h3 id="8-4-pull-拉取远程库到本地库"><a href="#8-4-pull-拉取远程库到本地库" class="headerlink" title="*8.4 pull* 拉取远程库到本地库"></a><em><strong>*8.4 pull*</strong></em> 拉取远程库到本地库</h3><p>右键点击项目，可以将远程仓库的内容 pull 到本地仓库。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps94.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps95.png" alt="img"></p><p>注意：pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。 </p><h3 id="8-5-clone-克隆远程库到本地"><a href="#8-5-clone-克隆远程库到本地" class="headerlink" title="*8.5 clone* 克隆远程库到本地"></a><em><strong>*8.5 clone*</strong></em> 克隆远程库到本地</h3><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps96.png" alt="img"></p><p>为 clone 下来的项目创建一个工程，然后点击 Next。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps97.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps98.png" alt="img"></p><h2 id="第-9-章-国内代码托管中心-码云"><a href="#第-9-章-国内代码托管中心-码云" class="headerlink" title="第 *9* 章 国内代码托管中心****-****码云"></a>第 <em><strong>*9*</strong></em> 章 国内代码托管中心****-****码云</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="*9.1* 简介"></a><em><strong>*9.1*</strong></em> 简介</h3><p>众所周知，GitHub 服务器在国外，使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况，大家也可以使用国内的项目托管网站-码云。 </p><p>码云是开源中国推出的基于 <a href="https://link.jianshu.com/?t=http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000">Git</a> <a href="https://link.jianshu.com/?t=http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000">的</a>代码托管服务中心，网址是 <a href="https://gitee.com/">https://gitee.com/</a> ，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好它是最好的选择。 </p><h4 id="9-2-码云帐号注册和登录"><a href="#9-2-码云帐号注册和登录" class="headerlink" title="*9.2* 码云帐号注册和登录"></a><em><strong>*9.2*</strong></em> 码云帐号注册和登录</h4><p>进入码云官网地址：<a href="https://gitee.com/[%EF%BC%8C](https://gitee.com/)%E7%82%B9%E5%87%BB%E6%B3%A8%E5%86%8C">https://gitee.com/[，](https://gitee.com/)点击注册</a> Gitee </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps99.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps100.png" alt="img"></p><p> 帐号注册成功以后，直接登录。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps101.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps102.png" alt="img"></p><p>点击首页右上角的加号，选择下面的新建仓库 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps103.png" alt="img"></p><p>填写仓库名称，路径和选择是否开源（共开库或私有库） </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps104.png" alt="img"></p><p>最后根据需求选择分支模型，然后点击创建按钮。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps105.png" alt="img"></p><p>远程库创建好以后，就可以看到 HTTPS 和 SSH 的链接。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps106.png" alt="img"></p><h5 id="9-4-1-IDEA-安装码云插件"><a href="#9-4-1-IDEA-安装码云插件" class="headerlink" title="*9.4.1 IDEA* 安装码云插件"></a><em><strong>*9.4.1 IDEA*</strong></em> 安装码云插件</h5><p>Idea 默认不带码云插件，我们第一步要安装 Gitee 插件。 </p><p>如图所示，在 Idea 插件商店搜索 Gitee，然后点击右侧的 Install 按钮。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps107.png" alt="img"></p><p>Idea 链接码云和链接 GitHub 几乎一样，安装成功后，重启 Idea。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps108.png" alt="img"></p><p> Idea 重启以后在 Version Control 设置里面看到 Gitee，说明码云插件安装成功。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps109.png" alt="img"></p><p> 然后在码云插件里面添加码云帐号，我们就可以用 Idea 连接码云了。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps110.png" alt="img"></p><h5 id="9-4-2-IDEA-连接码云"><a href="#9-4-2-IDEA-连接码云" class="headerlink" title="*9.4.2 IDEA* 连接码云"></a><em><strong>*9.4.2 IDEA*</strong></em> 连接码云</h5><p>Idea 连接码云和连接 GitHub 几乎一样，首先在 Idea 里面创建一个工程，初始化 git 工程，然后将代码添加到暂存区，提交到本地库，这些步骤上面已经讲过，此处不再赘述。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps111.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps112.png" alt="img"></p><p>给远程库链接定义个 name，然后再 URL 里面填入码云远程库的 HTTPS 链接即可。码云服务器在国内，用 HTTPS 链接即可，没必要用 SSH 免密链接。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps113.png" alt="img"></p><p>然后选择定义好的远程链接，点击 Push 即可。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps114.png" alt="img"></p><p>看到提示就说明 Push 远程库成功。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps115.png" alt="img"></p><p>去码云远程库查看代码。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps116.png" alt="img"></p><p>只要码云远程库链接定义好以后，对码云远程库进行 pull 和 clone 的操作和 Github 一致，此处不再赘述。 </p><h3 id="9-5-码云复制-GitHub-项目"><a href="#9-5-码云复制-GitHub-项目" class="headerlink" title="*9.5* 码云复制 *GitHub* 项目"></a><em><strong>*9.5*</strong></em> 码云复制 <em><strong>*GitHub*</strong></em> 项目</h3><p>码云提供了直接复制 GitHub 项目的功能，方便我们做项目的迁移和下载。 </p><p>具体操作如下： </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps117.png" alt="img"></p><p> 将 GitHub 的远程库 HTTPS 链接复制过来，点击创建按钮即可。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps118.png" alt="img"></p><p>如果 GitHub 项目更新了以后，在码云项目端可以手动重新同步，进行更新！ </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps119.png" alt="img"></p><h2 id="第-10-章-自建代码托管平台-GitLab"><a href="#第-10-章-自建代码托管平台-GitLab" class="headerlink" title="第 *10* 章 自建代码托管平台*-GitLab*"></a>第 <em><strong>*10*</strong></em> 章 自建代码托管平台<em><strong>*-GitLab*</strong></em></h2><h3 id="10-1-GitLab-简介"><a href="#10-1-GitLab-简介" class="headerlink" title="*10.1 GitLab* 简介"></a><em><strong>*10.1 GitLab*</strong></em> 简介</h3><p>GitLab 是由 GitLabInc.开发，使用 <a href="https://baike.baidu.com/item/MIT%E8%AE%B8%E5%8F%AF%E8%AF%81">MIT</a> <a href="https://baike.baidu.com/item/MIT%E8%AE%B8%E5%8F%AF%E8%AF%81">许可证的</a>基于<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C">网络的</a> <a href="https://baike.baidu.com/item/Git">Git</a> <a href="https://baike.baidu.com/item/%E4%BB%93%E5%BA%93">仓库管</a>理工具，且具有 <a href="https://baike.baidu.com/item/wiki">wiki</a> <a href="https://baike.baidu.com/item/wiki">和</a> issue 跟踪功能。使用 <a href="https://baike.baidu.com/item/Git">Git</a> <a href="https://baike.baidu.com/item/Git">作</a>为代码管理工具，并在此基础上搭建起来的 web 服务。 </p><p>GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 <a href="https://baike.baidu.com/item/Ruby%E8%AF%AD%E8%A8%80">Ruby</a> <a href="https://baike.baidu.com/item/Ruby%E8%AF%AD%E8%A8%80">语言写</a></p><p>成。后来，一些部分用 <a href="https://baike.baidu.com/item/Go%E8%AF%AD%E8%A8%80">Go</a> <a href="https://baike.baidu.com/item/Go%E8%AF%AD%E8%A8%80">语言重</a>写。截止 2018 年 5 月，该公司约有 290 名团队成员，以</p><p>及 2000 多名开源贡献者。GitLab 被 IBM，Sony，JülichResearchCenter，NASA，Alibaba，</p><p>Invincea，O’ReillyMedia，Leibniz-Rechenzentrum(LRZ)，CERN，SpaceX 等组织使用。 </p><h3 id="10-2-GitLab-官网地址"><a href="#10-2-GitLab-官网地址" class="headerlink" title="*10.2 GitLab* 官网地址"></a><em><strong>*10.2 GitLab*</strong></em> 官网地址</h3><p>官网地址：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a> 安装说明：<a href="https://about.gitlab.com/installation/[">https://about.gitlab.com/installation/[</a> ](<a href="https://about.gitlab.com/installation/">https://about.gitlab.com/installation/</a>)</p><h3 id="10-3-GitLab-安装"><a href="#10-3-GitLab-安装" class="headerlink" title="*10.3 GitLab* 安装"></a><em><strong>*10.3 GitLab*</strong></em> 安装</h3><h4 id="10-3-1-服务器准备"><a href="#10-3-1-服务器准备" class="headerlink" title="*10.3.1* 服务器准备"></a><em><strong>*10.3.1*</strong></em> 服务器准备</h4><p>准备一个系统为 CentOS7 以上版本的服务器，要求内存 4G，磁盘 50G。关闭防火墙，并且配置好主机名和 IP，保证服务器可以上网。 </p><p>此教程使用虚拟机：主机名：gitlab-server  IP 地址：192.168.6.200 </p><h4 id="10-3-2-安装包准备"><a href="#10-3-2-安装包准备" class="headerlink" title="*10.3.2* 安装包准备"></a><em><strong>*10.3.2*</strong></em> 安装包准备</h4><p>Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。下载地址： </p><p><a href="https://packages.gitlab.com/gitlab/gitlabce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm">https://packages.gitlab.com/gitlab/gitlabce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm</a> </p><p>注：资料里提供了此 rpm 包，直接将此包上传到服务器/opt/module 目录下即可。 </p><h5 id="10-3-3-编写安装脚本"><a href="#10-3-3-编写安装脚本" class="headerlink" title="*10.3.3* 编写安装脚本"></a><em><strong>*10.3.3*</strong></em> 编写安装脚本</h5><p>安装 gitlab 步骤比较繁琐，因此我们可以参考官网编写 gitlab 的安装脚本。 </p><p>[root@gitlab-server module]# vim gitlab-install.sh sudo rpm -ivh /opt/module/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm </p><p>sudo yum install -y curl policycoreutils-python openssh-server cronie sudo lokkit -s http -s ssh </p><p>sudo yum install -y postfix </p><p>sudo service postfix start </p><p>sudo chkconfig postfix on </p><p>curl <a href="https://packages.gitlab.com/install/repositories/gitlab/gitlabce/script.rpm.sh">https://packages.gitlab.com/install/repositories/gitlab/gitlabce/script.rpm.sh</a> | sudo bash </p><p>sudo EXTERNAL_URL=”<a href="http://gitlab.example.com&quot;/">http://gitlab.example.com&quot;</a> yum -y install gitlabce </p><p>给脚本增加执行权限 </p><p>[root@gitlab-server module]# chmod +x gitlab-install.sh [root@gitlab-server module]# ll 总用量 403104 -rw-r–r–. 1 root root 412774002 4月  7 15:47 gitlab-ce-13.10.2ce.0.el7.x86_64.rpm -rwxr-xr-x. 1 root root    416 4月  7 15:49 gitlab-install.sh </p><p>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。 </p><p>[root@gitlab-server module]# ./gitlab-install.sh  警告：/opt/module/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY 准备中…              ################################# [100%] 正在升级/安装…   1:gitlab-ce-13.10.2-ce.0.el7     ################################# [100%]  。 。 。 。 。 。 </p><p><em><strong>*10.3.4*</strong></em> 初始化 <em><strong>*GitLab*</strong></em> 服务执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待… </p><p>[root@gitlab-server module]# gitlab-ctl reconfigure  。 。 。 。 。 。 Running handlers: Running handlers complete Chef Client finished, 425/608 resources updated in 03 minutes 08 seconds gitlab Reconfigured!  </p><h4 id="10-3-5-启动-GitLab-服务"><a href="#10-3-5-启动-GitLab-服务" class="headerlink" title="*10.3.5* 启动 *GitLab* 服务"></a><em><strong>*10.3.5*</strong></em> 启动 <em><strong>*GitLab*</strong></em> 服务</h4><p>执行以下命令启动 GitLab 服务，如需停止，执行 gitlab-ctl stop </p><p>[root@gitlab-server module]# gitlab-ctl start ok: run: alertmanager: (pid 6812) 134s ok: run: gitaly: (pid 6740) 135s ok: run: gitlab-monitor: (pid 6765) 135s </p><p>ok: run: gitlab-workhorse: (pid 6722) 136s ok: run: logrotate: (pid 5994) 197s ok: run: nginx: (pid 5930) 203s ok: run: node-exporter: (pid 6234) 185s ok: run: postgres-exporter: (pid 6834) 133s ok: run: postgresql: (pid 5456) 257s ok: run: prometheus: (pid 6777) 134s ok: run: redis: (pid 5327) 263s ok: run: redis-exporter: (pid 6391) 173s ok: run: sidekiq: (pid 5797) 215s ok: run: unicorn: (pid 5728) 221s </p><p><em><strong>*10.3.6*</strong></em> 使用浏览器访问 <em><strong>*GitLab*</strong></em> 使用主机名或者 IP 地址即可访问 GitLab 服务。需要提前配一下 windows 的 hosts 文件。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps120.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps121.png" alt="img"></p><p> 首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。因此我们修改密码为 Atguigu.123456  然后使用修改后的密码登录 GitLab。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps122.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps123.png" alt="img"></p><h4 id="10-3-7-GitLab-创建远程库"><a href="#10-3-7-GitLab-创建远程库" class="headerlink" title="*10.3.7 GitLab* 创建远程库"></a><em><strong>*10.3.7 GitLab*</strong></em> 创建远程库</h4><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps124.png" alt="img"></p><p>➢ 1）安装 GitLab 插件 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps125.png" alt="img"></p><p>➢ 2）设置 GitLab 插件 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps126.png" alt="img"></p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps127.png" alt="img"></p><p>➢ 3）push 本地代码到 GitLab 远程库 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps128.png" alt="img"></p><p> 自定义远程连接 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps129.png" alt="img"></p><p>注意：gitlab 网页上复制过来的连接是：<a href="http://gitlab.example.com/root/git-test.git">http://</a><a href="http://gitlab.example.com/root/git-test.git">gitlab.example.com</a><a href="http://gitlab.example.com/root/git-test.git">/root/git</a><a href="http://gitlab.example.com/root/git-test.git">-</a><a href="http://gitlab.example.com/root/git-test.git">test.git</a><a href="http://gitlab.example.com/root/git-test.git">，</a>需要手动修改为：<a href="http://gitlab-server/root/git-test.git">http:/</a><a href="http://gitlab-server/root/git-test.git">/gitlab</a><a href="http://gitlab-server/root/git-test.git">-</a><a href="http://gitlab-server/root/git-test.git">server</a><a href="http://gitlab-server/root/git-test.git">/root/git</a><a href="http://gitlab-server/root/git-test.git">-</a><a href="http://gitlab-server/root/git-test.git">test.git</a><a href="http://gitlab-server/root/git-test.git"> </a></p><p> 选择 gitlab 远程连接，进行 push。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps130.png" alt="img"></p><p> 首次向连接 gitlab，需要登录帐号和密码，用 root 帐号和我们修改的密码登录即可。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps131.png" alt="img"></p><p>代码 Push 成功。 </p><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml16424\wps132.png" alt="img"></p><p>只要 GitLab 的远程库连接定义好以后，对 GitLab 远程库进行 pull 和 clone 的操作和</p><p>Github 和码云一致，此处不再赘述。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;尚硅谷技术课程系列之 Git &lt;/p&gt;
&lt;p&gt;（作者：尚硅谷大数据研发部） &lt;/p&gt;
&lt;p&gt;版本：V2.0 &lt;/p&gt;
&lt;h1 id=&quot;第-1-章-Git-概述&quot;&gt;&lt;a href=&quot;#第-1-章-Git-概述&quot; class=&quot;headerlink&quot; title=&quot;第****1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>javaweb Summery</title>
    <link href="http://example.com/2021/06/20/javaweb-Summery/"/>
    <id>http://example.com/2021/06/20/javaweb-Summery/</id>
    <published>2021-06-20T12:03:20.000Z</published>
    <updated>2021-06-20T12:08:14.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><pre><code>1. web概念概述2. HTML</code></pre><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;                    &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;                        &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;                        &lt;/body&gt;            &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例        * 案例：公司简介            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;ch&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;黑马程序员简介&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                        &lt;h1&gt;                公司简介            &lt;/h1&gt;            &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;p&gt;            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。            &lt;/p&gt;                        &lt;p&gt;            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。            &lt;/p&gt;                        &lt;p&gt;                        黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。            &lt;/p&gt;                        &lt;p&gt;                        一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。            &lt;/p&gt;                        &lt;hr color=&quot;#ffd700&quot;&gt;                        &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                &lt;center&gt;                    江苏传智播客教育科技股份有限公司&lt;br&gt;                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                &lt;/center&gt;            &lt;/font&gt;</code></pre><p>​<br>​                </p><pre><code>            &lt;/body&gt;            &lt;/html&gt;    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;4. 代码实现    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;黑马旅游网&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            &lt;!--采用table来完成布局--&gt;        &lt;!--最外层的table，用于整个页面的布局--&gt;        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;           &lt;!-- 第1行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第2行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第3行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;                            &lt;td&gt;                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                                &lt;td&gt;                                门票                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第4行 轮播图 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第5行 黑马精选--&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;                    黑马精选                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第6行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第7行 国内游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;                    国内游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第8行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第9行 境外游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;                    境外游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第10行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                                &lt;td&gt;                                    &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                                &lt;td&gt;                                   &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;</code></pre><p>​        </p><pre><code>                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第11行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;                &lt;!-- 第12行 --&gt;            &lt;tr&gt;                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    江苏传智播客教育科技股份有限公司                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                    &lt;/font&gt;                &lt;/td&gt;            &lt;/tr&gt;                    &lt;/table&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><pre><code>1. HTML标签：表单标签2. CSS：</code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性</code></pre><p>​        </p><pre><code>    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;注册页面&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0px;            padding: 0px;            box-sizing: border-box;        &#125;        body&#123;            background: url(&quot;img/register_bg.png&quot;) no-repeat center;            padding-top: 25px;        &#125;            .rg_layout&#123;            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;            background-color: white;            /*让div水平居中*/            margin: auto;        &#125;            .rg_left&#123;            /*border: 1px solid red;*/            float: left;            margin: 15px;        &#125;        .rg_left &gt; p:first-child&#123;            color:#FFD026;            font-size: 20px;        &#125;            .rg_left &gt; p:last-child&#123;            color:#A6A6A6;            font-size: 20px;            &#125;</code></pre><p>​        </p><pre><code>        .rg_center&#123;            float: left;           /* border: 1px solid red;*/            &#125;            .rg_right&#123;            /*border: 1px solid red;*/            float: right;            margin: 15px;        &#125;            .rg_right &gt; p:first-child&#123;            font-size: 15px;            &#125;        .rg_right p a &#123;            color:pink;        &#125;            .td_left&#123;            width: 100px;            text-align: right;            height: 45px;        &#125;        .td_right&#123;            padding-left: 50px ;        &#125;            #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        &#125;        #checkcode&#123;            width: 110px;        &#125;            #img_check&#123;            height: 32px;            vertical-align: middle;        &#125;            #btn_sub&#123;            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        &#125;        &lt;/style&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                            &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;</code></pre><p>​        </p><pre><code>                        &lt;tr&gt;                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                    &lt;/form&gt;</code></pre><p>​        </p><pre><code>            &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/div&gt;</code></pre><p>​        </p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. web概念概述
2. HTML
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;web概念概述&quot;&gt;&lt;a href=&quot;#web概念概述&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GIT 常用命令</title>
    <link href="http://example.com/2021/06/20/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/06/20/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-06-20T12:02:39.000Z</published>
    <updated>2021-06-20T12:07:38.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT常用命令"><a href="#GIT常用命令" class="headerlink" title="GIT常用命令"></a>GIT常用命令</h1><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>Git branch -v</td><td>查看当前分支</td></tr><tr><td>Git branch hot-fix</td><td>添加热分支（紧急修复）</td></tr><tr><td>Git checkout  分支名</td><td>切换当前分支</td></tr><tr><td>Git merge  分支名</td><td>合并分支（没有产生合并冲突）</td></tr><tr><td>手动更改合文件 vim</td><td>合并分支（产生合并冲突）</td></tr><tr><td></td><td></td></tr></tbody></table><p>冲突产生的原因：</p><p>合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替</p><p>我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GIT常用命令&quot;&gt;&lt;a href=&quot;#GIT常用命令&quot; class=&quot;headerlink&quot; title=&quot;GIT常用命令&quot;&gt;&lt;/a&gt;GIT常用命令&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer Network summery  网络层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-06-20T12:01:53.000Z</published>
    <updated>2021-06-20T12:06:46.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-network-summery-网络层"><a href="#Computer-network-summery-网络层" class="headerlink" title="Computer network summery :网络层"></a>Computer network summery :网络层</h1><h2 id="一、功能和服务"><a href="#一、功能和服务" class="headerlink" title="一、功能和服务"></a>一、功能和服务</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><ul><li><p>路由器不运行应用层和运输层协议</p></li><li><p>功能：转发和路由选择</p></li><li><p>转发：</p></li><li><p>路由选择：网络层决定分组所采用的路径或路由；计算方法是<strong>路由选择算法</strong>( routing algorithm)</p></li><li><p>路由器都具有一张<strong>转发表</strong> (fOlwarding tahle) </p></li><li><p>某些网络体系结构也要求在数据报在路径中流动之前建立连接</p><p>​    例如：ATM 、帧中继、 MPLS</p></li></ul><h3 id="1-2-交换机"><a href="#1-2-交换机" class="headerlink" title="1.2 交换机"></a>1.2 交换机</h3><p>某些分组交换机称为</p><p>链路层交换机(link-Iayer switches) </p><p>其他分组交换机称为路由器( router) </p><h3 id="1-3-服务模型"><a href="#1-3-服务模型" class="headerlink" title="1.3 服务模型"></a>1.3 服务模型</h3><p>定义了分组在发送与接收端系统之间的端到端运输特性</p><ul><li>网络层提供的特定服务<ul><li>确保支付</li><li>具有时延上界的确 保交付</li><li>有序分组支付</li><li>确保最小带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li><li>网络层提供尽力而为服务</li></ul><h3 id="1-4虚电路和数据报网络"><a href="#1-4虚电路和数据报网络" class="headerlink" title="1.4虚电路和数据报网络"></a>1.4虚电路和数据报网络</h3><ul><li>与运输层类似，网络层也能够在两台主机之间提供无连接服务或连接服务</li></ul><ol><li><p><strong>虚电路网络</strong>:仅在网络层提供连接服务的计算机网络</p></li><li><p><strong>数据报网络</strong>:仅在网络层提供无连接服务的计算机网络</p></li><li><p>几乎所有主要计算机网络体系中都不<strong>同时</strong>提供两种服务</p></li><li><p>与运输层的<strong>区别</strong>：运输层服务在端系统中实现，网络层连接服务在端系统中，也在位于网络核心的路由器中实现</p></li><li><p>虚电路网络和数据报网络是计算机网络的两种基本类型 作出转发时，使用了非常不同的信息。</p></li></ol><ul><li><p>虚电路网络</p></li><li><p>数据报网络</p><ul><li><p>端系统要发送分组—&gt;就为该分组加上目的端系统的地</p><p>址，—&gt;将分组推进网络中  </p><p>无需建立任何虚电路，路由器不维护任何虚电路的状态信息</p></li></ul></li></ul><h2 id="二、路由转发"><a href="#二、路由转发" class="headerlink" title="二、路由转发"></a>二、路由转发</h2><h3 id="1、路由器："><a href="#1、路由器：" class="headerlink" title="1、路由器："></a>1、路由器：</h3><ul><li><p>结构</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528204542791.png" alt="image-20210528204542791"></p><ul><li>输入端口：与物理链路相连</li><li>交换结构：网络路由器中的网络</li><li>输出端口：存储和传输交换结构传出的分组</li><li>路由选择处理器：执行路由选择协议</li></ul></li></ul><h3 id="2、输入端口"><a href="#2、输入端口" class="headerlink" title="2、输入端口"></a>2、输入端口</h3><ul><li>输入端口的处理<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205032133.png" alt="image-20210528205032133"></li><li>从链路接收分组，对分组进行处理，通过路由表查找某分组的输出端口，发送到交换结构。</li><li>阻塞的分组在输入端口进行排队</li></ul></li></ul><h3 id="3、交换结构"><a href="#3、交换结构" class="headerlink" title="3、交换结构"></a>3、交换结构</h3><ul><li><p>交换结构：核心部位</p><ul><li><p>三种交换技术：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205614574.png" alt="image-20210528205614574"></p><ul><li><p>内存交换</p></li><li><p>总线交换</p></li><li><p>互联网络交换</p><p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p></li></ul></li></ul></li></ul><h3 id="4、输出端口"><a href="#4、输出端口" class="headerlink" title="4、输出端口"></a>4、输出端口</h3><ul><li>输出端口<ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528205817371.png" alt="image-20210528205817371"></li><li>选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能</li></ul></li><li>排队（拥塞）<ul><li>输入线路速率，比输出速率大，路由器空间耗尽，后到达的分组会丢包</li></ul></li></ul><h2 id="三、网际协议-IP"><a href="#三、网际协议-IP" class="headerlink" title="三、网际协议 IP"></a>三、网际协议 IP</h2><p>因特网中的转发和编址</p><ul><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211114845.png" alt="image-20210528211114845"></li></ul><h3 id="1、数据报格式"><a href="#1、数据报格式" class="headerlink" title="1、数据报格式"></a>1、数据报格式</h3><p>（IPv4）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528211224903.png" alt="image-20210528211224903"></p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本号</td><td align="center">IPv4/IPv6</td></tr><tr><td align="center">首部长度</td><td align="center">一般20字节</td></tr><tr><td align="center">服务类型</td><td align="center">服务类型</td></tr><tr><td align="center">数据报长度</td><td align="center">IP数据报总长度</td></tr><tr><td align="center">标识、标志、片偏移</td><td align="center">与ip分片有关的标示量</td></tr><tr><td align="center">寿命</td><td align="center">寿命 (Time-To- Live TTL)；避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源和目的IP</td><td align="center">转发的地址</td></tr><tr><td align="center">选项</td><td align="center">选项字段 首部扩展（超过20字节）</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table><h3 id="2、数据报分片"><a href="#2、数据报分片" class="headerlink" title="2、数据报分片"></a>2、数据报分片</h3><ul><li><p>数据报不能超过链路层所能承受的最大网络层分组</p></li><li><p>数据报过大时，进行分组，分成的较小数据报叫做片</p></li><li><p>片在目的地端系统进行重新组装，而不是路由器（简便网络内核）</p></li><li><p>发送方为它发送的每个数据报的标识号加1；也就是同一数据报，不同的片 标志相同</p></li><li><p>分片之后转发的片中，最后一个片的标志比特被设为0 ，而所有其他片的标志比特被设为1，</p></li><li><p>偏移字段指定该片应放在初始 数据报的哪个位置</p></li></ul><h3 id="3、IP编址"><a href="#3、IP编址" class="headerlink" title="3、IP编址"></a>3、IP编址</h3><h3 id="4、互联网控制报文协议-ICMP"><a href="#4、互联网控制报文协议-ICMP" class="headerlink" title="4、互联网控制报文协议 (ICMP)"></a>4、互联网控制报文协议 (ICMP)</h3><ul><li><p>主机和路由器用来彼此沟通网络层的信息，用来进行差错报告。</p></li><li><p>ICMP报文是承载在ip 分组中，但是也被看做ip的一部分</p></li><li><p>报文类型</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528214029686.png" alt="image-20210528214029686"></p></li></ul><ul><li>众所周知的 ping 程序发送一个 ICMP 类型 编码 的报文到指定主机</li></ul><h3 id="5、ipv6"><a href="#5、ipv6" class="headerlink" title="5、ipv6"></a>5、ipv6</h3><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210528213948939.png" alt="image-20210528213948939"></p><p><strong>概述</strong></p><ul><li><p>解决ipv4地址不足的问题</p></li><li><p>报文结构</p><table><thead><tr><th align="center">字段名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">版本</td><td align="center">IPv4/IPv6                         4比特</td></tr><tr><td align="center">流标签</td><td align="center">于标识一条数据报的流    20比特</td></tr><tr><td align="center">流量类型</td><td align="center">与TOS 字段的含义相似   8比特</td></tr><tr><td align="center">有效负载长度</td><td align="center">IP首部后数据字节数量  16比特</td></tr><tr><td align="center">下一个首部</td><td align="center">标识数据包交付对象（TCP/UDP ）</td></tr><tr><td align="center">跳限制</td><td align="center">与TTL类似  避免路由选择环路</td></tr><tr><td align="center">协议</td><td align="center">指示IP在运输层依赖的协议</td></tr><tr><td align="center">首部检验和</td><td align="center">帮助路由器检测收到的 数据报中的比特错误</td></tr><tr><td align="center">源地址</td><td align="center">128比特</td></tr><tr><td align="center">目的地址</td><td align="center">128比特</td></tr><tr><td align="center">数据部分</td><td align="center">有效载荷)</td></tr></tbody></table></li><li><p>IPv6首部40字节</p></li></ul><p><strong>相对ipv4特点（不同）：</strong></p><ul><li>不允许在中间路由器上进行分片与重新组装，只能在源与目的地上执行———-没有了分片标志</li><li>没有首部检验和字段，检验在运输层和数据链路层中完成</li><li>没有选项字段，删除选项字段使得 IP 首部成为定长的 40 字节</li><li>地址容量扩大了</li><li>拥有流标签和优先级</li></ul><h2 id="四、路由选择算法"><a href="#四、路由选择算法" class="headerlink" title="四、路由选择算法"></a>四、路由选择算法</h2><p>主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器 (default router) , 又称为该主机的第一跳路由器 (first- hop router）</p><p>源主机的默认路由器称作源路由器( source 川出r) ，把目的主机的默认路由器称作目的路由器 (destination router)</p><p>一个分组从源主机到目的主机的路由选择的较好 方法即路由选择算法</p><p>在两个路由之间根据链路开销，存在一条或者多条最低开销路径。</p><p>最低开销路径也就是最短路径———————最短路径算法SPF；</p><p><strong>路由控制</strong></p><ul><li><p>每路由控制。</p><p>每台路由器中运行一种路由选择算法的情况，每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。这种每路由器控制的方法在因特网中已经使用了几十年。</p><p>OSPF和BGP协议都是基于这种每路由器的方法进行控制的。</p></li><li><p>逻辑集中式控制。</p><p>逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况。通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能(负载共享、防火墙功能、NAT)的丰富集合，而这些功能先前是在单独的中间盒中实现的。</p><p>SDN采用了逻辑集中控制器的概念，而这种方法在生产部署中得到了越来越多的应用。</p></li></ul><h4 id="1-路由选择算法"><a href="#1-路由选择算法" class="headerlink" title="1.路由选择算法"></a>1.路由选择算法</h4><p><strong>分类：</strong></p><ul><li><p><code>全局式路由选择算法</code> (globaJ routing aJgorithm) </p><p>：用完整的、全局性的网络知识计算从源到目的地之间的最低开销路径，即 以所有结点之间的连通</p><p>性及所有链路的费用为输入</p><p>例：链路状态算法  LS  </p><p>​       适应每路由和逻辑集中控制：路由计算可以在集中式路由选择器 开门中，也可以在每台路由器的路优选择组件</p></li></ul><p>​        <code>分散式路由选择算法**</code> (dece t.ralized routing aJgorithm)</p><p>​                以迭代、分布式的方式计算最低开销路径 ，没有结点拥有关于所有网络链路费用的完整信息，                而每个结点仅有与其直接相连链路的费用知识即可开始工作</p><p>​        例：距离向量算法 DV   </p><p>​                天然适应逻辑集中式控制</p><ul><li><p><code>静态路由选择算法</code> (SlaLÌc rouling aJgorithm)：**手工配置、路由更新慢、优先级高</p><p>简单，开销小，但不能及时适应网络状态的变化，适用于小型网络。</p><p><code>动态路由选择算法</code>(dynamic rouling aJ gorithm)**：路由更新快（定期更新、及时响应链路费用或网络拓扑变化）</p><p>能较好地适应网络状态的变化，实现较为复杂，适用于大型网络。</p><p>容易受到路优选择循环、路由震荡的影响</p></li><li><p><code>负载敏感算法</code> load-sensiLÌve aJ gorithm)</p><p>：链路开销动态变化，反映当前链路底层链路的拥塞水平</p><p><code>负载迟钝算法</code>(load-insensitive) </p><p>当今的路由选择算法都是负载迟钝的。</p></li></ul><p><strong>常见算法：</strong></p><ul><li><p>电路交换路由选择算 (circuiL- swiLched routing algorith m)</p></li><li><p>距离向量(Distance- Vector, DV) 算法</p><ul><li>路由器周期性地向其相邻路由器广播自己知道的路由信息，用以通知相邻路由器自己可以到达的网络以及到达该网络的距离。相邻路由器可以根据收到的路由信息修改和刷新自己的路由表。</li><li>优点：算法简单、易于实现。</li><li>缺点：慢收敛问题，路由器的路径变化需要像波浪一样从相邻路由器传播出去，过程缓慢。</li></ul></li><li><p>链路状态广播 (link state broadcast) 算法 </p><ul><li>也叫最短路径优先(shortest path first SPF)算法，它的主要做法如下：<ul><li>首先由路由器向相邻路由器发送查询报文，测试和它相邻路由器的链路状态。如果可以收到相邻路由器发回的响应，则说明该相邻路由器和这个路由器之间可以正常通信；</li><li>在收到该路由器和其他相邻路由器的链路状态后，还向系统中所有参加最短路径优先算法的路由器发送链路状态报文；</li><li>各路由器收到其他路由器发来的链路状态报文后，根据报文中的数据刷新本路由器所保存的网络拓扑结构图。如果链路发生变化，路由器将启用Dijkstra算法生成新的最短路径优先数，并刷新本地路由表；</li></ul></li></ul></li></ul><p><em><strong>分层次的路由选择协议：</strong></em></p><p>因特网采用的路由选择协议主要是<strong>自适应的、动态的、分布式的、分层次的</strong>路由选择协议。</p><p><em><strong>自治系统（autonomous system,AS）</strong></em></p><p> 就是几个路由器组成了一个小团体，小团体内部使用专用的协议进行通信，而小团体和小团体之间也使用专用的协议进行通信。</p><p>目前的因特网中，ISP就是一个自治系统。</p><h2 id="五、路由选择协议"><a href="#五、路由选择协议" class="headerlink" title="五、路由选择协议"></a>五、路由选择协议</h2><p>计算出用于在网络中转发分组的转发表</p><p>两种 AS 内部路由选择协议 (RIP/OSPF) 和一种 AS 间路由选择协议 (BGP)</p><h3 id="1、AS-内部路由选择协议"><a href="#1、AS-内部路由选择协议" class="headerlink" title="1、AS 内部路由选择协议"></a>1、AS 内部路由选择协议</h3><h4 id="1-1-路由信息协议-RIP"><a href="#1-1-路由信息协议-RIP" class="headerlink" title="1.1 路由信息协议 RIP"></a>1.1 路由信息协议 RIP</h4><p> (Routing Information Protocol)</p><p>✅ 它是一种分布式的、基于距离向量的路由选择协议。<br>✅ 它要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。<br><strong>关于距离的定义：</strong></p><p>从一个路由器到直接连接的网络的距离定义为 1。<br>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。<br>“距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。<br>这里的“距离”实际上指的是“最短距离”。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p><p>RIP 允许一条路径最多只能包含 15 个路由器。</p><p>这意味着 RIP 只会选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p><p><strong>RIP 协议的三个特点:</strong></p><ul><li><p>仅和相邻路由器交换信息。</p></li><li><p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</p></li><li><p>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p><p><strong>AS（自治系统）之内的路由器如何建立路由表？</strong></p></li></ul><p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。它的路由表是空的。以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。<br>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。<br>RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</p><p> <strong>RIP2的报文格式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414151233228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>RIP2 报文由首部和路由部分组成。</p><ul><li>RIP2 报文中的路由部分由若干个路由信息组成。</li><li>地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</li><li>路由标记填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。</li><li>再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。</li></ul><p>一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4 + 20 × 25 = 504 4+20\times25=5044+20×25=504字节。如超过，必须再用一个 RIP 报文来传送。</p><h4 id="1-2-开放最短路径优先-OSPF"><a href="#1-2-开放最短路径优先-OSPF" class="headerlink" title="1.2 开放最短路径优先 OSPF"></a>1.2 开放最短路径优先 OSPF</h4><ul><li><p>OSPF (Open Shortest Path First) 是为克服 RIP 的缺点在<code>1989</code>年开发出来的。</p></li><li><p>使用了 Dijkstra 提出的最短路径算法 SPF</p></li></ul><p><strong>区域</strong></p><p>OSPF 将一个自治系统再划分为若干个更小的范围，叫作<code>区域</code>。</p><p>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</p><p><img src="https://img-blog.csdnimg.cn/20200414174248189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>OSPF 使用 IP 数据报传送：</strong></p><ul><li>✅ OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>✅ OSPF 构成的数据报很短。好处是可以不必将长的数据报分片传送。</li><li>✅ 支持可变长度的子网划分和无分类编址 CIDR。</li></ul><p><strong>OSPF 分组</strong></p><p><img src="https://img-blog.csdnimg.cn/20200414174524743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>五种分组类型</p><p>1️⃣ 类型1：问候 (Hello) 分组。<br>2️⃣ 类型2：数据库描述 (Database Description) 分组。<br>3️⃣ 类型3：链路状态请求 (Link State Request) 分组。<br>4️⃣ 类型4：链路状态更新 (Link State Update) 分组，用洪泛法对全网更新链路状态。<br>5️⃣ 类型5：链路状态确认 (Link State Acknowledgment) 分组。</p><h3 id="2、AS-间路由选择协议"><a href="#2、AS-间路由选择协议" class="headerlink" title="2、AS 间路由选择协议"></a>2、AS 间路由选择协议</h3><p> <strong>(边界网关协议 BGP）</strong></p><ul><li><p>BGP 是不同自治系统的路由器之间交换路由信息的协议</p></li><li><p>要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200414174933546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>BGP-4 共使用四种报文</strong> </p><ol><li> 打开 (OPEN) 报文：用来与相邻的另一个BGP发言人建立关系。</li><li> 更新 (UPDATE) 报文：用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li> 保活 (KEEPALIVE) 报文：用来确认打开报文和周期性地证实邻站关系。</li><li> 通知 (NOTIFICATION) 报文：用来发送检测到的差错。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200414175219726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="六、简单网络管理协议（SNMP）"><a href="#六、简单网络管理协议（SNMP）" class="headerlink" title="六、简单网络管理协议（SNMP）"></a>六、简单网络管理协议（SNMP）</h2><p>基于T C P / I P的网络管理包含两个部分：网络管理站（也叫管理进程， m a n a g e r）和被管的网络单元（也叫被管设备）。被管设备端和管理相关的软件叫做代理程序( a g e n t )或代理进程。</p><p>管理进程和代理进程之间的通信可以有两种方式。一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的 I C M P端口？）。另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生。</p><p>基于T C P / I P的网络管理包含3个组成部分：</p><ol><li><p> 一个管理信息库M I B（Management Information Base）。管理信息库包含所有代理进程的所有可被查询和修改的参数。</p></li><li><p> 关于M I B的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。</p></li><li><p> 管理进程和代理进程之间的通信协议，叫做简单网络管理协议 S N M P（Simple Network Management Protocol）。</p></li></ol><p>协议<br>关于管理进程和代理进程之间的交互信息， S N M P定义了5种报文：</p><ol><li><p> get - r e q u e s t操作：从代理进程处提取一个或多个参数值。</p></li><li><p> get - n e x t - r e q u e s t操作：从代理进程处提取一个或多个参数的下一个参数值</p></li><li><p> set - r e q u e s t操作：设置代理进程的一个或多个参数值。</p></li><li><p> get - r e s p o n s e操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</p></li><li><p>t r a p 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</p></li></ol><p>前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的。</p><p>管理信息结构<br>SNMP中，数据类型不多，只有INTEGER，OCTER STRING，IPAddress等</p><p>对象标识符<br>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</p><p>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于 D N S或U n i x的文件系统</p><p> 管理信息库介绍<br>所谓管理信息库，或者M I B，就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p><p>M I B组：s y s t e m（系统标识）、i f（接口）、a t（地址转换）、i p、i c m p和t c p。</p><p>s y s t e m组非常简单，它包含7个简单变量</p><p>interface组只定义了一个简单变量，那就是系统的接口数量</p><p>i p组定义了很多简单变量和3个表格变量</p><p>i c m p组包含4个普通计数器变量（ I C M P报文的输出和输入数量以及 I C M P差错报文的输入和输出数量）和2 2个其他I C M P报文数量的计数器：11个是输出计数器，另外11个是输入计数器。</p><p>t c p组中的简单变量几乎都和T C P状态有关。</p><h2 id="七、SDN-控制平面"><a href="#七、SDN-控制平面" class="headerlink" title="七、SDN 控制平面"></a>七、SDN 控制平面</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Computer-network-summery-网络层&quot;&gt;&lt;a href=&quot;#Computer-network-summery-网络层&quot; class=&quot;headerlink&quot; title=&quot;Computer network summery :网络层&quot;&gt;&lt;/a&gt;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer Network summery  应用层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-06-20T12:01:24.000Z</published>
    <updated>2021-06-20T12:07:05.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-summery-应用层"><a href="#Computer-Network-summery-应用层" class="headerlink" title="Computer Network summery  应用层"></a>Computer Network summery  应用层</h1><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><h3 id="1-协议原理"><a href="#1-协议原理" class="headerlink" title="1.协议原理"></a>1.协议原理</h3><ul><li><p>常见的网络应用程序： Web 、电子邮件、 DNS 、对等文件分发</p></li><li><p>主要概念：应用程序的网络服务、客户和服务器、进程、运输层接口</p></li><li><p>应用软件在端系统上运行 </p></li></ul><h3 id="2-应用程序体系结构"><a href="#2-应用程序体系结构" class="headerlink" title="2.应用程序体系结构"></a>2.应用程序体系结构</h3><ul><li><p>网络应用程序体系结构：</p><ul><li><p>客户-服务器体系结构：（配备大量数据中心，创建虚拟服务器）</p><p>​                常见应用程序Telnet 、电子邮件、Web/FTP</p></li><li><p>对等P2P体系结构</p><ul><li>当前流行的、流量密集型应用  包括文件共享(例如 BitTorrenl) 、对等方协助下载加速器(例如迅雷)、因特网电话(例如 Skype) IPTV</li><li>P2P 的自扩展性 self- scalab i1 ity)</li></ul></li></ul></li></ul><h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3.进程"></a>3.进程</h3><ul><li><p>进行通信的实际上是进程，而不是程序</p></li><li><p>客户和服务器进程</p><ul><li>客户进程/服务器进程   例：web服务中，浏览器：客户进程；web服务器：服务进程</li></ul></li><li><p>API</p><ul><li><p>进程通过一个称为<strong>套接字</strong> (socket)的软件接口向网络发送报文和从网络接收报文 </p></li><li><p>套接字是建立网络应用程序的可编程接口，也称为应用程序和网络之间的<strong>应用程序编程接口</strong> (Application Programming Interface , API)</p></li><li><p>可以控制套接字在<strong>应用层端</strong>，对套接字的<strong>运输层端</strong>几乎没有控制权 </p><p>应用程序开发者对于运输层的控制仅限于：</p><p>①选择运输层协议;</p><p>②几个运输层参数</p></li></ul></li><li><p>进程寻址</p><ul><li>标识进程：目的地端口号(port number)：用来标识 运行在主机上的进程</li></ul></li></ul><h3 id="4-运输服务"><a href="#4-运输服务" class="headerlink" title="4.运输服务"></a>4.运输服务</h3><h4 id="4-1应用程序"><a href="#4-1应用程序" class="headerlink" title="4.1应用程序"></a>4.1应用程序</h4><ul><li><p>可靠数据传输：一端发送的应用数据正确、完全地交付给该应用程序的另一端</p><ul><li><p>容忍丢失的应用：能够接受不可靠传输的应用进程</p><p>例如 多媒体应用</p></li></ul></li><li><p>吞吐量：运输层协议能够以某种特定的速率提供确保的可用吞吐量</p><ul><li><p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong> (bandwidth- sensitive applicaLi on)</p></li><li><p><strong>弹性应用</strong>( el皑白 applicaLi on) 能够根据情况或多或少地利用可供使用的吞吐量</p><p>例如：电子邮件、文件传输以及 Web 传送 </p></li></ul></li><li><p>定时 </p><ul><li><p>某些服务为了有效性 ，要求数据交付有严格的时间限制</p><p>例如 :交互式实时应用程序</p></li></ul></li><li><p>安全性</p></li></ul><h4 id="4-2因特网"><a href="#4-2因特网" class="headerlink" title="4.2因特网"></a>4.2因特网</h4><ul><li><p>因特网(更一般的是 TCP/IP 网络)为应用程序提供两个运输层协议，即 UDP和 TCP</p></li><li><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527112725518.png" alt="image-20210527112725518"></p></li><li><p><strong>TCP</strong></p></li><li><p><strong>UDP</strong></p></li><li><p>互联网运输协议不能提供任何<strong>定时</strong>或<strong>带宽保证</strong></p></li><li><p>流行的因特网应用及其应用层协议和支撑的运输协议</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527113131403.png" alt="image-20210527113131403"></p></li></ul><h4 id="5-应用层协议"><a href="#5-应用层协议" class="headerlink" title="5.应用层协议"></a>5.应用层协议</h4><ul><li><p>作用：定义了运行在不同端系统上的应用程序进程如何相互传递报文：</p><ul><li>交换的报文类型，</li><li>各种报文类型的语法，</li><li>字段的语义</li><li>一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul></li><li><p>应用层协议只是网络应用的一部分</p></li><li><p>讨论几种重要的应用: Web 、文件传输、电子邮件、目录服务和P2P</p><p>以及他们的相关协议。</p></li></ul><h2 id="二、Web与HTTP"><a href="#二、Web与HTTP" class="headerlink" title="二、Web与HTTP"></a>二、Web与HTTP</h2><h3 id="1-http"><a href="#1-http" class="headerlink" title="1.http"></a>1.http</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><ul><li><p>Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) </p></li><li><p>由两个程序实现：客户端程序和服务器程序</p></li><li><p>使用TCP 作为支撑运输协议</p></li><li><p>无状态协议：不保存关于客户的任何信息</p></li><li><p>HTTP 既能够使用非持续连接，也能够使用持续连接，默认状态是持续性连接</p><ul><li>持续性连接</li><li>非持续性连接</li></ul></li></ul><h4 id="1-2报文格式"><a href="#1-2报文格式" class="headerlink" title="1.2报文格式"></a>1.2报文格式</h4><p>​    分类:请求报文和响应报文</p><ul><li><p>请求报文</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527201409324.png" alt="image-20210527201409324"></p></li></ul><p>HTTP 请求报文的第一行 <strong>请求行</strong> (request line) ，</p><p>后继的行叫做<strong>首部行</strong>( header line) </p><p>请求行有3个字段:方法字段、 URL 字段和 HTTP 版本字段 </p><p>方法宇段可以取几种不同的值，包括 GET OST HEAD PUT DELETE</p><p>Connec Li on: close 首部行</p><p>User- agent: 首部行</p><p>Accept -language 首部行</p><p>首部行 Host: www. someschool. edu</p><ul><li>请求报文通用首部格式</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202001957.png" alt="image-20210527202001957"></p><ul><li>响应报文</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202207984.png" alt="image-20210527202207984"></p><p>​                组成：一个初始状态行 (sLatus line) 、首部行 (header 1ine) 、实体体                 (enLity body)—–报文的主要部分</p><p>​                Connection: close 首部行</p><p>​                Date: 首部行</p><p>​                Server: 首部行</p><p>​                Last- Moclified: 首部行</p><p>​                Conlenl- Length: 首部行</p><p>​                Conlent- Type: 首部行</p><ul><li>响应报文通用格式：</li></ul><p>​    <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527202521768.png" alt="image-20210527202521768"></p><ul><li>响应报文常见的状态码和相关的短语:</li></ul><p> 200 OK: 请求成功信息在返回的响应报文中</p><p>• 301 Movecl Pennanenùy: 请求的对象已经被永久转移了，新的 URL 定义在响应报文的LocaLi oD: 首部行中 客户软件将自动获取新的 URL</p><p>• 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解72 </p><p>• 404 Not FO lll1 d: 被请求的文档不在服务器上</p><p>• 505 HTTP Version Not Supported: 服务器不支持请求报文使用的 HTTP 协议版本</p><h4 id="1-3Cookie"><a href="#1-3Cookie" class="headerlink" title="1.3Cookie"></a>1.3Cookie</h4><ul><li><p>cookie 技术的4个组件:</p><ul><li>①在 HTTP 响应报文中的 cookie 首部行;</li><li>②在 HTTP 请求报文中的一个 cookie 首部行;</li><li>③在用户端系统中保留有 cookie件，并由用户的浏览器进行管理;</li><li>④位于 Web 站点的一个后端数据库</li></ul></li><li><p>流程：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527203342657.png" alt="image-20210527203342657"></p></li></ul><ul><li><hr></li></ul><ol><li><p>用户首次访问 个站点时，可能需要提供 个用户标识(可能是名字)</p></li><li><p>在后继会话中，浏览器向服务器传递cookie 首部，从而向该服务器标识了用户</p></li><li><p>因此 cookie 可以在无状态的 HTTP 之上建立个用户会话层 </p></li></ol><ul><li>注:它的使用仍具有争议，因为它们被认为是对用户隐私的一种侵害</li></ul><h4 id="1-4Web缓存"><a href="#1-4Web缓存" class="headerlink" title="1.4Web缓存"></a>1.4Web缓存</h4><ul><li><p><strong>Web 缓存器</strong>也叫<strong>代理服务器</strong></p></li><li><p>拥有自己的存储空间；</p></li><li><p>Web 缓存器是服务器同时又是客户（可以发送和接收响应）</p></li><li><p>部署 Web 缓存器有两个原因：</p><ul><li><p>大大减少对客户请求的响应时间</p><ul><li><p>是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之</p><p>间的瓶颈带宽时更是如此</p></li></ul></li><li><p>大大减少一个机构的接入链路到闲特网的通信量</p><ul><li>减少通信量， 不必急于增加带宽，降低了费用。</li></ul></li></ul></li></ul><p>具体详见 图解http</p><h2 id="三、文件传输协议：FTP"><a href="#三、文件传输协议：FTP" class="headerlink" title="三、文件传输协议：FTP"></a>三、文件传输协议：FTP</h2><h4 id="1-协议运行"><a href="#1-协议运行" class="headerlink" title="1. 协议运行"></a>1. 协议运行</h4><p>，用户通过一个阿?用户代理与阿?交五 该用</p><p>户首先提供远程主机的主机名，使本地主机的归?客户进程建立一个到远程主机凹?服务</p><p>器进程的 TCP 连接。该用户接着提供用户标识和口令，作为 FTP 命令的一部分在该 TCP</p><p>连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者</p><p>多个文件复制到远程文件系统(反之亦然)。</p><h4 id="2-FTP-和HTTP-的区别"><a href="#2-FTP-和HTTP-的区别" class="headerlink" title="2. FTP 和HTTP 的区别"></a>2. FTP 和HTTP 的区别</h4><h5 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1 连接"></a>2.1 连接</h5><ul><li>FTP 使用了两个并行的 TCP 连接来传输文件<ul><li>控制连接 (control connection)：在两主机之间传输控制信息</li><li>数据连接( data connection)：实际发送一个文件</li><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527205305119.png" alt="image-20210527205305119"></li></ul></li><li>HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行</li></ul><h5 id="2-2-状态"><a href="#2-2-状态" class="headerlink" title="2.2 状态"></a>2.2 状态</h5><ul><li>FTP 服务器必须在整个会话期间保留用户的状态( state)；</li><li>HTTP 是无状态的，即它不必对任何用户状态进行追踪</li></ul><h4 id="3-常见命令和回答"><a href="#3-常见命令和回答" class="headerlink" title="3.常见命令和回答"></a>3.常见命令和回答</h4><ul><li>命令和回答都是7比特 ASCII格式在控制连接上传送</li></ul><h5 id="3-1-命令"><a href="#3-1-命令" class="headerlink" title="3.1 命令"></a>3.1 命令</h5><ul><li><p>每个命令由 个大写字母 ASCII 字符组成，有些还具有可选参数</p></li><li><p>为常见的命令如下:</p><ul><li><p>USER usemame: 用于向服务器传送用户标识</p></li><li><p>P ASS password: 用于向服务器发送用户口令</p></li><li><p>UST: 用于请求服务器回送当前远程目录中的所有文件列表 该文件列表是经一个(新建且非持续连接)数据连接传送的，而不是在控制 TCP 连接上传送。</p></li><li><p>RETR filename: 用于从远程主机当前目录检索(自 gel) 文件 该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件</p></li><li><p>STOR filename: 用于在远程主机的当前目录上存放(即 put) 文件</p></li></ul></li><li><p>每个命令都对应着一个从服务器发向客户的回答。</p></li></ul><h5 id="3-2-回答"><a href="#3-2-回答" class="headerlink" title="3.2 回答"></a>3.2 回答</h5><ul><li><p>回答是一个三位数字，加上可选信息。</p></li><li><p>一些典型的回答连同它们可能的报文：</p><ul><li>331 Usemame OK , Password requüed (用户名 OK ，需要口令)</li><li>125 Dala connection already open; transfer starting (数据连接已经打开，开始传送)</li><li>425 Can’ L open daLa connection (无法打开数据连接)</li><li>452 Error writing (写文件差错)</li></ul></li></ul><h2 id="四、电子邮件"><a href="#四、电子邮件" class="headerlink" title="四、电子邮件"></a>四、电子邮件</h2><h2 id="五、DNS"><a href="#五、DNS" class="headerlink" title="五、DNS"></a>五、DNS</h2><p>因特网的目录服务</p><h2 id="六、P2P"><a href="#六、P2P" class="headerlink" title="六、P2P"></a>六、P2P</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Computer-Network-summery-应用层&quot;&gt;&lt;a href=&quot;#Computer-Network-summery-应用层&quot; class=&quot;headerlink&quot; title=&quot;Computer Network summery  应用层&quot;&gt;&lt;/a&gt;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer Network  summery：运输层</title>
    <link href="http://example.com/2021/06/20/Computer-Network-summery%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/06/20/Computer-Network-summery%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-06-20T11:59:58.000Z</published>
    <updated>2021-06-20T12:06:21.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-summery：运输层"><a href="#Computer-Network-summery：运输层" class="headerlink" title="Computer Network  summery：运输层"></a>Computer Network  summery：运输层</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul><li><p>为运行在不同主机上的进程提供服务（逻辑通信）</p></li><li><p>运输层协议在端系统中实现，不是在路由器中实现。</p></li><li><p>应用层报文段 ：将应用层报文分块，添加运输层首部</p></li><li><p>应用层协议：TCP  / UDP</p><ul><li>TCP :面向连接的，可靠的服务</li><li>UDP：无连接的，不可靠服务</li></ul></li><li><p>网络层可能会使分组丢失，篡改，冗余，运输层可以提供可靠数据传输</p></li><li><p>多路复用和多路分解</p><ul><li><p>多路复用：运输层报文段正确交付到相应 套接字</p></li><li><p>多路分解：主机收集套接字信息，生成运输层报文，并传输到网络层中</p></li><li><p>UDP 的多路复用和分解</p><ul><li>一个UDP套接字：二元组（目的IP，目的端口号）</li></ul></li></ul></li><li><ul><li>tcp的多路复用和分解<ul><li>TCP套接字（目的IP，目的端口号，源IP，源端口号）<ul><li>后续报文段与之匹配，发送到该端口</li></ul></li><li>服务器主机支持很多并行套接字，每个与一个进程相连</li></ul></li></ul></li><li><p>== 端口扫描技术 == </p></li></ul><h2 id="二、UDP协议"><a href="#二、UDP协议" class="headerlink" title="二、UDP协议"></a>二、UDP协议</h2><p>  1.概述</p><ul><li>特点<ul><li>无需建立连接：无连接传输</li><li>分组首部开销小: 首部8个字节</li><li>控制更加精细（与应用层相比）</li><li>无连接的状态：无连接状态参数</li></ul></li><li>用于承载网络管理数据SNMP</li><li>运行的协议和服务：DNS、</li></ul><ol start="2"><li><p>报文结构</p><p>2.1 报文结构:</p></li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526194949625.png" alt="image-20210526194949625"></p><p>​     2.2 检验和：检测传输比特是否改变  </p><ul><li>方法：</li></ul><ul><li>原因：端到端服务需要差错检测，各链路情况不同，无法逐链路确保可靠性   即:</li></ul><h2 id="三、可靠传输原理"><a href="#三、可靠传输原理" class="headerlink" title="三、可靠传输原理"></a>三、可靠传输原理</h2><ol><li><p>流水线可靠数据传输协议</p><ul><li>不使用停等方式运行，允许发送方发送多个分组而无需等待确认， 许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，这种技术被称为流水线( pipelining)</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526195644330.png" alt="image-20210526195644330"></p><ul><li><p>流水线可靠传输协议带来的问题：</p><ul><li><p>必须增加序号范围</p></li><li><p>发送方和接收方两端也许必须缓存多个分组</p></li><li><p>解决流水线的差错恢复有两种基本方法是:回退 (Go- Back- N)</p><p>GBN) 和选择重传 (Selective Repeat. SR)</p></li></ul></li></ul></li><li><p>回退N步</p></li></ol><ol start="3"><li>选择重传</li></ol><h2 id="四、TCP协议"><a href="#四、TCP协议" class="headerlink" title="四、TCP协议"></a>四、TCP协议</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>提供的是全双工服务(full- duplex service)</li><li>TCP 连接是点对点( point-to-point) 的</li><li>连接的建立：三次握手</li><li>连接的断开：四次挥手</li><li>TCP  最大报文段长度 (Maximum Segmenl Size , MSS) ， MSS 的典型值为 1460 字节</li><li>TCP/IP 首部字段长度20字节</li><li>TCP 数据发送和接收依赖两端主机维护的接收缓存和发送缓存。应用程序从此缓存中读取数据流。（每一端都有各自的发送缓存和接收缓存）</li></ul><h3 id="2-报文结构"><a href="#2-报文结构" class="headerlink" title="2.报文结构"></a>2.报文结构</h3><p>：通常是20个字节（选项部分可变长，平常是0）</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526201119908.png" alt="image-20210526201119908"></p><ul><li>32 比特的序号字段 (sequence number field) <ul><li>标记发送方数据报文段首字节的字节流编号</li></ul></li><li>32 比特的确认号字段( acknowledgment number field) <ul><li>主机 期望从主机 收到的下一字节的序号</li></ul></li><li>16 比特的接收窗口字段 (receive window field)<ul><li>用于流量控制</li></ul></li><li>可选与变长的选项字段（options field) </li><li>4 比特的首部长度字段 (header length field)</li><li>6 比特的标志字段 (fLag field) <ul><li>RST SYN FIN 比特用于连接建立和拆除</li><li>PSH ： 指示接收方应立即尽可能得将数据交给上层</li><li>URG ：指示报文段存在着被发送端的上层实体置为”紧急”的数据 紧急数据的最后一个字节由 16 比特的数据指针字段指出。</li></ul></li><li>接收窗口</li></ul><h3 id="3-累计确认"><a href="#3-累计确认" class="headerlink" title="3.累计确认"></a>3.累计确认</h3><p>对客户到服务器的数据的确认被装载在</p><p>个承载服务器到客户的数据的报文段中;这种确认被称为是被捎带( piggybacked )在服务器到客户的数据报文段中的</p><h3 id="4-超时重传"><a href="#4-超时重传" class="headerlink" title="4.超时重传"></a>4.超时重传</h3><p>4.1往返时间的估计</p><ul><li><p>样本RTT:某报文段的确认被收到之间的时间量</p><ul><li>为已发送，未确认的报文段估计 SampleRTT</li><li>不为已被重传的报文段计算 SampleRTT; </li></ul></li><li><p>SampleRTT 均值  (称为 EstimatedRTT)</p><ul><li><p>计算方法：</p><p>EstÌmatedRTT = (1 -α) . EstimatedRTT +α. SampleRTT </p></li><li><p>α的 参考值是α=0.125 </p></li></ul></li><li><p>RTT 偏差DevRTT</p><ul><li>DevRTT = (1 -β) . DevRTT +β. I SampleRTT matedRTT I </li><li>β 的推荐值为 0.25</li></ul></li><li><p>重传超时间隔</p><ul><li>算法：TimeoutInterval = EstimatedRTI +4 . DevRTT</li><li>推荐的初始 TimeoutInterval 值为1 秒</li></ul></li></ul><h3 id="5-可靠数据传输："><a href="#5-可靠数据传输：" class="headerlink" title="5.可靠数据传输："></a>5.可靠数据传输：</h3><ul><li><p>TCP 发送方与发送和重传有关的主要事件:从应用程序接收数据;定时器超时和收到 ACK </p><ul><li>定时器：当报文段被传给 IP时， TCP 启动定时器</li><li>超时：重传报文段，TCP重启定时器</li><li>ACK：包含了有效 ACK 字段值的报文段的接受和比较</li></ul></li><li><h2 id="一些特殊情况："><a href="#一些特殊情况：" class="headerlink" title="一些特殊情况："></a>一些特殊情况：</h2></li><li><p>超时间隔加倍</p></li><li><p>快速重传：一旦收到 个冗余 ACK ，TCP 就执行快速重传(fast retransmil) </p><ul><li>超时重传超时周期长，增加了端到端时延</li><li>冗余 ACK(duplicate ACK)   （出现在报文丢失）对相同数据的 ACK</li></ul></li><li><p>TCP 确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的</p></li></ul><h3 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6.流量控制"></a>6.流量控制</h3><p>6.1概念：</p><p>流量控制服务( fl0w- control service) 以消除发送方使接收方缓存溢出的可能性。</p><ul><li><p>接收缓存</p><ul><li><p>用RcvBuffer 来表示其大小</p></li><li><p>• LastByteReacl: 主机 上的应用进程从发送缓存读出的数据流的最后 个字节的编号</p><p>• LastByteRcvd:  到达的并已放入主机 接收缓存中的数据流的最后字节编号</p></li><li><p>算法：LasLByteRcvd - LastByteRead ~ RcvBuffer </p></li></ul></li><li><p>接收窗口用：rwnd </p><ul><li>根据缓存可用空间的数量来设置:</li><li>rwnd = RcvBuffer - [LastByteRcvd - LastßyteRead ] </li><li><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211048201.png" alt="image-20210526211048201"></li></ul></li><li><p>主机在该连接的整个生命周期应保证:</p><p>​                LastByteSent - LastByteAcked &lt;=rwnd</p></li></ul><h3 id="7-TCP连接"><a href="#7-TCP连接" class="headerlink" title="7.TCP连接"></a>7.TCP连接</h3><p>7.1建立连接</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211607326.png" alt="image-20210526211607326"></p><p>7.2 连接的断开</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211636290.png" alt="image-20210526211636290"></p><p>7.3 状态的变迁</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211720656.png" alt="image-20210526211720656"></p><p>7.4 SYN泛洪攻击</p><h3 id="8-拥塞控制"><a href="#8-拥塞控制" class="headerlink" title="8.拥塞控制"></a>8.拥塞控制</h3><p>7.1 概念：TCP 发送方因 网络的拥塞而被遏制;这种形式的发送方的控制被称为拥塞控制 (congestion control)</p><ul><li><p>在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥塞窗口</p><p>(congeslion window) 。</p><ul><li><p>拥塞窗口表示为 cwnd  对 TCP 发送方 发送流量的速率进行了限制 </p></li><li><p>在一个发送方中未被确认的数据量不会超过 cwnd rwnd 中的最小值，即：</p><p>LastyleSent - LastByteAcked&lt;= min { cwnd ，rwnd }</p></li></ul></li></ul><p>7.2拥塞控制：</p><ul><li><p>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率</p></li><li><p>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此 ，当对先前未确认报文段的确认到达时，增加发送方的速率。</p></li><li><p>带宽探测：为探测拥塞开始出现的速率， TCP 发送方增加它的</p><p>传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化</p></li></ul><p>7.3拥塞控制算法</p><p>该算法包括 个主要部分 ①慢启动;②拥塞避免;③快速恢复</p><p>如图所示：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526213509588.png" alt="image-20210526213509588"></p><ol><li><p>慢启动</p><p>TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据包的数量</p><p>慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 <strong>ACK</strong>，拥塞窗⼝ <strong>cwnd</strong> 的⼤⼩就会加 <strong>1</strong>。</p><p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</p><p>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</p><p>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</p><p>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发</p><p>4 个，所以这⼀次能够发送 8 个。</p></li><li><p>拥塞避免算法</p></li></ol><ul><li><p>当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。</p></li><li><p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。</p></li><li><p>规则：每当收到⼀个 <strong>ACK</strong> 时，<strong>cwnd</strong> 增加 <strong>1/cwnd</strong>。</p></li><li><p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ： </p></li></ul><p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9</p><p>个 MSS ⼤⼩的数据，变成了线性增⻓。</p><ul><li>拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶段，但是增⻓速度缓慢了。</li></ul><p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」。</p><p>拥塞发⽣</p><p>当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：</p><p>超时重传</p><p>快速重传</p><p>这两种使⽤的拥塞发送算法是不同的， </p><ol><li>发⽣超时重传的拥塞发⽣算法</li></ol><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。</p><ul><li><p>ssthresh 和 cwnd 的值会发⽣变化：</p><p>​                ssthresh 设为 cwnd/2 ，cwnd 重置为 1</p></li></ul><p>2.发⽣快速重传的拥塞发⽣算法</p><p>还有更好的⽅式，前⾯我们讲过「快速重传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地᯿传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：</p><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p><p>ssthresh = cwnd ;进⼊快速恢复算法</p><p>3.快速恢复</p><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也不那么糟</p><p>糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：</p><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p><p>ssthresh = cwnd ;</p><p>然后，进⼊快速恢复算法如下：</p><p>拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</p><p>重传丢失的数据包；</p><p>如果再收到重复的 ACK，那么 cwnd 增加 1；</p><p>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说</p><p>明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进</p><p>⼊拥塞避免状态；也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。</p><ol start="4"><li><p>回顾</p><p>TCP 的拥塞控制是:</p></li></ol><p>每个 RTT cwnd 线性(加性)增加 lMSS ，然后出现 个冗余ACK 事件时 cwnd 减半(乘性减) 。</p><p>因此， TCP 拥塞控制常常被称为加性增、乘性减(Additive-lncrease , Multiplicati 吨- Decrease , AIMD) 拥塞控制方式 </p><ul><li><p>整体流程</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526214305050.png" alt="image-20210526214305050"></p></li><li><p>其他算法：Reno 算法、TCPVegas 算法</p></li></ul><p>参考文献  :计算机网络自顶向下方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Computer-Network-summery：运输层&quot;&gt;&lt;a href=&quot;#Computer-Network-summery：运输层&quot; class=&quot;headerlink&quot; title=&quot;Computer Network  summery：运输层&quot;&gt;&lt;/a&gt;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/04/30/summery-of%20-advanced-SQL/"/>
    <id>http://example.com/2021/04/30/summery-of%20-advanced-SQL/</id>
    <published>2021-04-30T01:34:58.274Z</published>
    <updated>2021-04-30T01:34:58.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql并发参数调整"><a href="#Mysql并发参数调整" class="headerlink" title="Mysql并发参数调整"></a><a href="https://www.cnblogs.com/roadlandscape/p/12808422.html">Mysql并发参数调整</a></h1><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p><p>1.max_connections</p><p>　　采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。<br>　　Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><p>　　　　show variables like ‘max_connections’　　最大连接数</p><p>　　　　show status like ‘max_used_connections’　　响应的连接数</p><p>　　　　max_used_connections / max_connections * 100% （理想值≈ 85%）</p><p>2.back_log</p><p>　　back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 +（max_connections / 5）， 但最大不超过900。<br>　　如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><p>3.table_open_cache</p><p>　　该参数用来控制所有SQL语句执行线程可打开表缓存的数量（针对整个数据库，不是session会话）， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：max_connections*N</p><p>4.thread_cache_size</p><p>　　为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p><p>5.innodb_lock_wait_timeout</p><p>　　该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说，可以将行锁的等待时间调大， 以避免发生大的回滚操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql并发参数调整&quot;&gt;&lt;a href=&quot;#Mysql并发参数调整&quot; class=&quot;headerlink&quot; title=&quot;Mysql并发参数调整&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/roadlandscape/p/1280</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/04/30/%E7%9B%AE%E6%A0%87/"/>
    <id>http://example.com/2021/04/30/%E7%9B%AE%E6%A0%87/</id>
    <published>2021-04-30T01:32:08.908Z</published>
    <updated>2021-04-30T01:32:09.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>​    一、为什么要学习数据库<br>​    二、数据库的相关概念<br>​        DBMS、DB、SQL<br>​    三、数据库存储数据的特点<br>​    四、初始MySQL<br>​        MySQL产品的介绍<br>​        MySQL产品的安装          ★<br>​        MySQL服务的启动和停止     ★<br>​        MySQL服务的登录和退出     ★<br>​        MySQL的常见命令和语法规范<br>​    五、DQL语言的学习   ★<br>​        基础查询        ★<br>​        条件查询         ★<br>​        排序查询         ★<br>​        常见函数        ★<br>​        分组函数        ★<br>​        分组查询           ★<br>​        连接查询         ★<br>​        子查询       √<br>​        分页查询       ★<br>​        union联合查询    √<br>​        </p><pre><code>六、DML语言的学习    ★                 插入语句                            修改语句                            删除语句                        七、DDL语言的学习      库和表的管理     √                    常见数据类型介绍  √              常见约束        √            八、TCL语言的学习    事务和事务处理                 九、视图的讲解           √十、变量                      十一、存储过程和函数   十二、流程控制结构       </code></pre><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><p>​    1.持久化数据到本地<br>​    2.可以实现结构化查询，方便管理<br>​    </p><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p><p>##数据库存储数据的特点<br>    1、将数据放到表中，表再放到库中<br>    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><p>###MySQL服务的启动和停止<br>    方式一：计算机——右击管理——服务<br>    方式二：通过管理员身份运行<br>    net start 服务名（启动服务）<br>    net stop 服务名（停止服务）</p><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>​    方式一：通过mysql自带的客户端<br>​    只限于root用户</p><pre><code>方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C</code></pre><p>​<br>​    </p><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写<br>​    2.每条命令最好用分号结尾<br>​    3.每条命令根据需要，可以进行缩进 或换行<br>​    4.注释<br>​        单行注释：#注释文字<br>​        单行注释：– 注释文字<br>​        多行注释：/* 注释文字  */<br>​<br>​<br>​    </p><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><p>​    DQL（Data Query Language）：数据查询语言<br>​        select<br>​    DML(Data Manipulate Language):数据操作语言<br>​        insert 、update、delete<br>​    DDL（Data Define Languge）：数据定义语言<br>​        create、drop、alter<br>​    TCL（Transaction Control Language）：事务控制语言<br>​        commit、rollback<br>​    </p><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><p>​    语法：<br>​    SELECT 要查询的东西<br>​    【FROM 表名】;</p><pre><code>类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><p>​    条件查询：根据条件过滤原始表的数据，查询到想要的数据<br>​    语法：<br>​    select<br>​        要查询的字段|表达式|常量值|函数<br>​    from<br>​        表<br>​    where<br>​        条件 ;</p><pre><code>分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><p>​    一、单行函数<br>​    1、字符函数<br>​        concat拼接<br>​        substr截取子串<br>​        upper转换成大写<br>​        lower转换成小写<br>​        trim去前后指定的空格和字符<br>​        ltrim去左边空格<br>​        rtrim去右边空格<br>​        replace替换<br>​        lpad左填充<br>​        rpad右填充<br>​        instr返回子串第一次出现的索引<br>​        length 获取字节个数<br>​        </p><pre><code>2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断    5、其他函数    version版本    database当前库    user当前连接用户</code></pre><p>​    </p><p>二、分组函数</p><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><p>​    语法：<br>​    select 查询的字段，分组函数<br>​    from 表<br>​    group by 分组的字段<br>​<br>​    </p><pre><code>特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选        针对的表    位置            关键字分组前筛选：    原始表        group by的前面        where分组后筛选：    分组后的结果集    group by的后面        having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名</code></pre><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空    ② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><p>表的管理：<br>    1.创建表</p><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME</code></pre><p>​<br>​    );<br>​<br>​    DESC studentinfo;<br>​    #2.修改表 alter<br>​    语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;<br>​<br>    #①修改字段名<br>    ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</p><pre><code>#②修改表名ALTER TABLE stuinfo RENAME [TO]  studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;</code></pre><p>​<br>​    #3.删除表<br>​<br>​    DROP TABLE [IF EXISTS] studentinfo;</p><p>​    </p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：    小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    （ACID）<br>​    原子性：要么都执行，要么都回滚<br>​    一致性：保证数据的状态操作前和操作后保持一致<br>​    隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰<br>​    持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</p><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>    1、开启事务    取消自动提交事务的功能        2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete        3、提交事务或回滚事务</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p><p>视图和表的区别：</p><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表    完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>​    语法：<br>​    CREATE VIEW  视图名<br>​    AS<br>​    查询语句;</p><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><p>​    1、查看视图的数据 ★<br>​    </p><pre><code>SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;</code></pre><p>​<br>​    4、删除视图的数据<br>​    DELETE FROM my_v4;</p><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><p>​    #方式一：<br>​    CREATE OR REPLACE VIEW test_v7<br>​    AS<br>​    SELECT last_name FROM employees<br>​    WHERE employee_id&gt;100;<br>​    </p><pre><code>#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>​    DROP VIEW test_v1,test_v2,test_v3;</p><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><p>​    DESC test_v7;<br>​    SHOW CREATE VIEW test_v7;</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><p>​    call 存储过程名(实参列表)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>​    SELECT 函数名（实参列表）</p><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><p>二、局部变量</p><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><p>二者的区别：</p><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p>三、if elseif语句</p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;​    一、为什么要学习数据库&lt;br&gt;​    二、数据库的相关概念&lt;br&gt;​        DBMS、DB、SQL&lt;br&gt;​    三、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL常见问题</title>
    <link href="http://example.com/2021/04/28/SQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/04/28/SQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-28T09:16:53.000Z</published>
    <updated>2021-04-28T09:34:16.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="delete-truncate-drop-的区别"><a href="#delete-truncate-drop-的区别" class="headerlink" title="delete truncate drop 的区别"></a>delete truncate drop 的区别</h2><p>TRUNCATE TABLE 在功能上与不带 Where 子句的 Delete 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 Delete 速度快，且使用的系统和事务日志资源少。</p><p> Delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p> TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 Delete。</p><p> 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 Where 子句的 Delete 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><p> TRUNCATE TABLE 不能用于参与了索引视图的表。</p><p> truncate,delete,drop的异同点：<br> 注意:这里说的delete是指不带where子句的delete语句</p><p>相同点:truncate和不带where子句的delete, 以及drop都会删除表内的数据 </p><p>不同点:<br>   1.truncate和 delete只删除数据不删除表的结构(定义)<br>    drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.</p><p>   2.delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.<br>    truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p><p>   3.delete语句不影响表所占用的extent, 高水线(high w2atermark)保持原位置不动<br>    显然drop语句将表所占用的空间全部释放<br>    truncate 语句缺省情况下将空间释放到 minextents个 extent,除非使用reuse storage;  truncate会将高水线复位(回到最开始).</p><p>   4.速度,一般来说: drop&gt; truncate &gt; delete</p><p>   5.安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及</p><p>   使用上：<br>   想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.</p><p>   想删除表,当然用drop</p><p>   想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.</p><p>   如果是整理表内部的碎片,可以用truncate跟上reuse stroage,再重新导入/插入数据</p><h2 id="sql基本组成"><a href="#sql基本组成" class="headerlink" title="sql基本组成"></a>sql基本组成</h2><p><strong>DDL****（Data</strong> <strong>Definition Language</strong>）<strong>数据库<strong><strong>定义</strong></strong>语言</strong></p><p>  DDL不需要commit. eg. CREATE ALTER DROP TRUNCATE COMMENT RENAME</p><p>****DML**（*<em>Data Manipulation Language*<em>）*<em>数据操纵语言*</em></em></em></p><p>  DML需要commit. eg. SELECT INSERT UPDATE DELETE MERGE CALL EXPLAIN PLAN LOCK TABLE</p><p><strong>DCL<strong><strong>（</strong></strong>Data Control Language<strong><strong>）</strong></strong>数据库控制语言</strong> <strong>授权，角色控制等</strong><br>  GRANT 授权, REVOKE 取消授权<br><strong>TCL<strong><strong>（</strong></strong>Transaction Control Language<strong><strong>）</strong></strong>事务控制语言</strong><br>  SAVEPOINT 设置保存点, ROLLBACK 回滚, SET TRANSACTION</p><h2 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h2><p>sql执行顺序<br>(1)from<br>(3) join<br>(2) on<br>(4) where<br>(5)group by(开始使用select中的别名，后面的语句中都可以使用)<br>(6) avg,sum….<br>(7)having<br>(8) select<br>(9) distinct<br>(10) order by</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>Knolege Point SQL</title>
    <link href="http://example.com/2021/04/28/Knolege-Point-SQL/"/>
    <id>http://example.com/2021/04/28/Knolege-Point-SQL/</id>
    <published>2021-04-28T09:14:52.000Z</published>
    <updated>2021-04-28T09:35:58.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>​    一、为什么要学习数据库<br>​    二、数据库的相关概念<br>​        DBMS、DB、SQL<br>​    三、数据库存储数据的特点<br>​    四、初始MySQL<br>​        MySQL产品的介绍<br>​        MySQL产品的安装          ★<br>​        MySQL服务的启动和停止     ★<br>​        MySQL服务的登录和退出     ★<br>​        MySQL的常见命令和语法规范<br>​    五、DQL语言的学习   ★<br>​        基础查询        ★<br>​        条件查询         ★<br>​        排序查询         ★<br>​        常见函数        ★<br>​        分组函数        ★<br>​        分组查询           ★<br>​        连接查询         ★<br>​        子查询       √<br>​        分页查询       ★<br>​        union联合查询    √<br>​        </p><pre><code>六、DML语言的学习    ★                 插入语句                            修改语句                            删除语句                        七、DDL语言的学习      库和表的管理     √                    常见数据类型介绍  √              常见约束        √            八、TCL语言的学习    事务和事务处理                 九、视图的讲解           √十、变量                      十一、存储过程和函数   十二、流程控制结构       </code></pre><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><p>​    1.持久化数据到本地<br>​    2.可以实现结构化查询，方便管理<br>​    </p><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p><p>##数据库存储数据的特点<br>    1、将数据放到表中，表再放到库中<br>    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><p>###MySQL服务的启动和停止<br>    方式一：计算机——右击管理——服务<br>    方式二：通过管理员身份运行<br>    net start 服务名（启动服务）<br>    net stop 服务名（停止服务）</p><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>​    方式一：通过mysql自带的客户端<br>​    只限于root用户</p><pre><code>方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C</code></pre><p>​<br>​    </p><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写<br>​    2.每条命令最好用分号结尾<br>​    3.每条命令根据需要，可以进行缩进 或换行<br>​    4.注释<br>​        单行注释：#注释文字<br>​        单行注释：– 注释文字<br>​        多行注释：/* 注释文字  */<br>​<br>​<br>​    </p><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><p>​    DQL（Data Query Language）：数据查询语言<br>​        select<br>​    DML(Data Manipulate Language):数据操作语言<br>​        insert 、update、delete<br>​    DDL（Data Define Languge）：数据定义语言<br>​        create、drop、alter<br>​    TCL（Transaction Control Language）：事务控制语言<br>​        commit、rollback<br>​    </p><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><p>​    语法：<br>​    SELECT 要查询的东西<br>​    【FROM 表名】;</p><pre><code>类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><p>​    条件查询：根据条件过滤原始表的数据，查询到想要的数据<br>​    语法：<br>​    select<br>​        要查询的字段|表达式|常量值|函数<br>​    from<br>​        表<br>​    where<br>​        条件 ;</p><pre><code>分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><p>​    一、单行函数<br>​    1、字符函数<br>​        concat拼接<br>​        substr截取子串<br>​        upper转换成大写<br>​        lower转换成小写<br>​        trim去前后指定的空格和字符<br>​        ltrim去左边空格<br>​        rtrim去右边空格<br>​        replace替换<br>​        lpad左填充<br>​        rpad右填充<br>​        instr返回子串第一次出现的索引<br>​        length 获取字节个数<br>​        </p><pre><code>2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断    5、其他函数    version版本    database当前库    user当前连接用户</code></pre><p>​    </p><p>二、分组函数</p><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><p>​    语法：<br>​    select 查询的字段，分组函数<br>​    from 表<br>​    group by 分组的字段<br>​<br>​    </p><pre><code>特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选        针对的表    位置            关键字分组前筛选：    原始表        group by的前面        where分组后筛选：    分组后的结果集    group by的后面        having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名</code></pre><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空    ② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><p>表的管理：<br>    1.创建表</p><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME</code></pre><p>​<br>​    );<br>​    </p><pre><code>DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO]  studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;</code></pre><p>​<br>​    #3.删除表<br>​    </p><pre><code>DROP TABLE [IF EXISTS] studentinfo;</code></pre><p>​    </p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：    小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    （ACID）<br>​    原子性：要么都执行，要么都回滚<br>​    一致性：保证数据的状态操作前和操作后保持一致<br>​    隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰<br>​    持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</p><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>    1、开启事务    取消自动提交事务的功能        2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete        3、提交事务或回滚事务</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p><p>视图和表的区别：</p><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表    完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>​    语法：<br>​    CREATE VIEW  视图名<br>​    AS<br>​    查询语句;</p><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><p>​    1、查看视图的数据 ★<br>​    </p><pre><code>SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;</code></pre><p>​<br>​    4、删除视图的数据<br>​    DELETE FROM my_v4;</p><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><p>​    #方式一：<br>​    CREATE OR REPLACE VIEW test_v7<br>​    AS<br>​    SELECT last_name FROM employees<br>​    WHERE employee_id&gt;100;<br>​    </p><pre><code>#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>​    DROP VIEW test_v1,test_v2,test_v3;</p><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><p>​    DESC test_v7;<br>​    SHOW CREATE VIEW test_v7;</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><p>​    call 存储过程名(实参列表)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>​    SELECT 函数名（实参列表）</p><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><p>二、局部变量</p><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><p>二者的区别：</p><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p>三、if elseif语句</p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
  </entry>
  
  <entry>
    <title>Summery of SQL Basic</title>
    <link href="http://example.com/2021/04/28/Summery-of-SQL-Basic/"/>
    <id>http://example.com/2021/04/28/Summery-of-SQL-Basic/</id>
    <published>2021-04-28T09:05:48.000Z</published>
    <updated>2021-04-28T09:34:59.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1：基础查询"><a href="#1：基础查询" class="headerlink" title="1：基础查询"></a>1：基础查询</h3><p>语法：<br>select 查询列表 from 表名;</p><p>类似于：System.out.println(打印东西);</p><p>特点：</p><p>1、查询列表可以是：表中的字段、常量值、表达式、函数<br>2、查询的结果是一个虚拟的表格</p><p>USE myemployees;</p><h5 id="1-查询表中的单个字段"><a href="#1-查询表中的单个字段" class="headerlink" title="1.查询表中的单个字段"></a>1.查询表中的单个字段</h5><p>​                SELECT last_name FROM employees;</p><h5 id="2-查询表中的多个字段"><a href="#2-查询表中的多个字段" class="headerlink" title="2.查询表中的多个字段"></a>2.查询表中的多个字段</h5><p>​                SELECT last_name,salary,email FROM employees;</p><h5 id="3-查询表中的所有字段"><a href="#3-查询表中的所有字段" class="headerlink" title="3.查询表中的所有字段"></a>3.查询表中的所有字段</h5><h6 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h6><p>SELECT<br>    <code>employee_id</code>,<br>    <code>first_name</code>,<br>    <code>last_name</code>,<br>    <code>phone_number</code>,<br>    <code>last_name</code>,<br>    <code>job_id</code>,<br>    <code>phone_number</code>,<br>    <code>job_id</code>,<br>    <code>salary</code>,<br>    <code>commission_pct</code>,<br>    <code>manager_id</code>,<br>    <code>department_id</code>,<br>    <code>hiredate</code><br>FROM<br>    employees ;</p><h6 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h6><p> SELECT * FROM employees;</p><h5 id="4-查询常量值"><a href="#4-查询常量值" class="headerlink" title="4.查询常量值"></a>4.查询常量值</h5><p> SELECT 100;<br> SELECT ‘john’;</p><h5 id="5-查询表达式"><a href="#5-查询表达式" class="headerlink" title="5.查询表达式"></a>5.查询表达式</h5><p> SELECT 100%98;</p><h5 id="6-查询函数"><a href="#6-查询函数" class="headerlink" title="6.查询函数"></a>6.查询函数</h5><p> SELECT VERSION();</p><h5 id="7-起别名"><a href="#7-起别名" class="headerlink" title="7.起别名"></a>7.起别名</h5><p> ①便于理解<br> ②如果要查询的字段有重名的情况，使用别名可以区分开来</p><h6 id="方式一：使用as"><a href="#方式一：使用as" class="headerlink" title="方式一：使用as"></a>方式一：使用as</h6><p>SELECT 100%98 AS 结果;<br>SELECT last_name AS 姓,first_name AS 名 FROM employees;</p><h6 id="方式二：使用空格"><a href="#方式二：使用空格" class="headerlink" title="方式二：使用空格"></a>方式二：使用空格</h6><p>SELECT last_name 姓,first_name 名 FROM employees;</p><h6 id="案例：查询salary，显示结果为-out-put"><a href="#案例：查询salary，显示结果为-out-put" class="headerlink" title="案例：查询salary，显示结果为 out put"></a>案例：查询salary，显示结果为 out put</h6><p>SELECT salary AS “out put” FROM employees;</p><h5 id="8-去重"><a href="#8-去重" class="headerlink" title="8.去重"></a>8.去重</h5><h6 id="案例：查询员工表中涉及到的所有的部门编号"><a href="#案例：查询员工表中涉及到的所有的部门编号" class="headerlink" title="案例：查询员工表中涉及到的所有的部门编号"></a>案例：查询员工表中涉及到的所有的部门编号</h6><p>SELECT DISTINCT department_id FROM employees;</p><h5 id="9-号的作用"><a href="#9-号的作用" class="headerlink" title="9.+号的作用"></a>9.+号的作用</h5><p> java中的+号：<br>①运算符，两个操作数都为数值型<br>②连接符，只要有一个操作数为字符串</p><p>mysql中的+号：<br>仅仅只有一个功能：运算符</p><p>select 100+90; 两个操作数都为数值型，则做加法运算<br>select ‘123’+90;只要其中一方为字符型，试图将字符型数值转换成数值型<br>            如果转换成功，则继续做加法运算<br>select ‘john’+90;    如果转换失败，则将字符型数值转换成0</p><p>select null+10; 只要其中一方为null，则结果肯定为null</p><h5 id="案例：查询员工名和姓连接成一个字段，并显示为-姓名"><a href="#案例：查询员工名和姓连接成一个字段，并显示为-姓名" class="headerlink" title="案例：查询员工名和姓连接成一个字段，并显示为 姓名"></a>案例：查询员工名和姓连接成一个字段，并显示为 姓名</h5><p>SELECT CONCAT(‘a’,’b’,’c’) AS 结果;</p><p>SELECT<br>    CONCAT(last_name,first_name) AS 姓名<br>FROM<br>    employees;</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>​    </p><pre><code>  1.    下面的语句是否可以执行成功  </code></pre><p>SELECT last_name , job_id , salary AS sal<br>FROM employees; </p><h5 id="2-下面的语句是否可以执行成功"><a href="#2-下面的语句是否可以执行成功" class="headerlink" title="2.下面的语句是否可以执行成功"></a>2.下面的语句是否可以执行成功</h5><p>SELECT  *  FROM employees; </p><h5 id="3-找出下面语句中的错误"><a href="#3-找出下面语句中的错误" class="headerlink" title="3.找出下面语句中的错误"></a>3.找出下面语句中的错误</h5><p>SELECT employee_id , last_name,<br>salary * 12 AS “ANNUAL  SALARY”<br>FROM employees;</p><h5 id="4-显示表departments的结构，并查询其中的全部数据"><a href="#4-显示表departments的结构，并查询其中的全部数据" class="headerlink" title="4.显示表departments的结构，并查询其中的全部数据"></a>4.显示表departments的结构，并查询其中的全部数据</h5><p>DESC departments;<br>SELECT * FROM <code>departments</code>;</p><h5 id="5-显示出表employees中的全部job-id（不能重复）"><a href="#5-显示出表employees中的全部job-id（不能重复）" class="headerlink" title="5.显示出表employees中的全部job_id（不能重复）"></a>5.显示出表employees中的全部job_id（不能重复）</h5><p>SELECT DISTINCT job_id FROM employees;</p><h5 id="6-显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT-PUT"><a href="#6-显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT-PUT" class="headerlink" title="6.显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT"></a>6.显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</h5><p>SELECT<br>    IFNULL(commission_pct,0) AS 奖金率,<br>    commission_pct<br>FROM<br>    employees;</p><p>#——————————————-</p><p>SELECT<br>    CONCAT(<code>first_name</code>,’,’,<code>last_name</code>,’,’,<code>job_id</code>,’,’,IFNULL(commission_pct,0)) AS out_put<br>FROM<br>    employees;</p><h3 id="2：条件查询"><a href="#2：条件查询" class="headerlink" title="2：条件查询"></a>2：条件查询</h3><p>语法：<br>    select<br>        查询列表<br>    from<br>        表名<br>    where<br>        筛选条件;</p><p>分类：<br>    一、按条件表达式筛选</p><pre><code>简单条件运算符：&gt; &lt; = != &lt;&gt; &gt;= &lt;=二、按逻辑表达式筛选逻辑运算符：作用：用于连接条件表达式    &amp;&amp; || !    and or not    &amp;&amp;和and：两个条件都为true，结果为true，反之为false||或or： 只要有一个条件为true，结果为true，反之为false!或not： 如果连接的条件本身为false，结果为true，反之为false三、模糊查询    like    between and    in    is null</code></pre><h4 id="一、按条件表达式筛选"><a href="#一、按条件表达式筛选" class="headerlink" title="一、按条件表达式筛选"></a>一、按条件表达式筛选</h4><h6 id="案例1：查询工资-gt-12000的员工信息"><a href="#案例1：查询工资-gt-12000的员工信息" class="headerlink" title="案例1：查询工资&gt;12000的员工信息"></a>案例1：查询工资&gt;12000的员工信息</h6><p>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    salary&gt;12000;</p><h6 id="案例2：查询部门编号不等于90号的员工名和部门编号"><a href="#案例2：查询部门编号不等于90号的员工名和部门编号" class="headerlink" title="案例2：查询部门编号不等于90号的员工名和部门编号"></a>案例2：查询部门编号不等于90号的员工名和部门编号</h6><p>SELECT<br>    last_name,<br>    department_id<br>FROM<br>    employees<br>WHERE<br>    department_id&lt;&gt;90;</p><h4 id="二、按逻辑表达式筛选"><a href="#二、按逻辑表达式筛选" class="headerlink" title="二、按逻辑表达式筛选"></a>二、按逻辑表达式筛选</h4><p>#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金<br>SELECT<br>    last_name,<br>    salary,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    salary&gt;=10000 AND salary&lt;=20000;<br>#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息<br>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    NOT(department_id&gt;=90 AND  department_id&lt;=110) OR salary&gt;15000;</p><h4 id="三、模糊查询"><a href="#三、模糊查询" class="headerlink" title="三、模糊查询"></a>三、模糊查询</h4><p>like<br>between and<br>in<br>is null|is not null</p><h4 id="1-like"><a href="#1-like" class="headerlink" title="1.like"></a>1.like</h4><p>特点：<br>①一般和通配符搭配使用<br>    通配符：<br>    % 任意多个字符,包含0个字符<br>    _ 任意单个字符<br>*、</p><h5 id="案例1：查询员工名中包含字符a的员工信息"><a href="#案例1：查询员工名中包含字符a的员工信息" class="headerlink" title="案例1：查询员工名中包含字符a的员工信息"></a>案例1：查询员工名中包含字符a的员工信息</h5><p>select<br>    *<br>from<br>    employees<br>where<br>    last_name like ‘%a%’;#abc</p><h5 id="案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资"><a href="#案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资" class="headerlink" title="案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资"></a>案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资</h5><p>select<br>    last_name,<br>    salary<br>FROM<br>    employees<br>WHERE<br>    last_name LIKE ‘__n_l%’;</p><h5 id="案例3：查询员工名中第二个字符为-的员工名"><a href="#案例3：查询员工名中第二个字符为-的员工名" class="headerlink" title="案例3：查询员工名中第二个字符为_的员工名"></a>案例3：查询员工名中第二个字符为_的员工名</h5><p>SELECT<br>    last_name<br>FROM<br>    employees<br>WHERE<br>    last_name LIKE ‘<em>$</em>%’ ESCAPE ‘$’;</p><h4 id="2-between-and"><a href="#2-between-and" class="headerlink" title="2.between and"></a>2.between and</h4><p>①使用between and 可以提高语句的简洁度<br>②包含临界值<br>③两个临界值不要调换顺序</p><h5 id="案例1：查询员工编号在100到120之间的员工信息"><a href="#案例1：查询员工编号在100到120之间的员工信息" class="headerlink" title="案例1：查询员工编号在100到120之间的员工信息"></a>案例1：查询员工编号在100到120之间的员工信息</h5><p>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    employee_id &gt;= 120 AND employee_id&lt;=100;<br>#———————-<br>SELECT<br>    *<br>FROM<br>    employees<br>WHERE<br>    employee_id BETWEEN 120 AND 100;</p><h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a>3.in</h4><p>含义：判断某字段的值是否属于in列表中的某一项<br>特点：<br>    ①使用in提高语句简洁度<br>    ②in列表的值类型必须一致或兼容<br>    ③in列表中不支持通配符</p><h5 id="案例：查询员工的工种编号是-IT-PROG、AD-VP、AD-PRES中的一个员工名和工种编号"><a href="#案例：查询员工的工种编号是-IT-PROG、AD-VP、AD-PRES中的一个员工名和工种编号" class="headerlink" title="案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号"></a>案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</h5><p>SELECT<br>    last_name,<br>    job_id<br>FROM<br>    employees<br>WHERE<br>    job_id = ‘IT_PROT’ OR job_id = ‘AD_VP’ OR JOB_ID =’AD_PRES’;</p><p>#——————</p><p>SELECT<br>    last_name,<br>    job_id<br>FROM<br>    employees<br>WHERE<br>    job_id IN( ‘IT_PROT’ ,’AD_VP’,’AD_PRES’);</p><h4 id="4、is-null"><a href="#4、is-null" class="headerlink" title="4、is null"></a>4、is null</h4><p>=或&lt;&gt;不能用于判断null值<br>is null或is not null 可以判断null值</p><h5 id="案例1：查询没有奖金的员工名和奖金率"><a href="#案例1：查询没有奖金的员工名和奖金率" class="headerlink" title="案例1：查询没有奖金的员工名和奖金率"></a>案例1：查询没有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct IS NULL;</p><h5 id="案例1：查询有奖金的员工名和奖金率"><a href="#案例1：查询有奖金的员工名和奖金率" class="headerlink" title="案例1：查询有奖金的员工名和奖金率"></a>案例1：查询有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct IS NOT NULL;</p><p>#———-以下为×<br>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees</p><p>WHERE<br>    salary IS 12000;</p><h4 id="安全等于-lt-gt"><a href="#安全等于-lt-gt" class="headerlink" title="安全等于  &lt;=&gt;"></a>安全等于  &lt;=&gt;</h4><h5 id="案例1：查询没有奖金的员工名和奖金率-1"><a href="#案例1：查询没有奖金的员工名和奖金率-1" class="headerlink" title="案例1：查询没有奖金的员工名和奖金率"></a>案例1：查询没有奖金的员工名和奖金率</h5><p>SELECT<br>    last_name,<br>    commission_pct<br>FROM<br>    employees<br>WHERE<br>    commission_pct &lt;=&gt;NULL;</p><h5 id="案例2：查询工资为12000的员工信息"><a href="#案例2：查询工资为12000的员工信息" class="headerlink" title="案例2：查询工资为12000的员工信息"></a>案例2：查询工资为12000的员工信息</h5><p>SELECT<br>    last_name,<br>    salary<br>FROM<br>    employees</p><p>WHERE<br>    salary &lt;=&gt; 12000;</p><p>#is null pk &lt;=&gt;</p><p>IS NULL:仅仅可以判断NULL值，可读性较高，建议使用<br>&lt;=&gt;    :既可以判断NULL值，又可以判断普通的数值，可读性较低</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><h5 id="1-显示系统时间-注：日期-时间"><a href="#1-显示系统时间-注：日期-时间" class="headerlink" title="1.显示系统时间(注：日期+时间)"></a>1.显示系统时间(注：日期+时间)</h5><p>SELECT NOW();</p><h5 id="2-查询员工号，姓名，工资，以及工资提高百分之20-后的结果（new-salary）"><a href="#2-查询员工号，姓名，工资，以及工资提高百分之20-后的结果（new-salary）" class="headerlink" title="2.    查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）"></a>2.    查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</h5><p>SELECT employee_id,last_name,salary,salary*1.2 “new salary”<br>FROM employees;</p><h5 id="3-将员工的姓名按首字母排序，并写出姓名的长度（length）"><a href="#3-将员工的姓名按首字母排序，并写出姓名的长度（length）" class="headerlink" title="3.    将员工的姓名按首字母排序，并写出姓名的长度（length）"></a>3.    将员工的姓名按首字母排序，并写出姓名的长度（length）</h5><p>SELECT LENGTH(last_name) 长度,SUBSTR(last_name,1,1) 首字符,last_name<br>FROM employees<br>ORDER BY 首字符;</p><h5 id="4-做一个查询，产生下面的结果"><a href="#4-做一个查询，产生下面的结果" class="headerlink" title="4.    做一个查询，产生下面的结果"></a>4.    做一个查询，产生下面的结果</h5><p><last_name> earns <salary> monthly but wants &lt;salary*3&gt;<br>Dream Salary<br>King earns 24000 monthly but wants 72000</p><p>SELECT CONCAT(last_name,’ earns ‘,salary,’ monthly but wants ‘,salary*3) AS “Dream Salary”<br>FROM employees<br>WHERE salary=24000;</p><h5 id="5-使用case-when，按照下面的条件："><a href="#5-使用case-when，按照下面的条件：" class="headerlink" title="5.    使用case-when，按照下面的条件："></a>5.    使用case-when，按照下面的条件：</h5><p>job                  grade<br>AD_PRES            A<br>ST_MAN             B<br>IT_PROG             C<br>SA_REP              D<br>ST_CLERK           E<br>产生下面的结果<br>Last_name    Job_id    Grade<br>king    AD_PRES    A</p><p>SELECT last_name,job_id AS  job,<br>CASE job_id<br>WHEN ‘AD_PRES’ THEN ‘A’<br>WHEN ‘ST_MAN’ THEN ‘B’<br>WHEN ‘IT_PROG’ THEN ‘C’<br>WHEN ‘SA_PRE’ THEN ‘D’<br>WHEN ‘ST_CLERK’ THEN ‘E’<br>END AS Grade<br>FROM employees<br>WHERE job_id = ‘AD_PRES’;</p><h3 id="3排序查询"><a href="#3排序查询" class="headerlink" title="3排序查询"></a>3排序查询</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>select 查询列表<br>from 表名<br>【where  筛选条件】<br>order by 排序的字段或表达式;</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1、asc代表的是升序，可以省略<br>desc代表的是降序</p><p>2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段</p><p>3、order by子句在查询语句的最后面，除了limit子句</p><h5 id="1、按单个字段排序"><a href="#1、按单个字段排序" class="headerlink" title="1、按单个字段排序"></a>1、按单个字段排序</h5><p>SELECT * FROM employees ORDER BY salary DESC;</p><h5 id="2、添加筛选条件再排序"><a href="#2、添加筛选条件再排序" class="headerlink" title="2、添加筛选条件再排序"></a>2、添加筛选条件再排序</h5><h6 id="案例：查询部门编号-gt-90的员工信息，并按员工编号降序"><a href="#案例：查询部门编号-gt-90的员工信息，并按员工编号降序" class="headerlink" title="案例：查询部门编号&gt;=90的员工信息，并按员工编号降序"></a>案例：查询部门编号&gt;=90的员工信息，并按员工编号降序</h6><p>SELECT *<br>FROM employees<br>WHERE department_id&gt;=90<br>ORDER BY employee_id DESC;</p><h5 id="3、按表达式排序"><a href="#3、按表达式排序" class="headerlink" title="3、按表达式排序"></a>3、按表达式排序</h5><h6 id="案例：查询员工信息-按年薪降序"><a href="#案例：查询员工信息-按年薪降序" class="headerlink" title="案例：查询员工信息 按年薪降序"></a>案例：查询员工信息 按年薪降序</h6><p>SELECT <em>,salary</em>12*(1+IFNULL(commission_pct,0))<br>FROM employees<br>ORDER BY salary<em>12</em>(1+IFNULL(commission_pct,0)) DESC;</p><h5 id="4、按别名排序"><a href="#4、按别名排序" class="headerlink" title="4、按别名排序"></a>4、按别名排序</h5><h6 id="案例：查询员工信息-按年薪升序"><a href="#案例：查询员工信息-按年薪升序" class="headerlink" title="案例：查询员工信息 按年薪升序"></a>案例：查询员工信息 按年薪升序</h6><p>SELECT <em>,salary</em>12*(1+IFNULL(commission_pct,0)) 年薪<br>FROM employees<br>ORDER BY 年薪 ASC;</p><h5 id="5、按函数排序"><a href="#5、按函数排序" class="headerlink" title="5、按函数排序"></a>5、按函数排序</h5><h6 id="案例：查询员工名，并且按名字的长度降序"><a href="#案例：查询员工名，并且按名字的长度降序" class="headerlink" title="案例：查询员工名，并且按名字的长度降序"></a>案例：查询员工名，并且按名字的长度降序</h6><p>SELECT LENGTH(last_name),last_name<br>FROM employees<br>ORDER BY LENGTH(last_name) DESC;</p><h5 id="6、按多个字段排序"><a href="#6、按多个字段排序" class="headerlink" title="6、按多个字段排序"></a>6、按多个字段排序</h5><h6 id="案例：查询员工信息，要求先按工资降序，再按employee-id升序"><a href="#案例：查询员工信息，要求先按工资降序，再按employee-id升序" class="headerlink" title="案例：查询员工信息，要求先按工资降序，再按employee_id升序"></a>案例：查询员工信息，要求先按工资降序，再按employee_id升序</h6><p>SELECT *<br>FROM employees<br>ORDER BY salary DESC,employee_id ASC;</p><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><h6 id="1-查询员工的姓名和部门号和年薪，按年薪降序-按姓名升序"><a href="#1-查询员工的姓名和部门号和年薪，按年薪降序-按姓名升序" class="headerlink" title="1.查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序"></a>1.查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序</h6><p>SELECT last_name,department_id,salary<em>12</em>(1+IFNULL(commission_pct,0)) 年薪<br>FROM employees<br>ORDER BY 年薪 DESC,last_name ASC;</p><h6 id="2-选择工资不在8000到17000的员工的姓名和工资，按工资降序"><a href="#2-选择工资不在8000到17000的员工的姓名和工资，按工资降序" class="headerlink" title="2.选择工资不在8000到17000的员工的姓名和工资，按工资降序"></a>2.选择工资不在8000到17000的员工的姓名和工资，按工资降序</h6><p>SELECT last_name,salary<br>FROM employees</p><p>WHERE salary NOT BETWEEN 8000 AND 17000<br>ORDER BY salary DESC;</p><h6 id="3-查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序"><a href="#3-查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序" class="headerlink" title="3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序"></a>3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</h6><p>SELECT *,LENGTH(email)<br>FROM employees<br>WHERE email LIKE ‘%e%’<br>ORDER BY LENGTH(email) DESC,department_id ASC;</p><h3 id="4：常见函数"><a href="#4：常见函数" class="headerlink" title="4：常见函数"></a>4：常见函数</h3><h4 id="概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名"><a href="#概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名" class="headerlink" title="概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名"></a>概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</h4><p>好处：1、隐藏了实现细节  2、提高代码的重用性<br> 调用：select 函数名(实参列表) 【from 表】;<br> 特点：<br>    ①叫什么（函数名）<br>    ②干什么（函数功能）</p><p>分类：<br>    1、单行函数<br>    如 concat、length、ifnull等<br>    2、分组函数</p><pre><code>功能：做统计使用，又称为统计函数、聚合函数、组函数</code></pre><h4 id="常见函数："><a href="#常见函数：" class="headerlink" title="常见函数："></a>常见函数：</h4><p>​    一、单行函数<br>​    字符函数：<br>​    length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节)<br>​    concat<br>​    substr<br>​    instr<br>​    trim<br>​    upper<br>​    lower<br>​    lpad<br>​    rpad<br>​    replace<br>​    </p><pre><code>数学函数：roundceilfloortruncatemod日期函数：nowcurdatecurtimeyearmonthmonthnamedayhourminutesecondstr_to_datedate_format其他函数：versiondatabaseuser控制函数ifcase</code></pre><p>​    </p><h4 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h4><p>#1.length 获取参数值的字节个数<br>SELECT LENGTH(‘john’);<br>SELECT LENGTH(‘张三丰hahaha’);</p><p>SHOW VARIABLES LIKE ‘%char%’</p><h4 id="2-concat-拼接字符串"><a href="#2-concat-拼接字符串" class="headerlink" title="2.concat 拼接字符串"></a>2.concat 拼接字符串</h4><p>SELECT CONCAT(last_name,’_’,first_name) 姓名 FROM employees;</p><h4 id="3-upper、lower"><a href="#3-upper、lower" class="headerlink" title="3.upper、lower"></a>3.upper、lower</h4><p>SELECT UPPER(‘john’);<br>SELECT LOWER(‘joHn’);</p><h5 id="示例：将姓变大写，名变小写，然后拼接"><a href="#示例：将姓变大写，名变小写，然后拼接" class="headerlink" title="示例：将姓变大写，名变小写，然后拼接"></a>示例：将姓变大写，名变小写，然后拼接</h5><p>SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</p><h4 id="4-substr、substring"><a href="#4-substr、substring" class="headerlink" title="4.substr、substring"></a>4.substr、substring</h4><p>注意：索引从1开始</p><h5 id="截取从指定索引处后面所有字符"><a href="#截取从指定索引处后面所有字符" class="headerlink" title="截取从指定索引处后面所有字符"></a>截取从指定索引处后面所有字符</h5><p>SELECT SUBSTR(‘李莫愁爱上了陆展元’,7)  out_put;</p><h5 id="截取从指定索引处指定字符长度的字符"><a href="#截取从指定索引处指定字符长度的字符" class="headerlink" title="截取从指定索引处指定字符长度的字符"></a>截取从指定索引处指定字符长度的字符</h5><p>SELECT SUBSTR(‘李莫愁爱上了陆展元’,1,3) out_put;</p><h6 id="案例：姓名中首字符大写，其他字符小写然后用-拼接，显示出来"><a href="#案例：姓名中首字符大写，其他字符小写然后用-拼接，显示出来" class="headerlink" title="案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来"></a>案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</h6><p>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),’_’,LOWER(SUBSTR(last_name,2)))  out_put<br>FROM employees;</p><h4 id="5-instr-返回子串第一次出现的索引，如果找不到返回0"><a href="#5-instr-返回子串第一次出现的索引，如果找不到返回0" class="headerlink" title="5.instr 返回子串第一次出现的索引，如果找不到返回0"></a>5.instr 返回子串第一次出现的索引，如果找不到返回0</h4><p>SELECT INSTR(‘杨不殷六侠悔爱上了殷六侠’,’殷八侠’) AS out_put;</p><h4 id="6-trim"><a href="#6-trim" class="headerlink" title="6.trim"></a>6.trim</h4><p>SELECT LENGTH(TRIM(‘    张翠山    ‘)) AS out_put;</p><p>SELECT TRIM(‘aa’ FROM ‘aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’)  AS out_put;</p><h4 id="7-lpad-用指定的字符实现左填充指定长度"><a href="#7-lpad-用指定的字符实现左填充指定长度" class="headerlink" title="7.lpad 用指定的字符实现左填充指定长度"></a>7.lpad 用指定的字符实现左填充指定长度</h4><p>SELECT LPAD(‘殷素素’,2,’*’) AS out_put;</p><h4 id="8-rpad-用指定的字符实现右填充指定长度"><a href="#8-rpad-用指定的字符实现右填充指定长度" class="headerlink" title="8.rpad 用指定的字符实现右填充指定长度"></a>8.rpad 用指定的字符实现右填充指定长度</h4><p>SELECT RPAD(‘殷素素’,12,’ab’) AS out_put;</p><h4 id="9-replace-替换"><a href="#9-replace-替换" class="headerlink" title="9.replace 替换"></a>9.replace 替换</h4><p>SELECT REPLACE(‘周芷若周芷若周芷若周芷若张无忌爱上了周芷若’,’周芷若’,’赵敏’) AS out_put;</p><h4 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h4><h5 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round 四舍五入"></a>round 四舍五入</h5><p>SELECT ROUND(-1.55);<br>SELECT ROUND(1.567,2);</p><h5 id="ceil-向上取整-返回-gt-该参数的最小整数"><a href="#ceil-向上取整-返回-gt-该参数的最小整数" class="headerlink" title="ceil 向上取整,返回&gt;=该参数的最小整数"></a>ceil 向上取整,返回&gt;=该参数的最小整数</h5><p>SELECT CEIL(-1.02);</p><h5 id="floor-向下取整，返回-lt-该参数的最大整数"><a href="#floor-向下取整，返回-lt-该参数的最大整数" class="headerlink" title="floor 向下取整，返回&lt;=该参数的最大整数"></a>floor 向下取整，返回&lt;=该参数的最大整数</h5><p>SELECT FLOOR(-9.99);</p><h5 id="truncate-截断"><a href="#truncate-截断" class="headerlink" title="truncate 截断"></a>truncate 截断</h5><p>SELECT TRUNCATE(1.69999,1);</p><h5 id="mod取余"><a href="#mod取余" class="headerlink" title="mod取余"></a>mod取余</h5><p>mod(a,b) ：  a-a/b*b</p><p>mod(-10,-3):-10- (-10)/(-3)*（-3）=-1</p><p>SELECT MOD(10,-3);<br>SELECT 10%3;</p><h4 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h4><h5 id="now-返回当前系统日期-时间"><a href="#now-返回当前系统日期-时间" class="headerlink" title="now 返回当前系统日期+时间"></a>now 返回当前系统日期+时间</h5><p>SELECT NOW();</p><h5 id="curdate-返回当前系统日期，不包含时间"><a href="#curdate-返回当前系统日期，不包含时间" class="headerlink" title="curdate 返回当前系统日期，不包含时间"></a>curdate 返回当前系统日期，不包含时间</h5><p>SELECT CURDATE();</p><h5 id="curtime-返回当前时间，不包含日期"><a href="#curtime-返回当前时间，不包含日期" class="headerlink" title="curtime 返回当前时间，不包含日期"></a>curtime 返回当前时间，不包含日期</h5><p>SELECT CURTIME();</p><h5 id="可以获取指定的部分，年、月、日、小时、分钟、秒"><a href="#可以获取指定的部分，年、月、日、小时、分钟、秒" class="headerlink" title="可以获取指定的部分，年、月、日、小时、分钟、秒"></a>可以获取指定的部分，年、月、日、小时、分钟、秒</h5><p>SELECT YEAR(NOW()) 年;<br>SELECT YEAR(‘1998-1-1’) 年;</p><p>SELECT  YEAR(hiredate) 年 FROM employees;</p><p>SELECT MONTH(NOW()) 月;<br>SELECT MONTHNAME(NOW()) 月;</p><h5 id="str-to-date-将字符通过指定的格式转换成日期"><a href="#str-to-date-将字符通过指定的格式转换成日期" class="headerlink" title="str_to_date 将字符通过指定的格式转换成日期"></a>str_to_date 将字符通过指定的格式转换成日期</h5><p>SELECT STR_TO_DATE(‘1998-3-2’,’%Y-%c-%d’) AS out_put;</p><h5 id="查询入职日期为1992–4-3的员工信息"><a href="#查询入职日期为1992–4-3的员工信息" class="headerlink" title="查询入职日期为1992–4-3的员工信息"></a>查询入职日期为1992–4-3的员工信息</h5><p>SELECT * FROM employees WHERE hiredate = ‘1992-4-3’;</p><p>SELECT * FROM employees WHERE hiredate = STR_TO_DATE(‘4-3 1992’,’%c-%d %Y’);</p><h5 id="date-format-将日期转换成字符"><a href="#date-format-将日期转换成字符" class="headerlink" title="date_format 将日期转换成字符"></a>date_format 将日期转换成字符</h5><p>SELECT DATE_FORMAT(NOW(),’%y年%m月%d日’) AS out_put;</p><h5 id="查询有奖金的员工名和入职日期-xx月-xx日-xx年"><a href="#查询有奖金的员工名和入职日期-xx月-xx日-xx年" class="headerlink" title="查询有奖金的员工名和入职日期(xx月/xx日 xx年)"></a>查询有奖金的员工名和入职日期(xx月/xx日 xx年)</h5><p>SELECT last_name,DATE_FORMAT(hiredate,’%m月/%d日 %y年’) 入职日期<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p><h4 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h4><p>SELECT VERSION();<br>SELECT DATABASE();<br>SELECT USER();</p><h4 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h4><h5 id="1-if函数：-if-else-的效果"><a href="#1-if函数：-if-else-的效果" class="headerlink" title="1.if函数： if else 的效果"></a>1.if函数： if else 的效果</h5><p>SELECT IF(10&lt;5,’大’,’小’);</p><p>SELECT last_name,commission_pct,IF(commission_pct IS NULL,’没奖金，呵呵’,’有奖金，嘻嘻’) 备注<br>FROM employees;</p><h5 id="2-case函数的使用一：-switch-case-的效果"><a href="#2-case函数的使用一：-switch-case-的效果" class="headerlink" title="2.case函数的使用一： switch case 的效果"></a>2.case函数的使用一： switch case 的效果</h5><p>java中<br>switch(变量或表达式){<br>    case 常量1：语句1;break;<br>    …<br>    default:语句n;break;</p><p>}</p><p>mysql中</p><p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p><h4 id="案例：查询员工的工资，要求"><a href="#案例：查询员工的工资，要求" class="headerlink" title="案例：查询员工的工资，要求"></a>案例：查询员工的工资，要求</h4><p>部门号=30，显示的工资为1.1倍<br>部门号=40，显示的工资为1.2倍<br>部门号=50，显示的工资为1.3倍<br>其他部门，显示的工资为原工资</p><p>SELECT salary 原始工资,department_id,<br>CASE department_id<br>WHEN 30 THEN salary<em>1.1<br>WHEN 40 THEN salary</em>1.2<br>WHEN 50 THEN salary*1.3<br>ELSE salary<br>END AS 新工资<br>FROM employees;</p><h5 id="3-case-函数的使用二：类似于-多重if"><a href="#3-case-函数的使用二：类似于-多重if" class="headerlink" title="3.case 函数的使用二：类似于 多重if"></a>3.case 函数的使用二：类似于 多重if</h5><p>java中：<br>if(条件1){<br>    语句1；<br>}else if(条件2){<br>    语句2；<br>}<br>…<br>else{<br>    语句n;<br>}</p><p>mysql中：</p><p>case<br>when 条件1 then 要显示的值1或语句1<br>when 条件2 then 要显示的值2或语句2<br>。。。<br>else 要显示的值n或语句n<br>end</p><h5 id="案例：查询员工的工资的情况"><a href="#案例：查询员工的工资的情况" class="headerlink" title="案例：查询员工的工资的情况"></a>案例：查询员工的工资的情况</h5><p>如果工资&gt;20000,显示A级别<br>如果工资&gt;15000,显示B级别<br>如果工资&gt;10000，显示C级别<br>否则，显示D级别</p><p>SELECT salary,<br>CASE<br>WHEN salary&gt;20000 THEN ‘A’<br>WHEN salary&gt;15000 THEN ‘B’<br>WHEN salary&gt;10000 THEN ‘C’<br>ELSE ‘D’<br>END AS 工资级别<br>FROM employees;</p><h3 id="5：分组查询"><a href="#5：分组查询" class="headerlink" title="5：分组查询"></a>5：分组查询</h3><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><p>select 查询列表<br>from 表<br>【where 筛选条件】<br>group by 分组的字段<br>【order by 排序的字段】;</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><p>1、和分组函数一同查询的字段必须是group by后出现的字段<br>2、筛选分为两类：分组前筛选和分组后筛选<br>        针对的表            位置        连接的关键字<br>分组前筛选    原始表                group by前    where</p><p>分组后筛选    group by后的结果集            group by后    having</p><p>问题1：分组函数做筛选能不能放在where后面<br>答：不能</p><p>问题2：where——group by——having</p><p>一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</p><p>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用</p><h4 id="引入：查询每个部门的员工个数"><a href="#引入：查询每个部门的员工个数" class="headerlink" title="引入：查询每个部门的员工个数"></a>引入：查询每个部门的员工个数</h4><p>SELECT COUNT(*) FROM employees WHERE department_id=90;</p><h5 id="1-简单的分组"><a href="#1-简单的分组" class="headerlink" title="1.简单的分组"></a>1.简单的分组</h5><h5 id="案例1：查询每个工种的员工平均工资"><a href="#案例1：查询每个工种的员工平均工资" class="headerlink" title="案例1：查询每个工种的员工平均工资"></a>案例1：查询每个工种的员工平均工资</h5><p>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p><h5 id="案例2：查询每个位置的部门个数"><a href="#案例2：查询每个位置的部门个数" class="headerlink" title="案例2：查询每个位置的部门个数"></a>案例2：查询每个位置的部门个数</h5><p>SELECT COUNT(*),location_id<br>FROM departments<br>GROUP BY location_id;</p><h5 id="2、可以实现分组前的筛选"><a href="#2、可以实现分组前的筛选" class="headerlink" title="2、可以实现分组前的筛选"></a>2、可以实现分组前的筛选</h5><h5 id="案例1：查询邮箱中包含a字符的-每个部门的最高工资"><a href="#案例1：查询邮箱中包含a字符的-每个部门的最高工资" class="headerlink" title="案例1：查询邮箱中包含a字符的 每个部门的最高工资"></a>案例1：查询邮箱中包含a字符的 每个部门的最高工资</h5><p>SELECT MAX(salary),department_id<br>FROM employees<br>WHERE email LIKE ‘%a%’<br>GROUP BY department_id;</p><h5 id="案例2：查询有奖金的每个领导手下员工的平均工资"><a href="#案例2：查询有奖金的每个领导手下员工的平均工资" class="headerlink" title="案例2：查询有奖金的每个领导手下员工的平均工资"></a>案例2：查询有奖金的每个领导手下员工的平均工资</h5><p>SELECT AVG(salary),manager_id<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY manager_id;</p><h5 id="3、分组后筛选"><a href="#3、分组后筛选" class="headerlink" title="3、分组后筛选"></a>3、分组后筛选</h5><p>#案例：查询哪个部门的员工个数&gt;5</p><h5 id="①查询每个部门的员工个数"><a href="#①查询每个部门的员工个数" class="headerlink" title="①查询每个部门的员工个数"></a>①查询每个部门的员工个数</h5><p>SELECT COUNT(*),department_id<br>FROM employees<br>GROUP BY department_id;</p><h5 id="②-筛选刚才①结果"><a href="#②-筛选刚才①结果" class="headerlink" title="② 筛选刚才①结果"></a>② 筛选刚才①结果</h5><p>SELECT COUNT(*),department_id<br>FROM employees</p><p>GROUP BY department_id</p><p>HAVING COUNT(*)&gt;5;</p><h5 id="案例2：每个工种有奖金的员工的最高工资-gt-12000的工种编号和最高工资"><a href="#案例2：每个工种有奖金的员工的最高工资-gt-12000的工种编号和最高工资" class="headerlink" title="案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资"></a>案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</h5><p>SELECT job_id,MAX(salary)<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING MAX(salary)&gt;12000;</p><h5 id="案例3：领导编号-gt-102的每个领导手下的最低工资大于5000的领导编号和最低工资"><a href="#案例3：领导编号-gt-102的每个领导手下的最低工资大于5000的领导编号和最低工资" class="headerlink" title="案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资"></a>案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</h5><p>manager_id&gt;102</p><p>SELECT manager_id,MIN(salary)<br>FROM employees<br>GROUP BY manager_id<br>HAVING MIN(salary)&gt;5000;</p><h5 id="4-添加排序"><a href="#4-添加排序" class="headerlink" title="4.添加排序"></a>4.添加排序</h5><h5 id="案例：每个工种有奖金的员工的最高工资-gt-6000的工种编号和最高工资-按最高工资升序"><a href="#案例：每个工种有奖金的员工的最高工资-gt-6000的工种编号和最高工资-按最高工资升序" class="headerlink" title="案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序"></a>案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</h5><p>SELECT job_id,MAX(salary) m<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING m&gt;6000<br>ORDER BY m ;</p><h5 id="5-按多个字段分组"><a href="#5-按多个字段分组" class="headerlink" title="5.按多个字段分组"></a>5.按多个字段分组</h5><h5 id="案例：查询每个工种每个部门的最低工资-并按最低工资降序"><a href="#案例：查询每个工种每个部门的最低工资-并按最低工资降序" class="headerlink" title="案例：查询每个工种每个部门的最低工资,并按最低工资降序"></a>案例：查询每个工种每个部门的最低工资,并按最低工资降序</h5><p>SELECT MIN(salary),job_id,department_id<br>FROM employees<br>GROUP BY department_id,job_id<br>ORDER BY MIN(salary) DESC;</p><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><h5 id="1-查询各job-id的员工工资的最大值，最小值，平均值，总和，并按job-id升序"><a href="#1-查询各job-id的员工工资的最大值，最小值，平均值，总和，并按job-id升序" class="headerlink" title="1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序"></a>1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序</h5><p>SELECT MAX(salary),MIN(salary),AVG(salary),SUM(salary),job_id<br>FROM employees<br>GROUP BY job_id<br>ORDER BY job_id;</p><h5 id="2-查询员工最高工资和最低工资的差距（DIFFERENCE）"><a href="#2-查询员工最高工资和最低工资的差距（DIFFERENCE）" class="headerlink" title="2.查询员工最高工资和最低工资的差距（DIFFERENCE）"></a>2.查询员工最高工资和最低工资的差距（DIFFERENCE）</h5><p>SELECT MAX(salary)-MIN(salary) DIFFRENCE<br>FROM employees;</p><h5 id="3-查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内"><a href="#3-查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内" class="headerlink" title="3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内"></a>3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</h5><p>SELECT MIN(salary),manager_id<br>FROM employees<br>WHERE manager_id IS NOT NULL<br>GROUP BY manager_id<br>HAVING MIN(salary)&gt;=6000;</p><h5 id="4-查询所有部门的编号，员工数量和工资平均值-并按平均工资降序"><a href="#4-查询所有部门的编号，员工数量和工资平均值-并按平均工资降序" class="headerlink" title="4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序"></a>4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序</h5><p>SELECT department_id,COUNT(*),AVG(salary) a<br>FROM employees<br>GROUP BY department_id<br>ORDER BY a DESC;</p><h5 id="5-选择具有各个job-id的员工人数"><a href="#5-选择具有各个job-id的员工人数" class="headerlink" title="5.选择具有各个job_id的员工人数"></a>5.选择具有各个job_id的员工人数</h5><p>SELECT COUNT(*) 个数,job_id<br>FROM employees<br>GROUP BY job_id;</p><h4 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h4><h5 id="功能：用作统计使用，又称为聚合函数或统计函数或组函数"><a href="#功能：用作统计使用，又称为聚合函数或统计函数或组函数" class="headerlink" title="功能：用作统计使用，又称为聚合函数或统计函数或组函数"></a>功能：用作统计使用，又称为聚合函数或统计函数或组函数</h5><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</p><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><p>1、sum、avg一般用于处理数值型<br>   max、min、count可以处理任何类型<br>2、以上分组函数都忽略null值</p><p>3、可以和distinct搭配实现去重的运算</p><p>4、count函数的单独介绍<br>一般使用count(*)用作统计行数</p><p>5、和分组函数一同查询的字段要求是group by后的字段</p><h4 id="1、简单-的使用"><a href="#1、简单-的使用" class="headerlink" title="1、简单 的使用"></a>1、简单 的使用</h4><p>SELECT SUM(salary) FROM employees;<br>SELECT AVG(salary) FROM employees;<br>SELECT MIN(salary) FROM employees;<br>SELECT MAX(salary) FROM employees;<br>SELECT COUNT(salary) FROM employees;</p><p>SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;</p><p>SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;</p><h4 id="2、参数支持哪些类型"><a href="#2、参数支持哪些类型" class="headerlink" title="2、参数支持哪些类型"></a>2、参数支持哪些类型</h4><p>SELECT SUM(last_name) ,AVG(last_name) FROM employees;<br>SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;</p><p>SELECT MAX(last_name),MIN(last_name) FROM employees;</p><p>SELECT MAX(hiredate),MIN(hiredate) FROM employees;</p><p>SELECT COUNT(commission_pct) FROM employees;<br>SELECT COUNT(last_name) FROM employees;</p><h4 id="3、是否忽略null"><a href="#3、是否忽略null" class="headerlink" title="3、是否忽略null"></a>3、是否忽略null</h4><p>SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;</p><p>SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;</p><p>SELECT COUNT(commission_pct) FROM employees;<br>SELECT commission_pct FROM employees;</p><h4 id="4、和distinct搭配"><a href="#4、和distinct搭配" class="headerlink" title="4、和distinct搭配"></a>4、和distinct搭配</h4><p>SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</p><p>SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</p><h4 id="5、count函数的详细介绍"><a href="#5、count函数的详细介绍" class="headerlink" title="5、count函数的详细介绍"></a>5、count函数的详细介绍</h4><p>SELECT COUNT(salary) FROM employees;</p><p>SELECT COUNT(*) FROM employees;</p><p>SELECT COUNT(1) FROM employees;</p><h5 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h5><p>MYISAM存储引擎下  ，COUNT(<em>)的效率高<br>INNODB存储引擎下，COUNT(</em>)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</p><h5 id="6、和分组函数一同查询的字段有限制"><a href="#6、和分组函数一同查询的字段有限制" class="headerlink" title="6、和分组函数一同查询的字段有限制"></a>6、和分组函数一同查询的字段有限制</h5><p>SELECT AVG(salary),employee_id  FROM employees;</p><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><h5 id="1-查询公司员工工资的最大值，最小值，平均值，总和"><a href="#1-查询公司员工工资的最大值，最小值，平均值，总和" class="headerlink" title="1.查询公司员工工资的最大值，最小值，平均值，总和"></a>1.查询公司员工工资的最大值，最小值，平均值，总和</h5><p>SELECT MAX(salary) 最大值,MIN(salary) 最小值,AVG(salary) 平均值,SUM(salary) 和<br>FROM employees;</p><h4 id="2-查询员工表中的最大入职时间和最小入职时间的相差天数-（DIFFRENCE）"><a href="#2-查询员工表中的最大入职时间和最小入职时间的相差天数-（DIFFRENCE）" class="headerlink" title="#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）"></a>#2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）</h4><p>SELECT MAX(hiredate) 最大,MIN(hiredate) 最小,(MAX(hiredate)-MIN(hiredate))/1000/3600/24 DIFFRENCE<br>FROM employees;</p><p>SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE<br>FROM employees;</p><p>SELECT DATEDIFF(‘1995-2-7’,’1995-2-6’);</p><h5 id="3-查询部门编号为90的员工个数"><a href="#3-查询部门编号为90的员工个数" class="headerlink" title="3.查询部门编号为90的员工个数"></a>3.查询部门编号为90的员工个数</h5><p>SELECT COUNT(*) FROM employees WHERE department_id = 90;</p><h3 id="6：连接查询"><a href="#6：连接查询" class="headerlink" title="6：连接查询"></a>6：连接查询</h3><p>/*<br>含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p><p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p><p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p><p>分类：</p><pre><code>按年代分类：sql92标准:仅仅支持内连接sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接按功能分类：    内连接：        等值连接        非等值连接        自连接    外连接：        左外连接        右外连接        全外连接        交叉连接</code></pre><p>*/</p><p>SELECT * FROM beauty;</p><p>SELECT * FROM boys;</p><p>SELECT NAME,boyName FROM boys,beauty<br>WHERE beauty.boyfriend_id= boys.id;</p><p>#一、sql92标准<br>#1、等值连接<br>/*</p><p>① 多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③ 多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p><p>*/</p><p>#案例1：查询女神名和对应的男神名<br>SELECT NAME,boyName<br>FROM boys,beauty<br>WHERE beauty.boyfriend_id= boys.id;</p><p>#案例2：查询员工名和对应的部门名</p><p>SELECT last_name,department_name<br>FROM employees,departments<br>WHERE employees.<code>department_id</code>=departments.<code>department_id</code>;</p><p>#2、为表起别名<br>/*<br>①提高语句的简洁度<br>②区分多个重名的字段</p><p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</p><p>*/<br>#查询员工名、工种号、工种名</p><p>SELECT e.last_name,e.job_id,j.job_title<br>FROM employees  e,jobs j<br>WHERE e.<code>job_id</code>=j.<code>job_id</code>;</p><p>#3、两个表的顺序是否可以调换</p><p>#查询员工名、工种号、工种名</p><p>SELECT e.last_name,e.job_id,j.job_title<br>FROM jobs j,employees e<br>WHERE e.<code>job_id</code>=j.<code>job_id</code>;</p><p>#4、可以加筛选</p><p>#案例：查询有奖金的员工名、部门名</p><p>SELECT last_name,department_name,commission_pct</p><p>FROM employees e,departments d<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND e.<code>commission_pct</code> IS NOT NULL;</p><p>#案例2：查询城市名中第二个字符为o的部门名和城市名</p><p>SELECT department_name,city<br>FROM departments d,locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>AND city LIKE ‘_o%’;</p><p>#5、可以加分组</p><p>#案例1：查询每个城市的部门个数</p><p>SELECT COUNT(*) 个数,city<br>FROM departments d,locations l<br>WHERE d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city;</p><p>#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资<br>SELECT department_name,d.<code>manager_id</code>,MIN(salary)<br>FROM departments d,employees e<br>WHERE d.<code>department_id</code>=e.<code>department_id</code><br>AND commission_pct IS NOT NULL<br>GROUP BY department_name,d.<code>manager_id</code>;<br>#6、可以加排序</p><p>#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</p><p>SELECT job_title,COUNT(<em>)<br>FROM employees e,jobs j<br>WHERE e.<code>job_id</code>=j.<code>job_id</code><br>GROUP BY job_title<br>ORDER BY COUNT(</em>) DESC;</p><p>#7、可以实现三表连接？</p><p>#案例：查询员工名、部门名和所在的城市</p><p>SELECT last_name,department_name,city<br>FROM employees e,departments d,locations l<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND d.<code>location_id</code>=l.<code>location_id</code><br>AND city LIKE ‘s%’</p><p>ORDER BY department_name DESC;</p><p>#2、非等值连接</p><p>#案例1：查询员工的工资和工资级别</p><p>SELECT salary,grade_level<br>FROM employees e,job_grades g<br>WHERE salary BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code><br>AND g.<code>grade_level</code>=’A’;</p><p>/*<br>select salary,employee_id from employees;<br>select * from job_grades;<br>CREATE TABLE job_grades<br>(grade_level VARCHAR(3),<br> lowest_sal  int,<br> highest_sal int);</p><p>INSERT INTO job_grades<br>VALUES (‘A’, 1000, 2999);</p><p>INSERT INTO job_grades<br>VALUES (‘B’, 3000, 5999);</p><p>INSERT INTO job_grades<br>VALUES(‘C’, 6000, 9999);</p><p>INSERT INTO job_grades<br>VALUES(‘D’, 10000, 14999);</p><p>INSERT INTO job_grades<br>VALUES(‘E’, 15000, 24999);</p><p>INSERT INTO job_grades<br>VALUES(‘F’, 25000, 40000);</p><p>*/</p><p>#3、自连接</p><p>#案例：查询 员工名和上级的名称</p><p>SELECT e.employee_id,e.last_name,m.employee_id,m.last_name<br>FROM employees e,employees m<br>WHERE e.<code>manager_id</code>=m.<code>employee_id</code>;</p><h4 id="外查询案例"><a href="#外查询案例" class="headerlink" title="外查询案例"></a>外查询案例</h4><p>一、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</p><p>SELECT b.id,b.name,bo.*<br>FROM beauty b<br>LEFT OUTER JOIN boys bo<br>ON b.<code>boyfriend_id</code> = bo.<code>id</code><br>WHERE b.<code>id</code>&gt;3;<br>#二、查询哪个城市没有部门</p><p>SELECT city<br>FROM departments d<br>RIGHT OUTER JOIN locations l<br>ON d.<code>location_id</code>=l.<code>location_id</code><br>WHERE  d.<code>department_id</code> IS NULL;</p><p>#三、查询部门名为SAL或IT的员工信息</p><p>SELECT e.*,d.department_name,d.<code>department_id</code><br>FROM departments  d<br>LEFT JOIN employees e<br>ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE d.<code>department_name</code> IN(‘SAL’,’IT’);</p><p>SELECT * FROM departments<br>WHERE <code>department_name</code> IN(‘SAL’,’IT’);</p><h3 id="连接查询-sql99语法"><a href="#连接查询-sql99语法" class="headerlink" title="连接查询  sql99语法"></a>连接查询  sql99语法</h3><p>/*<br>语法：<br>    select 查询列表<br>    from 表1 别名 【连接类型】<br>    join 表2 别名<br>    on 连接条件<br>    【where 筛选条件】<br>    【group by 分组】<br>    【having 筛选条件】<br>    【order by 排序列表】</p><p>分类：<br>内连接（★）：inner<br>外连接<br>    左外(★):left 【outer】<br>    右外(★)：right 【outer】<br>    全外：full【outer】<br>交叉连接：cross </p><p>*/</p><p>#一）内连接<br>/*<br>语法：</p><p>select 查询列表<br>from 表1 别名<br>inner join 表2 别名<br>on 连接条件;</p><p>分类：<br>等值<br>非等值<br>自连接</p><p>特点：<br>①添加排序、分组、筛选<br>②inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p><p>*/</p><p>#1、等值连接<br>#案例1.查询员工名、部门名</p><p>SELECT last_name,department_name<br>FROM departments d<br> JOIN  employees e<br>ON e.<code>department_id</code> = d.<code>department_id</code>;</p><p>#案例2.查询名字中包含e的员工名和工种名（添加筛选）<br>SELECT last_name,job_title<br>FROM employees e<br>INNER JOIN jobs j<br>ON e.<code>job_id</code>=  j.<code>job_id</code><br>WHERE e.<code>last_name</code> LIKE ‘%e%’;</p><p>#3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</p><p>#①查询每个城市的部门个数<br>#②在①结果上筛选满足条件的<br>SELECT city,COUNT(<em>) 部门个数<br>FROM departments d<br>INNER JOIN locations l<br>ON d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city<br>HAVING COUNT(</em>)&gt;3;</p><p>#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</p><p>#①查询每个部门的员工个数<br>SELECT COUNT(*),department_name<br>FROM employees e<br>INNER JOIN departments d<br>ON e.<code>department_id</code>=d.<code>department_id</code><br>GROUP BY department_name</p><p>#② 在①结果上筛选员工个数&gt;3的记录，并排序</p><p>SELECT COUNT(<em>) 个数,department_name<br>FROM employees e<br>INNER JOIN departments d<br>ON e.<code>department_id</code>=d.<code>department_id</code><br>GROUP BY department_name<br>HAVING COUNT(</em>)&gt;3<br>ORDER BY COUNT(*) DESC;</p><p>#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</p><p>SELECT last_name,department_name,job_title<br>FROM employees e<br>INNER JOIN departments d ON e.<code>department_id</code>=d.<code>department_id</code><br>INNER JOIN jobs j ON e.<code>job_id</code> = j.<code>job_id</code></p><p>ORDER BY department_name DESC;</p><p>#二）非等值连接</p><p>#查询员工的工资级别</p><p>SELECT salary,grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p><p> #查询工资级别的个数&gt;20的个数，并且按工资级别降序<br> SELECT COUNT(<em>),grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code><br> GROUP BY grade_level<br> HAVING COUNT(</em>)&gt;20<br> ORDER BY grade_level DESC;</p><p> #三）自连接</p><p> #查询员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.<code>manager_id</code>= m.<code>employee_id</code>;</p><p>  #查询姓名中包含字符k的员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.<code>manager_id</code>= m.<code>employee_id</code><br> WHERE e.<code>last_name</code> LIKE ‘%k%’;</p><p> #二、外连接</p><p> /*<br> 应用场景：用于查询一个表中有，另一个表没有的记录</p><p> 特点：<br> 1、外连接的查询结果为主表中的所有记录<br>    如果从表中有和它匹配的，则显示匹配的值<br>    如果从表中没有和它匹配的，则显示null<br>    外连接查询结果=内连接结果+主表中有而从表没有的记录<br> 2、左外连接，left join左边的是主表<br>    右外连接，right join右边的是主表<br> 3、左外和右外交换两个表的顺序，可以实现同样的效果<br> 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的<br> */<br> #引入：查询男朋友 不在男神表的的女神名</p><p> SELECT * FROM beauty;<br> SELECT * FROM boys;</p><p> #左外连接<br> SELECT b.<em>,bo.</em><br> FROM boys bo<br> LEFT OUTER JOIN beauty b<br> ON b.<code>boyfriend_id</code> = bo.<code>id</code><br> WHERE b.<code>id</code> IS NULL;</p><p> #案例1：查询哪个部门没有员工<br> #左外<br> SELECT d.*,e.employee_id<br> FROM departments d<br> LEFT OUTER JOIN employees e<br> ON d.<code>department_id</code> = e.<code>department_id</code><br> WHERE e.<code>employee_id</code> IS NULL;</p><p> #右外</p><p>  SELECT d.*,e.employee_id<br> FROM employees e<br> RIGHT OUTER JOIN departments d<br> ON d.<code>department_id</code> = e.<code>department_id</code><br> WHERE e.<code>employee_id</code> IS NULL;</p><p> #全外</p><p> USE girls;<br> SELECT b.<em>,bo.</em><br> FROM beauty b<br> FULL OUTER JOIN boys bo<br> ON b.<code>boyfriend_id</code> = bo.id;</p><p> #交叉连接</p><p> SELECT b.<em>,bo.</em><br> FROM beauty b<br> CROSS JOIN boys bo;</p><p> #sql92和 sql99pk<br> /*<br> 功能：sql99支持的较多<br> 可读性：sql99实现连接条件和筛选条件的分离，可读性较高<br> */</p><h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><p>#1.显示所有员工的姓名，部门号和部门名称。<br>USE myemployees;</p><p>SELECT last_name,d.department_id,department_name<br>FROM employees e,departments d<br>WHERE e.<code>department_id</code> = d.<code>department_id</code>;</p><p>#2.查询90号部门员工的job_id和90号部门的location_id</p><p>SELECT job_id,location_id<br>FROM employees e,departments d<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND e.<code>department_id</code>=90;</p><p>#3.    选择所有有奖金的员工的<br>last_name , department_name , location_id , city</p><p>SELECT last_name , department_name , l.location_id , city<br>FROM employees e,departments d,locations l<br>WHERE e.department_id = d.department_id<br>AND d.location_id=l.location_id<br>AND e.commission_pct IS NOT NULL;</p><p>#4.选择city在Toronto工作的员工的<br>last_name , job_id , department_id , department_name </p><p>SELECT last_name , job_id , d.department_id , department_name<br>FROM employees e,departments d ,locations l<br>WHERE e.department_id = d.department_id<br>AND d.location_id=l.location_id<br>AND city = ‘Toronto’;</p><p>#5.查询每个工种、每个部门的部门名、工种名和最低工资</p><p>SELECT department_name,job_title,MIN(salary) 最低工资<br>FROM employees e,departments d,jobs j<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>AND e.<code>job_id</code>=j.<code>job_id</code><br>GROUP BY department_name,job_title;</p><p>#6.查询每个国家下的部门个数大于2的国家编号</p><p>SELECT country_id,COUNT(*) 部门个数<br>FROM departments d,locations l<br>WHERE d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY country_id<br>HAVING 部门个数&gt;2;</p><p>#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式<br>employees    Emp#    manager    Mgr#<br>kochhar        101    king    100</p><p>SELECT e.last_name employees,e.employee_id “Emp#”,m.last_name manager,m.employee_id “Mgr#”<br>FROM employees e,employees m<br>WHERE e.manager_id = m.employee_id<br>AND e.last_name=’kochhar’;</p><h3 id="分页查询-★"><a href="#分页查询-★" class="headerlink" title="分页查询 ★"></a>分页查询 ★</h3><p>/*</p><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求<br>语法：<br>    select 查询列表<br>    from 表<br>    【join type join 表2<br>    on 连接条件<br>    where 筛选条件<br>    group by 分组字段<br>    having 分组后的筛选<br>    order by 排序的字段】<br>    limit 【offset,】size;</p><pre><code>offset要显示条目的起始索引（起始索引从0开始）size 要显示的条目个数</code></pre><p>特点：<br>    ①limit语句放在查询语句的最后<br>    ②公式<br>    要显示的页数 page，每页的条目数size</p><pre><code>select 查询列表from 表limit (page-1)*size,size;size=10page  1    02      103    20</code></pre><p>*/<br>#案例1：查询前五条员工信息</p><p>SELECT * FROM  employees LIMIT 0,5;<br>SELECT * FROM  employees LIMIT 5;</p><p>#案例2：查询第11条——第25条<br>SELECT * FROM  employees LIMIT 10,15;</p><p>#案例3：有奖金的员工信息，并且工资较高的前10名显示出来<br>SELECT<br>    *<br>FROM<br>        employees<br>WHERE commission_pct IS NOT NULL<br>ORDER BY salary DESC<br>LIMIT 10 ;</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>/*<br>含义：<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询</p><p>分类：<br>按子查询出现的位置：<br>    select后面：<br>        仅仅支持标量子查询</p><pre><code>from后面：    支持表子查询where或having后面：★    标量子查询（单行） √    列子查询  （多行） √        行子查询    exists后面（相关子查询）    表子查询</code></pre><p>按结果集的行列数不同：<br>    标量子查询（结果集只有一行一列）<br>    列子查询（结果集只有一列多行）<br>    行子查询（结果集有一行多列）<br>    表子查询（结果集一般为多行多列）</p><p>*/</p><p>#一、where或having后面<br>/*<br>1、标量子查询（单行子查询）<br>2、列子查询（多行子查询）</p><p>3、行子查询（多列多行）</p><p>特点：<br>①子查询放在小括号内<br>②子查询一般放在条件的右侧<br>③标量子查询，一般搭配着单行操作符使用</p><blockquote><p>&lt; &gt;= &lt;= = &lt;&gt;</p></blockquote><p>列子查询，一般搭配着多行操作符使用<br>in、any/some、all</p><p>④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</p><p>*/<br>#1.标量子查询★</p><p>#案例1：谁的工资比 Abel 高?</p><p>#①查询Abel的工资<br>SELECT salary<br>FROM employees<br>WHERE last_name = ‘Abel’</p><p>#②查询员工的信息，满足 salary&gt;①结果<br>SELECT *<br>FROM employees<br>WHERE salary&gt;(</p><pre><code>SELECT salaryFROM employeesWHERE last_name = &#39;Abel&#39;</code></pre><p>);</p><p>#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</p><p>#①查询141号员工的job_id<br>SELECT job_id<br>FROM employees<br>WHERE employee_id = 141</p><p>#②查询143号员工的salary<br>SELECT salary<br>FROM employees<br>WHERE employee_id = 143</p><p>#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</p><p>SELECT last_name,job_id,salary<br>FROM employees<br>WHERE job_id = (<br>    SELECT job_id<br>    FROM employees<br>    WHERE employee_id = 141<br>) AND salary&gt;(<br>    SELECT salary<br>    FROM employees<br>    WHERE employee_id = 143</p><p>);</p><p>#案例3：返回公司工资最少的员工的last_name,job_id和salary</p><p>#①查询公司的 最低工资<br>SELECT MIN(salary)<br>FROM employees</p><p>#②查询last_name,job_id和salary，要求salary=①<br>SELECT last_name,job_id,salary<br>FROM employees<br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM employees<br>);</p><p>#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</p><p>#①查询50号部门的最低工资<br>SELECT  MIN(salary)<br>FROM employees<br>WHERE department_id = 50</p><p>#②查询每个部门的最低工资</p><p>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#③ 在②基础上筛选，满足min(salary)&gt;①<br>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>    SELECT  MIN(salary)<br>    FROM employees<br>    WHERE department_id = 50</p><p>);</p><p>#非法使用标量子查询</p><p>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>    SELECT  salary<br>    FROM employees<br>    WHERE department_id = 250</p><p>);</p><p>#2.列子查询（多行子查询）★<br>#案例1：返回location_id是1400或1700的部门中的所有员工姓名</p><p>#①查询location_id是1400或1700的部门编号<br>SELECT DISTINCT department_id<br>FROM departments<br>WHERE location_id IN(1400,1700)</p><p>#②查询员工姓名，要求部门号是①列表中的某一个</p><p>SELECT last_name<br>FROM employees<br>WHERE department_id  &lt;&gt;ALL(<br>    SELECT DISTINCT department_id<br>    FROM departments<br>    WHERE location_id IN(1400,1700)</p><p>);</p><p>#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</p><p>#①查询job_id为‘IT_PROG’部门任一工资</p><p>SELECT DISTINCT salary<br>FROM employees<br>WHERE job_id = ‘IT_PROG’</p><p>#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个<br>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ANY(<br>    SELECT DISTINCT salary<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#或<br>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>    SELECT MAX(salary)<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</p><p>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ALL(<br>    SELECT DISTINCT salary<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#或</p><p>SELECT last_name,employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>    SELECT MIN( salary)<br>    FROM employees<br>    WHERE job_id = ‘IT_PROG’</p><p>) AND job_id&lt;&gt;’IT_PROG’;</p><p>#3、行子查询（结果集一行多列或多行多列）</p><p>#案例：查询员工编号最小并且工资最高的员工信息</p><p>SELECT *<br>FROM employees<br>WHERE (employee_id,salary)=(<br>    SELECT MIN(employee_id),MAX(salary)<br>    FROM employees<br>);</p><p>#①查询最小的员工编号<br>SELECT MIN(employee_id)<br>FROM employees</p><p>#②查询最高工资<br>SELECT MAX(salary)<br>FROM employees</p><p>#③查询员工信息<br>SELECT *<br>FROM employees<br>WHERE employee_id=(<br>    SELECT MIN(employee_id)<br>    FROM employees</p><p>)AND salary=(<br>    SELECT MAX(salary)<br>    FROM employees</p><p>);</p><p>#二、select后面<br>/*<br>仅仅支持标量子查询<br>*/</p><p>#案例：查询每个部门的员工个数</p><p>SELECT d.*,(</p><pre><code>SELECT COUNT(*)FROM employees eWHERE e.department_id = d.`department_id`</code></pre><p> ) 个数<br> FROM departments d;</p><p> #案例2：查询员工号=102的部门名</p><p>SELECT (<br>    SELECT department_name,e.department_id<br>    FROM departments d<br>    INNER JOIN employees e<br>    ON d.department_id=e.department_id<br>    WHERE e.employee_id=102</p><p>) 部门名;</p><p>#三、from后面<br>/*<br>将子查询结果充当一张表，要求必须起别名<br>*/</p><p>#案例：查询每个部门的平均工资的工资等级<br>#①查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>SELECT * FROM job_grades;</p><p>#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</p><p>SELECT  ag_dep.*,g.<code>grade_level</code><br>FROM (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>) ag_dep<br>INNER JOIN job_grades g<br>ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</p><p>#四、exists后面（相关子查询）</p><p>/*<br>语法：<br>exists(完整的查询语句)<br>结果：<br>1或0</p><p>*/</p><p>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);</p><p>#案例1：查询有员工的部门名</p><p>#in<br>SELECT department_name<br>FROM departments d<br>WHERE d.<code>department_id</code> IN(<br>    SELECT department_id<br>    FROM employees</p><p>)</p><p>#exists</p><p>SELECT department_name<br>FROM departments d<br>WHERE EXISTS(<br>    SELECT *<br>    FROM employees e<br>    WHERE d.<code>department_id</code>=e.<code>department_id</code></p><p>);</p><p>#案例2：查询没有女朋友的男神信息</p><p>#in</p><p>SELECT bo.*<br>FROM boys bo<br>WHERE bo.id NOT IN(<br>    SELECT boyfriend_id<br>    FROM beauty<br>)</p><p>#exists<br>SELECT bo.*<br>FROM boys bo<br>WHERE NOT EXISTS(<br>    SELECT boyfriend_id<br>    FROM beauty b<br>    WHERE bo.<code>id</code>=b.<code>boyfriend_id</code></p><p>);</p><p>#1.    查询和Zlotkey相同部门的员工姓名和工资</p><p>#①查询Zlotkey的部门<br>SELECT department_id<br>FROM employees<br>WHERE last_name = ‘Zlotkey’</p><p>#②查询部门号=①的姓名和工资<br>SELECT last_name,salary<br>FROM employees<br>WHERE department_id = (<br>    SELECT department_id<br>    FROM employees<br>    WHERE last_name = ‘Zlotkey’</p><p>)</p><p>#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</p><p>#①查询平均工资<br>SELECT AVG(salary)<br>FROM employees</p><p>#②查询工资&gt;①的员工号，姓名和工资。</p><p>SELECT last_name,employee_id,salary<br>FROM employees<br>WHERE salary&gt;(</p><pre><code>SELECT AVG(salary)FROM employees</code></pre><p>);</p><p>#3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资<br>#①查询各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#②连接①结果集和employees表，进行筛选<br>SELECT employee_id,last_name,salary,e.department_id<br>FROM employees e<br>INNER JOIN (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id</p><p>) ag_dep<br>ON e.department_id = ag_dep.department_id<br>WHERE salary&gt;ag_dep.ag ;</p><p>#4.    查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名<br>#①查询姓名中包含字母u的员工的部门</p><p>SELECT  DISTINCT department_id<br>FROM employees<br>WHERE last_name LIKE ‘%u%’</p><p>#②查询部门号=①中的任意一个的员工号和姓名<br>SELECT last_name,employee_id<br>FROM employees<br>WHERE department_id IN(<br>    SELECT  DISTINCT department_id<br>    FROM employees<br>    WHERE last_name LIKE ‘%u%’<br>);</p><p>#5. 查询在部门的location_id为1700的部门工作的员工的员工号</p><p>#①查询location_id为1700的部门</p><p>SELECT DISTINCT department_id<br>FROM departments<br>WHERE location_id  = 1700</p><p>#②查询部门号=①中的任意一个的员工号<br>SELECT employee_id<br>FROM employees<br>WHERE department_id =ANY(<br>    SELECT DISTINCT department_id<br>    FROM departments<br>    WHERE location_id  = 1700</p><p>);<br>#6.查询管理者是King的员工姓名和工资</p><p>#①查询姓名为king的员工编号<br>SELECT employee_id<br>FROM employees<br>WHERE last_name  = ‘K_ing’</p><p>#②查询哪个员工的manager_id = ①<br>SELECT last_name,salary<br>FROM employees<br>WHERE manager_id IN(<br>    SELECT employee_id<br>    FROM employees<br>    WHERE last_name  = ‘K_ing’</p><p>);</p><p>#7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</p><p>#①查询最高工资<br>SELECT MAX(salary)<br>FROM employees</p><p>#②查询工资=①的姓.名</p><p>SELECT CONCAT(first_name,last_name) “姓.名”<br>FROM employees<br>WHERE salary=(<br>    SELECT MAX(salary)<br>    FROM employees</p><p>);</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>/*</p><p>数据定义语言</p><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><hr><p>一、库的管理<br>创建、修改、删除<br>二、表的管理<br>创建、修改、删除</p><p>创建： create<br>修改： alter<br>删除： drop</p><p>*/</p><p>#一、库的管理<br>#1、库的创建<br>/*<br>语法：<br>create database  [if not exists]库名;<br>*/</p><p>#案例：创建库Books</p><p>CREATE DATABASE IF NOT EXISTS books ;</p><p>#2、库的修改</p><p>RENAME DATABASE books TO 新库名;</p><p>#更改库的字符集</p><p>ALTER DATABASE books CHARACTER SET gbk;</p><p>#3、库的删除</p><p>DROP DATABASE IF EXISTS books;</p><p>#二、表的管理<br>#1.表的创建 ★</p><p>/*<br>语法：<br>create table 表名(<br>    列名 列的类型【(长度) 约束】,<br>    列名 列的类型【(长度) 约束】,<br>    列名 列的类型【(长度) 约束】,<br>    …<br>    列名 列的类型【(长度) 约束】</p><p>)</p><p>*/<br>#案例：创建表Book</p><p>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId  INT,#作者编号<br>    publishDate DATETIME#出版日期</p><p>);</p><p>DESC book;</p><p>#案例：创建表author<br>CREATE TABLE IF NOT EXISTS author(<br>    id INT,<br>    au_name VARCHAR(20),<br>    nation VARCHAR(10)</p><p>)<br>DESC author;</p><p>#2.表的修改</p><p>/*<br>语法<br>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</p><p>*/</p><p>#①修改列名</p><p>ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</p><p>#②修改列的类型或约束<br>ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</p><p>#③添加新列<br>ALTER TABLE author ADD COLUMN annual DOUBLE; </p><p>#④删除列</p><p>ALTER TABLE book_author DROP COLUMN  annual;<br>#⑤修改表名</p><p>ALTER TABLE author RENAME TO book_author;</p><p>DESC book;</p><p>#3.表的删除</p><p>DROP TABLE IF EXISTS book_author;</p><p>SHOW TABLES;</p><p>#通用的写法：</p><p>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;</p><p>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE  表名();</p><p>#4.表的复制</p><p>INSERT INTO author VALUES<br>(1,’村上春树’,’日本’),<br>(2,’莫言’,’中国’),<br>(3,’冯唐’,’中国’),<br>(4,’金庸’,’中国’);</p><p>SELECT * FROM Author;<br>SELECT * FROM copy2;<br>#1.仅仅复制表的结构</p><p>CREATE TABLE copy LIKE author;</p><p>#2.复制表的结构+数据<br>CREATE TABLE copy2<br>SELECT * FROM author;</p><p>#只复制部分数据<br>CREATE TABLE copy3<br>SELECT id,au_name<br>FROM author<br>WHERE nation=’中国’;</p><p>#仅仅复制某些字段</p><p>CREATE TABLE copy4<br>SELECT id,au_name<br>FROM author<br>WHERE 0;</p><h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><ol><li>创建表dept1<br>NAME    NULL?    TYPE<br>id        INT(7)<br>NAME        VARCHAR(25)</li></ol><p>USE test;</p><p>CREATE TABLE dept1(<br>    id INT(7),<br>    NAME VARCHAR(25)</p><p>);</p><ol start="2"><li>将表departments中的数据插入新表dept2中</li></ol><p>CREATE TABLE dept2<br>SELECT department_id,department_name<br>FROM myemployees.departments;</p><p>#3.    创建表emp5<br>NAME    NULL?    TYPE<br>id        INT(7)<br>First_name    VARCHAR (25)<br>Last_name    VARCHAR(25)<br>Dept_id        INT(7)</p><p>CREATE TABLE emp5(<br>id INT(7),<br>first_name VARCHAR(25),<br>last_name VARCHAR(25),<br>dept_id INT(7)</p><p>);</p><p>#4.    将列Last_name的长度增加到50</p><p>ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);<br>#5.    根据表employees创建employees2</p><p>CREATE TABLE employees2 LIKE myemployees.employees;</p><p>#6.    删除表emp5<br>DROP TABLE IF EXISTS emp5;</p><p>#7.    将表employees2重命名为emp5</p><p>ALTER TABLE employees2 RENAME TO emp5;</p><p>#8.在表dept和emp5中添加新列test_column，并检查所作的操作</p><p>ALTER TABLE emp5 ADD COLUMN test_column INT;<br>#9.直接删除表emp5中的列 dept_id<br>DESC emp5;<br>ALTER TABLE emp5 DROP COLUMN test_column;</p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><hr><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p><p>语法：<br>查询语句1<br>union<br>查询语句2<br>union<br>…</p><p>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p><p>特点：★<br>1、要求多条查询语句的查询列数是一致的！<br>2、要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3、union关键字默认去重，如果使用union all 可以包含重复项</p><p>*/</p><p>#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</p><p>SELECT * FROM employees WHERE email LIKE ‘%a%’ OR department_id&gt;90;;</p><p>SELECT * FROM employees  WHERE email LIKE ‘%a%’<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;</p><p>#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</p><p>SELECT id,cname FROM t_ca WHERE csex=’男’<br>UNION ALL<br>SELECT t_id,tname FROM t_ua WHERE tGender=’male’;</p><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><p>/*</p><p>数据操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p><p>*/</p><p>#一、插入语句<br>#方式一：经典的插入<br>/*<br>语法：<br>insert into 表名(列名,…) values(值1,…);</p><p>*/<br>SELECT * FROM beauty;<br>#1.插入的值的类型要与列的类型一致或兼容<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,’唐艺昕’,’女’,’1990-4-23’,’1898888888’,NULL,2);</p><p>#2.不可以为null的列必须插入值。可以为null的列如何插入值？<br>#方式一：<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,’唐艺昕’,’女’,’1990-4-23’,’1898888888’,NULL,2);</p><p>#方式二：</p><p>INSERT INTO beauty(id,NAME,sex,phone)<br>VALUES(15,’娜扎’,’女’,’1388888888’);</p><p>#3.列的顺序是否可以调换<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(‘蒋欣’,’女’,16,’110’);</p><p>#4.列数和值的个数必须一致</p><p>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(‘关晓彤’,’女’,17,’110’);</p><p>#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</p><p>INSERT INTO beauty<br>VALUES(18,’张飞’,’男’,NULL,’119’,NULL,NULL);</p><p>#方式二：<br>/*</p><p>语法：<br>insert into 表名<br>set 列名=值,列名=值,…<br>*/</p><p>INSERT INTO beauty<br>SET id=19,NAME=’刘涛’,phone=’999’;</p><p>#两种方式大pk ★</p><p>#1、方式一支持插入多行,方式二不支持</p><p>INSERT INTO beauty<br>VALUES(23,’唐艺昕1’,’女’,’1990-4-23’,’1898888888’,NULL,2)<br>,(24,’唐艺昕2’,’女’,’1990-4-23’,’1898888888’,NULL,2)<br>,(25,’唐艺昕3’,’女’,’1990-4-23’,’1898888888’,NULL,2);</p><p>#2、方式一支持子查询，方式二不支持</p><p>INSERT INTO beauty(id,NAME,phone)<br>SELECT 26,’宋茜’,’11809866’;</p><p>INSERT INTO beauty(id,NAME,phone)<br>SELECT id,boyname,’1234567’<br>FROM boys WHERE id&lt;3;</p><p>#二、修改语句</p><p>/*</p><p>1.修改单表的记录★</p><p>语法：<br>update 表名<br>set 列=新值,列=新值,…<br>where 筛选条件;</p><p>2.修改多表的记录【补充】</p><p>语法：<br>sql92语法：<br>update 表1 别名,表2 别名<br>set 列=值,…<br>where 连接条件<br>and 筛选条件;</p><p>sql99语法：<br>update 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br>set 列=值,…<br>where 筛选条件;</p><p>*/</p><p>#1.修改单表的记录<br>#案例1：修改beauty表中姓唐的女神的电话为13899888899</p><p>UPDATE beauty SET phone = ‘13899888899’<br>WHERE NAME LIKE ‘唐%’;</p><p>#案例2：修改boys表中id好为2的名称为张飞，魅力值 10<br>UPDATE boys SET boyname=’张飞’,usercp=10<br>WHERE id=2;</p><p>#2.修改多表的记录</p><p>#案例 1：修改张无忌的女朋友的手机号为114</p><p>UPDATE boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>SET b.<code>phone</code>=’119’,bo.<code>userCP</code>=1000<br>WHERE bo.<code>boyName</code>=’张无忌’;</p><p>#案例2：修改没有男朋友的女神的男朋友编号都为2号</p><p>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>SET b.<code>boyfriend_id</code>=2<br>WHERE bo.<code>id</code> IS NULL;</p><p>SELECT * FROM boys;</p><p>#三、删除语句<br>/*</p><p>方式一：delete<br>语法：</p><p>1、单表的删除【★】<br>delete from 表名 where 筛选条件</p><p>2、多表的删除【补充】</p><p>sql92语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名,表2 别名<br>where 连接条件<br>and 筛选条件;</p><p>sql99语法：</p><p>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;</p><p>方式二：truncate<br>语法：truncate table 表名;</p><p>*/</p><p>#方式一：delete<br>#1.单表的删除<br>#案例：删除手机号以9结尾的女神信息</p><p>DELETE FROM beauty WHERE phone LIKE ‘%9’;<br>SELECT * FROM beauty;</p><p>#2.多表的删除</p><p>#案例：删除张无忌的女朋友的信息</p><p>DELETE b<br>FROM beauty b<br>INNER JOIN boys bo ON b.<code>boyfriend_id</code> = bo.<code>id</code><br>WHERE bo.<code>boyName</code>=’张无忌’;</p><p>#案例：删除黄晓明的信息以及他女朋友的信息<br>DELETE b,bo<br>FROM beauty b<br>INNER JOIN boys bo ON b.<code>boyfriend_id</code>=bo.<code>id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p><p>#方式二：truncate语句</p><p>#案例：将魅力值&gt;100的男神信息删除<br>TRUNCATE TABLE boys ;</p><p>#delete pk truncate【面试题★】</p><p>/*</p><p>1.delete 可以加where 条件，truncate不能加</p><p>2.truncate删除，效率高一丢丢<br>3.假如要删除的表中有自增长列，<br>如果用delete删除后，再插入数据，自增长列的值从断点开始，<br>而truncate删除后，再插入数据，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值</p><p>5.truncate删除不能回滚，delete删除可以回滚.</p><p>*/</p><p>SELECT * FROM boys;</p><p>DELETE FROM boys;<br>TRUNCATE TABLE boys;<br>INSERT INTO boys (boyname,usercp)<br>VALUES(‘张飞’,100),(‘刘备’,100),(‘关云长’,100);</p><h4 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h4><ol><li>运行以下脚本创建表my_employees</li></ol><p>USE myemployees;<br>CREATE TABLE my_employees(<br>    Id INT(10),<br>    First_name VARCHAR(10),<br>    Last_name VARCHAR(10),<br>    Userid VARCHAR(10),<br>    Salary DOUBLE(10,2)<br>);<br>CREATE TABLE users(<br>    id INT,<br>    userid VARCHAR(10),<br>    department_id INT</p><p>);<br>#2.    显示表my_employees的结构<br>DESC my_employees;</p><p>#3.    向my_employees表中插入下列数据<br>ID    FIRST_NAME    LAST_NAME    USERID    SALARY<br>1    patel        Ralph        Rpatel    895<br>2    Dancs        Betty        Bdancs    860<br>3    Biri        Ben        Bbiri    1100<br>4    Newman        Chad        Cnewman    750<br>5    Ropeburn    Audrey        Aropebur    1550</p><p>#方式一：<br>INSERT INTO my_employees<br>VALUES(1,’patel’,’Ralph’,’Rpatel’,895),<br>(2,’Dancs’,’Betty’,’Bdancs’,860),<br>(3,’Biri’,’Ben’,’Bbiri’,1100),<br>(4,’Newman’,’Chad’,’Cnewman’,750),<br>(5,’Ropeburn’,’Audrey’,’Aropebur’,1550);<br>DELETE FROM my_employees;<br>#方式二：</p><p>INSERT INTO my_employees<br>SELECT 1,’patel’,’Ralph’,’Rpatel’,895 UNION<br>SELECT 2,’Dancs’,’Betty’,’Bdancs’,860 UNION<br>SELECT 3,’Biri’,’Ben’,’Bbiri’,1100 UNION<br>SELECT 4,’Newman’,’Chad’,’Cnewman’,750 UNION<br>SELECT 5,’Ropeburn’,’Audrey’,’Aropebur’,1550;</p><p>#4.     向users表中插入数据<br>1    Rpatel    10<br>2    Bdancs    10<br>3    Bbiri    20<br>4    Cnewman    30<br>5    Aropebur    40</p><p>INSERT INTO users<br>VALUES(1,’Rpatel’,10),<br>(2,’Bdancs’,10),<br>(3,’Bbiri’,20);</p><p>#5.将3号员工的last_name修改为“drelxer”<br>UPDATE my_employees SET last_name=’drelxer’ WHERE id = 3;</p><p>#6.将所有工资少于900的员工的工资修改为1000<br>UPDATE my_employees SET salary=1000 WHERE salary&lt;900;</p><p>#7.将userid 为Bbiri的user表和my_employees表的记录全部删除</p><p>DELETE u,e<br>FROM users u<br>JOIN my_employees e ON u.<code>userid</code>=e.<code>Userid</code><br>WHERE u.<code>userid</code>=’Bbiri’;</p><p>#8.删除所有数据</p><p>DELETE FROM my_employees;<br>DELETE FROM users;<br>#9.检查所作的修正</p><p>SELECT * FROM my_employees;<br>SELECT * FROM users;</p><p>#10.清空表my_employees<br>TRUNCATE TABLE my_employees;</p><h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><hr><p>/*<br>数值型：<br>    整型<br>    小数：<br>        定点数<br>        浮点数<br>字符型：<br>    较短的文本：char、varchar<br>    较长的文本：text、blob（较长的二进制数据）</p><p>日期型：</p><p>*/</p><p>#一、整型<br>/*<br>分类：<br>tinyint、smallint、mediumint、int/integer、bigint<br>1     2        3    4        8</p><p>特点：<br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p><p>*/</p><p>#1.如何设置无符号和有符号</p><p>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>    t1 INT(7) ZEROFILL,<br>    t2 INT(7) ZEROFILL </p><p>);</p><p>DESC tab_int;</p><p>INSERT INTO tab_int VALUES(-123456);<br>INSERT INTO tab_int VALUES(-123456,-123456);<br>INSERT INTO tab_int VALUES(2147483648,4294967296);</p><p>INSERT INTO tab_int VALUES(123,123);</p><p>SELECT * FROM tab_int;</p><p>#二、小数<br>/*<br>分类：<br>1.浮点型<br>float(M,D)<br>double(M,D)<br>2.定点型<br>dec(M，D)<br>decimal(M,D)</p><p>特点：</p><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p><p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p><p>*/<br>#测试M和D</p><p>DROP TABLE tab_float;<br>CREATE TABLE tab_float(<br>    f1 FLOAT,<br>    f2 DOUBLE,<br>    f3 DECIMAL<br>);<br>SELECT * FROM tab_float;<br>DESC tab_float;</p><p>INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);<br>INSERT INTO tab_float VALUES(123.456,123.456,123.456);<br>INSERT INTO tab_float VALUES(123.4,123.4,123.4);<br>INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);</p><p>#原则：<br>/*<br>所选择的类型越简单越好，能保存数值的类型越小越好</p><p>*/</p><p>#三、字符型<br>/*<br>较短的文本：</p><p>char<br>varchar</p><p>其他：</p><p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p><p>较长的文本：<br>text<br>blob(较大的二进制)</p><p>特点：</p><pre><code>写法        M的意思                    特点            空间的耗费    效率</code></pre><p>char    char(M)        最大的字符数，可以省略，默认为1        固定长度的字符        比较耗费    高</p><p>varchar varchar(M)    最大的字符数，不可以省略        可变长度的字符        比较节省    低<br>*/</p><p>CREATE TABLE tab_char(<br>    c1 ENUM(‘a’,’b’,’c’)</p><p>);</p><p>INSERT INTO tab_char VALUES(‘a’);<br>INSERT INTO tab_char VALUES(‘b’);<br>INSERT INTO tab_char VALUES(‘c’);<br>INSERT INTO tab_char VALUES(‘m’);<br>INSERT INTO tab_char VALUES(‘A’);</p><p>SELECT * FROM tab_set;</p><p>CREATE TABLE tab_set(</p><pre><code>s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</code></pre><p>);<br>INSERT INTO tab_set VALUES(‘a’);<br>INSERT INTO tab_set VALUES(‘A,B’);<br>INSERT INTO tab_set VALUES(‘a,c,d’);</p><p>#四、日期型</p><p>/*</p><p>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</p><p>datetime保存日期+时间<br>timestamp保存日期+时间</p><p>特点：</p><pre><code>    字节        范围        时区等的影响</code></pre><p>datetime                   8        1000——9999                      不受<br>timestamp    4                   1970-2038                        受</p><p>*/</p><p>CREATE TABLE tab_date(<br>    t1 DATETIME,<br>    t2 TIMESTAMP</p><p>);</p><p>INSERT INTO tab_date VALUES(NOW(),NOW());</p><p>SELECT * FROM tab_date;</p><p>SHOW VARIABLES LIKE ‘time_zone’;</p><p>SET time_zone=’+9:00’;</p><h3 id="子查询案例"><a href="#子查询案例" class="headerlink" title="子查询案例"></a>子查询案例</h3><hr><h4 id="1-查询工资最低的员工信息-last-name-salary"><a href="#1-查询工资最低的员工信息-last-name-salary" class="headerlink" title="1. 查询工资最低的员工信息: last_name, salary"></a>1. 查询工资最低的员工信息: last_name, salary</h4><p>#①查询最低的工资<br>SELECT MIN(salary)<br>FROM employees</p><p>#②查询last_name,salary，要求salary=①<br>SELECT last_name,salary<br>FROM employees<br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM employees<br>);</p><h4 id="2-查询平均工资最低的部门信息"><a href="#2-查询平均工资最低的部门信息" class="headerlink" title="2. 查询平均工资最低的部门信息"></a>2. 查询平均工资最低的部门信息</h4><p>#方式一：<br>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>#②查询①结果上的最低平均工资<br>SELECT MIN(ag)<br>FROM (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>) ag_dep</p><p>#③查询哪个部门的平均工资=②</p><p>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary)=(<br>    SELECT MIN(ag)<br>    FROM (<br>        SELECT AVG(salary) ag,department_id<br>        FROM employees<br>        GROUP BY department_id<br>    ) ag_dep</p><p>);</p><p>#④查询部门信息</p><p>SELECT d.*<br>FROM departments d<br>WHERE d.<code>department_id</code>=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    HAVING AVG(salary)=(<br>        SELECT MIN(ag)<br>        FROM (<br>            SELECT AVG(salary) ag,department_id<br>            FROM employees<br>            GROUP BY department_id<br>        ) ag_dep</p><pre><code>)</code></pre><p>);</p><p>#方式二：<br>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#②求出最低平均工资的部门编号<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY AVG(salary)<br>LIMIT 1;</p><p>#③查询部门信息<br>SELECT *<br>FROM departments<br>WHERE department_id=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary)<br>    LIMIT 1<br>);</p><h4 id="3-查询平均工资最低的部门信息和该部门的平均工资"><a href="#3-查询平均工资最低的部门信息和该部门的平均工资" class="headerlink" title="3. 查询平均工资最低的部门信息和该部门的平均工资"></a>3. 查询平均工资最低的部门信息和该部门的平均工资</h4><p>#①各部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>#②求出最低平均工资的部门编号<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY AVG(salary)<br>LIMIT 1;<br>#③查询部门信息<br>SELECT d.*,ag<br>FROM departments d<br>JOIN (<br>    SELECT AVG(salary) ag,department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary)<br>    LIMIT 1</p><p>) ag_dep<br>ON d.<code>department_id</code>=ag_dep.department_id;</p><h4 id="4-查询平均工资最高的-job-信息"><a href="#4-查询平均工资最高的-job-信息" class="headerlink" title="4. 查询平均工资最高的 job 信息"></a>4. 查询平均工资最高的 job 信息</h4><p>#①查询最高的job的平均工资<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1</p><p>#②查询job信息<br>SELECT *<br>FROM jobs<br>WHERE job_id=(<br>    SELECT job_id<br>    FROM employees<br>    GROUP BY job_id<br>    ORDER BY AVG(salary) DESC<br>    LIMIT 1</p><p>);</p><h4 id="5-查询平均工资高于公司平均工资的部门有哪些"><a href="#5-查询平均工资高于公司平均工资的部门有哪些" class="headerlink" title="5. 查询平均工资高于公司平均工资的部门有哪些?"></a>5. 查询平均工资高于公司平均工资的部门有哪些?</h4><p>#①查询平均工资<br>SELECT AVG(salary)<br>FROM employees</p><p>#②查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id</p><p>#③筛选②结果集，满足平均工资&gt;①</p><p>SELECT AVG(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING AVG(salary)&gt;(<br>    SELECT AVG(salary)<br>    FROM employees</p><p>);</p><h4 id="6-查询出公司中所有-manager-的详细信息"><a href="#6-查询出公司中所有-manager-的详细信息" class="headerlink" title="6. 查询出公司中所有 manager 的详细信息."></a>6. 查询出公司中所有 manager 的详细信息.</h4><p>#①查询所有manager的员工编号<br>SELECT DISTINCT manager_id<br>FROM employees</p><p>#②查询详细信息，满足employee_id=①<br>SELECT *<br>FROM employees<br>WHERE employee_id =ANY(<br>    SELECT DISTINCT manager_id<br>    FROM employees</p><p>);</p><h4 id="7-各个部门中-最高工资中最低的那个部门的-最低工资是多少"><a href="#7-各个部门中-最高工资中最低的那个部门的-最低工资是多少" class="headerlink" title="7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少"></a>7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</h4><p>#①查询各部门的最高工资中最低的部门编号<br>SELECT department_id<br>FROM employees<br>GROUP BY department_id<br>ORDER BY MAX(salary)<br>LIMIT 1</p><p>#②查询①结果的那个部门的最低工资</p><p>SELECT MIN(salary) ,department_id<br>FROM employees<br>WHERE department_id=(<br>    SELECT department_id<br>    FROM employees<br>    GROUP BY department_id<br>    ORDER BY MAX(salary)<br>    LIMIT 1</p><p>);</p><h4 id="8-查询平均工资最高的部门的-manager-的详细信息-last-name-department-id-email-salary"><a href="#8-查询平均工资最高的部门的-manager-的详细信息-last-name-department-id-email-salary" class="headerlink" title="8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary"></a>8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</h4><p>#①查询平均工资最高的部门编号<br>SELECT<br>    department_id<br>FROM<br>    employees<br>GROUP BY department_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1 </p><p>#②将employees和departments连接查询，筛选条件是①<br>    SELECT<br>        last_name, d.department_id, email, salary<br>    FROM<br>        employees e<br>        INNER JOIN departments d<br>            ON d.manager_id = e.employee_id<br>    WHERE d.department_id =<br>        (SELECT<br>            department_id<br>        FROM<br>            employees<br>        GROUP BY department_id<br>        ORDER BY AVG(salary) DESC<br>        LIMIT 1) ;</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>#常见约束</p><p>/*</p><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><p>分类：六大约束<br>    NOT NULL：非空，用于保证该字段的值不能为空<br>    比如姓名、学号等<br>    DEFAULT:默认，用于保证该字段有默认值<br>    比如性别<br>    PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空<br>    比如学号、员工编号等<br>    UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空<br>    比如座位号<br>    CHECK:检查约束【mysql中不支持】<br>    比如年龄、性别<br>    FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值<br>        在从表添加外键约束，用于引用主表中某列的值<br>    比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p><p>添加约束的时机：<br>    1.创建表时<br>    2.修改表时</p><p>约束的添加分类：<br>    列级约束：<br>        六大约束语法上都支持，但外键约束没有效果</p><pre><code>表级约束：        除了非空、默认，其他的都支持</code></pre><p>​<br>主键和唯一的大对比：</p><pre><code>    保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合主键    √        ×        至多有1个           √，但不推荐唯一    √        √        可以有多个          √，但不推荐</code></pre><p>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表<br>    删除数据时，先删除从表，再删除主表</p><p>*/</p><p>CREATE TABLE 表名(<br>    字段名 字段类型 列级约束,<br>    字段名 字段类型,<br>    表级约束</p><p>)<br>CREATE DATABASE students;<br>#一、创建表时添加约束</p><p>#1.添加列级约束<br>/*<br>语法：</p><p>直接在字段名和类型后面追加 约束类型即可。</p><p>只支持：默认、非空、主键、唯一</p><p>*/</p><p>USE students;<br>DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT PRIMARY KEY,#主键<br>    stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>    gender CHAR(1) CHECK(gender=’男’ OR gender =’女’),#检查<br>    seat INT UNIQUE,#唯一<br>    age INT DEFAULT  18,#默认约束<br>    majorId INT REFERENCES major(id)#外键</p><p>);</p><p>CREATE TABLE major(<br>    id INT PRIMARY KEY,<br>    majorName VARCHAR(20)<br>);</p><p>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;</p><p>#2.添加表级约束<br>/*</p><p>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名)<br>*/</p><p>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT,</p><pre><code>CONSTRAINT pk PRIMARY KEY(id),#主键CONSTRAINT uq UNIQUE(seat),#唯一键CONSTRAINT ck CHECK(gender =&#39;男&#39; OR gender  = &#39;女&#39;),#检查CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</code></pre><p>);</p><p>SHOW INDEX FROM stuinfo;</p><p>#通用的写法：★</p><p>CREATE TABLE IF NOT EXISTS stuinfo(<br>    id INT PRIMARY KEY,<br>    stuname VARCHAR(20),<br>    sex CHAR(1),<br>    age INT DEFAULT 18,<br>    seat INT UNIQUE,<br>    majorid INT,<br>    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</p><p>);</p><p>#二、修改表时添加约束</p><p>/*<br>1、添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;</p><p>2、添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</p><p>*/<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT<br>)<br>DESC stuinfo;<br>#1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;<br>#2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br>#3.添加主键<br>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;<br>#②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p><p>#4.添加唯一</p><p>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;<br>#②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);</p><p>#5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </p><p>#三、修改表时删除约束</p><p>#1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</p><p>#2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;</p><p>#3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;</p><p>#4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;</p><p>#5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</p><p>SHOW INDEX FROM stuinfo;</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）</p><p>ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;<br>ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);</p><p>#2.    向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）</p><p>#3.    向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。<br>ALTER TABLE emp2 ADD COLUMN dept_id INT;<br>ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);</p><pre><code>    位置        支持的约束类型            是否可以起约束名</code></pre><p>列级约束：    列的后面    语法都支持，但外键没有效果    不可以<br>表级约束：    所有列的下面    默认和非空不支持，其他支持    可以（主键没有效果）</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>#视图<br>/*<br>含义：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据</p><p>比如：舞蹈班和普通班级的对比<br>    创建语法的关键字    是否实际占用物理空间    使用</p><p>视图    create view        只是保存了sql逻辑    增删改查，只是一般不能增删改</p><p>表    create table        保存了数据        增删改查</p><p>*/</p><p>#案例：查询姓张的学生名和专业名<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.<code>majorid</code>= m.<code>id</code><br>WHERE s.<code>stuname</code> LIKE ‘张%’;</p><p>CREATE VIEW v1<br>AS<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.<code>majorid</code>= m.<code>id</code>;</p><p>SELECT * FROM v1 WHERE stuname LIKE ‘张%’;</p><p>#一、创建视图<br>/*<br>语法：<br>create view 视图名<br>as<br>查询语句;</p><p>*/<br>USE myemployees;</p><p>#1.查询姓名中包含a字符的员工名、部门名和工种信息<br>#①创建<br>CREATE VIEW myv1<br>AS</p><p>SELECT last_name,department_name,job_title<br>FROM employees e<br>JOIN departments d ON e.department_id  = d.department_id<br>JOIN jobs j ON j.job_id  = e.job_id;</p><p>#②使用<br>SELECT * FROM myv1 WHERE last_name LIKE ‘%a%’;</p><p>#2.查询各部门的平均工资级别</p><p>#①创建视图查看每个部门的平均工资<br>CREATE VIEW myv2<br>AS<br>SELECT AVG(salary) ag,department_id<br>FROM employees<br>GROUP BY department_id;</p><p>#②使用<br>SELECT myv2.<code>ag</code>,g.grade_level<br>FROM myv2<br>JOIN job_grades g<br>ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p><p>#3.查询平均工资最低的部门信息</p><p>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p><p>#4.查询平均工资最低的部门名和工资</p><p>CREATE VIEW myv3<br>AS<br>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p><p>SELECT d.*,m.ag<br>FROM myv3 m<br>JOIN departments d<br>ON m.<code>department_id</code>=d.<code>department_id</code>;</p><p>#二、视图的修改</p><p>#方式一：<br>/*<br>create or replace view  视图名<br>as<br>查询语句;</p><p>*/<br>SELECT * FROM myv3 </p><p>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p><p>#方式二：<br>/*<br>语法：<br>alter view 视图名<br>as<br>查询语句;</p><p>*/<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;</p><p>#三、删除视图</p><p>/*</p><p>语法：drop view 视图名,视图名,…;<br>*/</p><p>DROP VIEW emp_v1,emp_v2,myv3;</p><p>#四、查看视图</p><p>DESC myv3;</p><p>SHOW CREATE VIEW myv3;</p><p>#五、视图的更新</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email,salary<em>12</em>(1+IFNULL(commission_pct,0)) “annual salary”<br>FROM employees;</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;</p><p>SELECT * FROM myv1;<br>SELECT * FROM employees;<br>#1.插入</p><p>INSERT INTO myv1 VALUES(‘张飞’,‘zf@qq.com’);</p><p>#2.修改<br>UPDATE myv1 SET last_name = ‘张无忌’ WHERE last_name=’张飞’;</p><p>#3.删除<br>DELETE FROM myv1 WHERE last_name = ‘张无忌’;</p><p>#具备以下特点的视图不允许更新</p><p>#①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p><p>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT MAX(salary) m,department_id<br>FROM employees<br>GROUP BY department_id;</p><p>SELECT * FROM myv1;</p><p>#更新<br>UPDATE myv1 SET m=9000 WHERE department_id=10;</p><p>#②常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS</p><p>SELECT ‘john’ NAME;</p><p>SELECT * FROM myv2;</p><p>#更新<br>UPDATE myv2 SET NAME=’lucy’;</p><p>#③Select中包含子查询</p><p>CREATE OR REPLACE VIEW myv3<br>AS</p><p>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;</p><p>#更新<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资=100000;</p><p>#④join<br>CREATE OR REPLACE VIEW myv4<br>AS</p><p>SELECT last_name,department_name<br>FROM employees e<br>JOIN departments d<br>ON e.department_id  = d.department_id;</p><p>#更新</p><p>SELECT * FROM myv4;<br>UPDATE myv4 SET last_name  = ‘张飞’ WHERE last_name=’Whalen’;<br>INSERT INTO myv4 VALUES(‘陈真’,’xxxx’);</p><p>#⑤from一个不能更新的视图<br>CREATE OR REPLACE VIEW myv5<br>AS</p><p>SELECT * FROM myv3;</p><p>#更新</p><p>SELECT * FROM myv5;</p><p>UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;</p><p>#⑥where子句的子查询引用了from子句中的表</p><p>CREATE OR REPLACE VIEW myv6<br>AS</p><p>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>    SELECT  manager_id<br>    FROM employees<br>    WHERE manager_id IS NOT NULL<br>);</p><p>#更新<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary=10000 WHERE last_name = ‘k_ing’;</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p><p>CREATE OR REPLACE VIEW emp_v1<br>AS<br>SELECT last_name,salary,email<br>FROM employees<br>WHERE phone_number LIKE ‘011%’;</p><p>#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p><p>CREATE OR REPLACE VIEW emp_v2<br>AS<br>SELECT MAX(salary) mx_dep,department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MAX(salary)&gt;12000;</p><p>SELECT d.*,m.mx_dep<br>FROM departments d<br>JOIN emp_v2 m<br>ON m.department_id = d.<code>department_id</code>;</p><h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><p>/*<br>又称为自增长列<br>含义：可以不用手动的插入值，系统提供默认的序列值</p><p>特点：<br>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 SET auto_increment_increment=3;设置步长<br>可以通过 手动插入值，设置起始值</p><p>*/</p><p>#一、创建表时设置标识列</p><p>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>    id INT  ,<br>    NAME FLOAT UNIQUE AUTO_INCREMENT,<br>    seat INT </p><p>);<br>TRUNCATE TABLE tab_identity;</p><p>INSERT INTO tab_identity(id,NAME) VALUES(NULL,’john’);<br>INSERT INTO tab_identity(NAME) VALUES(‘lucy’);<br>SELECT * FROM tab_identity;</p><p>SHOW VARIABLES LIKE ‘%auto_increment%’;</p><p>SET auto_increment_increment=3;</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>/*<br>系统变量：<br>    全局变量<br>    会话变量</p><p>自定义变量：<br>    用户变量<br>    局部变量</p><p><em>/<br>#一、系统变量<br>/</em><br>说明：变量由系统定义，不是用户定义，属于服务器层面<br>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br>使用步骤：<br>1、查看所有系统变量<br>show global|【session】variables;<br>2、查看满足条件的部分系统变量<br>show global|【session】 variables like ‘%char%’;<br>3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br>4、为某个系统变量赋值<br>方式一：<br>set global|【session】系统变量名=值;<br>方式二：<br>set @@global|【session】系统变量名=值;</p><p><em>/<br>#1》全局变量<br>/</em><br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>*/<br>#①查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br>#②查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>#③查看指定的系统变量的值<br>SELECT @@global.autocommit;<br>#④为某个系统变量赋值<br>SET @@global.autocommit=0;<br>SET GLOBAL autocommit=0;</p><p>#2》会话变量<br>/*<br>作用域：针对于当前会话（连接）有效<br>*/<br>#①查看所有会话变量<br>SHOW SESSION VARIABLES;<br>#②查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE ‘%char%’;<br>#③查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;<br>#④为某个会话变量赋值<br>SET @@session.tx_isolation=’read-uncommitted’;<br>SET SESSION tx_isolation=’read-committed’;</p><p>#二、自定义变量<br>/*<br>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）<br>*/</p><p>#1》用户变量<br>/*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*/</p><p>#赋值操作符：=或:=<br>#①声明并初始化<br>SET @变量名=值;<br>SET @变量名:=值;<br>SELECT @变量名:=值;</p><p>#②赋值（更新变量的值）<br>#方式一：<br>    SET @变量名=值;<br>    SET @变量名:=值;<br>    SELECT @变量名:=值;<br>#方式二：<br>    SELECT 字段 INTO @变量名<br>    FROM 表;<br>#③使用（查看变量的值）<br>SELECT @变量名;</p><p>#2》局部变量<br>/*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*/</p><p>#①声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】;</p><p>#②赋值（更新变量的值）</p><p>#方式一：<br>    SET 局部变量名=值;<br>    SET 局部变量名:=值;<br>    SELECT 局部变量名:=值;<br>#方式二：<br>    SELECT 字段 INTO 具备变量名<br>    FROM 表;<br>#③使用（查看变量的值）<br>SELECT 局部变量名;</p><p>#案例：声明两个变量，求和并打印</p><p>#用户变量<br>SET @m=1;<br>SET @n=1;<br>SET @sum=@m+@n;<br>SELECT @sum;</p><p>#局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p><p>#用户变量和局部变量的对比</p><pre><code>    作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><p>局部变量定义 只能在 begin 和end之间 定义 否则会有语法错误</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>#TCL<br>/*<br>Transaction Control Language 事务控制语言</p><p>事务：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><p>案例：转账</p><p>张三丰  1000<br>郭襄    1000</p><p>update 表 set 张三丰的余额=500 where name=’张三丰’<br>意外<br>update 表 set 郭襄的余额=1500 where name=’郭襄’</p><p>事务的特性：<br>ACID<br>原子性：一个事务不可再分割，要么都执行要么都不执行<br>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态<br>隔离性：一个事务的执行不受其他事务的干扰<br>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</p><p>事务的创建<br>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p><p>delete from 表 where id =1;</p><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</p><p>set autocommit=0;</p><p>步骤1：开启事务<br>set autocommit=0;<br>start transaction;可选的<br>步骤2：编写事务中的sql语句(select insert update delete)<br>语句1;<br>语句2;<br>…</p><p>步骤3：结束事务<br>commit;提交事务<br>rollback;回滚事务</p><p>savepoint 节点名;设置保存点</p><p>事务的隔离级别：<br>          脏读        不可重复读    幻读<br>read uncommitted：√        √        √<br>read committed：  ×        √        √<br>repeatable read： ×        ×        √<br>serializable      ×             ×               ×</p><p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed<br>查看隔离级别<br>select @@tx_isolation;<br>设置隔离级别<br>set session|global transaction isolation level 隔离级别;</p><p>开启事务的语句;<br>update 表 set 张三丰的余额=500 where name=’张三丰’</p><p>update 表 set 郭襄的余额=1500 where name=’郭襄’<br>结束事务的语句;</p><p>*/</p><p>SHOW VARIABLES LIKE ‘autocommit’;<br>SHOW ENGINES;</p><p>#1.演示事务的使用步骤</p><p>#开启事务<br>SET autocommit=0;<br>START TRANSACTION;<br>#编写一组事务的语句<br>UPDATE account SET balance = 1000 WHERE username=’张无忌’;<br>UPDATE account SET balance = 1000 WHERE username=’赵敏’;</p><p>#结束事务<br>ROLLBACK;<br>#commit;</p><p>SELECT * FROM account;</p><p>#2.演示事务对于delete和truncate的处理的区别</p><p>SET autocommit=0;<br>START TRANSACTION;</p><p>DELETE FROM account;<br>ROLLBACK;</p><p>#3.演示savepoint 的使用<br>SET autocommit=0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id=28;<br>ROLLBACK TO a;#回滚到保存点</p><p>SELECT * FROM account;</p><h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><p>/*<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p><p><em>/<br>#存储过程<br>/</em><br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p>*/</p><p>#一、创建语法</p><p>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN</p><pre><code>存储过程体（一组合法的SQL语句）</code></pre><p>END</p><p>#注意：<br>/*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p><p>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*/</p><p>#二、调用语法</p><p>CALL 存储过程名(实参列表);</p><p>#——————————–案例演示———————————–<br>#1.空参列表<br>#案例：插入到admin表中五条记录</p><p>SELECT * FROM admin;</p><p>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>    INSERT INTO admin(username,<code>password</code>)<br>    VALUES(‘john1’,’0000’),(‘lily’,’0000’),(‘rose’,’0000’),(‘jack’,’0000’),(‘tom’,’0000’);<br>END $</p><p>#调用<br>CALL myp1()$</p><p>#2.创建带in模式参数的存储过程</p><p>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息</p><p>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.*<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>    WHERE b.name=beautyName;</p><p>END $</p><p>#调用<br>CALL myp2(‘柳岩’)$</p><p>#案例2 ：创建存储过程实现，用户是否登录成功</p><p>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>    DECLARE result INT DEFAULT 0;#声明并初始化</p><pre><code>SELECT COUNT(*) INTO result#赋值FROM adminWHERE admin.username = usernameAND admin.password = PASSWORD;SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用</code></pre><p>END $</p><p>#调用<br>CALL myp3(‘张飞’,’8888’)$</p><p>#3.创建out 模式参数的存储过程<br>#案例1：根据输入的女神名，返回对应的男神名<br>注意：默认是 in类型<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.boyname INTO boyname<br>    FROM boys bo<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName ;</p><p>END $</p><p>#案例2：根据输入的女神名，返回对应的男神名和魅力值</p><p>CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT)<br>BEGIN<br>    SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>    FROM boys<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = boys.id<br>    WHERE b.name=beautyName ;</p><p>END $</p><p>#调用<br>CALL myp7(‘小昭’,@name,@cp)$<br>SELECT @name,@cp$</p><p>#4.创建带inout模式参数的存储过程<br>#案例1：传入a和b两个值，最终a和b都翻倍并返回</p><p>CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)<br>BEGIN<br>    SET a=a<em>2;<br>    SET b=b</em>2;<br>END $</p><p>#调用<br>SET @m=10$<br>SET @n=20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$</p><p>#三、删除存储过程<br>#语法：drop procedure 存储过程名<br>DROP PROCEDURE p1;<br>DROP PROCEDURE p2,p3;#×</p><p>#四、查看存储过程的信息<br>DESC myp2;×<br>SHOW CREATE PROCEDURE  myp2;</p><p>#一、创建存储过程实现传入用户名和密码，插入到admin表中</p><p>CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))<br>BEGIN<br>    INSERT INTO admin(admin.username,PASSWORD)<br>    VALUES(username,loginpwd);<br>END $</p><p>#二、创建存储过程实现传入女神编号，返回女神名称和女神电话</p><p>CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))</p><p>BEGIN<br>    SELECT b.name ,b.phone INTO NAME,phone<br>    FROM beauty b<br>    WHERE b.id = id;</p><p>END $<br>#三、创建存储存储过程或函数实现传入两个女神生日，返回大小</p><p>CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)<br>BEGIN<br>    SELECT DATEDIFF(birth1,birth2) INTO result;<br>END $<br>#四、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回<br>CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))<br>BEGIN<br>    SELECT DATE_FORMAT(mydate,’%y年%m月%d日’) INTO strDate;<br>END $</p><p>CALL test_pro4(NOW(),@str)$<br>SELECT @str $</p><p>#五、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串<br>如 传入 ：小昭<br>返回： 小昭 AND 张无忌<br>DROP PROCEDURE test_pro5 $<br>CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))<br>BEGIN<br>    SELECT CONCAT(beautyName,’ and ‘,IFNULL(boyName,’null’)) INTO str<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName;</p><pre><code>SET str=</code></pre><p>END $</p><p>CALL test_pro5(‘柳岩’,@str)$<br>SELECT @str $</p><p>#六、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录<br>DROP PROCEDURE test_pro6$<br>CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)<br>BEGIN<br>    SELECT * FROM beauty LIMIT startIndex,size;<br>END $</p><p>CALL test_pro6(3,5)$</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>/*<br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p>区别：</p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p>*/</p><p>#一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>    函数体<br>END<br>/*</p><p>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型</p><p>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p><p>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记</p><p>*/</p><p>#二、调用语法<br>SELECT 函数名(参数列表)</p><p>#——————————案例演示—————————-<br>#1.无参有返回<br>#案例：返回公司的员工个数<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN</p><pre><code>DECLARE c INT DEFAULT 0;#定义局部变量SELECT COUNT(*) INTO c#赋值FROM employees;RETURN c;</code></pre><p>END $</p><p>SELECT myf1()$</p><p>#2.有参有返回<br>#案例1：根据员工名，返回它的工资</p><p>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    SET @sal=0;#定义用户变量<br>    SELECT salary INTO @sal   #赋值<br>    FROM employees<br>    WHERE last_name = empName;</p><pre><code>RETURN @sal;</code></pre><p>END $</p><p>SELECT myf2(‘k_ing’) $</p><p>#案例2：根据部门名，返回该部门的平均工资</p><p>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    DECLARE sal DOUBLE ;<br>    SELECT AVG(salary) INTO sal<br>    FROM employees e<br>    JOIN departments d ON e.department_id = d.department_id<br>    WHERE d.department_name=deptName;<br>    RETURN sal;<br>END $</p><p>SELECT myf3(‘IT’)$</p><p>#三、查看函数</p><p>SHOW CREATE FUNCTION myf3;</p><p>#四、删除函数<br>DROP FUNCTION myf3;</p><p>#案例<br>#一、创建函数，实现传入两个float，返回二者之和</p><p>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>    DECLARE SUM FLOAT DEFAULT 0;<br>    SET SUM=num1+num2;<br>    RETURN SUM;<br>END $</p><p>SELECT test_fun1(1,2)$</p><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><p>/*<br>顺序、分支、循环</p><p>*/</p><p>#一、分支结构<br>#1.if函数<br>/*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面</p><p>*/</p><p>#2.case结构<br>/*<br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>…<br>else 语句n;<br>end </p><p>情况2：<br>case<br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>…<br>else 语句n;<br>end </p><p>应用在begin end 中或外面</p><p>*/</p><p>#3.if结构</p><p>/*<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>….<br>else 语句n;<br>end if;<br>功能：类似于多重if</p><p>只能应用在begin end 中</p><p>*/</p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p><p>CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;<br>    IF score&gt;90 THEN SET ch=’A’;<br>    ELSEIF score&gt;80 THEN SET ch=’B’;<br>    ELSEIF score&gt;60 THEN SET ch=’C’;<br>    ELSE SET ch=’D’;<br>    END IF;<br>    RETURN ch;</p><p>END $</p><p>SELECT test_if(87)$</p><p>#案例2：创建存储过程，如果工资&lt;2000,则删除，如果5000&gt;工资&gt;2000,则涨工资1000，否则涨工资500</p><p>CREATE PROCEDURE test_if_pro(IN sal DOUBLE)<br>BEGIN<br>    IF sal&lt;2000 THEN DELETE FROM employees WHERE employees.salary=sal;<br>    ELSEIF sal&gt;=2000 AND sal&lt;5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.<code>salary</code>=sal;<br>    ELSE UPDATE employees SET salary=salary+500 WHERE employees.<code>salary</code>=sal;<br>    END IF;</p><p>END $</p><p>CALL test_if_pro(2100)$</p><p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p><p>CREATE FUNCTION test_case(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;</p><pre><code>CASE WHEN score&gt;90 THEN SET ch=&#39;A&#39;;WHEN score&gt;80 THEN SET ch=&#39;B&#39;;WHEN score&gt;60 THEN SET ch=&#39;C&#39;;ELSE SET ch=&#39;D&#39;;END CASE;RETURN ch;</code></pre><p>END $</p><p>SELECT test_case(56)$</p><p>#二、循环结构<br>/*<br>分类：<br>while、loop、repeat</p><p>循环控制：</p><p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p><p>*/</p><p>#1.while<br>/*</p><p>语法：</p><p>【标签:】while 循环条件 do<br>    循环体;<br>end while【 标签】;</p><p>联想：</p><p>while(循环条件){</p><pre><code>循环体;</code></pre><p>}</p><p>*/</p><p>#2.loop<br>/*</p><p>语法：<br>【标签:】loop<br>    循环体;<br>end loop 【标签】;</p><p>可以用来模拟简单的死循环</p><p>*/</p><p>#3.repeat<br>/*<br>语法：<br>【标签：】repeat<br>    循环体;<br>until 结束循环的条件<br>end repeat 【标签】;</p><p>*/</p><p>#1.没有添加循环控制语句<br>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘Rose’,i),’666’);<br>        SET i=i+1;<br>    END WHILE;</p><p>END $</p><p>CALL pro_while1(100)$</p><p>/*</p><p>int i=1;<br>while(i&lt;=insertcount){</p><pre><code>//插入i++;</code></pre><p>}</p><p>*/</p><p>#2.添加leave语句</p><p>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    a:WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘xiaohua’,i),’0000’);<br>        IF i&gt;=20 THEN LEAVE a;<br>        END IF;<br>        SET i=i+1;<br>    END WHILE a;<br>END $</p><p>CALL test_while1(100)$</p><p>#3.添加iterate语句</p><p>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    a:WHILE i&lt;=insertCount DO<br>        SET i=i+1;<br>        IF MOD(i,2)!=0 THEN ITERATE a;<br>        END IF;</p><pre><code>    INSERT INTO admin(username,`password`) VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);    END WHILE a;</code></pre><p>END $</p><p>CALL test_while1(100)$</p><p>/*</p><p>int i=0;<br>while(i&lt;=insertCount){<br>    i++;<br>    if(i%2==0){<br>        continue;<br>    }<br>    插入</p><p>}</p><p>*/</p><p>/*一、已知表stringcontent<br>其中字段：<br>id 自增长<br>content varchar(20)</p><p>向该表插入指定个数的，随机的字符串<br>*/<br>DROP TABLE IF EXISTS stringcontent;<br>CREATE TABLE stringcontent(<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    content VARCHAR(20)</p><p>);<br>DELIMITER $<br>CREATE PROCEDURE test_randstr_insert(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    DECLARE str VARCHAR(26) DEFAULT ‘abcdefghijklmnopqrstuvwxyz’;<br>    DECLARE startIndex INT;#代表初始索引<br>    DECLARE len INT;#代表截取的字符长度<br>    WHILE i&lt;=insertcount DO<br>        SET startIndex=FLOOR(RAND()<em>26+1);#代表初始索引，随机范围1-26<br>        SET len=FLOOR(RAND()</em>(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）<br>        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));<br>        SET i=i+1;<br>    END WHILE;</p><p>END $</p><p>CALL test_randstr_insert(10)$</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会</title>
    <link href="http://example.com/2021/04/22/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://example.com/2021/04/22/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id>
    <published>2021-04-22T15:49:22.000Z</published>
    <updated>2021-04-28T09:35:38.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-SQL"><a href="#第一章-SQL" class="headerlink" title="第一章 SQL"></a>第一章 SQL</h3><h4 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h4><ul><li><p>数据库软件应称为DBMS（数据库管理系统）。</p></li><li><p>表（table） 某种特定类型数据的结构化清单。</p><ul><li>表名 表名具有唯一性 ， 在相同数据库中不能两次使用相同的表名。</li><li>模式（schema） 关于数据库和表的布局及特性的信息。</li></ul></li><li><p>列 </p><ul><li><p>表由列组成。列中存储着表中某部分的信息</p></li><li><p>列（column） 表中的一个字段。所有表都是由一个或多个列组</p><p>成的。</p></li></ul></li><li><p>数据类型（datatype）</p><ul><li>数据类型  所容许的数据的类型。限制（或容许）列中存储的数据。</li></ul></li><li><p>行（row） 表中的一个记录。</p><ul><li><p>表中的数据是按行存储</p></li><li><p>主键（primary key）列（或一组列），其值能够唯一区分表</p><p>中每个行。</p><ul><li><p>大多数数据库应保证创建的每个表具有一个主键。</p></li><li><p> 任意两行都不具有相同的主键值；</p><p> 每个行都必须具有一个主键值（主键列不允许NULL值）。</p></li><li><p>主键的最好习惯 ：</p><p>不更新主键列中的值；</p><p>不重用主键列的值；</p><p> 不在主键列中使用可能会更改的值。 </p></li></ul></li></ul></li></ul><h4 id="2-SQL-：结构化查询语言"><a href="#2-SQL-：结构化查询语言" class="headerlink" title="2.SQL    ：结构化查询语言"></a>2.SQL    ：结构化查询语言</h4><ul><li><p>优点：SQL不是某个特定数据库供应商专有的语言。 </p><p> SQL简单易学 </p><p> 它 是一种强有力的语言， 可以进行非常复杂和高级的数据库操作。</p></li><li><p>事实上任意两个DBMS实现的SQL都不完全相同</p></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    介绍了什么是SQL以及它为什么很有用</p><h3 id="第二章MYSQL-简介"><a href="#第二章MYSQL-简介" class="headerlink" title="第二章MYSQL 简介"></a>第二章MYSQL 简介</h3><h4 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h4><p>​    一种DBMS，即它是一种数据库软件。</p><ul><li><p>客户机是与用户打交道的软件。</p><p>服务器部分是负责所有数据访问和处理的一个软件。</p></li><li><p>版本： 4——InnoDB引擎，增加事务处理（第26章）、并（第17章）、改</p><p>​            进全文本搜索（第18章）等的支持。</p><p>​             4.1——对函数库、子查询（第14章）、集成帮助等的重要增加。</p><p>​             5——存储过程 、触发器 、游标 、视图 </p></li></ul><h4 id="2-MySQL工具"><a href="#2-MySQL工具" class="headerlink" title="2.MySQL工具"></a>2.MySQL工具</h4><p>​        mysql命令行实用程序；图形交互客户机</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>本章介绍了什么是MySQL，并引入了几个客户机实用程序（一个命</p><p>令行实用程序，两个可选但强烈建议使用的图形实用程序）。</p><h3 id="第三章-使用mysql"><a href="#第三章-使用mysql" class="headerlink" title="第三章 使用mysql"></a>第三章 使用mysql</h3><h4 id="1-链接"><a href="#1-链接" class="headerlink" title="1.链接"></a>1.链接</h4><h4 id="2-选择数据库"><a href="#2-选择数据库" class="headerlink" title="2.选择数据库"></a>2.选择数据库</h4><h4 id="3-了解数据库和表"><a href="#3-了解数据库和表" class="headerlink" title="3.了解数据库和表"></a>3.了解数据库和表</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="第四章-检索数据"><a href="#第四章-检索数据" class="headerlink" title="第四章 检索数据"></a>第四章 检索数据</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h4 id="检索单列"><a href="#检索单列" class="headerlink" title="检索单列"></a>检索单列</h4><h4 id="检所多列"><a href="#检所多列" class="headerlink" title="检所多列"></a>检所多列</h4><h4 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h4><h4 id="检索所有行"><a href="#检索所有行" class="headerlink" title="检索所有行"></a>检索所有行</h4><h4 id="检所不同的行"><a href="#检所不同的行" class="headerlink" title="检所不同的行"></a>检所不同的行</h4><h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><h4 id="完全限制表名"><a href="#完全限制表名" class="headerlink" title="完全限制表名"></a>完全限制表名</h4><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><h3 id="第五章-排序检索数据"><a href="#第五章-排序检索数据" class="headerlink" title="第五章 排序检索数据"></a>第五章 排序检索数据</h3><h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><h4 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h4><h4 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h4><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><h3 id="第六章-过滤数据"><a href="#第六章-过滤数据" class="headerlink" title="第六章 过滤数据"></a>第六章 过滤数据</h3><h4 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h4><h4 id="where子句操作符"><a href="#where子句操作符" class="headerlink" title="where子句操作符"></a>where子句操作符</h4><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h3 id="第七章-数据过滤"><a href="#第七章-数据过滤" class="headerlink" title="第七章 数据过滤"></a>第七章 数据过滤</h3><h4 id="组合where子句"><a href="#组合where子句" class="headerlink" title="组合where子句"></a>组合where子句</h4><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><h3 id="第八章-使用通配符过滤数据"><a href="#第八章-使用通配符过滤数据" class="headerlink" title="第八章 使用通配符过滤数据"></a>第八章 使用通配符过滤数据</h3><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><h3 id="第九章-正则表达式进行搜索"><a href="#第九章-正则表达式进行搜索" class="headerlink" title="第九章 正则表达式进行搜索"></a>第九章 正则表达式进行搜索</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h4 id="MYSQL-正则表达式"><a href="#MYSQL-正则表达式" class="headerlink" title="MYSQL 正则表达式"></a>MYSQL 正则表达式</h4><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><h3 id="第十章计算字段"><a href="#第十章计算字段" class="headerlink" title="第十章计算字段"></a>第十章计算字段</h3><h4 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h4><h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><h4 id="算术计算"><a href="#算术计算" class="headerlink" title="算术计算"></a>算术计算</h4><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><h3 id="11章-计算字段"><a href="#11章-计算字段" class="headerlink" title="11章 计算字段"></a>11章 计算字段</h3><h4 id="计算字段-1"><a href="#计算字段-1" class="headerlink" title="计算字段"></a>计算字段</h4><h4 id="2-拼接字段"><a href="#2-拼接字段" class="headerlink" title="2.拼接字段"></a>2.拼接字段</h4><ul><li>别名<ul><li>其他用途</li><li></li></ul></li><li>  拼接</li><li>  去空格</li><li>  算术运算</li></ul><h3 id="11章-数据处理函数"><a href="#11章-数据处理函数" class="headerlink" title="11章 数据处理函数"></a>11章 数据处理函数</h3><p>1.函数：文本函数；数值函数；日期时间函数；系统函数</p><p>2.文本函数</p><ul><li></li></ul><p>3.数值函数</p><ul><li></li></ul><p>4.日期时间函数</p><ul><li></li><li></li><li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210421183227715.png" alt="image-20210421183227715"></p></li></ul><p>5.系统函数</p><ul><li></li></ul><h3 id="12章-汇总数据"><a href="#12章-汇总数据" class="headerlink" title="12章 汇总数据"></a>12章 汇总数据</h3><h3 id="13章-分组数据"><a href="#13章-分组数据" class="headerlink" title="13章 分组数据"></a>13章 分组数据</h3><h4 id="1-数据分组"><a href="#1-数据分组" class="headerlink" title="1.数据分组"></a>1.数据分组</h4><h4 id="2-创建分组"><a href="#2-创建分组" class="headerlink" title="2.创建分组"></a>2.创建分组</h4><h4 id="3-过滤分组"><a href="#3-过滤分组" class="headerlink" title="3.过滤分组"></a>3.过滤分组</h4><h4 id="4-分组和和排序"><a href="#4-分组和和排序" class="headerlink" title="4.分组和和排序"></a>4.分组和和排序</h4><h4 id="5-select子句顺序"><a href="#5-select子句顺序" class="headerlink" title="5.select子句顺序"></a>5.select子句顺序</h4><h3 id="14章-子查询"><a href="#14章-子查询" class="headerlink" title="14章 子查询"></a>14章 子查询</h3><p>1.子查询</p><ol start="2"><li></li></ol><h3 id="第十五章-连结表"><a href="#第十五章-连结表" class="headerlink" title="第十五章 连结表"></a>第十五章 连结表</h3><h4 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h4><h4 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h4><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="第十六章-创建高级联结"><a href="#第十六章-创建高级联结" class="headerlink" title="第十六章 创建高级联结"></a>第十六章 创建高级联结</h3><h4 id="表别名"><a href="#表别名" class="headerlink" title="表别名"></a>表别名</h4><h4 id="不同类型联结"><a href="#不同类型联结" class="headerlink" title="不同类型联结"></a>不同类型联结</h4><h4 id="带聚集函数的联结"><a href="#带聚集函数的联结" class="headerlink" title="带聚集函数的联结"></a>带聚集函数的联结</h4><h4 id="联结和连接条件"><a href="#联结和连接条件" class="headerlink" title="联结和连接条件"></a>联结和连接条件</h4><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><h3 id="第十七章-组合查询"><a href="#第十七章-组合查询" class="headerlink" title="第十七章 组合查询"></a>第十七章 组合查询</h3><h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><h4 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h4><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h3 id="第十八章-全文本搜索"><a href="#第十八章-全文本搜索" class="headerlink" title="第十八章 全文本搜索"></a>第十八章 全文本搜索</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="第十九章-插入数据"><a href="#第十九章-插入数据" class="headerlink" title="第十九章 插入数据"></a>第十九章 插入数据</h3><h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><h4 id="插入完整行"><a href="#插入完整行" class="headerlink" title="插入完整行"></a>插入完整行</h4><h4 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h4><h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十章-更新和删除数据"><a href="#第二十章-更新和删除数据" class="headerlink" title="第二十章 更新和删除数据"></a>第二十章 更新和删除数据</h3><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h4 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h4><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><h3 id="第二-十一章-创建和操纵表"><a href="#第二-十一章-创建和操纵表" class="headerlink" title="第二 十一章 创建和操纵表"></a>第二 十一章 创建和操纵表</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><h4 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十二章-使用视图"><a href="#第二十二章-使用视图" class="headerlink" title="第二十二章 使用视图"></a>第二十二章 使用视图</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><h4 id="-6"><a href="#-6" class="headerlink" title=""></a></h4><h3 id="第二十三章-存储过程"><a href="#第二十三章-存储过程" class="headerlink" title="第二十三章 存储过程"></a>第二十三章 存储过程</h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><h4 id="优点：简单，安全，高性能；"><a href="#优点：简单，安全，高性能；" class="headerlink" title="优点：简单，安全，高性能；"></a>优点：简单，安全，高性能；</h4><ul><li></li><li>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </li><li></li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十四章-游标"><a href="#第二十四章-游标" class="headerlink" title="第二十四章 游标"></a>第二十四章 游标</h3><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h4><h4 id="-7"><a href="#-7" class="headerlink" title=""></a></h4><h3 id="第二十五章-触发器"><a href="#第二十五章-触发器" class="headerlink" title="第二十五章 触发器"></a>第二十五章 触发器</h3><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><h4 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十六章-管理事务处理"><a href="#第二十六章-管理事务处理" class="headerlink" title="第二十六章 管理事务处理"></a>第二十六章 管理事务处理</h3><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><h4 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h4><h4 id="-8"><a href="#-8" class="headerlink" title=""></a></h4><h3 id="第二十七章-全球化和本地化"><a href="#第二十七章-全球化和本地化" class="headerlink" title="第二十七章 全球化和本地化"></a>第二十七章 全球化和本地化</h3><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><h4 id="校对顺序"><a href="#校对顺序" class="headerlink" title="校对顺序"></a>校对顺序</h4><h4 id="使用字符集和校对顺序"><a href="#使用字符集和校对顺序" class="headerlink" title="使用字符集和校对顺序"></a>使用字符集和校对顺序</h4><h4 id="小结-18"><a href="#小结-18" class="headerlink" title="小结"></a>小结</h4><h4 id="-9"><a href="#-9" class="headerlink" title=""></a></h4><h3 id="第二十八章-安全管理"><a href="#第二十八章-安全管理" class="headerlink" title="第二十八章 安全管理"></a>第二十八章 安全管理</h3><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><h4 id="-10"><a href="#-10" class="headerlink" title=""></a></h4><h4 id="小结-19"><a href="#小结-19" class="headerlink" title="小结"></a>小结</h4><h3 id="第二十九章-数据库维护"><a href="#第二十九章-数据库维护" class="headerlink" title="第二十九章 数据库维护"></a>第二十九章 数据库维护</h3><h4 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h4><h4 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h4><h4 id="诊断启动"><a href="#诊断启动" class="headerlink" title="诊断启动"></a>诊断启动</h4><h4 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h4><h3 id="第三十章-改善性能"><a href="#第三十章-改善性能" class="headerlink" title="第三十章 改善性能"></a>第三十章 改善性能</h3><h4 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h4><h4 id="小结-20"><a href="#小结-20" class="headerlink" title="小结"></a>小结</h4><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
  </entry>
  
  <entry>
    <title>second of my blog</title>
    <link href="http://example.com/2021/04/22/2021-04-22-second-of-my-blog/"/>
    <id>http://example.com/2021/04/22/2021-04-22-second-of-my-blog/</id>
    <published>2021-04-22T06:29:30.000Z</published>
    <updated>2021-04-30T01:32:51.619Z</updated>
    
    <content type="html"><![CDATA[<p>CWR：拥塞窗口减少标志（显示拥塞通知 加在tcp首部保留位）<br>ECE:ECN-Echo（显示拥塞通知 加在tcp首部保留位）</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>TCP:可靠传输通信<br>UDP：尽力而为传输协议，（细节控制交给应用层）<br>1<br>6.2端口号<br>识别同一台计算机中进行通信的不同应用程序（程序地址）<br>根据端口号识别应用<br>tcp/ip或UDP/IP通信中通常都用五个信息来识别一个通信：<br>源IP地址，源IP地址，协议号，源端口号，目的端口号<br>路由协议通过在路由器之间共享路由信息来支持可路由协议。路由信息在相邻路由器之间传递，确保所有路由器知道到其它路由器的路径。总之，路由协议创建了路由表，描述了网络拓扑结构；路由协议与路由器协同工作，执行路由选择和数据包转发功能。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>路由协议主要运行于路由器上，路由协议是用来确定到达路径的起到一个地图导航，负责找路的作用。它工作在网络层。它包括RIP，IGRP（Cisco私有协议），EIGRP（Cisco私有协议），OSPF，IS-IS，BGP。<br>路由协议作为TCP/IP协议族中重要成员之一，其选路过程实现的好坏会影响整个Internet网络的效率。按应用范围的不同，路由协议可分为两类：<br>1、在一个AS内的路由协议称为内部网关协议（interior gateway protocol）。<br>备注：Autonomous System，自治系统，指一个互连网络，就是把整个Internet划分为许多较小的网络单位，这些小的网络有权自主地决定在本系统中应采用何种路由协议。一般由一个ISP运营的网络如移动/联通的网络位于一个AS（自治系统）内，有统一的AS number（自治系统号）。<br>2、AS之间的路由协议称为外部网关协议（exterior gateway protocol）。这里网关是路由器的旧称。<br><strong>常见的路由协议*</strong><br>有RIP、IGRP（Cisco私有协议）、EIGRP（Cisco私有协议）、OSPF、IS-IS、[BGP](<a href="https://baike.baidu.com/item/BGP">https://baike.baidu.com/item/BGP</a><br><strong>OSPF****<br>OSPF协议是“开放式最短路径优先(Open Shortest Path First)”的缩写，属于链路状态路由协议。OSPF提出了“区域（area）”的概念，每个区域中所有路由器维护着一个相同的链路状态数据库 （LSDB）。OSPF利用所维护的链路状态数据 库，通过最短生成树算法（SPF算法）计算得到路由表。OSPF的收敛速度较快。由于其特有的开放性以及良好的扩展性，目前OSPF协议在各种网络中广泛部署。<br>BGP</strong>****<br>为了维护各个ISP的独立利益，标准化组织制定了ISP间的路由协议BGP。BGP是“边界网关协议（Border Gateway Protocol）”的缩写，处理各ISP之间的路由传递。但是BGP运行在相对核心的地位，需要用户对网络的结构有相当的了解，否则可能会造成较大损失</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
  <entry>
    <title>First of my blog</title>
    <link href="http://example.com/2021/04/07/First-of-my-blog/"/>
    <id>http://example.com/2021/04/07/First-of-my-blog/</id>
    <published>2021-04-07T06:29:30.000Z</published>
    <updated>2021-04-24T15:40:37.734Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="thinks" scheme="http://example.com/categories/thinks/"/>
    
    
    <category term="thinks" scheme="http://example.com/tags/thinks/"/>
    
  </entry>
  
</feed>
