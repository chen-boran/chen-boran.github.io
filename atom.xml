<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-21T08:24:22.962Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git常见操作总结</title>
    <link href="http://example.com/2022/03/21/Git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/21/Git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-21T07:09:36.000Z</published>
    <updated>2022-03-21T08:24:22.962Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220321162417377.png" alt="image-20220321162417377"></p><p>首先是简单的操作：</p><ul><li><p>git init - 初始化仓库。</p></li><li><p>git add . - 添加文件到暂存区。</p></li><li><p>git commit - 将暂存区内容添加到仓库中。</p></li><li><p>git clone -拷贝一份远程仓库，也就是下载一个项目。</p></li><li><p>git  rm   删除工作区文件。</p></li><li><p>git  commit    提交暂存区到本地仓库。</p></li><li><p>git diff     比较文件的不同，即暂存区和工作区的差异。</p></li><li><p>git status    查看仓库当前的状态，显示有变更的文件。</p></li><li><p>git  mv  移动或重命名工作区文件。</p></li><li><p>git reset – hard HEAD^   回退到当前版本之前提交的版本（一个^相当于往前一个版本）。</p></li><li><p>git reset –hard  （部分）版本号    回退到任意一个之前提交的版本</p></li><li><p>git checkout – &lt;文件路径&gt;  回退到上一个版本提交的状态（此时是没有提交的状态，相当于Ctrl + z）</p></li><li><p>git  reset HEAD  &lt;文件路径文件名&gt;  将文件撤销追踪 ，撤出暂存区。</p></li><li><p>git log -查看提交本地仓库的记录日志</p></li><li><p>git tag -创建标签 格式：git tag &lt;标签名&gt;</p><p>标签默认加到最新的一次提交上。</p><p>git tag &lt;标签名&gt;  &lt;某一次commit的ID&gt;  ：给某一次的commit添加标签</p><p>git tag -d &lt;标签名&gt; : 标签名</p></li></ul><p>远程操作：</p><ul><li><p>git remote ：远程仓库操作</p></li><li><p>git fetch  ：从远程获取代码库</p></li><li><p>git push ：本地仓库文件推送到远程仓库</p><p>例如：git push origin master</p></li><li><p>git pull：拉取远程仓库到本地。</p></li></ul><p>分支</p><ul><li><p>git branch &lt;分支名&gt; -创建分支</p><p>git branch -查看所有分支</p><p>git checkout &lt;分支名字&gt; -切换分支</p><p>git branch -d &lt;分支名称&gt;   -删除分支，注意的是不能删除当前分支。并且分支有commit操作的时候也不能删除（必须经过合并）</p><p>git branch -D &lt;分支名称&gt;  强制删除某一分支</p><p>git checkout -b &lt;分支名称&gt;  -直接创建一个新的分支并且跳转。</p></li><li><p>git merge &lt;合并的分支名&gt; </p></li></ul><p>合并冲突：</p><ul><li>git merge -abort  ：忽略其他分支，保留现在分支代码（解决合并冲突）</li></ul><p>创建 远程仓库</p><p><a href="https://www.runoob.com/git/git-remote-repo.html">GIT教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们先来理解下 Git 工作区、暂存区和版本库概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作区：&lt;/strong&gt;就是你在电脑里能看到的目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂存区：&lt;/strong&gt;英文叫 stage 或 index。一般存放在 &lt;strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/21/vim/"/>
    <id>http://example.com/2022/03/21/vim/</id>
    <published>2022-03-21T06:07:52.732Z</published>
    <updated>2022-03-21T06:07:53.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>正常模式下：</p><p>（）：移动到上一句下一句</p><p>{}：移动到上一段下一段</p><p>H/J/K/L：左上下右移动光标</p><p>gg：移动到开头行第一个字符</p><p>G：移动到文本结尾行第一个字符</p><p>命令模式下：</p><p>:0   :跳转到行首</p><p>:$   :跳转到行尾</p><p>如果444你只关心当前屏幕的话，可以快速移动光标到屏幕的顶部、中间和底部：用 H（High）、</p><p>M（Middle）和 L（Low）就可以做到。</p><h3 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h3><p>熟练掌握这些按键 </p><p>正常模式下</p><p><strong>d 加动作来进行删除</strong>（dd 删除整行）；D 则相当于 d$，删除到行尾。 </p><p><strong>c 加动作来进行修改</strong>（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模</p><p>式。</p><p><strong>s</strong>     相当于 cl，删除一个字符然后进入插入模式；</p><p><strong>S</strong>     相当于 cc，替换整行的内容。</p><p>i     在<strong>当前字符前面</strong>进入插入模式；</p><p>I     则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。</p><p>a     在<strong>当前字符后面</strong>进入插入模式；</p><p>A     相当于 $a，把光标移到行尾然后进入插入模式。</p><p>o     在当前行下方插入一个新行，然后在这行进入插入模式；</p><p>O     在当前行上方插入一个新行，然后在这行进入插入模式。</p><p>r     替换光标下的字符；</p><p>R     则进入替换模式，每次按键（直到 <Esc>）替换一个字符。</p><p>u     撤销最近的一个修改动作；</p><p>U     撤销当前行上的所有修改。</p><p><strong>文本对象选择</strong></p><p> 还有几个动作只能在 c、d、v 这样命令之后用，我们也需要学习一下。</p><p>这些选择动作的基本附加键是 a 和 i。其中，a 可以简单理解为英文单词 a，表示选定后</p><p>续动作要求的完整内容，而 i 可理解为英文单词 inner，代表后续动作要求的内容的“内</p><p>部”。 我们来看一下具体的例子。</p><p>假设有下面的文本内容：</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>;     重复最近的字符查找（f、t 等）操作</p><p>,     重复最近的字符查找操作，反方向</p><p>n     重复最近的字符串查找操作（/ 和 ?） </p><p>N     重复最近的字符串查找操作（/ 和 ?），反方向</p><p>.     重复执行最近的修改操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h1&gt;&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis-集群</title>
    <link href="http://example.com/2022/03/17/Redis-%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2022/03/17/Redis-%E9%9B%86%E7%BE%A4/</id>
    <published>2022-03-17T07:33:57.000Z</published>
    <updated>2022-03-18T06:18:22.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Redis集群是Redis提供的分布式数据库方案， 通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><p>下面重点介绍：集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息等各个方面</p><h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><p>一个Redis集群通常由多个节点（node）组成。</p><p>刚开始时节点相互独立，组建集群就要将节点连接起来。构成多节点的集群。</p><p>连接节点的命令：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318114812146.png" alt="image-20220318114812146"></p><p>通过向节点发送命令，令其与指定的ip和端口的节点握手。从而将ip和port指向的节点加入当前所在集群。</p><p>下面详细介绍启动节点的方法、与集群有关的数据结构，以及CLUSTER MEET命令的实现原理</p><h3 id="1、启动节点"><a href="#1、启动节点" class="headerlink" title="1、启动节点"></a>1、启动节点</h3><p>一个结点就是一个Redis服务器，启动时根据cluster-enabled配置选项确定是否开启集群功能。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318115229354.png" alt="image-20220318115229354"></p><p>节点会继续使用单机模式使用的所有组件</p><p>包括：</p><ul><li>使用文件事件处理器来处理命令请求和返回命令回复。</li><li>使用时间事件处理器来执行serverCron函数</li><li>继续使用数据库来保存键值对数据</li><li>继续使用数据库来保存键值对数据</li><li>继续使用发布与订阅模块来执行PUBLISH、SUBSCRIBE等命令</li><li>继续使用复制模块来进行节点的复制工作</li><li>继续使用Lua脚本环境来执行客户端输入的Lua脚本。</li><li>继续使用redisServer结构来保存服务器的状态，使用redisClient结构来保存客户端的状态</li></ul><h3 id="2、集群数据结构"><a href="#2、集群数据结构" class="headerlink" title="2、集群数据结构"></a>2、集群数据结构</h3><p>上面介绍集群使用的常规单机组建，下面介绍集群模式下特有的数据结构。</p><p>集群模式下才会用到的数据，节点将它们保存到了cluster.h/clusterNode结构、cluster.h/clusterLink结构，以及cluster.h/clusterState结构里面 </p><p><strong>clusterNode结构</strong></p><p>用来保存节点的状态（每个节点都有），</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318115843866.png" alt="image-20220318115843866" style="zoom:67%;" /><p>其中的link属性是一个<strong>clusterLink结构</strong>，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：</p><p>注：redisClient结构和clusterLink结构的有什么异同呢？</p><p>同：都有自己的套接字描述符和输入、输出缓冲区</p><p>异：redisClient结构中的套接字和缓冲区是用于连接客户端的；</p><p>​        clusterLink结构中的套接字和缓冲区则是用于连接节点的。</p><p><strong>clusterState结构</strong></p><p>每个节点都保存着一个，这个结构记录了在当前节点的视角下，集群目前所处的状态</p><h3 id="3、CLUSTER-MEET命令的实现"><a href="#3、CLUSTER-MEET命令的实现" class="headerlink" title="3、CLUSTER MEET命令的实现"></a>3、CLUSTER MEET命令的实现</h3><p>假设向节点 A 发送命令，让节点 B加入集群。</p><p>那么要经过以下流程：</p><ul><li> 节点A会为节点B创建一个clusterNode结构，将该结构添加到自己的clusterState.nodes字典里面。</li><li>节点A将根据给定的IP地址和端口号，向节点B发送一条MEET消息（message）。</li><li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点B将向节点A返回一条PONG消息。</li><li>节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li><li>节点A将向节点B返回一条PING消息。</li><li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li></ul><p>类似三次握手协议，可以对比着进行记忆。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318120552027.png" alt="image-20220318120552027"></p><h2 id="二、槽指派"><a href="#二、槽指派" class="headerlink" title="二、槽指派"></a>二、槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对</p><p>具体形式：</p><ul><li>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽。</li><li>每个键都属于这16384个槽的其中一个。</li><li>每个节点可以处理0个或最多16384个槽</li></ul><p>集群中16384个槽只要有一个没有得到处理，那么集群就处于下线状态。（fail）。</p><p><strong>命令</strong></p><p>槽指派通过向节点发送CLUSTER ADDSLOTS命令，一个节点可以指多个槽。</p><p>举例：<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121224118.png" alt="image-20220318121224118" style="zoom:80%;" /></p><p>全部的槽指派成功之后，集群进入上线状态。</p><h3 id="1、记录节点的槽指派信息"><a href="#1、记录节点的槽指派信息" class="headerlink" title="1、记录节点的槽指派信息"></a>1、记录节点的槽指派信息</h3><p>clusterNode结构的<strong>slots属性</strong>和<strong>numslot属性</strong>记录了节点负责处理哪些槽。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121423532.png" alt="image-20220318121423532"></p><p>slots属性</p><p>Slot是一个数组</p><p>Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号</p><p>用数组元素的值是否为1确定是否被分配处理（1：表示处理）</p><p>示例如下：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121607634.png" alt="image-20220318121607634"></p><p><strong>numslots属性</strong></p><p>记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制位的数量。</p><h3 id="2、传播节点的槽指派信息"><a href="#2、传播节点的槽指派信息" class="headerlink" title="2、传播节点的槽指派信息"></a>2、传播节点的槽指派信息</h3><p>一个节点会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。通过接受其他节点发送的节点slot数组，更新自身的clusterState.nodes字典中的clusterNode结构。</p><p>每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面。</p><h4 id="3、记录集群所有槽的指派信息"><a href="#3、记录集群所有槽的指派信息" class="headerlink" title="3、记录集群所有槽的指派信息"></a>3、记录集群所有槽的指派信息</h4><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318131756379.png" alt="image-20220318131756379"></p><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：</p><ul><li>如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。</li><li>如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。</li></ul><p>通过将所有槽的指派信息保存在clusterState.slots数组里面，程序要检查槽i是否已经被指派， 只需要访问clusterState.slots[i]的值即可，这个操作的复杂度仅为O（1）。</p><p>需要说明的是：虽然clusterState.slots数组记录了集群中所有槽的指派信息，但使用clusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的。</p><h4 id="4、CLUSTER-ADDSLOTS命令的实现"><a href="#4、CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="4、CLUSTER ADDSLOTS命令的实现"></a>4、CLUSTER ADDSLOTS命令的实现</h4><p>CLUSTER ADDSLOTS命令有一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318132213728.png" alt="image-20220318132213728"></p><p>用一段伪代码定义命令的实现：</p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318132247998.png" alt="image-20220318132247998" style="zoom:67%;" /></p><h2 id="三、在集群中执行命令"><a href="#三、在集群中执行命令" class="headerlink" title="三、在集群中执行命令"></a>三、在集群中执行命令</h2><p>集群处于上线状态，那么客户端就可以向集群中的节点发送数据命令了。</p><p>执行流程图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133044005.png" alt="image-20220318133044005" style="zoom:67%;" /></p><p>下面介绍计算所属槽的方法</p><h3 id="1、计算键属于哪个槽"><a href="#1、计算键属于哪个槽" class="headerlink" title="1、计算键属于哪个槽"></a>1、计算键属于哪个槽</h3><p>计算算法：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133200870.png" alt="image-20220318133200870"></p><p>CRC16（key）语句用于计算键key的CRC-16校验和。</p><p>使用CLUSTER KEYSLOT＜key＞命令可以查看一个给定键属于哪个槽</p><h3 id="2、判断槽是否由当前节点负责处理"><a href="#2、判断槽是否由当前节点负责处理" class="headerlink" title="2、判断槽是否由当前节点负责处理"></a>2、判断槽是否由当前节点负责处理</h3><p>上面计算出键所属的槽之后，节点就会检查自己的clusterState.slots数组中的项i，进行判断。</p><ul><li>如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令。</li><li>如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回<strong>MOVED错误</strong>，指引客户端转向至正在处理槽i的节点。</li></ul><h3 id="3、MOVED错误"><a href="#3、MOVED错误" class="headerlink" title="3、MOVED错误"></a>3、MOVED错误</h3><p>当节点发现键所在的槽并非由自己负责处理时，向客户端发送的错误。</p><p>格式：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133644636.png" alt="image-20220318133644636" style="zoom:67%;" /></p><p>客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点。</p><p>并且向其重新发送之前想要执行的命令。</p><h3 id="4、节点数据库的实现"><a href="#4、节点数据库的实现" class="headerlink" title="4、节点数据库的实现"></a>4、节点数据库的实现</h3><p>集群节点保存键值对以及键值对过期时间的方式和之前介绍的单机Redis的方式完全相同。</p><p>节点和单机服务器在数据库方面的一个区别是，<strong>节点只能使用0号数据库</strong>，而单机Redis服务器则没有这一限制。</p><p>另外，除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133958399.png" alt="image-20220318133958399"></p><h2 id="四、重新分片"><a href="#四、重新分片" class="headerlink" title="四、重新分片"></a>四、重新分片</h2><p>将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片可以线上进行 ，集群不需要下线，可以继续处理命令请求。</p><h3 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h3><p>重新分片由集群管理软件redis-trib负责执行，通过向<strong>源节点</strong>和<strong>目标节点</strong>发送命令来进行重新分片操作。</p><p>首先是操作单个槽：</p><p>步骤如下：</p><ul><li>目标节点发送CLUSTER SETSLOT＜slot＞IMPORTING＜source_id＞命令，令其准备好接收slot</li></ul><p>键值对。</p><ul><li><p>对源节点发送CLUSTER SETSLOT＜slot＞MIGRATING＜target_id＞命令，令其准备好slot槽的键值对迁移。</p></li><li><p>向源节点发送CLUSTER GETKEYSINSLOT＜slot＞＜count＞命令，获得最多count个属于槽slot的键值对的键名（key name）。</p></li><li><p>对于获取的每一个键名，redis-trib都向源节点发送一个MIGRATE＜target_ip＞＜target_port＞＜key_name＞0＜timeout＞命令， 原子地从源节点迁移至目标节点。</p></li><li><p>重复执行获取键名和迁移的过程</p><p>如图所示：（迁移键的过程）</p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318134854939.png" alt="image-20220318134854939"></p></li><li><p>redis-trib向集群中的任意一个节点发送CLUSTERSETSLOT＜slot＞NODE＜target_id＞命令，通知槽slot已经指派给目标节点。</p></li></ul><p>对于多个槽的重新分配。需要对每个槽分别执行上述步骤。</p><h2 id="五、ASK错误"><a href="#五、ASK错误" class="headerlink" title="五、ASK错误"></a>五、ASK错误</h2><h3 id="1、ASK错误"><a href="#1、ASK错误" class="headerlink" title="1、ASK错误"></a>1、ASK错误</h3><p>重新分片期间，可能会发生这样的错误：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。</p><p>有趣的情况发生了:客户端向源节点请求命令含有的数据库建恰好属于被迁移的槽的时候。</p><ul><li>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</li><li> 如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，则返回ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</li></ul><p><strong>被隐藏的ASK错误</strong></p><p>和接到MOVED错误时的情况类似，集群模式的redis-cli在接到ASK错误时也不会打印错误，对用户来说是隐藏的。</p><p>接到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送原本想要执行的命令</p><h3 id="2、ASKING命令"><a href="#2、ASKING命令" class="headerlink" title="2、ASKING命令"></a>2、ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识</p><p>如果节点的clusterState.importing_slots_from[i]显示节点正在导入槽i，并且发送命令的客户端带有REDIS_ASKING标识，那么节点将破例执行这个关于槽i的命令一次。</p><p>如图所示：    </p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318135750323.png" alt="image-20220318135750323" style="zoom:67%;" /></p><h3 id="3、ASK错误和MOVED错误的区别"><a href="#3、ASK错误和MOVED错误的区别" class="headerlink" title="3、ASK错误和MOVED错误的区别"></a>3、ASK错误和MOVED错误的区别</h3><p>同：两者都会导致客户端转向。</p><p>异：MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，<strong>客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点</strong>。</p><p>​        与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施，<strong>这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响</strong>。</p><h2 id="六、复制与故障转移"><a href="#六、复制与故障转移" class="headerlink" title="六、复制与故障转移"></a>六、复制与故障转移</h2><p>Redis集群中的节点分为主节点（master）和从节点</p><p>主节点：用于处理槽</p><p>从节点：复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p><p>下面将介绍节点的复制方法，检测节点是否下线的方法，以及对下线主节点进行故障转移的方法。</p><h3 id="1、设置从节点"><a href="#1、设置从节点" class="headerlink" title="1、设置从节点"></a>1、设置从节点</h3><p>使用</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318140329801.png" alt="image-20220318140329801" style="zoom:67%;" /></p><p>命令</p><p>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p><p>从节点复制主节点，</p><p>:one:首先要查找自己的clusterState.nodes字典。找到node_id所对应节点的clusterNode结构，将自己的clusterState.myself.slaveof指针指向这个结构。</p><p>:two:修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识（自己已经变成了从节点）</p><p>:three: 节点调用复制代码，根据指向的那个clusterNode结构（主节点），进行赋值</p><p>从上面来看：从节点复制主节点相当于向从节点发送命令SLAVEOF。</p><h3 id="2、故障检测"><a href="#2、故障检测" class="headerlink" title="2、故障检测"></a>2、故障检测</h3><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><p>如果接收节点没能在规定时间内返回PONG消息，那么发送节点认定该节点<strong>疑似下线</strong>。</p><p>需要注意的是：集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息</p><p>（包括：某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL））</p><p>举个例子：</p><p>​    当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的</p><p>clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告</p><p>（failure report）添加到clusterNode结构的fail_reports链表里面：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318141033674.png" alt="image-20220318141033674"></p><p>​        那么如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL）。</p><p>​    之后主节点通过广播的形式，通知集群中的所有节点，该节点下线的消息。</p><h3 id="3、-故障转移"><a href="#3、-故障转移" class="headerlink" title="3、 故障转移"></a>3、 故障转移</h3><p>发生条件：一个<strong>从节点</strong>发现自己正在复制的<strong>主节点</strong>进入了已下线状态时，从节点将开始对下线主节点进行故障转移</p><p>步骤如下：</p><p>​    1）复制下线主节点的所有从节点里面，会有一个从节点被选中。</p><p>​    2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p><p>​    3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</p><p>​    4）新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</p><p>​    5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p><h3 id="4、新的主节点的选取"><a href="#4、新的主节点的选取" class="headerlink" title="4、新的主节点的选取"></a>4、新的主节点的选取</h3><p>选举方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）集群的配置纪元是一个自增计数器，它的初始值为0。</span><br><span class="line">2）当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</span><br><span class="line">3）对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</span><br><span class="line">4）当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</span><br><span class="line">5）如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</span><br><span class="line">6）每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</span><br><span class="line">7）如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</span><br><span class="line">8）因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</span><br><span class="line">9）如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</span><br></pre></td></tr></table></figure><p>选举新主节点的方法和 选举领头Sentinel的方法非常相似， 都是基于Raft算法的领头选举（leader election）方法来实现的。</p><h2 id="七、消息"><a href="#七、消息" class="headerlink" title="七、消息"></a>七、消息</h2><p>集群中的各个节点通过发送和接收消息（message）来进行通信。</p><p>称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）</p><p>节点之间发送的消息种类：</p><ul><li>MEET消息：当发送者接到客户端发送的CLUSTERMEET命令时，发送者会向接收者发送MEET消息</li><li>PING消息：检测被选中的节点是否在线</li><li>PONG消息：回复PING</li><li>FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li><li>PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h1&gt;&lt;p&gt;Redis集群是Redis提供的分布式数据库方案， 通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。&lt;/p&gt;
&lt;p&gt;下</summary>
      
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-慢查询日志</title>
    <link href="http://example.com/2022/03/17/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2022/03/17/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-17T07:16:19.000Z</published>
    <updated>2022-03-17T07:29:20.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，通过这个功能产生的日志来监视和优化查询速度。</p><h3 id="一、配置选项"><a href="#一、配置选项" class="headerlink" title="一、配置选项"></a>一、配置选项</h3><p>有两个和慢查询日志相关的选项：</p><ul><li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。</li><li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</li></ul><p>服务器使用先进先出的方式保存多条慢查询日志，当 存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。</p><h3 id="二、慢查询记录的保存"><a href="#二、慢查询记录的保存" class="headerlink" title="二、慢查询记录的保存"></a>二、慢查询记录的保存</h3><p>服务器状态中包含了几个和慢查询日志功能有关的属性</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203171521925.png" alt="image-20220317152127766"></p><p>说明：</p><ul><li><p>slowlog_entry_id属性的初始值为0，随着新的日志的创建不断更新。</p></li><li><p>slowlog<strong>链表</strong>保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203171523416.png" alt="image-20220317152318278"></p></li></ul><h3 id="三、浏览和删除"><a href="#三、浏览和删除" class="headerlink" title="三、浏览和删除"></a>三、浏览和删除</h3><p>查看日志的SLOWLOG GET</p><p>查看日志数量的SLOWLOG LEN</p><p>清除所有慢查询日志的SLOWLOG RESET</p><p>打印和删除慢查询日志可以通过遍历slowlog链表实现。</p><h3 id="四、添加新日志"><a href="#四、添加新日志" class="headerlink" title="四、添加新日志"></a>四、添加新日志</h3><p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长。</p><p>这个时长传递给<strong>slowlogPushEntryIfNeeded函数</strong>，最终决定是否创建慢查询日志。</p><p>并且新创建的日志放到slowlog的链表头，并且将slowlog_entry_id的值增加1。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-15T07:19:11.000Z</published>
    <updated>2022-03-15T07:19:11.716Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统-内存管理</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-14T12:19:57.000Z</published>
    <updated>2022-03-15T10:45:27.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>需要了解的知识：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142030815.png" alt="image-20220314203051697"></p><p>1、什么是内存？作用？</p><p>内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾。</p><p>2、内存装入的三种方式</p><ul><li><p>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。</p><p>绝对装入只适用于单道程序环境。</p></li><li><p>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地 址、数据存放的地址都是相对于起始地址而言的逻辑地址。</p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求 的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申 请内存空间。</p></li><li><p>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装 入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。</p></li></ul><p>3、程序的运行</p><ul><li><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言） </p></li><li><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块 </p></li><li><p>装入（装载）：由装入程序将装入模块装入内存运行</p></li></ul><h3 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h3><ul><li>内存空间分配和回收</li><li>内存空间扩容</li><li>地址转换</li><li>内存保护</li></ul><p>1、内存空间分配和回收：操作系统负责<strong>内存空间的分配与回收</strong></p><p>2、内存空间扩容：操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></p><p>3、地址转换：操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换（三种装入方式）</p><p>4、内存保护：操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</p><p>（CPU检查是否越界）</p><h3 id="三、覆盖和交换"><a href="#三、覆盖和交换" class="headerlink" title="三、覆盖和交换"></a>三、覆盖和交换</h3><p>覆盖和交换是内存空间扩容的方法，此外还有虚拟内存技术。</p><p>1、覆盖技术</p><p>覆盖技术的思想：将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。 需要常驻内存的段放在“固定区”中，调入后就不再 调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存， 用不到时调出内存。</p><p>如图所示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142107600.png" alt="image-20220314210738510"></p><p>-缺点：对用户不透明，现在已经成为历史。</p><p>2、交换技术</p><p>​    设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中 某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>​    回忆之前的知识：中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>​    暂时换出外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p>​    总结之前的状态模型：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142109908.png" alt="image-20220314210948530"></p><p>注意：PCB 会常驻内存，不会被换出外存</p><h3 id="四、连续内存分配管理"><a href="#四、连续内存分配管理" class="headerlink" title="四、连续内存分配管理"></a>四、连续内存分配管理</h3><p>连续内存分配管理是内存空间分配和回收的方式之一</p><p>如图所示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142111790.png" alt="image-20220314211149486"></p><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><p><strong>分类</strong>：</p><p>可以分成单一连续分配、固定分区分配、动态分区分配。</p><p>1、单一连续分配</p><p>​    内存被分为系统区和用户区。 </p><p>​        系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；</p><p>​        用户区用于存放用户进程相关数据。 </p><p>​    内存中只能有一道用户程序，用户程序独占整个用户区 空间。 </p><p>​    优点：实现简单；无外部碎片；可以采用覆盖技术扩充 内存；不一定需要采取内存保护 </p><p>​    缺点：只能用于单用户、单任务的操作系统中；有内部 碎片；存储器利用率极低。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142119367.png" alt="image-20220314211952123"></p><p>2、固定分区分配</p><p>​        整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。</p><p>​    分成</p><ul><li><p>分区大小相同：</p><p>分区大小相等：缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合</p></li><li><p>分区大小不同：</p><p>增加了灵活性，可以满足不同大小的进 程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142118494.png" alt="image-20220314211830222"></p></li></ul><p><strong>3、动态分区分配</strong></p><p>​    又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。</p><p>​    动态分区分配没有内部碎片，但是有外部碎片。 </p><p>注：</p><ul><li><p>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 </p></li><li><p>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。（通过紧凑技术来解决）</p></li></ul><p>4、总结</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142115124.png" alt="image-20220314211520809"></p><h3 id="五、动态分区分配算法"><a href="#五、动态分区分配算法" class="headerlink" title="五、动态分区分配算法"></a>五、动态分区分配算法</h3><p>在上面学习的动态分区分配时，多个分区都空闲的时候，那么要选择哪个呢？</p><p>下面是解决这个问题的四种算法。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142121060.png" alt="image-20220314212136836"></p><p>1、首次适应算法</p><p>​        算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 </p><p>​        实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142123637.png" alt="image-20220314212314372"></p><p>2、最坏适应算法</p><p>​        算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区 域。 优先使用更小的空闲区。 </p><pre><code>     实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 </code></pre><p>表），找到大小能满足要求的第一个空闲分区。 </p><p>​        <strong>缺点： 这种方法会产生很多的外部碎片。</strong></p><p>3、最佳适应算法</p><p>​        算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，</p><pre><code>     实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 </code></pre><p>表），找到大小能满足要求的第一个空闲分区。</p><p><strong>缺点： 这种方式会导致较大的连续空闲区被</strong> <strong>迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong> </p><p>4、临近适应算法</p><p>​        算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲 分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 </p><pre><code>     实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查 找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</code></pre><p>5、总结</p><p>​        综合来看，四种算法中，首次适应算法的效果反而更好</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142122366.png" alt="image-20220314212231038"></p><h3 id="六、基本分页存储管理的基-本概念"><a href="#六、基本分页存储管理的基-本概念" class="headerlink" title="六、基本分页存储管理的基 本概念"></a>六、基本分页存储管理的基 本概念</h3><p>之前上面介绍到的都是连续分配的形式。下面介绍非连续分配。</p><p>连续分配：为用户进程分配的必须是一个连续的内存空间。 </p><p>非连续分配：为用户进程分配的可以是一些分散的内存空间。</p><p>​        关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142127675.png" alt="image-20220314212735413"></p><p>1、什么是分页存储？</p><ul><li><p>将内存空间分为一个个大小相等的分区，，每个分区就是一个“页框”</p><p>（页框号=页帧号=内存块号=物理块号=物理页号）</p></li><li><p>将进程的逻辑地址空间也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“页”或“页面” 。</p></li></ul><p>下面是几点说明：</p><ul><li><p>操作系统以页框为单位为各个进程分配内存空间。</p></li><li><p>进程的页面与内存的页框有一一对应的关系。</p></li><li><p>页面可以不是连续存放的，也可以不放到相邻的页框中。</p></li></ul><p>2、页表</p><p>​    下面是一个重要的概念，”页表“</p><p>​    页表通常存储在进程控制块中PCB 。</p><p>图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142147228.png" alt="image-20220314214751984"></p><p>说明：</p><p>   1.一个进程对应一张页表</p><ol start="2"><li><p>进程的每个页面对应一个页表项</p></li><li><p>每个页表项由“页号”和“块号”组成</p></li><li><p>页表记录进程页面和实际存放的内存块之间的映射关系</p></li><li><p>每个页表项的长度是相同的</p></li></ol><p>问题：</p><p> 问题一：每个页表多少字节？</p><p>​        计算机中内存块的数量——&gt;页表项中块号至少占多少字节</p><p>总结：        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142150512.png" alt="image-20220314215008122"></p><h3 id="七、虚拟内存"><a href="#七、虚拟内存" class="headerlink" title="七、虚拟内存"></a>七、虚拟内存</h3><p>之前了解了传统内存扩容的方式，加上覆盖和交换。下面学习虚拟内存技术。</p><p>基本概念：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142129890.png" alt="image-20220314212947614"></p><p>1、传统存储管理方式</p><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：</p><p>​    ①作业很大时，不能全 部装入内存，导致大作业无法运行；</p><p>​    ②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 </p><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。导致了内存中会驻留大量的、暂时用不到的 数据，浪费了内存资源。</p><p>2、局部性原理</p><p>时间局部性：如果执行了程序中的某条指令，那么不久后<strong>这条指令</strong>很有可能再次执行；（因为程序中存在大量的循环） </p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其<strong>附近的存储单元</strong>也很有可能被访问。 （因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><p>3、虚拟内存</p><p><strong>定义</strong>：（用一段文字说明）</p><p><strong>基于局部性原理</strong>，在程序装入时，可以将程序中很快 会用到的部分装入内存，暂时用不到的部分留在外存， 就可以让程序开始执行。 </p><p>在程序执行过程中，当所访问的信息不在内存时，由 操作系统负责将所需信息从外存调入内存，然后继续执行程序。 </p><p>若内存空间不够，由操作系统负责将内存中暂时用不 到的信息换出到外存。 在操作系统的管理下，在用户看来<strong>似乎有一个比实际 内存大得多的内存</strong>，这就是<strong>虚拟内存</strong></p><p>注：</p><ul><li><p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 </p></li><li><p>虚拟内存的实际容量 =    min（内存和外存容量之和，CPU寻址范围）</p></li></ul><p><strong>特征：</strong></p><ul><li><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 </p></li><li><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换 入、换出。 </p></li><li><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p></li></ul><p><strong>实现</strong></p><p>由于一个作业会分多次调入调出内存，因此连续内存分配不方便，因此<strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上</strong>。</p><p>实现如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142137261.png" alt="image-20220314213743950"></p><p>操作系统需要提供页面置换和请求调页的功能。</p><h3 id="八、基本地址变换机构"><a href="#八、基本地址变换机构" class="headerlink" title="八、基本地址变换机构"></a>八、基本地址变换机构</h3><p>基本地址编制机构可以借助进程把逻辑地址转换成物理地址。</p><p>通常会在系统设置页表寄存器(PTR),用来存放页表和内存的启示地址和页表长度。</p><p>程序未执行时，页表和起始地址存放在PCB中，进程被调用的时候后，操作系统会把他们调到页表寄存器中。</p><p>流程如下：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151057772.png" alt="image-20220315105732653"></p><p>总结：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151058482.png" alt="image-20220315105817409"></p><h3 id="九、具有快表的地址变换机构"><a href="#九、具有快表的地址变换机构" class="headerlink" title="九、具有快表的地址变换机构"></a>九、具有快表的地址变换机构</h3><p>是基本地址变换机构的改进版。</p><p>1、什么事快表？TLB</p><p>​    快表：（TLB）一种访问速度比内存刈很多的高速缓存（TLB不是内存！） 用来存放最近访问的页表项的副本，可以加速地址变换的速度。 </p><p>​    与此对应，内存中的页表常称为慢表。</p><p>2、引入快表的地址变换过程？</p><p>引入快表之后优先查询块表是否命中。加快速度。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151102229.png" alt="image-20220315110210155"></p><p>具体流程：</p><p>①算页号、页内偏移量 </p><p>②检查页号合法性 </p><p>③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤； </p><p>若未命中则进行④ </p><p>④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 </p><p>⑤根据内存块号与页内偏移量得到物理地址 </p><p>⑥访问目标内存单元 </p><h3 id="十、二级页表"><a href="#十、二级页表" class="headerlink" title="十、二级页表"></a>十、二级页表</h3><p>之前都是分配给进程单级页表。</p><p>1、那么单级页表存在什么问题呢？</p><p>单级页表要在所有的页表项都连续存放的基础上才能找到页表项。当页表很大时，需要占用很多个连续的页框。</p><p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面 就可以正常运行了。因此没有必要让整个页表都常驻内存。</p><p>2、二级页表</p><p>那么为了解决这两个问题，我们可以把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151109832.png" alt="image-20220315110906749"></p><p>可以分成以下几步：</p><p>①按照地址结构将逻辑地址拆分成三部分 </p><p>②从PCB 中读出页目录表始址，再根据一级页号查页目录 </p><p>表，找到下一级页表在内存中的存放位置 </p><p>③根据二级页号查二级页表，找到最终想访问的内存块号 </p><p>④结合页内偏移量得到物理地址</p><p>3、注意事项</p><p>两级页表的访存次数分析（假设没有快表机构） </p><p>第一次访存：访问内存中的页目录表 </p><p>第二次访存：访问内存中的二级页表 </p><p>第三次访存：访问目标内存单元</p><h3 id="十一、基本分段存储管理方式"><a href="#十一、基本分段存储管理方式" class="headerlink" title="十一、基本分段存储管理方式"></a>十一、基本分段存储管理方式</h3><h3 id="十二、请求分页管理方式"><a href="#十二、请求分页管理方式" class="headerlink" title="十二、请求分页管理方式"></a>十二、请求分页管理方式</h3><p>之前介绍的都是基本的分页存储管理。</p><p>下面介绍请求分页管理方式</p><p>两者存在一些差别：</p><ul><li><p>在程序执行过程中，当<strong>所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然 后继续执行程序。 </p></li><li><p>若内存空间不够，由操作系统负责将<strong>内存中暂时用不到的信息换出到外存</strong>。</p></li></ul><p>请求分页管理方式主要有以下几点注意事项：</p><ul><li>页表机制</li><li>缺页中断机构</li><li>地址变换机构（注意与基本分页存储管理的页表 机制、地址变换流程对比）</li></ul><p>1、页表机制</p><p>与基本分页管理相比，实现“请求调页”，操作系统需要 知道每个页面是<strong>否已经调入内存</strong>；如果还没调入，那么也需要知道该页面在<strong>外存中存放的位置</strong>。</p><p>​    当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到 底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页 面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面 <strong>是否被修改</strong>的信息。</p><p>因此两者的页表结构也所不同。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151118557.png" alt="image-20220315111813484"></p><p>2、缺页中断机构</p><p>​    在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然 后由操作系统的缺页中断处理程序处理中断。 </p><p>​    此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修 改页表中相应的页表项。</p><p>​    缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 </p><p>一条指令在执行期间，可能产生多次缺页中断。</p><p>3、地址变换机构</p><p>​    请求分页存储管理与基本分页存储管理的主要区别： </p><p>​    在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然 后继续执行程序。 </p><p>​    若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>注：新增步骤1：请求调页（查到页表项时进行判断） </p><p>​        新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行） </p><p>​        新增步骤3：需要修改请求页表中新增的表项</p><h3 id="十三、页面置换算法"><a href="#十三、页面置换算法" class="headerlink" title="十三、页面置换算法"></a>十三、页面置换算法</h3><p>​    之前说到操作系统要为请求页面分配管理的方式提供页面置换和请求调页的功能。</p><p>​    下面关注页面置换算法的实现。</p><p>好的页面置换算法应该追求更少的缺页率。</p><p>下面介绍五种页面置换算法。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151130032.png" alt="image-20220315113004952"></p><p>1、最佳置换算法</p><p>最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被 访问的页面，这样可以保证最低的缺页率。</p><p>根据算法思想我们可以知道最佳置换算法总是淘汰最先出现的那个页面。</p><p>这个算法有一定的局限性，操作系统无法提前预判页面访问序列的情况下，最佳置换算法无法实现。</p><p>2、先进先出置换算法</p><p>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面 </p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 </p><p>队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>缺点是虽然实现简单，但是可能会产生Belady异常，算法性能差</p><p>注：Belady 异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>3、最近最久未使用算法</p><p>​    最近最久未使用置换算法（LRU，least    recently    used）：每次淘汰的页面是最近最久未使用的页面 </p><p>​    实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</p><p>​    <strong>缺点</strong>：该算法的实现需要专门的硬 件支持，虽然算法性能好， 但是实现困难，开销大</p><p>4、时钟置换算法</p><p>​    时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，NotRecently Used）</p><p>​    实现有一些复杂</p><p>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫᧿ （第二轮扫描 中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描 ）</p><p>​        如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151138515.png" alt="image-20220315113846445"></p><p>5、改进型时钟置换算法</p><p>对于简单的时钟算法，对于是否页面被修改并不关心，只关注是否被访问。之后进行写入内存。可以设置一种算法，将没有修改的页面不写进内存。避免不必要的开销。</p><p>扫描的规则：</p><p>将所有可能被置换的页面排成一个循环队列 </p><p>第一轮：从当前位置开始扫᧿ 到第一个（0,    0）的帧用于替换。本轮扫᧿ </p><p>不修改任何标志位 </p><p>第二轮：若第一轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    1）的帧用于 </p><p>替换。本轮将所有扫᧿ 过的帧访问位设为0 </p><p>第三轮：若第二轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    0）的帧用于 </p><p>替换。本轮扫᧿ 不修改任何标志位 </p><p>第四轮：若第三轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    1）的帧用于 </p><p>替换。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151141679.png" alt="image-20220315114139618"></p><p>此经过第三轮、第四轮扫᧿ 一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多 会进行四轮扫描。</p><h3 id="十四、页面分配策略"><a href="#十四、页面分配策略" class="headerlink" title="十四、页面分配策略"></a>十四、页面分配策略</h3><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151125804.png" alt="image-20220315112557721"></p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-文件管理</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-14T04:47:48.000Z</published>
    <updated>2022-03-15T10:45:17.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>文件——就是一组有意义的信息/数据集合</p><p>文件管理：</p><p>重点关注和解决以下问题：</p><ul><li><p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p></li><li><p>文件内部的数据应该怎样组织起来？</p></li><li><p>文件之间又应该又应该怎么组织起来？</p></li><li><p>从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？</p></li><li><p>从上往下看，文件数据应该怎么存放在外存（磁盘）上？</p></li></ul><p>文件属性：</p><p>常见的文件属性包括：</p><p>​    文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p><p>​    标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p><p>​    类型：指明文件的类型</p><p>​    位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p><p>​    大小：指明文件大小</p><p>​    创建时间、上次修改时间</p><p>​    文件所有者信息</p><p>​    保护信息：对文件进行保护的访问控制信息</p><p>重点回顾：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141642420.png" alt="image-20220314164225069"></p><h3 id="二、文件逻辑结构"><a href="#二、文件逻辑结构" class="headerlink" title="二、文件逻辑结构"></a>二、文件逻辑结构</h3><p>概念：指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p><p><strong>文件操作的具体实现与文件的逻辑结构、物理结构都有关</strong></p><p>分类：</p><p>​    分类标准：是否有结构</p><p>​    无结构文件、有结构文件文件</p><p>一、无结构文件</p><p>​    无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件。</p><p>​    因此也不用探讨无结构文件的“逻辑结构”问题。</p><p>​    举例：比如 .txt 文件</p><p>二、有结构文件</p><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。</p><p>1、定长记录、可变长记录</p><p>有结构文件是由一条条记录组成的。通常记录可以分成：定长记录和可变长记录。</p><p>​    定长记录：每条记录的长度相同。</p><p>​    可变长记录：各条记录的长度不确定，不一定是相同的。</p><p>2、<strong>有结构文件的逻辑结构</strong></p><p>分类标准： 根据有结构文件中的各条记录在逻辑上如何组织</p><p>:one:顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p>​    顺序文件的分类如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141700629.png" alt="image-20220314170005560"></p><p>​    一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件</p><p>​    缺点：删除一个记录比较困难。</p><p>:two:索引文件：索引文件本身是定长记录的顺序文件。(解决可变长记录文件，顺序查找的问题)</p><p>​    索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合</p><p>如图：</p><pre><code> &lt;img src=&quot;https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141704354.png&quot; alt=&quot;image-20220314170423294&quot; style=&quot;zoom:80%;&quot; /&gt;</code></pre><p>优点：可以使用不同的数据项创建多个索引表。</p><p>​            检索速度很快。</p><p>:three:索引顺序文件</p><p>​    索引顺序文件是索引文件和顺序文件思想的结合。</p><p>​    索引顺序文件，会为文件建立一张索引表，但是：并不是每个记录对应一个索引表项，而是<strong>一组</strong>记录对应一个索引表项。</p><p>如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141706960.png" alt="image-20220314170641899"></p><p>也就是说把相同组的文件索引放到一个新的索引文件中，组成一个顺序文件，由原来的索引文件进行索引。</p><p>:four:多级索引顺序文件</p><p>为了进一步提高效率，可以为顺序文件建立多级索引表。在此不做过多赘述。</p><h3 id="三、文件目录"><a href="#三、文件目录" class="headerlink" title="三、文件目录"></a>三、文件目录</h3><p>一层一层的文件目录对用户有什么好处？</p><p>​    文件组织清晰，易于查找</p><p>​    轻松的实现按名存取的目的。</p><p>那么文件目录是如何实现的呢？</p><p>随着计算机的发展文件目录的结构也在发生着变化。</p><h4 id="一、文件控制块"><a href="#一、文件控制块" class="headerlink" title="一、文件控制块"></a>一、文件控制块</h4><p>1、首先了解相关概念：文件控制块</p><p>​    文件控制块是为了实现目录的关键数据结构。</p><p>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件</p><p>目录文件中的一条记录就是一个<strong>文件控制块（FCB）</strong></p><p>2、需要对目录 进行哪些<strong>操作</strong>？</p><ul><li><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p></li><li><p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p></li><li><p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p></li><li><p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p></li><li><p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文</p></li></ul><p>件重命名）</p><h4 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a><strong>二、目录结构</strong></h4><p>:one:<strong>单级目录结构</strong></p><p>​    整个系统中值建立一张目录表</p><p>​    不允许文件重名；应用于早期操作系统。</p><p>:two:<strong>两级目录结构</strong></p><p>​    到了早期多用户操作系统使用两级目录结构。</p><p>​    分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User FlieDirectory）。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录</p><p>的用户名是否匹配）</p><p>​    <strong>缺点</strong>：用户不能对文件进行分类，灵活性不足。</p><p>:three:<strong>多级目录结构</strong></p><p>了解几个概念：</p><p>​    绝对路径：从根路径出发的路径</p><p>​    当前目录：当前所在的那一级目录</p><p>​    相对路径：指的是相对于当前目录的路径。</p><p>树型目录结构</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141721733.png" alt="image-20220314172144652"></p><p>​    如果查找文件时，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径” 。 <strong>引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</strong></p><p>缺点：不利于实现 文件的共享</p><p>​    树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><p>:four:无环图目录结构</p><p>具体思路是：</p><p>​    可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。需要为每个共享结点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。只有共享计数器减为0时，才删除结点。</p><p>​    因为文件是共享的，因此在共享文件中，一个用户修改了文件数据，那么所有用户都能看到文件变化。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141722761.png" alt="image-20220314172221700"></p><h4 id="三、索引节点"><a href="#三、索引节点" class="headerlink" title="三、索引节点"></a>三、索引节点</h4><p>FCB的改进：目录的使用只有文件名匹配之后才会读取其他信息。考虑让目录表“瘦身”来提升效率。</p><p>​    因此把目录中除了文件名之外的文件描述信息都放到一个索引节点。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141730554.png" alt="image-20220314173018481"></p><p>当找到文件名对应的目录项时，索引节点才调入内存。</p><p>注：存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="四、文件的物理结构"><a href="#四、文件的物理结构" class="headerlink" title="四、文件的物理结构 %*%"></a>四、文件的物理结构 %*%</h3><p>文件数据应该怎样存放在外存中？</p><p>文件的物理结构分类</p><p> 分类标准：文件分配方式</p><ul><li>连续分配</li><li><h2 id="连接分配"><a href="#连接分配" class="headerlink" title="连接分配"></a>连接分配</h2></li><li>索引分配</li></ul><p>一、文件块、磁盘块</p><p>操作系统为文件分配存储空间是以快为基本单位的。</p><p>类似于内存中的存储，也是分成一个个快/磁盘块</p><p>二、连续分配</p><p>​    连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><p>1、逻辑地址到物理地址的映射？</p><p>（逻辑块号，块内地址）——&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p><p>​    物理块号 = 起始块号 + 逻辑块号</p><p>​    当然还要检查是否逻辑块号合法（逻辑块号 ≥ 长度 就不合法）</p><p>2、图示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141836258.png" alt="image-20220314183641193"></p><p>​        分别存放块的起始地址和长度。不被包括的就是空的块</p><p>3、优缺点？</p><p>​    优点：<strong>支持随机读取和顺序读取</strong></p><p>​                连续分配在顺序读/写的速度最快。</p><p>​    缺点：连续分配物理上是连续的，因此想要拓展更改不方便。</p><p>​                存储空间利用率低，产生外部碎片。</p><p>三、链接分配</p><p>​    链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p>:one:显示链接</p><p>图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141926941.png" alt="image-20220314192635871"></p><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）</p><p>​    需要注意的是：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻内存。</p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，<strong>支持顺序存储</strong>，并且<strong>支持随机访问</strong>。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间</li></ul><p>:two:隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录</p><p>包括文件第一块的指针和最后一块的指针。</p><p>图示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141839578.png" alt="image-20220314183941511"></p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点：<strong>只支持顺序访问，不支持随机访问</strong>，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><p>四、索引分配</p><p>文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文</p><p>件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间</p><p>的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p>若文件太大，单个磁盘块存储不下整张索引表，如何解决？</p><p>有三种方案：</p><ul><li><p>①<strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，这就导致磁盘I/O次数过多，查找效率低下。 </p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932482.png" alt="image-20220314193232419"></p></li><li><p>②<strong>多层索引</strong>：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作。</p><p>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932185.png" alt="image-20220314193219131"></p></li><li><p>③<strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。</p><p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932230.png" alt="image-20220314193200149"></p></li></ul><h3 id="五、文件存储空间管理"><a href="#五、文件存储空间管理" class="headerlink" title="五、文件存储空间管理"></a>五、文件存储空间管理</h3><p>一、文件空间的划分和初始化</p><p>文件卷</p><p>文件区：存放文件数据。</p><p>目录区：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区</p><p>二、文件存储空间管理方法</p><p>学习时注意从三个方面进行理解：</p><ul><li><p>用什么方式记录、组织空闲块？</p></li><li><p>如何分配磁盘块？</p></li><li><p>如何回收磁盘块？</p></li></ul><p>:one:空闲表法</p><p>概述：（适用于连续表法分配方式）</p><ul><li><p>磁盘块分配：与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间</p></li><li><p>磁盘块回收：与内存管理中的动态分区分配很类似，当回收某个</p><p>存储区时需要有四种情况</p><ul><li>①回收区的前后都没有相邻空闲区；</li><li>②回收区的前后都是空闲区；</li><li>③回收区前面是空闲区；</li><li>④回收区后面是空闲区。总之，<strong>回收时需要注意表项的合并问题。</strong></li></ul></li></ul><p>:two:空闲链表法</p><p>具体如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141949582.png" alt="image-20220314194930505"></p><ul><li><p>分配：若某文件申请 K 个盘块，则从链头开始依次摘</p><p>下 K 个盘块分配，并修改空闲链的链头指针。</p></li><li><p>回收：回收的盘块依次挂到链尾，并修改空闲链的链</p><p>尾指针。</p></li></ul><p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p><p>:three:位示图法</p><p>​    位示图：每个二进制位对应一个盘块。用0和1来表示盘快是否分配。</p><p>​    注意<strong>盘块号与（字号</strong><strong>,</strong> <strong>位号）相互转换的公式：</strong></p><p>​        (字号, 位号)=(i, j) 的二进制位对应的 盘块号 b = ni + j</p><ul><li><p>分配：若文件需要K个块，</p><ul><li>顺序扫描位示图，找到K个相邻或不相邻的“0”；</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件；</li><li>将相应位设置为“1”。</li></ul></li><li><p>回收：</p><ul><li>根据回收的盘块号计算出对应的字号、位号；</li><li>将相应二进制位设为“0”     </li></ul></li></ul><p>:four:成组链接法</p><p>​        空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。</p><p>因此诞生了成组链表法：</p><p>​    使用一个专用的磁盘作为<strong>超级块</strong>,指向下一级内存块，每一级内存块的大小都是有限制的。</p><p>超级块中包含下一组空闲盘的快数。</p><p>​    如图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141958464.png" alt="image-20220314195800380"></p><h3 id="六、文件的基本操作"><a href="#六、文件的基本操作" class="headerlink" title="六、文件的基本操作"></a>六、文件的基本操作</h3><p>​    操作系统向上提供的基本功能：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141935390.png" alt="image-20220314193503323"></p><p>一、创建文件</p><p>​    调用Create，需要几个参数：</p><ul><li><p> 所需的外存空间大小（如：一个盘块，即1KB）</p></li><li><p>文件存放路径（“D:/Demo”）</p></li><li><p>文件名 </p></li></ul><p>Create的流程：</p><ul><li><p>在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</p></li><li><p>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中创建该文件对应的目录项。<strong>目录项中包含了文件名、文件在外存中的存放位置等信息。</strong></p></li></ul><p>二、删除文件</p><p>​    调用Delete，需要提供参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>Delete的流程：</p><ul><li><p> 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p></li><li><p>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</p><p>（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p></li><li><p>从目录表中删除文件对应的目录项。</p></li></ul><p>三、打开文件</p><p>​    在对文件进行操作之前，要求用户先使用 open 系统调用“打开文件”，需要提供的几个主要参数：</p><ul><li><p>文件存放路径</p></li><li><p>文件名</p></li><li><p>要对文件的操作类型（如：r 只读；rw 读写等）</p></li></ul><p>open 系统调用：</p><ul><li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p></li><li><p>将目录项复制到内存中的<strong>“打开文件表</strong>”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p></li></ul><p>打开文件之后，创建了打开文件表，用户再操作该文件就不需要重新查目录了。加快文件访问速度。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141942606.png" alt="image-20220314194229529"></p><p>四、关闭文件</p><p>​    进程使用完文件后，要“关闭文件”</p><p>  Close 系统调用 ：</p><ul><li><p>将进程的打开文件表相应表项删除</p></li><li><p>回收分配给该文件的内存空间等资源</p></li><li><p>系统打开文件表的打开计数器count 减1，若 <strong>count = 0，则删除对应表项</strong>。</p></li></ul><p>五、读文件</p><p>​    根据读指针、读入数据量、内存位置将文件数据从外存读入内存。</p><p>六、写文件</p><p>​    根据写指针、写出数据量、内存位置将文件从文件数据从内存写出外存。</p><h3 id="七、文件共享"><a href="#七、文件共享" class="headerlink" title="七、文件共享"></a>七、文件共享</h3><p>文件共享意味着系统中只含有一份文件数据，由多个用户共享。注意和文件复制的区别。</p><p>文件共享：为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。</p><p>下面是共享文件的两种方式：</p><p>一、硬链接</p><p>基于索引节点。索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p><p>若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减 1。 </p><p>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p><p>当 count = 0 时系统负责删除文件。</p><p>​    图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142000927.png" alt="image-20220314200030859"></p><p>二、软连接（符号链接）</p><p>基于符号链接的共享文件，相当于windows的桌面快捷方式。通过路径引用，定位到文件 。</p><p>图示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142001670.png" alt="image-20220314200143592"></p><h3 id="八、文件保护"><a href="#八、文件保护" class="headerlink" title="八、文件保护"></a>八、文件保护</h3><p>文件保护，是为了保护文件数据的安全。有三种常见方式。</p><p>一、口令保护</p><p>​    为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。</p><ul><li><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p></li><li><p>缺点：正确的“口令”存放在系统内部，不够安全。</p></li></ul><p>二、加密保护</p><p>​    使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p><ul><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码/译码，或者说加密/解密要花费一定时间。</li></ul><p>三、访问控制</p><p>​    在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。</p><p>例图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142005887.png" alt="image-20220314200523812"></p><p>​    精简的访问列表：（避免用户过多带来的负荷。）</p><p>​    系统会按照一定的分类标准 分组。每个组中的成员的权限是相同的。</p><h3 id="九、文进系统结构层次"><a href="#九、文进系统结构层次" class="headerlink" title="九、文进系统结构层次"></a>九、文进系统结构层次</h3><p>​        层次图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142005582.png" alt="image-20220314200548502"></p><h3 id="十、磁盘"><a href="#十、磁盘" class="headerlink" title="十、磁盘"></a>十、磁盘</h3><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142006860.png" alt="image-20220314200640766"></p><h3 id="十一、磁盘调度算法"><a href="#十一、磁盘调度算法" class="headerlink" title="十一、磁盘调度算法"></a>十一、磁盘调度算法</h3><p>1、寻找时间</p><p>​    在读/写数据前，将磁头移动到指定磁道所花的时间。</p><ul><li><p>①启动磁头臂是需要时间的。假设耗时为 s； </p></li><li><p>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道。则：寻道时间 TS = s + m*n</p></li></ul><p>2、延迟时间</p><p>​    通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p><p>​    设磁盘转速为 r （单位：转/秒，或 转/分），则平均所需的延迟时间 </p><p>​            TR = (1/2)*(1/r) = 1/(2r)</p><p>3、传输时间</p><p>​    从磁盘读出或向磁盘写入数据所经历的时间，</p><p>​    假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N。</p><p>​        则：传输时间Tt = (1/r) * (b/N) = b/(rN)</p><p>一、先来先服务算法（FCFS）</p><p>​    根据进程请求访问磁盘的先后顺序进行调度。</p><ul><li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li><li>缺点：近似于随机寻道</li></ul><p>二、最短寻找时间算法（SSTF）</p><p>​        会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（贪心的思想）</p><ul><li><p>优点：性能较好，平均寻道时间短</p></li><li><p>缺点：可能产生“饥饿”现象</p></li></ul><p>三、扫描算法（电梯算法）（SCAN）</p><p>在SSTF的基础上，规定：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移 动。这就是扫描算法（SCAN）的思想</p><ul><li><p>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</p></li><li><p>缺点：</p><ul><li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均</li></ul></li></ul><p>四、look算法</p><p>​        在SCAN 算法基础上规定：如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。</p><p>例：    </p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142014944.png" alt="image-20220314201413868"></p><ul><li>优点：比起 SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul><p>五、循环扫描算法（C-SCAN ）</p><p>​        在SCAN 的基础上：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><ul><li><p>优点：比起SCAN 来，对于各个位置磁道的响应频率很平均。</p></li><li><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向；比起SCAN算法来，平均寻道时间更长</p></li></ul><p>六、C-look算法</p><p>​    C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>例：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142016716.png" alt="image-20220314201638648"></p><ul><li>优点：比起 C-SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间</li></ul><p>进一步缩短</p><h3 id="十二、磁盘管理"><a href="#十二、磁盘管理" class="headerlink" title="十二、磁盘管理"></a>十二、磁盘管理</h3><p>可以认为的减少磁盘寻道的时间（其余两个都和磁盘本身的转速有关）</p><p>常见的方法：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142017014.png" alt="image-20220314201722940"></p><p>​    </p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-常见问题总结</title>
    <link href="http://example.com/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-13T12:29:59.000Z</published>
    <updated>2022-03-15T10:45:54.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见操作系统问题"><a href="#常见操作系统问题" class="headerlink" title="常见操作系统问题"></a>常见操作系统问题</h2><ul><li>进程和线程的区别？</li><li>进程调度算法有哪些</li><li>常见的进程通信方式</li><li>进程IPC问题</li><li>进程死锁</li><li>什么叫做内核进程？与普通用户进程有什么区别？</li><li>fork/vfork调用</li><li>孤儿进程/僵尸进程</li><li>时间片轮转算法的发展</li><li>常见的进程调度器</li><li>抢占式调度VS 协作式调度</li><li>系统调用</li><li>POSIX</li><li>系统调用参数传递过程</li><li>常用的内核数据结构有哪些？都是在什么场景使用</li><li>什么是中断</li><li>软中断和硬中断</li><li>描述一下中断处理程序的执行过程</li><li>使用网卡描述一下硬件使用中断来完成数据传输的过程</li><li>操作系统是如何感知中断并处理的</li><li>中断的上半部和下半部</li><li>介绍一下内核同步方法</li><li>Linux里面都有哪些锁？</li><li>悲观锁和乐观锁</li><li>说说Linux内存管理</li><li>内存映射策略</li><li>使用C 函数Malloc描述一下内存分配的过程</li><li>Linux虚拟文件系统</li><li>Linux IO调度程序 </li></ul>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-12T08:01:40.000Z</published>
    <updated>2022-03-15T10:45:36.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>下面是操作系统基本功能的进程管理。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1、概念：</p><p>​    例如windows的进程管理器中的每一条进程都是进程。</p><ul><li><p>程序是存放在磁盘中的可执行文件，是静态的。是一系列程序的集合。</p></li><li><p>进程是动态的，是程序的依次执行过程。</p></li></ul><p>2、组成</p><p>操作系统的进程由PCB 来控制。是进程存在的标志。</p><p>PCB中存放的都是操作系统对进程进行管理所需要的信息。是给操作系统用的</p><p>程序段、数据段是给进程自己用的。</p><p>通常PCB 中包含以下信息：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121609867.png" alt="image-20220312160940762" style="zoom:80%;" /></p><p>一个进程实体（进程映像 ）是由：PCB 、程序段、数据段组成。</p><p>注意：进程实体是动态的，进程是进程运行过程中某一时刻的状态。是资源分配和调度的独立单位。</p><p>3、特征</p><ul><li>动态性：最基本的特性</li><li>并发性</li><li>独立性</li><li>异步性</li><li>结构性</li></ul><h3 id="二、进程状态转换和组织"><a href="#二、进程状态转换和组织" class="headerlink" title="二、进程状态转换和组织"></a>二、进程状态转换和组织</h3><p>1、状态</p><ul><li>创建态：进程正在被创建，系统完成创建的一系列工作。</li><li>就绪态：进程准备好进行执行。</li><li>运行态：进程被调度。CPU 正好执行这个程序的程序序列</li><li>阻塞态：进程因为某些原因被阻塞了。</li><li>终止态：进程结束</li></ul><p>2、转换</p><p>转换图：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121644953.png" alt="image-20220312164405817" style="zoom:80%;" /><p>注意：</p><p>​    进程不能由阻塞态直接转换成运行态，也不能从就绪态直接转换成阻塞态。因为阻塞态是进程主动请求的，必须是运行态才能完成这个功能。</p><p>​    进程是可以从运行态转换成就绪态的。例如系统分配的时间片用完了。 </p><h3 id="三、进程控制"><a href="#三、进程控制" class="headerlink" title="三、进程控制"></a>三、进程控制</h3><p>进程控制：进程的状态转换，包括创建、撤销、实现转换等功能。</p><p>1、如何实现?</p><p>是使用原语实现的，原语的实现具有原子性。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-概述</title>
    <link href="http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-03-12T06:51:18.000Z</published>
    <updated>2022-03-15T10:45:47.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、操作系统基本特性"><a href="#一、操作系统基本特性" class="headerlink" title="一、操作系统基本特性"></a>一、操作系统基本特性</h2><p>​    操作系统基本特性：并发、共享、异步、虚拟</p><h3 id="一、并发"><a href="#一、并发" class="headerlink" title="一、并发"></a>一、并发</h3><p>​    首先区分并发和并行：</p><p>​        并发：两个或两个以上事件在同一时间间隔内，宏观上是同时发生，微观上交替发生。</p><p>​        并行：两个或两个以上事件在同一时刻发生 </p><p>​    那么下面进一步来看操作系统的并发性。</p><p>​    计算机系统上同时运行着多个程序，这些程序宏观上同时运行，微观上交替运行</p><p>注：</p><ul><li>单核CPU 同一时刻只能运行单个程序，各个程只能并发执行。</li></ul><h3 id="二、共享"><a href="#二、共享" class="headerlink" title="二、共享"></a>二、共享</h3><p>​    即资源共享，系统内的资源可供内存内多个程序共同使用。</p><p>1、共享方式</p><p>​    共享方式分成两种 ：互斥共享和同时共享方式</p><p>​    注：互斥共享指的是一个时间段内只允许一个进程访问该资源，例如摄像头。同时共享相反。</p><p>综上来看：并发性和共享性是互相为存在条件的。</p><h3 id="三、虚拟性"><a href="#三、虚拟性" class="headerlink" title="三、虚拟性"></a>三、虚拟性</h3><p>​    物理上的实体编程逻辑上的对应物。</p><p>​    举个例子：</p><p>​    QQ 需要254MB内存、迅雷需要500MB 内存，加入我的电脑只有2G，依然能够运行这些程序。</p><p>​    虚拟技术：</p><ul><li>空分复用技术（如虚拟存储器技术）</li><li>时分复用技术（如虚拟处理机）</li></ul><h3 id="四、异步"><a href="#四、异步" class="headerlink" title="四、异步"></a>四、异步</h3><p>​    多道程序下，允许多个进程并发执行，由于<strong>资源有限</strong>，之形式断断续续的，速度是不可知的。</p><p>只有系统拥有并发行，才会有异步性的特征。</p><h3 id="二、操作系统发展和分类"><a href="#二、操作系统发展和分类" class="headerlink" title="二、操作系统发展和分类"></a>二、操作系统发展和分类</h3><p>一、操作系统的发展：</p><p>1、手工操作阶段：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121511147.png" alt="image-20220312151119952" style="zoom:80%;" /><p>2、脱机输入输出阶段</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121512463.png" alt="image-20220312151240260" style="zoom:80%;" /><p>3、批处理阶段</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121513288.png" alt="image-20220312151342171" style="zoom:80%;" /><p>但是还是没有提供人机交互的问题。</p><p>4、分时操作系统</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121515301.png" alt="image-20220312151500158" style="zoom:80%;" /><p>5、实时操作系统</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121515388.png" alt="image-20220312151525257" style="zoom:80%;" /><p>注：重点了解各个操作系统的优缺点。</p><h3 id="三、操作系统的运行"><a href="#三、操作系统的运行" class="headerlink" title="三、操作系统的运行"></a>三、操作系统的运行</h3><p>举个例子：一条代码在计算机运行，首先通过编译器翻译成CPU能够读懂的二进制机器指令，然后交由CPU 执行。</p><p>1、两种类型的程序</p><p>需要区分两种程序：</p><ul><li><p>内核程序：操作系统的组成部分，组成了操作系统内核</p></li><li><p>应用程序：运行在操作系统之上的程序。</p><p>需要注意的是，操作系统内核有时候会执行一些<strong>特权指令</strong>。影响重大，因此只能操作系统内核来使用。（这些特权指令都是提前定义好的，CPU 可以识别）</p></li></ul><p>2、两种状态</p><p>那么CPU如何区分，内核程序和应用程序呢？</p><p>​    CPU有两种状态：内核态和用户态</p><ul><li>处于内核态（管态）时，说明运行的是内核程序。</li><li>处于用户态（目态），说明运行的是应用程序，只能执行非特权指令</li></ul><p>拓展：CPU 中的PSW有一个二进制位，1表示处于内核态，0表示用户态。</p><p>3、状态的切换</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121529618.png" alt="image-20220312152912447" style="zoom:80%;" /></p><p>因此我们可以总结：内核态到用户态的转变，进行修改PSW的 特权指令；用户态到内核态的转变，由中断引起，硬件自动完成。</p><h3 id="四、中断和异常"><a href="#四、中断和异常" class="headerlink" title="四、中断和异常"></a>四、中断和异常</h3><p>一、中断</p><p>操作系统夺回CPU 是使用权的唯一途径。</p><p>类型：内中断和外中断</p><ul><li><p>内中断：也叫异常，CPU执行的当前指令，引发的内部中断信号，引起内部中断。</p><p>此外还有：陷入指令（程序故意引发的）：应用程序–&gt;系统内核（系统调用就是依赖于陷入指令完成，）</p><p>故障、终止</p></li></ul><ul><li>外中断：一般叫做中断，CPU外部的来的中断信号，与当前运行程序无关。</li></ul><p>例：时钟中断：由时钟部件发来的中断信号。</p><p>​        IO设备发来的中断信号。</p><p>二、中断的基本原理</p><p>1、检查中断信号（又分成内外中断两种检测机制）</p><p>2、找到相应的中断处理程序，通过查找中断向量表的方式执行。中断处理程序都运行在内核态。</p><h3 id="六、系统调用"><a href="#六、系统调用" class="headerlink" title="六、系统调用"></a>六、系统调用</h3><p>1、</p><p>是操作系统提供的。使上层应用能够请求操作系统内核提供服务。和函数调用很类似。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121546102.png" alt="image-20220312154614995" style="zoom:80%;" /></p><p>2、系统调用的分类</p><p>在此不过多叙述如图：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121547178.png" alt="image-20220312154749072" style="zoom:80%;" /></p><p>​    凡是对于共享资源的使用就要经过系统调用来实现。由操作系统内核提供服务，进行调度。这样可以提高操作系统的安全性和稳定性。</p><p> 3、<strong>系统调用过程</strong></p><p>以编辑的程序调用库函数的例子进行分析。</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121552934.png" alt="image-20220312155236772" style="zoom:80%;" /><h3 id="七、操作系统内核"><a href="#七、操作系统内核" class="headerlink" title="七、操作系统内核"></a>七、操作系统内核</h3><p>1、</p><p>内核是操作系统最核心的部分，运行在内核态的程序叫做内核程序。</p><p>通过如下图示初步了解：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121555711.png" alt="image-20220312155522618" style="zoom:80%;" /></p><p>2、<strong>大内核和微内核</strong></p><p>大内核和小内核的相关功能划分不同，某些内核包含的功能想要执行就要到核心态运行。用户态和内核态的切换需要相关的代价。微内核和大内核各有各的有缺低点。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题总结</title>
    <link href="http://example.com/2022/03/09/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/09/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-09T08:08:12.000Z</published>
    <updated>2022-03-15T10:39:29.249Z</updated>
    
    <content type="html"><![CDATA[<p>【数据库】数据库中什么时候用索引？（应用场景）索引的作用 </p><p>1、定义：数据库索引是数据库管理系统中一个排序的数据结构,以协助快速查询,更新数据库 </p><p>中表的数据。 </p><p>2、实现方式：索引的实现通常使用 B 树和变种的 B+树(mysql 常用的索引就是 B+树)；索引 </p><p>是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。 </p><p>3、什么时候该用索引？ </p><p> </p><p>主键自动建立唯一索引恐涉侵权，请勿传播 </p><p>269 </p><p> </p><p>在经常用在连接（</p><p>join）的列上，这些列主要是一些外键，可以加快连接的速度 </p><p> </p><p>在经常需要根据范围搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； </p><p> </p><p>频繁作为查询条件（经常 where）的字段应该创建索引 </p><p> </p><p>查询中经常（OrderBy）排序的字段（因为索引已经排序，这样查询可以利用索引的排 </p><p>序，加快排序查询时间） </p><p> </p><p>查询中统计（</p><p>Count）或者分组（Groupby）的字段； </p><p>4、什么时候不该用索引？ </p><p> </p><p>在查询中很少使用或者参考的列不应该创建索引。 </p><p> </p><p>只有很少数据值的列也不应该增加索引。例如性别列 </p><p> </p><p>定义为 text, image 和 bit 数据类型的列不应该增加索引。这些列的数据量要么相当大， </p><p>要么取值很少,不利于使用索引。 </p><p> </p><p>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保 </p><p>存索引文件 </p><p> </p><p>表记录太少，不需要创建索引； </p><p> </p><p>经常增删改的表； </p><p>5、索引的优缺点 </p><p>优点： </p><p> </p><p>通过创建索引,可以在查询的过程中,提高系统的性能 </p><p> </p><p>通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性 </p><p> </p><p>在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间 </p><p>缺点： </p><p> </p><p>创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大 </p><p> </p><p>索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大 </p><p> </p><p>在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护 </p><p>6、索引的种类 </p><p> </p><p>普通索引：MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复 </p><p>值和空值，纯粹为了查询数据更快一 点。 </p><p> </p><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。 </p><p> </p><p>主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引） </p><p> </p><p>组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的 </p><p>左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。例如，这里由 id、 </p><p>name 和 age3 个字段构成的索引，索引行中就按 id/name/age 的顺序存放，索引可以索 </p><p>引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引 </p><p>最左面的前缀，那么就不会是用索引，比如，age 或者（</p><p>name，age）组合就不会使用 </p><p>索引查询。 </p><p> </p><p>全文索引：全文索引，只有在 MyISAM 引擎上才能使用，只能在 CHAR,VARCHAR,TEXT </p><p>类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通 </p><p>过其中的某个关键字等，就能找到该字段所属的记录行。一般开发中，不贵用到全文索 </p><p>引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。 </p><p>7、为什么使用联合索引 </p><p> </p><p>减 少 开 销 。 建 一 个 联 合 索 引 (col1,col2,col3) ， 实 际 相 当 于 建 了 </p><p>(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁 </p><p>盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ </p><p> </p><p>覆盖索引。对联合索引(col1,col2,col3)，如果有如下的 sql: select col1,col2,col3 from test恐涉侵权，请勿传播 </p><p>270 </p><p>where col1=1 and col2=2。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表， </p><p>这减少了很多的随机 io 操作。减少 io 操作，特别的随机 io 其实是 dba 主要的优化策略。 </p><p>所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 </p><p> </p><p>效率高。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 </p><p>sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出 </p><p>10%的数据，如果只有单值索引，那么通过该索引能筛选出 1000W10%=100w 条数据， </p><p>然后再回表从 100w 条数据中找到符合 col2=2 and col3= 3 的数据，然后再排序，再分页； </p><p>如果是联合索引，通过索引筛选出 1000w10% 10% *10%=1w，效率提升可想而知！ </p><p>8、数据库中的索引一般是什么数据结构？ </p><p>B+Tree 是一种树数据结构，是一个 n 叉排序树，每个节点通常有多个孩子，一棵 B+Tree 包 </p><p>含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两 </p><p>个以上孩子节点的节点。B+Tree 几乎是数据库默认的索引实现。 </p><p>延伸问题 1：hash 的查找时间复杂度是 O(1)比 B+的 O(logn)查找时间更短，为什么索引不用 </p><p>hash？（可以从 B+树索引的有序性，叶节点被双向链表连接，方便支持范围查找，以及分 </p><p>批加载至内存这几个方面回答） </p><p>这和业务场景有关，如果只查找一个值的话，hash 是一个很好的选择，单数据库经常会选 </p><p>择多条，这时候由于 B+树索引有序，并且又有链表相连，它的查询效率比 hash 就快很多了。 </p><p>而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计 </p><p>可以允许数据分批加载，同时树的高度较低，提高查找效率 </p><p>延伸问题 2：为什么不用红黑树（可以从内存，以及树深度和 IO 次数方面讨论这个问题。） </p><p>红黑树必须存在内存里的，数据库表太大了，存不进去。 </p><p>在大规模数据存储的时候，红黑树（二叉查找树）往往出现由于树的深度过大而造成磁盘 IO </p><p>读写过于频繁，进而导致效率低下的情况。B 树可以有多个子女，从几十到上千，可以降低 </p><p>树的高度。 </p><p>磁盘 IO 代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘 IO 频繁读写。根据磁 </p><p>盘查找存取的次数往往由树的高度所决定，红黑树查找一个节点最多要查 logN 层，每一层 </p><p>都是一个内存页。虽然你只是想找一个节点，但硬盘必须一次读一个页，那么一共 logN 次 </p><p>IO，消耗太大。 </p><p>延伸问题 3：为什么不用 B 树（可以从叶节点是否存数据，占用内存空间大小和是否支持范 </p><p>围查询这三个方面解释。 ） </p><p>B+树的数据都集中在叶子节点，分支节点只负责索引。 b 树的分支节点也有数据 。所以 </p><p>b+树的树高会小于 B 树，平均的 Io 次数会远大于 B+树。 </p><p>(比如一个节点是一个页 4096 字节，其中每条数据 128 字节，那么一个节点只能存 32 个数 </p><p>据项，那么对应的孩子节点数最多为 33 个，这显然不够用。而 b+树内部节点只作为导向作 </p><p>用，只存一个整数就可以（</p><p>int 型整数 32 位，消耗 4 个字节），4096/4=1024 个数据项。这 </p><p>样 b+树的每个节点的孩子数更多，整个树的高度就更低，大大增加查询效率。) </p><p>B+树索引节点没有数据。比较小。B 树可以把索引完全加载至内存中。 </p><p>B+树更擅长范围查询。叶子节点数据是按顺序放置的双向链表。 B 树范围查询只能中序遍 </p><p>历，做不到范围查询。 </p><p>原文链接：<a href="https://blog.csdn.net/uonele/article/details/106963120">https://blog.csdn.net/uonele/article/details/106963120</a> </p><p>9、索引的实现方式？ </p><p>在数据库中，常见的索引实现方式有哈希表、有序数组、搜索树。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091612123.png" alt="image-20220309161214865"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091612872.png" alt="image-20220309161241692"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091613097.png" alt="image-20220309161323946"></p><p>10、innodb 的索引模型</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091614652.png" alt="image-20220309161412514"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091614923.png" alt="image-20220309161435808"></p><p>11、索引维护</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091615077.png" alt="image-20220309161515930"></p><p>【数据库】MySQL 的逻辑架构 </p><p>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。 </p><p>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等 </p><p>所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。 </p><p>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存 </p><p>储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会 </p><p>解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信， </p><p>276恐涉侵权，请勿传播 </p><p>277 </p><p>只是简单响应上层服务器请求。 </p><p>【数据库】MySQL 的读写锁 </p><p>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型 </p><p>的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户 </p><p>在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会 </p><p>阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正 </p><p>在写入的同一资源。 </p><p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL </p><p>会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会 </p><p>被插入到读锁队列的前面，但是读锁不能插入到写锁前面。 </p><p>【数据库】MySQL 的锁策略有什么 </p><p>表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户 </p><p>在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有 </p><p>写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。 </p><p>行锁可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他 </p><p>存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。 </p><p>【数据库】数据库死锁如何解决 </p><p>死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现 </p><p>象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资 </p><p>源时也会产生死锁。 </p><p>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如 </p><p>InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有 </p><p>效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待 </p><p>超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持 </p><p>有最少行级排它锁的事务进行回滚。 </p><p>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是 </p><p>无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行 </p><p>因死锁回滚的事务即可。 </p><p>【数据库】数据库中的事务是怎么回事？ </p><p>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地 </p><p>对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩 </p><p>溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行 </p><p>成功，要么全部执行失败。 </p><p>ACID </p><p>\1. 原子性（</p><p>Atomicity） </p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 </p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚 </p><p>时反向执行这些修改操作即可。 </p><p>\2. 一致性（</p><p>Consistency） </p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取 </p><p>结果都是相同的。 </p><p>\3. 隔离性（</p><p>Isolation） </p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。 </p><p>\4. 持久性（Durability）恐涉侵权，请勿传播 </p><p>278 </p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的 </p><p>结果也不能丢失。 </p><p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数 </p><p>据的逻辑修改不同，重做日志记录的是数据页的物理修改。 </p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： </p><p>只有满足一致性，事务的执行结果才是正确的。 </p><p>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定 </p><p>能满足一致性。 </p><p>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满 </p><p>足一致性。 </p><p>事务满足持久化是为了能应对系统崩溃的情况。 </p><p>【数据库】MySQL 的隔离级别 </p><p>（</p><p>1）未提交读 READ UNCOMMITTED </p><p>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修 </p><p>改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有 </p><p>比其他级别好很多，很少使用。 </p><p>（</p><p>2）提交读 READ COMMITTED </p><p>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能” </p><p>看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对 </p><p>其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。 </p><p>（</p><p>3）可重复读 REPEATABLE READ（MySQL 默认的隔离级别） </p><p>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。 </p><p>但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。 </p><p>InnoDB 存储引擎通过多版本并发控制 MVCC 解决幻读的问题。 </p><p>（</p><p>4）可串行化 SERIALIZABLE </p><p>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都 </p><p>加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常 </p><p>需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。 </p><p>【数据库】聚簇索引和辅助索引 </p><p>总结：InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，聚簇索引就是按照 </p><p>每张表的主键构造一颗 B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集 </p><p>索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分； </p><p>一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建，但是这个主键如果 </p><p>更改代价较高，故建表时要考虑自增 ID 不能频繁 update 这点。 </p><p>我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需找 </p><p>主键索引的二级索引，现在找到主键索引再通过主键索引找数据； </p><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式。 </p><p>MySQL 数据库中 innodb 存储引擎，B+树索引可以分为聚簇索引（也称聚集索引，clustered </p><p>index）和辅助索引（有时也称非聚簇索引或二级索引，</p><p>secondary index，non-clustered index）。 </p><p>这两种索引内部都是 B+树，聚集索引的叶子节点存放着一整行的数据。 </p><p>Innobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、 </p><p>唯一索引。 </p><p>Innodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引 </p><p>聚簇索引(聚集索引)恐涉侵权，请勿传播 </p><p>279 </p><p>聚簇索引就是按照每张表的主键构造一颗 B+树，同时叶子节点中存放的就是整张表的 </p><p>行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是 </p><p>索引的一部分，每张表只能拥有一个聚簇索引。 </p><p>Innodb 通过主键聚集数据，如果没有定义主键，innodb 会选择非空的唯一索引代替。 </p><p>如果没有这样的索引，innodb 会隐式的定义一个主键来作为聚簇索引。 </p><p>聚簇索引的优缺点 </p><p>优点：</p><p>1.数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+树中，因此从聚簇索 </p><p>引中获取数据比非聚簇索引更快 </p><p>2.聚簇索引对于主键的排序查找和范围查找速度非常快 </p><p>缺点：</p><p>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出 </p><p>现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主 </p><p>键 </p><p>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表， </p><p>我们一般定义主键为不可更新。 </p><p>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行 </p><p>数据。 </p><p>辅助索引（非聚簇索引） </p><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅 </p><p>助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键 </p><p>值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。 </p><p>Innodb 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外， </p><p>还包含了相应行数据的聚簇索引键。 </p><p>辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在 </p><p>innodb 中有时也称辅助索引为二级索引。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-设计原则</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-02T08:20:42.000Z</published>
    <updated>2022-03-15T10:44:43.157Z</updated>
    
    <content type="html"><![CDATA[<p>下面了解一些经典的设计原则，包括，SOLID、KISS、YAGNI、DRY、LOD 等。</p><p>就SOLID原则来说，SOLID 原则并非单纯的 1 个原则，而是由 5个设计原则组成的，它们分别是：<strong>单一职责原则、开闭原则、里式替换原则、接口隔离原则</strong>和<strong>依赖反转原则</strong>。</p><h3 id="单一职责原则SRP"><a href="#单一职责原则SRP" class="headerlink" title="单一职责原则SRP"></a>单一职责原则SRP</h3><p>描述起来就是：一个类或者一个模块只完成一个功能（职责）</p><p>也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，</p><p>一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该</p><p>将它拆分成多个功能更加单一、粒度更细的类。</p><p>​    需要注意的是，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否</p><p>单一的判定，可能都是不一样的。具体场景具体分析，并没有一个明确的，一成不变的标准。</p><p>​    不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展</p><p>性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以</p><p>此作为最终的考量标准。</p><p>​    总结几个情况可能说明这类的设计不满足单一职责原则：</p><p>1、类中的代码行数、函数或者属性过多；</p><p>2、类依赖的其他类过多，或者依赖类的其他类过多；</p><p>3、私有方法过多；</p><p>4、比较难给类起一个合适的名字；</p><p>5、类中大量的方法都是集中操作类中的某几个属性。</p><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>上面介绍了单一职责原则，下面来看一下   第二个原则：开闭原则</p><p>大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设</p><p>计原则就是开闭原则。</p><p>开闭原则的英文全称是 Open Closed Principle，他所描述的原则是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><h3 id="里式替换原则LSP"><a href="#里式替换原则LSP" class="headerlink" title="里式替换原则LSP"></a><strong>里式替换原则</strong>LSP</h3><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。</p><p>原则的描述大致是：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”</p><p>原则描述为：<strong>客户端不应该强迫依赖它不需要的接口</strong>。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-面向对象</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-02T08:19:59.000Z</published>
    <updated>2022-03-15T10:44:33.455Z</updated>
    
    <content type="html"><![CDATA[<p>为了保证知识的全面性，在此讨论面向对象的设计思想，为之后的设计模式做铺垫。</p><h3 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h3><p>首先耳熟能详的面向对象的四大特性：封装、继承、抽象、多态。</p><p><strong>面向对象编程和面向对象编程语言？</strong></p><p>面向对象的两个重要概念：类和对象。</p><ul><li>面向对象编程可以理解成以面向对象四大特性为代码设计基础，以类和对象作为代码基本组织单元的一种编程范式。</li><li>面向对象编程语言：狭义上来说是实现面向对象特性，并且支持类和对象为主体的语法机制的编程语言。</li></ul><p><strong>面向对象分析和面向对象设计？</strong></p><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶</p><p>段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等。</p><h3 id="二、面向对象四大特性"><a href="#二、面向对象四大特性" class="headerlink" title="二、面向对象四大特性"></a>二、面向对象四大特性</h3><p>下面详细分析以下面向对象四大特性</p><p><strong>1. 关于封装特性</strong></p><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类</p><p>提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如</p><p>Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据</p><p>不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用</p><p>性。</p><p><strong>2. 关于抽象特性</strong></p><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只</p><p>需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或</p><p>者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代</p><p>码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也</p><p>是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p><strong>3. 关于继承特性</strong>继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子</p><p>类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程</p><p>语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p><strong>4. 关于多态特性</strong></p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特</p><p>性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可</p><p>以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h3 id="三、面向对象编程相比面向过程编程有什么优点？"><a href="#三、面向对象编程相比面向过程编程有什么优点？" class="headerlink" title="三、面向对象编程相比面向过程编程有什么优点？"></a>三、<strong>面向对象编程相比面向过程编程有什么优点？</strong></h3><p>面向过程编程适用于简单程序开发，程序流程有一条主线，分步骤顺序执行，对于简单的执行流程的程序来说比较适合。</p><p>面向对象编程是用于大规模程序开发，对于整体程序流程错综复杂。以类为思考对象。经过面向对象设计，将需求翻译成类。建立类之间的相互关系，最终组装成程序。</p><p>面向对象的设计模式提供了更清晰、模块化的代码组织方式。</p><p>面向对象编程的代码更易复用、易于维护和复用。（面向对象编程，具有更丰富的特性）</p><h3 id="四、接口和抽象类的区别？"><a href="#四、接口和抽象类的区别？" class="headerlink" title="四、接口和抽象类的区别？"></a>四、接口和抽象类的区别？</h3><p>java即支持抽象类也支持接口。</p><p>1、抽象类</p><p>​    抽象类不能被实例化，只能被继承。</p><p>​    抽象类中可以包含属性和方法，方法可以包含抽象方法（无代码具体实现）和非抽象方法。</p><p>​    子类继承抽象类，必须实现抽象类中的所有<strong>抽象</strong>方法。</p><p>抽象类是一种特殊的不能被实例化类，。</p><p>2、接口 </p><p>​    接口不能包含属性（成员变量）</p><p>​    接口只能还包含抽象方法（无具体实现 ）</p><p>​    实现类实现接口时，必须实现接口中的所有方法。</p><p>3、抽象类和接口的应用场景区别**</p><p>如果要表示一种is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示 has-a关系，并且解决抽象而不是代码复用的问题，那么就可以使用接口。</p><h3 id="五、基于接口编程？"><a href="#五、基于接口编程？" class="headerlink" title="五、基于接口编程？"></a>五、基于接口编程？</h3><p>一个和接口有关的原则：基于接口编程而非实现编程。</p><p>​    从本质上来说，接口可以理解成一组“协议”，“约定”，上述原则可以表述成：基于抽象编程而非实现编程：抽象是提高代码可扩展性、灵活行性、可维护性的有效手段之一</p><p> 定义接口要注意：</p><p>1、函数的命名不能暴露任何实现细节。 </p><p>2、 封装具体的实现细节。 </p><p>3、为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能</p><h3 id="六、多用组合少用继承"><a href="#六、多用组合少用继承" class="headerlink" title="六、多用组合少用继承"></a>六、多用组合少用继承</h3><p>有这么一条设计原则：组合优于继承</p><p><strong>1. 为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>2. 组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>3. 如何判断该用组合还是继承？</strong></p><p> 组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="七、贫血模型-VS-充血模型"><a href="#七、贫血模型-VS-充血模型" class="headerlink" title="七、贫血模型 VS 充血模型"></a>七、<strong>贫血模型</strong> <strong>VS</strong> <strong>充血模型</strong></h3><p>我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构， 相对于新兴的基于充血模型的</p><p>DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:33:00.000Z</published>
    <updated>2022-03-15T10:44:23.532Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:32:49.000Z</published>
    <updated>2022-03-15T10:44:09.830Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:31:58.000Z</published>
    <updated>2022-03-15T10:44:54.748Z</updated>
    
    <content type="html"><![CDATA[<p>前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常</p><p>用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很</p><p>具体，总体上来讲比较好掌握。</p><p>关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5</p><p>种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项</p><p>目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代</p><p>码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。</p><p>话不多说，让我们正式开始今天的学习吧！</p><p><strong>适配器模式的原理与实现</strong></p><p><strong>适配器模式</strong>的英文翻译是 <strong>Adapter Design Pattern</strong>。顾名思义，这个模式就是用来做适</p><p>配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类</p><p>可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适</p><p>配器，把两种不兼容的接口，通过转接变得可以一起工作。</p><p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适</p><p>配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码</p><p>实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget</p><p>接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">1 // 类适配器: 基于继承</span><br><span class="line"></span><br><span class="line">2 public interface ITarget &#123; </span><br><span class="line"></span><br><span class="line">3 void f1(); </span><br><span class="line"></span><br><span class="line">4 void f2(); </span><br><span class="line"></span><br><span class="line">5 void fc(); </span><br><span class="line"></span><br><span class="line">6 &#125; </span><br><span class="line"></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">8 public class Adaptee &#123; </span><br><span class="line"></span><br><span class="line">9 public void fa() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">10 public void fb() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">11 public void fc() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">12 &#125; </span><br><span class="line"></span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">14 public class Adaptor extends Adaptee implements ITarget &#123; </span><br><span class="line"></span><br><span class="line">15 public void f1() &#123; </span><br><span class="line"></span><br><span class="line">16 super.fa(); </span><br><span class="line"></span><br><span class="line">17 &#125; </span><br><span class="line"></span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">19 public void f2() &#123; </span><br><span class="line"></span><br><span class="line">20 //...重新实现f2()... </span><br><span class="line"></span><br><span class="line">21 &#125; </span><br><span class="line"></span><br><span class="line">22</span><br><span class="line"></span><br><span class="line">23 // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line"></span><br><span class="line">24 &#125; </span><br><span class="line"></span><br><span class="line">25</span><br><span class="line"></span><br><span class="line">26 // 对象适配器：基于组合</span><br><span class="line"></span><br><span class="line">27 public interface ITarget &#123; </span><br><span class="line"></span><br><span class="line">28 void f1(); </span><br><span class="line"></span><br><span class="line">29 void f2(); </span><br><span class="line"></span><br><span class="line">30 void fc(); </span><br><span class="line"></span><br><span class="line">31 &#125; </span><br><span class="line"></span><br><span class="line">32</span><br><span class="line"></span><br><span class="line">33 public class Adaptee &#123;34 public void fa() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">35 public void fb() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">36 public void fc() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">37 &#125; </span><br><span class="line"></span><br><span class="line">38</span><br><span class="line"></span><br><span class="line">39 public class Adaptor implements ITarget &#123; </span><br><span class="line"></span><br><span class="line">40 private Adaptee adaptee; </span><br><span class="line"></span><br><span class="line">41</span><br><span class="line"></span><br><span class="line">42 public Adaptor(Adaptee adaptee) &#123; </span><br><span class="line"></span><br><span class="line">43 this.adaptee = adaptee; </span><br><span class="line"></span><br><span class="line">44 &#125; </span><br><span class="line"></span><br><span class="line">45</span><br><span class="line"></span><br><span class="line">46 public void f1() &#123; </span><br><span class="line"></span><br><span class="line">47 adaptee.fa(); //委托给Adaptee </span><br><span class="line"></span><br><span class="line">48 &#125; </span><br><span class="line"></span><br><span class="line">49</span><br><span class="line"></span><br><span class="line">50 public void f2() &#123; </span><br><span class="line"></span><br><span class="line">51 //...重新实现f2()... </span><br><span class="line"></span><br><span class="line">52 &#125; </span><br><span class="line"></span><br><span class="line">53</span><br><span class="line"></span><br><span class="line">54 public void fc() &#123; </span><br><span class="line"></span><br><span class="line">55 adaptee.fc(); </span><br><span class="line"></span><br><span class="line">56 &#125; </span><br><span class="line"></span><br><span class="line">57 &#125;</span><br></pre></td></tr></table></figure><p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有</p><p>两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p><p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推</p><p>荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方</p><p>式，Adaptor 的代码量要少一些。</p><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们</p><p>推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p><p><strong>适配器模式应用场景总结</strong></p><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式</p><p>算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情</p><p>况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结</p><p>。</p><p><strong>1.</strong> <strong>封装有缺陷的接口设计</strong></p><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影</p><p>响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进</p><p>行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">1 public class CD &#123; //这个类来自外部sdk，我们无权修改它的代码</span><br><span class="line"></span><br><span class="line">2 //... </span><br><span class="line"></span><br><span class="line">3 public static void staticFunction1() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">5 public void uglyNamingFunction2() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">7 public void tooManyParamsFunction3(int paramA, int paramB, ...) &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">9 public void lowPerformanceFunction4() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">10 &#125; </span><br><span class="line"></span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">12 // 使用适配器模式进行重构</span><br><span class="line"></span><br><span class="line">13 public class ITarget &#123; </span><br><span class="line"></span><br><span class="line">14 void function1(); </span><br><span class="line"></span><br><span class="line">15 void function2(); </span><br><span class="line"></span><br><span class="line">16 void fucntion3(ParamsWrapperDefinition paramsWrapper); </span><br><span class="line"></span><br><span class="line">17 void function4(); </span><br><span class="line"></span><br><span class="line">18 //... </span><br><span class="line"></span><br><span class="line">19 &#125; </span><br><span class="line"></span><br><span class="line">20 // 注意：适配器类的命名不一定非得末尾带Adaptor </span><br><span class="line"></span><br><span class="line">21 public class CDAdaptor extends CD implements ITarget &#123; </span><br><span class="line"></span><br><span class="line">22 //... </span><br><span class="line"></span><br><span class="line">23 public void function1() &#123; </span><br><span class="line"></span><br><span class="line">24 super.staticFunction1(); </span><br><span class="line"></span><br><span class="line">25 &#125; </span><br><span class="line"></span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">27 public void function2() &#123; </span><br><span class="line"></span><br><span class="line">28 super.uglyNamingFucntion2(); </span><br><span class="line"></span><br><span class="line">29 &#125; </span><br><span class="line"></span><br><span class="line">3031 public void function3(ParamsWrapperDefinition paramsWrapper) &#123; </span><br><span class="line"></span><br><span class="line">32 super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...); </span><br><span class="line"></span><br><span class="line">33 &#125; </span><br><span class="line"></span><br><span class="line">34</span><br><span class="line"></span><br><span class="line">35 public void function4() &#123; </span><br><span class="line"></span><br><span class="line">36 //...reimplement it... </span><br><span class="line"></span><br><span class="line">37 &#125; </span><br><span class="line"></span><br><span class="line">38 &#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>统一多个类的接口设计</strong></p><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统</p><p>一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解</p><p>释一下。</p><p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入</p><p>了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感</p><p>词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用</p><p>各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定</p><p>义，这样我们可以复用调用敏感词过滤的代码。</p><p>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">1 public class ASensitiveWordsFilter &#123; // A敏感词过滤系统提供的接口</span><br><span class="line"></span><br><span class="line">2 //text是原始文本，函数输出用***替换敏感词之后的文本</span><br><span class="line"></span><br><span class="line">3 public String filterSexyWords(String text) &#123; </span><br><span class="line"></span><br><span class="line">4 // ... </span><br><span class="line"></span><br><span class="line">5 &#125; </span><br><span class="line"></span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">7 public String filterPoliticalWords(String text) &#123; </span><br><span class="line"></span><br><span class="line">8 // ... </span><br><span class="line"></span><br><span class="line">9 &#125; </span><br><span class="line"></span><br><span class="line">10 &#125; </span><br><span class="line"></span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">12 public class BSensitiveWordsFilter &#123; // B敏感词过滤系统提供的接口</span><br><span class="line"></span><br><span class="line">13 public String filter(String text) &#123; </span><br><span class="line"></span><br><span class="line">14 //... </span><br><span class="line"></span><br><span class="line">15 &#125; </span><br><span class="line"></span><br><span class="line">16 &#125; </span><br><span class="line"></span><br><span class="line">17</span><br><span class="line"></span><br><span class="line">18 public class CSensitiveWordsFilter &#123; // C敏感词过滤系统提供的接口</span><br><span class="line"></span><br><span class="line">19 public String filter(String text, String mask) &#123;20 //... </span><br><span class="line"></span><br><span class="line">21 &#125; </span><br><span class="line"></span><br><span class="line">22 &#125; </span><br><span class="line"></span><br><span class="line">23</span><br><span class="line"></span><br><span class="line">24 // 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="line"></span><br><span class="line">25 public class RiskManagement &#123; </span><br><span class="line"></span><br><span class="line">26 private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter(); </span><br><span class="line"></span><br><span class="line">27 private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter(); </span><br><span class="line"></span><br><span class="line">28 private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter(); </span><br><span class="line"></span><br><span class="line">29</span><br><span class="line"></span><br><span class="line">30 public String filterSensitiveWords(String text) &#123; </span><br><span class="line"></span><br><span class="line">31 String maskedText = aFilter.filterSexyWords(text); </span><br><span class="line"></span><br><span class="line">32 maskedText = aFilter.filterPoliticalWords(maskedText); </span><br><span class="line"></span><br><span class="line">33 maskedText = bFilter.filter(maskedText); </span><br><span class="line"></span><br><span class="line">34 maskedText = cFilter.filter(maskedText, &quot;***&quot;); </span><br><span class="line"></span><br><span class="line">35 return maskedText; </span><br><span class="line"></span><br><span class="line">36 &#125; </span><br><span class="line"></span><br><span class="line">37 &#125; </span><br><span class="line"></span><br><span class="line">38</span><br><span class="line"></span><br><span class="line">39 // 使用适配器模式进行改造</span><br><span class="line"></span><br><span class="line">40 public interface ISensitiveWordsFilter &#123; // 统一接口定义</span><br><span class="line"></span><br><span class="line">41 String filter(String text); </span><br><span class="line"></span><br><span class="line">42 &#125; </span><br><span class="line"></span><br><span class="line">43</span><br><span class="line"></span><br><span class="line">44 public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123; </span><br><span class="line"></span><br><span class="line">45 private ASensitiveWordsFilter aFilter; </span><br><span class="line"></span><br><span class="line">46 public String filter(String text) &#123; </span><br><span class="line"></span><br><span class="line">47 String maskedText = aFilter.filterSexyWords(text); </span><br><span class="line"></span><br><span class="line">48 maskedText = aFilter.filterPoliticalWords(maskedText); </span><br><span class="line"></span><br><span class="line">49 return maskedText; </span><br><span class="line"></span><br><span class="line">50 &#125; </span><br><span class="line"></span><br><span class="line">51 &#125; </span><br><span class="line"></span><br><span class="line">52 //...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor... </span><br><span class="line"></span><br><span class="line">53</span><br><span class="line"></span><br><span class="line">54 // 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="line"></span><br><span class="line">55 // 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="line"></span><br><span class="line">56 public class RiskManagement &#123; </span><br><span class="line"></span><br><span class="line">57 private List&lt;ISensitiveWordsFilter&gt; filters = new ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">58</span><br><span class="line"></span><br><span class="line">59 public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123; </span><br><span class="line"></span><br><span class="line">60 filters.add(filter); </span><br><span class="line"></span><br><span class="line">61 &#125; </span><br><span class="line"></span><br><span class="line">62</span><br><span class="line"></span><br><span class="line">63 public String filterSensitiveWords(String text) &#123; </span><br><span class="line"></span><br><span class="line">64 String maskedText = text; </span><br><span class="line"></span><br><span class="line">65 for (ISensitiveWordsFilter filter : filters) &#123; </span><br><span class="line"></span><br><span class="line">66 maskedText = filter.filter(maskedText); </span><br><span class="line"></span><br><span class="line">67 &#125; </span><br><span class="line"></span><br><span class="line">68 return maskedText; </span><br><span class="line"></span><br><span class="line">69 &#125; </span><br><span class="line"></span><br><span class="line">70 &#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>替换依赖的外部系统</strong></p><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以</p><p>减少对代码的改动。具体的代码示例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> 1 // 外部系统A </span><br><span class="line"></span><br><span class="line">2 public interface IA &#123; </span><br><span class="line"></span><br><span class="line">3 //... </span><br><span class="line"></span><br><span class="line">4 void fa(); </span><br><span class="line"></span><br><span class="line">5 &#125; </span><br><span class="line"></span><br><span class="line">6 public class A implements IA &#123; </span><br><span class="line"></span><br><span class="line">7 //... </span><br><span class="line"></span><br><span class="line">8 public void fa() &#123; //... &#125; </span><br><span class="line"></span><br><span class="line">9 &#125; </span><br><span class="line"></span><br><span class="line">10 // 在我们的项目中，外部系统A的使用示例</span><br><span class="line"></span><br><span class="line">11 public class Demo &#123; </span><br><span class="line"></span><br><span class="line">12 private IA a; </span><br><span class="line"></span><br><span class="line">13 public Demo(IA a) &#123; </span><br><span class="line"></span><br><span class="line">14 this.a = a; </span><br><span class="line"></span><br><span class="line">15 &#125; </span><br><span class="line"></span><br><span class="line">16 //... </span><br><span class="line"></span><br><span class="line">17 &#125; </span><br><span class="line"></span><br><span class="line">18 Demo d = new Demo(new A()); </span><br><span class="line"></span><br><span class="line">19</span><br><span class="line"></span><br><span class="line">20 // 将外部系统A替换成外部系统B </span><br><span class="line"></span><br><span class="line">21 public class BAdaptor implemnts IA &#123; </span><br><span class="line"></span><br><span class="line">22 private B b; </span><br><span class="line"></span><br><span class="line">23 public BAdaptor(B b) &#123; </span><br><span class="line"></span><br><span class="line">24 this.b= b; </span><br><span class="line"></span><br><span class="line">25 &#125; </span><br><span class="line"></span><br><span class="line">26 public void fa() &#123; </span><br><span class="line"></span><br><span class="line">27 //... </span><br><span class="line"></span><br><span class="line">28 b.fb(); </span><br><span class="line"></span><br><span class="line">29 &#125; </span><br><span class="line"></span><br><span class="line">30 &#125; </span><br><span class="line"></span><br><span class="line">31 // 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br><span class="line"></span><br><span class="line">32 // 只需要将BAdaptor如下注入到Demo即可。</span><br><span class="line"></span><br><span class="line">33 Demo d = new Demo(new BAdaptor(new B()));</span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>兼容老版本接口</strong></p><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且</p><p>标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用</p><p>场景。同样，我还是通过一个例子，来进一步解释一下。</p><p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它</p><p>改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接</p><p>从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为</p><p>了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使</p><p>用 Iterator 才行。</p><p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发</p><p>的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是</p><p>不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，</p><p>我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下</p><p>所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">1 public class Collections &#123; </span><br><span class="line"></span><br><span class="line">2 public static Emueration emumeration(final Collection c) &#123; </span><br><span class="line"></span><br><span class="line">3 return new Enumeration() &#123; </span><br><span class="line"></span><br><span class="line">4 Iterator i = c.iterator(); </span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">6 public boolean hasMoreElments() &#123; </span><br><span class="line"></span><br><span class="line">7 return i.hashNext(); </span><br><span class="line"></span><br><span class="line">8 &#125; </span><br><span class="line"></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">10 public Object nextElement() &#123; </span><br><span class="line"></span><br><span class="line">11 return i.next(): </span><br><span class="line"></span><br><span class="line">12 &#125; </span><br><span class="line"></span><br><span class="line">13 &#125; </span><br><span class="line"></span><br><span class="line">14 &#125; </span><br><span class="line"></span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure><p><strong>5.</strong> <strong>适配不同格式的数据</strong></p><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之</p><p>间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方</p><p>便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类</p><p>型的数据转化为集合容器类型。 复制代码</p><p>1 List<String> stooges = Arrays.asList(“Larry”, “Moe”, “Curly”);</p><p><strong>剖析适配器模式在</strong> <strong>Java</strong> <strong>日志中的应用</strong></p><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常</p><p>用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的</p><p>JCL(Jakarta Commons Logging) 等。</p><p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、</p><p>erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不</p><p>像 JDBC 那样，一开始就制定了数据库操作的接口规范。</p><p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选</p><p>一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框</p><p>架的选择就没那么随意了。</p><p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是</p><p>logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志</p><p>框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比</p><p>如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框</p><p>架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要</p><p>统一日志打印框架。</p><p>如果你是做 Java 开发的，那 Slf4j 这个</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-02T04:31:15.000Z</published>
    <updated>2022-03-15T10:44:00.215Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式一般用来来表示全局唯一类。</p><p>单例模式的缺点：对于OOP的抽象、继承、多态都支持的不好。</p><p><strong>1. 单例存在哪些问题？</strong></p><p>单例对 OOP 特性的支持不友好</p><p>单例会隐藏类之间的依赖关系</p><p>单例对代码的扩展性不友好</p><p>单例对代码的可测试性不友好</p><p>单例不支持有参数的构造函数</p><p><strong>2. 单例有什么替代解决方案？</strong></p><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实</p><p>现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，</p><p>寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对</p><p>象）。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，</p><p>关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例</p><p>类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传</p><p>去，不如直接做成单例类，使用起来简洁方便。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发-结构化并发应用程序</title>
    <link href="http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-02-13T08:35:30.000Z</published>
    <updated>2022-03-15T07:35:29.684Z</updated>
    
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发实战-基础知识</title>
    <link href="http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/02/13/JAVA%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-02-13T08:27:27.000Z</published>
    <updated>2022-03-15T10:38:46.479Z</updated>
    
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-表</title>
    <link href="http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E8%A1%A8/"/>
    <id>http://example.com/2022/02/12/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E8%A1%A8/</id>
    <published>2022-02-12T05:57:23.000Z</published>
    <updated>2022-03-15T10:39:48.751Z</updated>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
