<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boranの小さな巣</title>
  
  <subtitle>boranの小さな巣</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-30T12:58:21.514Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chen-boran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM-内存泄漏和溢出</title>
    <link href="http://example.com/2022/03/30/JVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2022/03/30/JVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E6%BA%A2%E5%87%BA/</id>
    <published>2022-03-30T10:15:23.000Z</published>
    <updated>2022-03-30T12:58:21.514Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载于：<a href="https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&mid=2247485412&idx=1&sn=bcb6805623c744a37a42157d8eaa64a1&chksm=c0ccef41f7bb6657f8719b9d55759b2766d8fed1223699d9ec0c8655cd5d388600a5299615b3&cur_album_id=1785069014436593665&scene=190#rd">【JVM进阶之路】四：直面内存溢出和内存泄漏</a></p><p>在Java中，和内存相关的问题主要有两种，<strong>内存溢出</strong>和<strong>内存泄漏</strong>。</p><ul><li>**内存溢出（*<em>Out Of Memory*<em>）</em></em> ：就是申请内存时，JVM没有足够的内存空间。通俗说法就是去蹲坑发现坑位满了。</li><li><strong>内存泄露 （Memory Leak）</strong>：就是申请了内存，但是没有释放，导致内存空间浪费。通俗说法就是有人占着茅坑不拉屎。</li></ul><h1 id="1、内存溢出"><a href="#1、内存溢出" class="headerlink" title="1、内存溢出"></a>1、内存溢出</h1><p>在JVM的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icBLAyZxNkaYVGRAYJX71F2tDyO0Uxbo15jnpIbA829CCia73mcbJHfTA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">JDK 1.8内存区域</p><h2 id="1-1、Java堆溢出"><a href="#1-1、Java堆溢出" class="headerlink" title="1.1、Java堆溢出"></a>1.1、Java堆溢出</h2><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p><p>我们来看一个代码的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来设置一下程序启动时的JVM参数。限制内存大小为20M，不允许扩展，并通过参数-XX：+HeapDumpOnOutOf-MemoryError 让虚拟机Dump出内存堆转储快照。</p><p>在Idea中设置JVM启动参数如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icnMxcGDmibT4CzTTGfsKCN7cwYT39kGoo11mKibFeO93oucKWSftSDr5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">Idea设置JVM参数</p><p>运行一下：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">堆内存溢出异常</p><p>Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。Java堆文件快照文件dump到了java_pid18728.hprof文件。</p><p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具（如JProfiler、Eclipse Memory Analyzer等）对Dump出来的堆转储快照进行分析。</p><p>看到内存占用信息如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icgYD1GOOgsNfaFKmmfdTYgNpJXicHnjAbLibrO1xJyia4npmOBibo1Uc9bg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">Jprofiler 打开的堆转储快照文件</p><p>然后可以查看代码问题如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icziaMLn90icj6IgOUClvzTCHPGf1guEWicVPTrojwPvIWCbrXUKc1UTjOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">Jprofiler查看代码问题</p><blockquote><p>常见堆JVM相关参数：</p><p><code>-XX:PrintFlagsInitial</code>: 查看所有参数的默认初始值<code>-XX:PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）<code>-Xms</code>: 初始堆空间内存（默认为物理内存的1/64）<code>-Xmx</code>: 最大堆空间内存（默认为物理内存的1/4）<code>-Xmn</code>: 设置新生代大小（初始值及最大值）<code>-XX:NewRatio</code>: 配置新生代与老年代在堆结构的占比<code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0/S1空间的比例<code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄(默认15)<code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志 打印<code>GC</code>简要信息：① <code>-XX:+PrintGC</code> ② <code>-verbose:gc``-XX:HandlePromotionFailure</code>：是否设置空间分配担保</p></blockquote><h2 id="1-2、虚拟机栈和本地方法栈溢出"><a href="#1-2、虚拟机栈和本地方法栈溢出" class="headerlink" title="1.2、虚拟机栈和本地方法栈溢出"></a>1.2、虚拟机栈和本地方法栈溢出</h2><p>HotSpot虚拟机中将虚拟机栈和本地方法栈合二为一，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟机栈和本地方法栈，有两种异常：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<code>StackOverflowError</code>异常。</li><li>如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 <code>OutOfMemoryError</code>异常。</li></ul><h3 id="1-2-1、StackOverflowError"><a href="#1-2-1、StackOverflowError" class="headerlink" title="1.2.1、StackOverflowError"></a>1.2.1、StackOverflowError</h3><p>HotSpot虚拟机不支持栈的动态扩展，在HotSpot虚拟机中，以下两种情况都会导致StackOverflowError。</p><ul><li><p><strong>栈容量过小</strong></p><p>如下，使用Xss参数减少栈内存容量</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vm参数：-Xss128k</span><br><span class="line"> */</span><br><span class="line">public class JavaVMStackSOF &#123;</span><br><span class="line">    private int stackLength = 1;</span><br><span class="line"></span><br><span class="line">    public void stackLeak() &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        JavaVMStackSOF oom = new JavaVMStackSOF();</span><br><span class="line">        try &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            System.out.println(&quot;stack length:&quot; + oom.stackLength);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icuHtsd4Zc9HIyNy413OSdPvQCWbWOUGEyMAsvzQjKPYico2vzv0dKZyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">栈内存溢出</p><ul><li><p><strong>栈帧太大</strong></p><p>如下，通过一长串变量，来占用局部变量表空间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icFPsv1htDVlHnuyTleqfGOVbeibnnrRGBic6icS0Iqp4moibMpx0Co8b0rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">carbon</p></li></ul><p>运行结果：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image-20210324211958180</p><p>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候， HotSpot虚拟机抛出的都是StackOverflowError异常。</p><h3 id="1-2-2、OutOfMemoryError"><a href="#1-2-2、OutOfMemoryError" class="headerlink" title="1.2.2、OutOfMemoryError"></a>1.2.2、OutOfMemoryError</h3><p>虽然不支持动态扩展栈，但是通过不断建立线程的方式，也可以在HotSpot上产生内存溢出异常。</p><p>需要注意，这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态。因为操作系统给每个进程的内存时有限的，线程数一多，自然会超过进程的容量。</p><p>创建线程导致内存溢出异常 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vm参数：-Xss2M</span><br><span class="line"> */</span><br><span class="line">public class JavaVMStackOOM &#123;</span><br><span class="line">    private void dontStop() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stackLeakByThread() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        JavaVMStackOOM oom = new JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一段比较有风险的代码，可能会导致系统假死，运行结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53icWk4ibmGibtgr5XUvWnQAMQo4fEabiaSTsKJcJGq4lrViawDQ7d1wiaGHBdQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210324213320530</p><h2 id="1-3、方法区和运行时常量池溢出"><a href="#1-3、方法区和运行时常量池溢出" class="headerlink" title="1.3、方法区和运行时常量池溢出"></a>1.3、方法区和运行时常量池溢出</h2><p>这里再提一下方法区和运行时常量池的变迁，JDK1.7以后字符串常量池移动到了堆中，JDK1.8在直接内存中划出一块区域<strong>元空间</strong>来实现方区域。</p><p>String:intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，永久代本身内存不限制可能会出现错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><h2 id="1-4、本机直接内存溢出"><a href="#1-4、本机直接内存溢出" class="headerlink" title="1.4、本机直接内存溢出"></a>1.4、本机直接内存溢出</h2><p>直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。</p><p>直接通过反射获取<code>Unsafe</code>实例，通过反射向操作系统申请分配内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vm参数：-Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="line"> */</span><br><span class="line">public class DirectMemoryOOM &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(true);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(null);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image-20210324215114989</p><p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况。</p><h1 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h1><p>内存回收，简单说就是应该被垃圾回收的对象没有被垃圾回收。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeaHDVASQXNBtGp0PMuZ53ic2AQ25VfYhW3f0oWWCf1SOUHKShVE6zOicMaYdVDiaIhDtyEwRPVejsHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">内存泄漏</p><p>在上图中：对象 X 引用对象 Y，X 的生命周期比 Y 的生命周期长，Y生命周期结束的时候，垃圾回收器不会回收对象Y。</p><p>我们来看几个内存泄漏的例子：</p><ul><li><p><strong>静态集合类引起内存泄漏</strong></p><p>静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class OOM &#123;</span><br><span class="line"> static List list = new ArrayList();</span><br><span class="line"></span><br><span class="line"> public void oomTests()&#123;</span><br><span class="line">   Object obj = new Object();</span><br><span class="line"></span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>单例模式</strong>：</p><p>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</p></li><li><p><strong>数据连接、IO、Socket等连接</strong></p><p>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    conn = DriverManager.getConnection(&quot;url&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    ResultSet rs = stmt.executeQuery(&quot;....&quot;);</span><br><span class="line">  &#125; catch (Exception e) &#123; </span><br><span class="line">   </span><br><span class="line">  &#125;finally &#123;</span><br><span class="line">    //不关闭连接</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>变量不合理的作用域</strong></p><p>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Simple &#123;</span><br><span class="line">    Object object;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        object = new Object();</span><br><span class="line">        //...其他代码</span><br><span class="line">        //由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span><br><span class="line">        object = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>引用了外部类的非静态内部类</strong></p><p>非静态内部类（或匿名类）的初始化总是需要依赖外部类的实例。默认情况下，每个非静态内部类都包含对其<strong>包含类</strong>的隐式引用，若在程序中使用这个内部类对象，那么<strong>即使在包含类对象超出范围之后，也不会被回收</strong>（内部类对象隐式地持有外部类对象的引用，使其成不能被回收）。</p></li><li><p><strong>Hash 值发生改变</strong></p><p>对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，会导致无法从容器中<strong>单独删除</strong>当前对象，造成内存泄露。</p></li><li><p><strong>ThreadLocal</strong> 造成的内存泄漏</p><p>ThreadLocal 可以实现变量的线程隔离，但若使用不当，就可能会引入内存泄漏问题。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载于：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;mid=2247485412&amp;idx=1&amp;sn=bcb6805623c744a37a42157d8eaa64a1&amp;chksm=c0ccef41f</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-字节码指令</title>
    <link href="http://example.com/2022/03/30/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2022/03/30/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</id>
    <published>2022-03-30T10:10:50.000Z</published>
    <updated>2022-03-30T12:46:23.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-字节码指令"><a href="#JVM-字节码指令" class="headerlink" title="JVM 字节码指令"></a>JVM 字节码指令</h1><ul><li><p>java虚拟机指令是由一个字节长度的代表着某种特定含义的数字（操作码）组以及跟随其后的0至多个代表此操作所需的参数（操作数）构成。</p></li><li><p>由于限制了Java虚拟机操作码的长度是一个字节。因此指令集中的操作码总数不超过256条。</p><p>在java虚拟机指令集中，大多数指令都包含其操作所对应的数据类型信息。</p></li></ul><p>例如 ：iload指令表明从局部变量表中加载int类型的数据到操作数栈中，同理fload是加载浮点数类型的数据到操作数栈。</p><p>​    对于大部分的数据类型相关的字节码指令，他们的操作码助记符中都有特殊字符表明专门为哪种数据类型服务：</p><p> i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表 float，d代表double，a代表reference。</p><p> 当然还有一些指令时和数据类型无关的。</p><p>​    JVM主要支持byte、short、int、long、float、double、char、reference集中数据类型，每种数据类型的操作码分别以不同的字母开头。 </p><pre><code> Java虚拟机指令集支持的数据类型</code></pre><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220330204336013.png" alt="image-20220330204336013"></p><p>续：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220330204311916.png" alt="image-20220330204311916"></p><p>上图列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列 所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。如 果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型 执行这项操作。例如，load指令有操作int类型的iload，但是没有操作byte类型的同类指令。</p><p>注：大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号 扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（ZeroExtend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short 和char类型数据的操作，实际上都是使用相应的int类型作为运算类型（Computational Type）。</p><p>主要把字节码按照用途大致分成九类。</p><h1 id="1、加载和存储指令"><a href="#1、加载和存储指令" class="headerlink" title="1、加载和存储指令"></a>1、加载和存储指令</h1><p>加载（load）和存储（store）指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：</p><p>这类的主要指令有：</p><ul><li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_、dload、 dload_、aload、aload_<n></li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、 fstore_、dstore、dstore_<n>、astore、astore_<n></li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li><li>扩充局部变量表的访问索引的指令：wide</li></ul><p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令， 如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p><p>iload_这一类以尖括号结尾的指令，实际上代表了一组指令，例如iload_，它可能代表了iload_0、iload_1、iload_2和iload_3这几条指令，这几条指令表示把第1、2、3个局部变量加载进操作数栈。</p><h1 id="2、运算指令"><a href="#2、运算指令" class="headerlink" title="2、运算指令"></a>2、运算指令</h1><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。</p><p>所有的算术指令包括：</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv 这类的主要指令有：</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><h1 id="3、类型转换指令"><a href="#3、类型转换指令" class="headerlink" title="3、类型转换指令"></a>3、类型转换指令</h1><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作有两个作用：</p><ul><li>显示类型操作转换</li><li>字节码指令不支持的类型转换</li></ul><p>类型转换指令主要分为两种：</p><p>1）宽化，小类型向大类型转换，比如 <code>int–&gt;long–&gt;float–&gt;double</code>，对应的指令有：i2l、i2f、i2d、l2f、l2d、f2d。</p><ul><li>从 int 到 long，或者从 int 到 double，是不会有精度丢失的；</li><li>从 int、long 到 float，或者 long 到 double 时，可能会发生精度丢失；</li><li>从 byte、char 和 short 到 int 的宽化类型转换实际上是隐式发生的，这样可以减少字节码指令，毕竟字节码指令只有 256 个，占一个字节。</li></ul><p>2）窄化，大类型向小类型转换，比如从 int 类型到 byte、short 或者 char，对应的指令有：i2b、i2s、i2c；从 long 到 int，对应的指令有：l2i；从 float 到 int 或者 long，对应的指令有：f2i、f2l；从 double 到 int、long 或者  float，对应的指令有：d2i、d2l、d2f。</p><ul><li>窄化很可能会发生精度丢失，毕竟是不同的数量级；</li><li>但 Java 虚拟机并不会因此抛出运行时异常。</li></ul><h1 id="4、对象创建与访问指令"><a href="#4、对象创建与访问指令" class="headerlink" title="4、对象创建与访问指令"></a>4、对象创建与访问指令</h1><p>在前面我们已经接触过了对象创建的指令。</p><p>ava虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><h1 id="5、操作数栈管理指令"><a href="#5、操作数栈管理指令" class="headerlink" title="5、操作数栈管理指令"></a>5、操作数栈管理指令</h1><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul><h1 id="6、控制转移指令"><a href="#6、控制转移指令" class="headerlink" title="6、控制转移指令"></a>6、控制转移指令</h1><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。</p><p>控制转移指令包括：</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li></ul><p>在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。</p><h1 id="7、方法调用和返回指令"><a href="#7、方法调用和返回指令" class="headerlink" title="7、方法调用和返回指令"></a>7、方法调用和返回指令</h1><p>方法调用在后面会学到，我们这里只是了解一下方法调用的一些指令：</p><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑 是由用户所设定的引导方法决定的。</li></ul><p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</p><h1 id="8、异常处理指令"><a href="#8、异常处理指令" class="headerlink" title="8、异常处理指令"></a>8、异常处理指令</h1><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。</p><p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。</p><h1 id="9、同步指令"><a href="#9、同步指令" class="headerlink" title="9、同步指令"></a>9、同步指令</h1><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p><p>例如一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void onlyMe(String f) &#123;</span><br><span class="line">    synchronized (f) &#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后查看字节码指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 0: aload_1                          </span><br><span class="line"> 1: dup                              </span><br><span class="line"> 2: astore_2                         </span><br><span class="line"> 3: monitorenter                     // 以栈顶元素作为锁，开始同步</span><br><span class="line"> 4: getstatic     #2                 </span><br><span class="line"> 7: aload_1                          </span><br><span class="line"> 8: invokevirtual #3                 </span><br><span class="line">11: aload_2</span><br><span class="line">12: monitorexit                     // 退出同步</span><br><span class="line">13: goto          21</span><br><span class="line">16: astore_3</span><br><span class="line">17: aload_2</span><br><span class="line">18: monitorexit</span><br><span class="line">19: aload_3</span><br><span class="line">20: athrow</span><br><span class="line">21: return</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM-字节码指令&quot;&gt;&lt;a href=&quot;#JVM-字节码指令&quot; class=&quot;headerlink&quot; title=&quot;JVM 字节码指令&quot;&gt;&lt;/a&gt;JVM 字节码指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java虚拟机指令是由一个字节长度的代表着某种特定含义的数字（操作</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-编译和优化</title>
    <link href="http://example.com/2022/03/28/JVM-%E7%BC%96%E8%AF%91%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/03/28/JVM-%E7%BC%96%E8%AF%91%E5%92%8C%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-28T04:19:30.000Z</published>
    <updated>2022-03-28T04:19:30.038Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-类加载机制</title>
    <link href="http://example.com/2022/03/28/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/03/28/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-28T04:19:06.000Z</published>
    <updated>2022-03-30T13:07:14.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h1><h2 id="一、类加载的过程"><a href="#一、类加载的过程" class="headerlink" title="一、类加载的过程"></a>一、类加载的过程</h2><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）。</p><p>其中验证、准备、解析三个部分统称为连接（Linking）。</p><p>注：加载、验证、准备、初始化、卸载这五个步骤的顺序是确定的。类加载过程必须按照这个顺序按部就班的开始（开始是说明仅仅是步骤开始，不必等待上一个步骤完成，下一个步骤就可以开始。）。但是解析阶段却不一定，解析可以在初始化的之后进行（即运行时绑定）。</p><p>如图所示：类的生命周期</p><p> <img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cFba2pnScwnfXmhhhp84bNK9fWw8UwD8IAOnWOZIjicuvs5WWMpqEdUg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p><p>《Java虚拟机规范》 严格规定了有且只有六种情况必须立即对类进行“初始化”：</p><ul><li>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</li><li>2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li><li>3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ul><p>这六种场景中的行为称为对一个类型进行主动引用。</p><p>除此之外，所有引用类型方式都不会出发初始化，成为被动引用。</p><p><strong>被动引用</strong>：</p><p>有三点说明：</p><ul><li>通过子类引用父类的<strong>静态字段</strong>，不会导致子类初始化，只会导致父类的初始化</li><li>通过数组来引用类，不会触发此类的初始化</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><p>注：一个类在初始化的时候，要求其父类已经全部初始化过了，但是一个借口在初始化时，并不要求其父接口全部完成了初始化。</p><p> 下面详细介绍类加载的过程：</p><h3 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h3><p>加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>在加载阶段，JVM要做三件事情：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cNjgPgic0MibcRqHc4g2kfEtJ8nnRf0ge3ZKapQLhaZkFpSpxtiacGoOibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p><ul><li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>注：虚拟机规范对于这三点描述不是很具体，因此留给了java应用的灵活性是很大的。加载阶段既可以是虚拟机内置的引导类加载器来完成，也可以是由用户自定义的类加载器来完成。</p><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。</p><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。</p><p>注：加载阶段和连接阶段的部分动作是交叉进行的，但是仍然保持固定的开始顺序。</p><h3 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h3><p>验证是连接阶段的第一步。</p><ul><li>目的：<strong>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求。</strong></li><li>验证阶段是非常重要的但是却不是必须的。只有使用的代码是完全经过了使用和验证，安全的，可考虑使用-Xverify：none参数关闭大部分的类验证措施，以缩短虚拟机类加载时间 。</li></ul><p>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cBuDTWyVsn0QUI8w3J5q6khuUlpUibe0HrJYicwicgibDJpHrE4WVLEHCicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>文件格式验证</li></ul><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。需要验证魔数、版本号、常量池常量类型是否支持、指向常量的索引值等等。</p><ul><li>元数据验证</li></ul><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，包括类是否有父类、父类是否继承了final修饰的类、非抽象类是否实现了父类定义的方法、类是否与父类有矛盾等等。</p><p>主要是对类的元数据信息进行<strong>语义</strong>检索，保证不存在与JAVA语言规范相悖的元数据信息。</p><ul><li>字节码验证</li></ul><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p><ul><li>符号引用验证</li></ul><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p><p>符号引用验证主要验证类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><h3 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h3><p>准备阶段是给静态变量分配内存并设置类变量初始值的阶段。</p><p>在JDK 7及之前，这些变量的内存在方法区（永久代）中分配，在JDK 8及之后，静态变量则会随着Class对象一起存放在Java堆中。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8c5DNVIuTicia7d6akzQ7WQQX45JD6gIoKZbUFe6ys84DXMySAdQiaXoVfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>注：准备阶段，容易混淆的概念：</p><p>​        1.进行内存分配的时候，仅仅包括类变量，不包括实例变量。实例变量会随着对象一起分配在Java堆中</p><p>基本数据类型的零值：</p><h3 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。与虚拟机实现的内存布局无关。</li><li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。与虚拟机实现的内存布局有关。如果有了直接引用那么引用的目标必定已经在虚拟机的内存中存在。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cs6smUScMl9iaOM9ZTibjMr8z6T5iarSTLeic2mmdicicykCuFOEp95FVXNog/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p><h3 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h3><p>类的初始化阶段是类加载过程的最后一个步骤。</p><p>直到这个阶段，才开始执行Java程序中的代码。将主导权移交给应用程序。会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</p><p>更直接的表示：初始化阶段就是执行类构造器<clinit>()方法的过程。</p><p>注：<clinit>()：是javac的自动生成物。</p><p>准备阶段，变量被赋的是系统要求的零值，在初始化阶段，赋的是代码里编写的值。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cibTSXPVDMwDnSuSRkNdUYicpkhEWqIsvOCG0aZjVibyTYXp3vBGeKmVCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p><h2 id="二、类与类加载器"><a href="#二、类与类加载器" class="headerlink" title="二、类与类加载器"></a>二、类与类加载器</h2><p>类加载器只用于实现类的加载动作。</p><p>但对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每 一个类加载器，都拥有一个独立的类名称空间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMjsqjVJe3XQmHibFatUwBmhPbAOQsYGHIEGYJic2MXsmwzQVCkqvQiazXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">类加载器和类确定类是否相等</p><p>这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则,即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>如下演示了不同的类加载器对instanceof关键字运算的结果的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //自定义一个简单的类加载器</span><br><span class="line">        ClassLoader myLoader = new ClassLoader() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            //加载类方法</span><br><span class="line">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //获取文件名</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    //加载输入流</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    //使用父类加载</span><br><span class="line">                    if (is == null) &#123;</span><br><span class="line">                        return super.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] b = new byte[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    //从流中转化类的实例</span><br><span class="line">                    return defineClass(name, b, 0, b.length);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    throw new ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //使用自己实现的类加载器加载</span><br><span class="line">        Object obj = myLoader.loadClass(&quot;cn.fighter3.loader.ClassLoaderTest&quot;).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        //实例判断</span><br><span class="line">        System.out.println(obj instanceof cn.fighter3.loader.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMxicP6OZrIsbTuSe0nN3cCu0hpK4QpPKTgxDCyibBia4dyBzs8gs3ICsRQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>在代码里定义了一个简单的类加载器，使用这个类加载器去加载<code>cn.fighter3.loader.ClassLoaderTest</code>类并创建实例，去做类型检查的时候，发现结果是false。</p><h2 id="三、双亲委派模型"><a href="#三、双亲委派模型" class="headerlink" title="三、双亲委派模型"></a>三、双亲委派模型</h2><p>从Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p><p>站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMLicib4voEciceY3xGFsibe7aWbZRA4Aa6t4q6xvnSXKLtnP9bcnev9SPuw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">双亲委派模型</p><p>双亲委派模型如上图：</p><ul><li>启动类加载器（Bootstrap Class Loader）：负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，能被Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类。</li><li>扩展类加载器（Extension Class Loader）：负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>应用程序类加载器（Application Class Loader）：负责加载用户类路径 （ClassPath）上所有的类库，如果没有自定义类加载器，一般情况下这个加载器就是程序中默认的类加载器。</li></ul><p>用户还可以加入自定义的类加载器器来进行扩展。</p><p><strong>双亲委派模型的工作过程</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKM6nibtLgvOy803PFUE7JKVjh15BjFMCcsc9u6SDTF1EMHGDDABJmibhOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>为什么要用双亲委派机制呢？</p></blockquote><p>答案是为了保证应用程序的稳定有序。</p><p>例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。</p><p>双亲委派模型的代码实现非常简单，在<code>java.lang.ClassLoader.java</code>中有一个 <code>loadClass</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // 首先，判断类是否被加载过</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // 如果父类加载器抛出ClassNotFoundException </span><br><span class="line">                // 说明父类加载器无法完成加载请求</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // 在父类加载器无法加载时 </span><br><span class="line">                // 再调用本身的findClass方法来进行类加载</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、破坏双亲委派模型"><a href="#四、破坏双亲委派模型" class="headerlink" title="四、破坏双亲委派模型"></a>四、破坏双亲委派模型</h2><p>双亲委派机制在历史上主要有三次破坏：</p><blockquote><p><strong>第一次破坏</strong></p></blockquote><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的 protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMYUYkKxYLhJweRYuJfK23O4dJKtUxvzMrn6eVv3g4h8qNuym1yUoWYw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">重写loadClass破坏双亲委派</p><blockquote><p><strong>第二次破坏</strong></p></blockquote><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>例如我们比较熟悉的JDBC:</p><p>各个厂商各有不同的JDBC的实现，Java在核心包<code>\lib</code>里定义了对应的SPI，那么这个就毫无疑问由<code>启动类加载器</code>加载器加载。</p><p>但是各个厂商的实现，是没办法放在核心包里的，只能放在<code>classpath</code>里，只能被<code>应用类加载器</code>加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。</p><p>为了解决这个我呢提，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMy2IW5HtULHnLWIiaaqU34NQBic5efB9sE51InlQ9WXjkRZCDhEiaRkbzA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">加载第三方spi第二次破坏</p><blockquote><p><strong>第三次破坏</strong></p></blockquote><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><blockquote><p>“简单的事情重复做，重复的事情认真做，认真的事情有创造性地做！”——</p><p>我是三分恶，可以叫我老三/三分/三哥/三子，一个能文能武的全栈开发，咱们下期见！</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM-类加载机制&quot;&gt;&lt;a href=&quot;#JVM-类加载机制&quot; class=&quot;headerlink&quot; title=&quot;JVM 类加载机制&quot;&gt;&lt;/a&gt;JVM 类加载机制&lt;/h1&gt;&lt;h2 id=&quot;一、类加载的过程&quot;&gt;&lt;a href=&quot;#一、类加载的过程&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-类文件结构</title>
    <link href="http://example.com/2022/03/28/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/03/28/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-28T04:18:36.000Z</published>
    <updated>2022-03-30T13:08:21.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p>Java虚拟机和字节码文件存储格式是Java实现语言无关性的基础。</p><p>Java虚拟机只和Class文件这种二进制文件相关联，后者中包含了java指令集和符号表和其他辅助信息。</p><p>虚拟机丝毫不关心Class文件来源于什么语言。</p><p>字节码是构成平台无关性的基石，虚拟机可以在如何执行同一种平台无关的代码，从而实现了一次编写，到处实现。</p><p> JAVA语言中的哥终于发关键字、常量、变量、运算符号的语义最终都会由多条字节码指令组合来表示。</p><h2 id="一、Class类文件结构"><a href="#一、Class类文件结构" class="headerlink" title="一、Class类文件结构"></a>一、Class类文件结构</h2><p>java语言保持着很好的向后兼容性。因此绝大多数的Class文件结构内容都在JDK1.2时代定义完毕。</p><ul><li><p>Class文件是一组以八个字节为单位的二进制字节流。需要注意的是，他们中间紧密排列，没有任何分隔符，仅仅存储必要的数据。</p></li><li><p>根据java虚拟机规范：Class文件使用一种类似于C语言中结构体的伪结构来存储数据。这种结构中只有两种数据类型：</p><ul><li>无符号数：（属于基本数据类型）u1，u2….表示一个字节、两个字节…..。用来描述数字、索引引用、数量值、或者按照UTF-8构成的字符串值</li><li>表：由多个无符号或者其他表构成的符合数据结构。通常以info结尾。</li></ul></li></ul><p>注:实际上Class文件也是一个“表”</p><p>​    Class文件因为没有空隙，因此其中的所有数据项的顺序和数量都是规定好的。</p><p>每一个 Class 文件对应于一个如下所示的 ClassFile 结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line"> u4 magic;</span><br><span class="line"> u2 minor_version;</span><br><span class="line"> u2 major_version;</span><br><span class="line"> u2 constant_pool_count;</span><br><span class="line"> cp_info constant_pool[constant_pool_count-1];</span><br><span class="line"> u2 access_flags;</span><br><span class="line"> u2 this_class;</span><br><span class="line"> u2 super_class;</span><br><span class="line"> u2 interfaces_count;</span><br><span class="line"> u2 interfaces[interfaces_count];</span><br><span class="line"> u2 fields_count;</span><br><span class="line"> field_info fields[fields_count];</span><br><span class="line"> u2 methods_count;</span><br><span class="line"> method_info methods[methods_count];</span><br><span class="line"> u2 attributes_count;</span><br><span class="line"> attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下各项的含义：</p><p><img src="https://mmbiz.qlogo.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UduUxwQXJm2XdDzUpLcvUDrBzHVJSYDFWiaDzRRpNyRuhiaCVAaMvQX9GYA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="图片"></p><p> 下面逐项详细介绍：</p><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><p>每个Class文件前四字节被称为魔数。</p><p>唯一作用是确定这个文件是否能被虚拟机接受并且执行(使用魔数不使用文件扩展名，是出于安全考虑，文件扩展名可以随意更改)</p><p>这是基本上每个Java开发人员的第一个Java程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用的是Idea工具，运行，target目录下会生成对应的class文件，为了查看文件的十六进制信息，我们可以安装一个插件<code>HexView</code>。</p><p>class文件十六进制</p><p>第一行中有一串特殊的字符 <code>cafebabe</code>，它就是一个魔数，是 JVM 识别 class 文件的标志，JVM 会在验证阶段检查 class 文件是否以该魔数开头，如果不是则会抛出 <code>ClassFormatError</code>。</p><p>这段字节很有意思——咖啡宝贝，Java原来不止是咖啡，还是宝贝😂</p><h3 id="1-2-版本号"><a href="#1-2-版本号" class="headerlink" title="1.2 版本号"></a>1.2 版本号</h3><p>紧跟着魔数的四个字节 存储的是 class 文件的版本号：第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。</p><p>Java的版本号是从 45 开始的，JDK1.1 之后的每个 JDK  大版本发布主版本号向上加1（JDK1.0<del>JDK1.1使用了45.0</del>45.3的版本号），高版本的 JDK 能向下兼容以前版本的 Class  文件，但不能运行以后版本的 Class 文件，即使文件格式未发生变化。</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h3><p>紧接着主、次版本号之后的是常量池入口。常量池可以比喻成Class文件中的资源仓库。</p><p>是一个表数据项目</p><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表<strong>常量池容量计数值</strong>（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UduWzbia5JJOdWjO4SWqYmXy8su5sm3AS2yv8IgsRroo6HnAwLB4EibuZsg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p><p> Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。</p><p>1、</p><p>常量池中主要存放两大类常量：<code>字面量（Literal）</code>和<code>符号引用（Symbolic References）</code>。</p><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p><p>符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul><p>2、</p><p>动态连接：Java代码在进行javac编译的时候，没有连接这个说法，而是在加载Class文件的时候进行动态连接，Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些信息不经过虚拟机在运行期间的转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</p><p>常量池会在类加载的时候提供对应的常量池引用，经过解析翻译到对应的内存地址中。</p><p>3、</p><p>常量池中的每一个常量都是一个表，介质JDK13，常量池中常量有17种不同类型。</p><p>这17类常量结构只有一个相同之处，表结构起始的第一位是个u1类型的标志位（tag），代表着当前常量属于哪种常量类型。</p><p>17种常量类型所代表的具体含义如表所示：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>标志</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">CONSTANT_Utf8_info</td><td align="left">1</td><td align="left">UTF-8 编码的字符串</td></tr><tr><td align="left">CONSTANT_Integer_info</td><td align="left">3</td><td align="left">整型字面量</td></tr><tr><td align="left">CONSTANT_Float_info</td><td align="left">4</td><td align="left">浮点型字面量</td></tr><tr><td align="left">CONSTANT_Long_info</td><td align="left">5</td><td align="left">长整型型字面量</td></tr><tr><td align="left">CONSTANT_Double_info</td><td align="left">6</td><td align="left">双精度浮点型字面量</td></tr><tr><td align="left">CONSTANT_Class_info</td><td align="left">7</td><td align="left">类或接口的符号引用</td></tr><tr><td align="left">CONSTANT_String_info</td><td align="left">8</td><td align="left">字符串类型字面量</td></tr><tr><td align="left">CONSTANT_Fieldref_info</td><td align="left">9</td><td align="left">字段的符号引用</td></tr><tr><td align="left">CONSTANT_Methodref_info</td><td align="left">10</td><td align="left">类中方法的符号引用</td></tr><tr><td align="left">CONSTANT_InterfaceMethodref_info</td><td align="left">11</td><td align="left">接口中方法的符号引用</td></tr><tr><td align="left">CONSTANT_NameAndType_info</td><td align="left">12</td><td align="left">字段或方法的部分符号引用</td></tr><tr><td align="left">CONSTANT_MethodHandle_info</td><td align="left">15</td><td align="left">表示方法句柄</td></tr><tr><td align="left">CONSTANT_MethodType_info</td><td align="left">16</td><td align="left">表示方法类型</td></tr><tr><td align="left">CONSTANT_Dynamic_info</td><td align="left">17</td><td align="left">表示一个动态计算常量</td></tr><tr><td align="left">CONSTANT_InvokeDynamic_info</td><td align="left">18</td><td align="left">表示一个动态方法调用点</td></tr><tr><td align="left">CONSTANT_Moudle_info</td><td align="left">19</td><td align="left">表示一个模块</td></tr><tr><td align="left">CONSTANT_Package_info</td><td align="left">20</td><td align="left">表示一个模块中开放或者导出的包</td></tr></tbody></table><p>我们直接看一下常量池中的17种数据类型的结构总表：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UduUn9Yx0DUmUVplWMGTlicpYtupU6n5hOYhFc3RFfh4rEcOibwhMeUjnyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210418173430171</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UduMade1vouy6IicIVQLjXagjOXvBZZLwwA85sLgL7CWOGBRy42Tgkzayg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210418173535751</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UdugKvEVoaGck4eG1wRWo4OJVUHdMtBOVTUONRW6D1juWL2k5JR37JibzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210418173624816</p><h3 id="1-4-访问标志"><a href="#1-4-访问标志" class="headerlink" title="1.4 访问标志"></a>1.4 访问标志</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags）。</p><ul><li>这个标志用于识别一些类或者接口层次的访问信息</li><li>包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。</li></ul><p>具体的标志位以及标志的含义如表：</p><table><thead><tr><th align="left"><strong>标志名称</strong></th><th align="left"><strong>标志值</strong></th><th align="left"><strong>含义</strong></th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td align="left">0x0001</td><td align="left">是否为 Public 类型</td></tr><tr><td align="left">ACC_FINAL</td><td align="left">0x0010</td><td align="left">是否被声明为 final，只有类可以设置</td></tr><tr><td align="left">ACC_SUPER</td><td align="left">0x0020</td><td align="left">是否允许使用 invokespecial 字节码指令的新语义</td></tr><tr><td align="left">ACC_INTERFACE</td><td align="left">0x0200</td><td align="left">标志这是一个接口</td></tr><tr><td align="left">ACC_ABSTRACT</td><td align="left">0x0400</td><td align="left">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td align="left">ACC_SYNTHETIC</td><td align="left">0x1000</td><td align="left">标志这个类并非由用户代码产生</td></tr><tr><td align="left">ACC_ANNOTATION</td><td align="left">0x2000</td><td align="left">标志这是一个注解</td></tr><tr><td align="left">ACC_ENUM</td><td align="left">0x4000</td><td align="left">标志这是一个枚举</td></tr></tbody></table><p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一 律为零。</p><h3 id="1-5-类索引、父类索引与接口索引集合"><a href="#1-5-类索引、父类索引与接口索引集合" class="headerlink" title="1.5 类索引、父类索引与接口索引集合"></a>1.5 类索引、父类索引与接口索引集合</h3><p>类索引、父类索引与接口索引集合都是u2类型的，其中接口索引集合是一组u2类型的数据集合</p><p> 这三者通常用来确定类的继承关系。</p><ul><li>类索引用于确定这个<strong>类的全限定名</strong>。</li><li>父类索引用于确定这个类的<strong>父类的全限定名</strong>。</li><li>由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了 java.lang.Object外，所有Java类的父类索引都不为0。</li></ul><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字后的接口顺序从左到右排列在接口索引集合中。</p><p>注：同之前的常量池计数器类似，接口索引集合，入口第一项有u2类型的数据类型的接口计数器，表示索引表的容量。</p><h3 id="1-6-字段表集合"><a href="#1-6-字段表集合" class="headerlink" title="1.6 字段表集合"></a>1.6 字段表集合</h3><p>接口索引结束后，接着是字段表（field_info），</p><ul><li>字段表用于<strong>描述接口或者类中声明的变量</strong>——这里的<code>字段（Field）</code>只包括类级变量以及实例级变量，不包括在方法内部声明的局部变量。</li><li>字段的名字、被定义成了什么数据类型，这些都是无法确定的，因此通常引用常量池中的常量进行描述。</li></ul><p>描述的主要信息包括：</p><p>①字段的作用域（public，protected，private修饰）</p><p>②是类级变量还是实例级变量（static修饰）</p><p>③是否可变（final修饰）</p><p>④并发可见性（volatile修饰，是否强制从主从读写）</p><p>⑤是否可序列化（transient修饰）</p><p>⑥字段数据类型（8种基本数据类型，对象，数组等引用类型）</p><p>⑦字段名称</p><p>字段表的结构如下：</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">access_flags</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">name_index</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">descriptor_index</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">1</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">attributes_count</td></tr></tbody></table><ul><li><p>access_flags是该字段的的访问标志，它和类中的访问标志很类似，用以描述该字段的权限类型：private、protected、public；并发可见性：volatile；可变性：final；</p><p>访问标志详情如下图所示：</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UduXic7S3xQCVhIzSdMbLhibFcH5TFYFiboZpqKFCnreC1wJrYlurZMDQdibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210419220242129</p><p>​        由于Java语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p><ul><li>name_index：表示字段的简单名称（简单名称是指没有类型或者参数修饰的方法名称或者字段名称）</li><li>descriptor_index：表示方法描述符（描述符的作用是用来描述字段的数据类型、方法和参数列表、返回值）</li></ul><h3 id="1-7-方法表集合"><a href="#1-7-方法表集合" class="headerlink" title="1.7 方法表集合"></a>1.7 方法表集合</h3><p>方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，如表所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UdulDhchdsVJJ5dZeUW7Bo1vmFJZ3LDQiciauMZzCNicbecEwPhrw023eKcQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210419220451611</p><p>有区别的部分只有方法访问标志<code>access_flag</code>, 因为volatile关键字和transient关键字不能修饰方法。</p><p>方法表标志位及其取值如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UdugF5AVhuOsYwP4bcZ3wdWB5ohQX84kOSppwqBWnVlm9h5y290LTgo3A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210419220603688</p><h3 id="1-8-属性表集合"><a href="#1-8-属性表集合" class="headerlink" title="1.8 属性表集合"></a>1.8 属性表集合</h3><p>接下来终于到了最后一项：属性表集合。</p><p>前面提到的Class文件、字段表、方法表都可以携带自己的属性表集合，就是引用的这里。</p><p>属性表集合中的属性如下所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UdukL2ZicOJVWhOWxV66ibys8yt6icMGxQ7UQLGcUYdH90L8yX03PYyGgVGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210419220806085</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfOTibyJzLhdKfDIJ0Sd9UduZg0bmic9vXt3mq1gTKicPVTjnYRFYr6PI23rKbI9vbrKhXWSSIYmib0yQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image-20210419220927662</p><p> 属性表集合的属性在此不做过多介绍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Class文件结构&quot;&gt;&lt;a href=&quot;#Class文件结构&quot; class=&quot;headerlink&quot; title=&quot;Class文件结构&quot;&gt;&lt;/a&gt;Class文件结构&lt;/h1&gt;&lt;p&gt;Java虚拟机和字节码文件存储格式是Java实现语言无关性的基础。&lt;/p&gt;
&lt;p&gt;J</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-故障处理工具</title>
    <link href="http://example.com/2022/03/28/JVM-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2022/03/28/JVM-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-03-28T03:07:06.000Z</published>
    <updated>2022-03-30T13:04:26.338Z</updated>
    
    <content type="html"><![CDATA[<p> 下面我们将从实践的角度去认识虚拟机内存管理的世界。</p><p>工具是处理数据的手段。恰当地使用虚拟机故障处理、分析的工具可以提升我们分析数据、定位并解决问题的效率。</p><h2 id="一、基本故障处理工具"><a href="#一、基本故障处理工具" class="headerlink" title="一、基本故障处理工具"></a>一、基本故障处理工具</h2><p>我们都知道JDK的bin目录中有java.exe、javac.exe这两个命令行工具</p><p>与此同时java的bin目录下还有其他各种小工具。</p><p> 随着jdk版本的更迭，这些小工具的数量和功能也在不知不觉地增加与增强。除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到它们，</p><p>下面介绍常见的小工具，以便更好地使用它们。</p><p>这些工具主要分成三类：</p><ul><li>商业授权工具：主要是JMC（Java Mission Control）及它要使用到的JFR（Java Flight Recorder），在商业环境中使用它则是要付费的</li><li>正式支持工具：这一类工具属于被长期支持的工具，不同平台、不同版本的JDK之间，这类工具可能会略有差异</li><li>实验性工具：“没有技术支持，并且是实验性质的”，即不是正式支持的实验性质工具。</li></ul><p>下面介绍常见的工具，以jdk1.5版本为例。</p><h3 id="1-1-jps"><a href="#1-1-jps" class="headerlink" title="1.1 jps"></a>1.1 jps</h3><p>jps（JVM Process Status Tool）</p><p>它的功能也和ps命令类似：</p><ul><li><p>可以列出正在运行的虚拟机进程，</p></li><li><p>显示虚拟机执行主类（MainClass，main()函数所在的类）名称</p></li><li><p>这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。</p></li></ul><p>是使用频率最高的JDK命令行工具。</p><p>因为对于本地虚拟机进程来说，他查询到的 LVMID与操作系统的进程ID（PID，Process Identifier）是一致的。</p><p>jps命令格式：</p><p>​            <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328113322493.png" alt="image-20220328113322493"></p><p>jps的其他参数:</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328113353009.png" alt="image-20220328113353009"></p><h3 id="1-2-jstat"><a href="#1-2-jstat" class="headerlink" title="1.2  jstat"></a>1.2  jstat</h3><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具</p><p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328114027797.png" alt="image-20220328114027797"></p><ul><li><p>VMID与LVMID：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328114512070.png" alt="image-20220328114512070"></li></ul></li><li><p>interval：查询间隔</p></li><li><p>count：查询次数</p></li></ul><p>常见参数：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328114244733.png" alt="image-20220328114244733"></p><h3 id="1-3-jinfo"><a href="#1-3-jinfo" class="headerlink" title="1.3 jinfo"></a>1.3 jinfo</h3><p>jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。</p><p>使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值， 就得使用jinfo的-flag选项进行查询了。</p><p>命令格式：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328114813425.png" alt="image-20220328114813425"></p><h3 id="1-4-jmap"><a href="#1-4-jmap" class="headerlink" title="1.4 jmap"></a>1.4 jmap</h3><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。</p><p>jmap的作用并不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列、Java堆和方法区的详细信息。</p><p>和jinfo命令一样，jmap有部分功能在Windows平台下是受限的（除了-dump和-histo选项，剩下的只能在linux中使用）</p><p>命令格式：</p><p>​            <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328115222432.png" alt="image-20220328115222432"></p><p>主要选项：<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328115236286.png" alt="image-20220328115236286"></p><h3 id="1-5-jhat"><a href="#1-5-jhat" class="headerlink" title="1.5 jhat"></a>1.5 jhat</h3><p>JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照</p><p>内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。</p><p>在实际工作环境中，并不常用。</p><h3 id="1-6-堆栈跟踪器"><a href="#1-6-堆栈跟踪器" class="headerlink" title="1.6 堆栈跟踪器"></a>1.6 堆栈跟踪器</h3><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）</p><p>目的通常是<strong>定位线程出现长时间停顿的原因</strong>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等</p><p>命令格式：</p><p>​            <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328115721080.png" alt="image-20220328115721080"></p><p>主要选项：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328115744490.png" alt="image-20220328115744490"></p><p>上面只介绍了几种基础的工具，当然jdk中还有很多的工具同样十分有用。在此不进行过多介绍。</p><h2 id="二、可视化故障处理工具"><a href="#二、可视化故障处理工具" class="headerlink" title="二、可视化故障处理工具"></a>二、可视化故障处理工具</h2><p>之前的都是命令行操作的工具。</p><p>同时jdk还集成了几个功能集成度更高的可视化工具。</p><p>有：JConsole、JHSDB、VisualVM和JMC四个</p><p>下面主要介绍VisualVM。</p><ul><li>VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一。</li></ul><p><strong>1.VisualVM兼容范围与插件安装</strong></p><p>VisualVM基于NetBeans平台开发工具，VisualVM基于NetBeans平台开发工具。</p><p>有了插件扩展支持，VisualVM可以做到：</p><p>·显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</p><p>·监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（jstat、jstack）。</p><p>·dump以及分析堆转储快照（jmap、jhat）。</p><p>·方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</p><p>·离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</p><p> VisualVM主要功能兼容性列表：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220328121114595.png" alt="image-20220328121114595"></p><p>首次启动VisualVM的时候没有继承任何插件。</p><p>VisualVM的插件可以手工进行安装。</p><p><strong>2.生成、浏览堆转储快照</strong></p><p>在VisualVM中生成堆转储快照文件有两种方式，可以执行下列任一操作：</p><p>·在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”。</p><p>·在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签中单击“堆Dump”。</p><p>之后可以对生成的转储快照进行保存。通过文件菜单的装入功能进行导入快照文件。</p><p><strong>3.分析程序性能</strong></p><p>在Profiler页签中，VisualVM提供了程序运行期间方法级的处理器执行时间分析以及内存分析</p><p>更多使用方法：<a href="https://www.cnblogs.com/avivaye/p/10515259.html"><a href="https://www.cnblogs.com/avivaye/p/10515259.html"> IDEA集成VisualVM</a></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 下面我们将从实践的角度去认识虚拟机内存管理的世界。&lt;/p&gt;
&lt;p&gt;工具是处理数据的手段。恰当地使用虚拟机故障处理、分析的工具可以提升我们分析数据、定位并解决问题的效率。&lt;/p&gt;
&lt;h2 id=&quot;一、基本故障处理工具&quot;&gt;&lt;a href=&quot;#一、基本故障处理工具&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-垃圾回收</title>
    <link href="http://example.com/2022/03/26/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/03/26/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-03-26T03:30:01.000Z</published>
    <updated>2022-03-30T13:05:40.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><p>java 中堆和方法区这两个区域有很明显的不确定性。内存的回收不随着线程的生命周期而进行。</p><p>程序编译期不能确定内存的分配和垃圾的回收。因为他们是动态的，在运行期间才会知道创建哪些创建多少对象。垃圾回收器关注的正是这部分内存。</p><p>关于垃圾回收，主要分以下几点进行介绍：</p><p>\1. 如何判断对象可以回收</p><p>\2. 垃圾回收算法</p><p>\3. 分代垃圾回收</p><p>\4. 垃圾回收器</p><p>\5. 垃圾回收调优</p><p>主要思考一下三个问题：</p><p>哪些内存需要回收？</p><p>什么时候回收</p><p>怎么回收？</p><h3 id="一、如何判断对象是否可以回收"><a href="#一、如何判断对象是否可以回收" class="headerlink" title="一、如何判断对象是否可以回收"></a>一、如何判断对象是否可以回收</h3><h4 id="1-1引用计数法"><a href="#1-1引用计数法" class="headerlink" title="1.1引用计数法"></a>1.1引用计数法</h4><p>引用计数法是给每个对象添加一个引用计数器，每当有一个计数器引用它，就把标记加一。</p><p>这种方法很简单易行，但是也有局限性。</p><p>引用计数法对于对象之间的循环引用问题，无法进行及时的回收，容易造成内存泄漏。</p><p>循环引用：即两个对象相互引用，各自的标记都。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326113529107.png" alt="image-20220326113529107"></p><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>java虚拟机使用的垃圾回收策略来探索是否有存货的对象。</p><p>根对象：一定不会被回收的对象</p><ul><li><p>扫描堆中的对象，看是否能沿着GC Root对象为七起点的引用链来找到该对象（说明被root对象引用），找不到的话，就可以进行回收。</p></li><li><p>哪些对象可以作为root对象呢？</p><ul><li>虚拟机运行中需要的系统核心类</li><li>操作系统运行引用的Java对象</li><li>Busy Monitor ：正在加锁的对象</li><li>活动进程中的对象</li></ul></li></ul><h4 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h4><p>无论是通过引用计数法判断对象引用的数量，还是可达性分析判断对象是否链可达，判定对象是否存活都和引用离不开关系。</p><p>jdk1.2之后对引用进行了细化。引用强度主键弱化。</p><p>1.强引用</p><p>​    平常所用的引用，例如对象的创建，强引用只要沿着GC root找到就不会被垃圾回收，只有没有GC root直接或者间接引用才会被垃圾回收。</p><p>2.软引用</p><p>​    用来描述一些还有用的，但是非必须的对象。</p><p>​    仅有软引用引用该对象时，在垃圾回收后，会把对象列进内存回收的范畴之内，内存仍不足时会再次出发垃圾回收，进行回收软引用对象。</p><p>​    可以配合引用队列来释放软引用自身。</p><p>​     </p><p>3.弱引用</p><p>​    被弱引用关联的对象只能生存到下一次垃圾收集发生之前</p><p>​    仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><p>​    可以配合引用队列来释放弱引用自身</p><p>4.虚引用</p><p>​    它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>​    <strong>必须配合引用队列使用</strong>，主要配合 ByteBuffffer 使用，被引用对象回收时，会将虚引用加入，</p><p>由 引用队列中的 Reference Handler 线程调用虚引用相关方法（UNsafe.freeMemory）释放直接内存。</p><p>注：对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</p><p>​    如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，稍后由Finalizer线程去执行它</p><p>5.终结器引用</p><p>​    无需手动编码，但其内部<strong>配合引用队列使用</strong>，在垃圾回收时，终结器引用入队（被引用对象</p><p>暂时没有被回收），再由 Finalizer 线程(线程优先级很低)通过终结器引用找到被引用对象并调用它的 fifinalize方法，第二次 GC 时才能回收被引用对象。</p><p>特别注意，在程序设计中⼀般很少使⽤弱引⽤与虚引⽤，使⽤软引⽤的情况᫾多，这是因为<strong>软引⽤可以</strong> <strong>加速</strong>JVM 对垃圾内存的回收速度，可以维护系统的运⾏安全，防⽌内存溢出（ OutOfMemory ）等问题的产生</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326114854831.png" alt="image-20220326114854831"></p><p>下面是来看个：</p><p>软引用对象的创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void soft() &#123;</span><br><span class="line">    // list --&gt; SoftReference --&gt; byte[]</span><br><span class="line"></span><br><span class="line">    List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;循环结束：&quot; + list.size());</span><br><span class="line">    for (SoftReference&lt;byte[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//内存中不重要的对象可以使用软引用</span><br></pre></td></tr></table></figure><p>运行结果可以看到，前四个软引用内存不足时都被垃圾回收了</p><p>（设置VM参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc）</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326120220651.png" alt="image-20220326120220651"></p><p>之前我们知道，软引用被回收之后，软引用本身也占用内存，需要使用引用队列进行回收。</p><p>正如上例，前四个软引用对象都是null了。可以把它们从List中去除。</p><p>下面使用引用队列演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示软引用, 配合引用队列</span><br><span class="line"> */</span><br><span class="line">public class Demo2_4 &#123;</span><br><span class="line">    private static final int _4MB = 4 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 引用队列</span><br><span class="line">        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br><span class="line">            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 从队列中获取无用的 软引用对象，并移除</span><br><span class="line">        Reference&lt;? extends byte[]&gt; poll = queue.poll();</span><br><span class="line">        while( poll != null) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===========================&quot;);</span><br><span class="line">        for (SoftReference&lt;byte[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用对象创建和垃圾回收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示弱引用</span><br><span class="line"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="line"> */</span><br><span class="line">public class Demo2_5 &#123;</span><br><span class="line">    private static final int _4MB = 4 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //  list --&gt; WeakReference --&gt; byte[]</span><br><span class="line">        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            for (WeakReference&lt;byte[]&gt; w : list) &#123;</span><br><span class="line">                System.out.print(w.get()+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;循环结束：&quot; + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326121701031.png" alt="image-20220326121701031"></p><h3 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h3><p>之前讨论了什么对象应该被回收。</p><p>那么垃圾对象需要怎么回收呢？</p><h4 id="2-1-垃圾收集理论"><a href="#2-1-垃圾收集理论" class="headerlink" title="2.1 垃圾收集理论"></a>2.1 垃圾收集理论</h4><p>根据对象存活周期的不</p><p>同将内存分为⼏块。⼀般将java堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的特点选择合适</p><p>的垃圾收集算法。</p><p><strong>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制</strong></p><p><strong>成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分</strong></p><p> <strong>配担保，所以我们必须选择标记清除和标记整理算法</strong>  </p><p>分代收集理论：大多数虚拟机都遵循了这个理论。它建立在两个假说之上：</p><ul><li>弱分代假说：绝大多数对象都是招生夕灭。</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p>因此垃圾收集器的一致性设计原则：收集器应该将java堆分成不同的区域，将回收对象依据年龄分配到不同的区域进行存储。</p><p>垃圾收集器因此可以回收其中某一个或者某些部分区域。因此有了Minor GC、MajorGC、Full GC 这样的回收类型划分。</p><p>设计者通常把内存区域分成新生代和老年代两个区域。</p><p>因此针对不同区域安排与存储对象存亡特性相匹配的垃圾回收算法</p><p>主要的垃圾回收算法有：标记清除法、标记整理法、标记复制法</p><p>这里区分一些常见概念：</p><ul><li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p></li><li><p>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</p></li><li><p>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</p></li><li><p>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</p></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p></li></ul><h4 id="2-1标记清除"><a href="#2-1标记清除" class="headerlink" title="2.1标记清除"></a>2.1标记清除</h4><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326122731856.png" alt="image-20220326122731856" style="zoom:50%;" /><p>优点：速度快，只需要进行标记，不用做出其他的操作。</p><p>缺点：会造成空间不连续，如过没有，回收之后的空间整理，会造成内存碎片。</p><p>​            执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低。</p><h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a><strong>2.2</strong> <strong>标记整理</strong></h4><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326122715110.png" alt="image-20220326122715110" style="zoom: 50%;" /><p>和标记清除的区别是：</p><p>优点：不会有内存碎片</p><p>缺点：整理的过程伴随着对象的移动。对象在内存中的地址变化了。会有额外的开销。</p><h4 id="2-3-复制算法"><a href="#2-3-复制算法" class="headerlink" title="2.3 复制算法"></a>2.3 复制算法</h4><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326122832151.png" alt="image-20220326122832151" style="zoom:50%;" /><p>优点：不会有内存碎片</p><p>缺点：空间利用率不高。</p><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代</p><h3 id="三、分代垃圾回收"><a href="#三、分代垃圾回收" class="headerlink" title="三、分代垃圾回收"></a>三、分代垃圾回收</h3><p>实际的jvm虚拟机不使用一种垃圾回收算法，整合三种算法。</p><p>把堆内存分成两个区域：新生代、老年代</p><p>新生代：存放引用时间短的，生命周期短的对象。</p><p>老年代：引用时间长，垃圾回收频率不频繁。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326123605077.png" alt="image-20220326123605077"></p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>分成伊甸园 、幸存区From、幸存区to</p><p>新创建的对象首先放到伊甸园中</p><p>第一次垃圾回收：出发 Minor GC</p><p>没被回收的对象放到幸存区To中，之后两个幸存区交换地址。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326123616814.png" alt="image-20220326123616814"></p><ul><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的</p></li></ul><p>对象年龄加 1并且交换 from to。</p><ul><li><p>下一次的 minor gc 会回收伊甸园和幸存区from中的对象。对象年龄继续加一，并且交换 from to。</p></li><li><p>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。（垃圾回收涉及对象空间的复制，地址会发生改变。为了防止混乱，需要阻塞其他进程）</p></li><li><p>如果经历了多次的垃圾回收，当对象寿命超过阈值时，会晋升至<strong>老年代</strong>，最大寿命是15（4bit）。</p></li></ul><ul><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时</li></ul><p>间更长</p><h4 id="3-1-相关VM参数"><a href="#3-1-相关VM参数" class="headerlink" title="3.1 相关VM参数"></a>3.1 相关VM参数</h4><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326140529222.png" alt="image-20220326140529222"></p><h3 id="四、经典垃圾回收器"><a href="#四、经典垃圾回收器" class="headerlink" title="四、经典垃圾回收器"></a>四、经典垃圾回收器</h3><p>垃圾回收器是内存回收的实践者。</p><p>常见的有：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326201351214.png" alt="image-20220326201351214"></p><h4 id="4-1-串行-Serial收集器"><a href="#4-1-串行-Serial收集器" class="headerlink" title="4.1 串行 Serial收集器"></a>4.1 串行 Serial收集器</h4><ul><li><p>单线程</p></li><li><p>适用于堆内存较小，适合个人电脑</p></li></ul><p>它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p>它只会使用一个处理器或一条收集线程去完成垃圾收集工作</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326201613444.png" alt="image-20220326201613444"></p><p>优点：简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的</p><h4 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a>4.2 ParNew收集器</h4><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop TheWorld、对象分配规则、回收策略等都与Serial收集器完全一致</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326202310963.png" alt="image-20220326202310963"></p><p>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>因此为了配合CMS 使用，Parnew依旧很常用。</p><h4 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a>4.3 Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器</p><p>Parallel Scavenge的诸多特性从表面上看和ParNew非常相似</p><p> Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）</p><p>也就是吞吐量优先的收集器。</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326202604589.png" alt="image-20220326202604589" style="zoom: 50%;" /><h4 id="4-4-CMS收集器"><a href="#4-4-CMS收集器" class="headerlink" title="4.4 CMS收集器"></a>4.4 CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>现在很多应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p><p>整个回收过程包括：</p><p>1）初始标记（CMS initial mark）</p><p>2）并发标记（CMS concurrent mark）</p><p>3）重新标记（CMS remark）</p><p>4）并发清除（CMS concurrent sweep）</p><p>其中初始标记、重新标记这两个步骤仍然需要“Stop TheWorld</p><p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并</p><p>发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</p><p>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</p><p>并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p><p>CMS收集器的运作步骤中并发和需要停顿的阶段：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326211101219.png" alt="image-20220326211101219"></p><p>优点：并发收集、低停顿</p><p> 缺点：CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。</p><p>​            CMS收集器对处理器资源非常敏感。会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量</p><h4 id="4-5-G1回收器"><a href="#4-5-G1回收器" class="headerlink" title="4.5 G1回收器"></a>4.5 G1回收器</h4><p>定义：Garbage First</p><p>2004 论文发布</p><p>2009 JDK 6u14 体验</p><p>2012 JDK 7u4 官方支持</p><p>2017 JDK 9 默认</p><p>适用场景</p><ul><li><p>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</p></li><li><p>超大堆内存，会将堆划分为多个大小相等的 Region</p></li><li><p>整体上是 标记+整理 算法，两个区域（region）之间是 复制 算法</p></li><li><p>G1是一款主要面向服务端应用的垃圾收集器</p></li><li><p>JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</p></li><li><p>G1收集器的运作⼤致分为以下⼏个步骤：</p><p>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p><p>·并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p><p>·最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p><p>·筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p></li></ul><p> <strong>G1</strong>收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的* region这也就是它的名字 Garbage-First 的由来 。这种使⽤Region划分内存空间以及有优先级的区域回收⽅式，</p><p>保证了GF收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。</p><p>1、G1  <strong>垃圾回收阶段</strong></p><p>这里介绍三个阶段：</p><ul><li>对新生代的垃圾回收期</li><li>新生代的垃圾收集同时执行并发标记</li><li>混合收集</li><li>如下图所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220326184024543.png" alt="image-20220326184024543"></p><p><strong>1) Young Collection</strong></p><p>会 STW</p><p>2）Young Collection + CM</p><p>在 Young GC 时会进行 GC Root 的初始标记</p><p>老年代占用<strong>堆空间</strong>比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</p><p> XX:InitiatingHeapOccupancyPercent=percent （默认45%）</p><p><strong>3)  Mixed Collection</strong></p><p>会对 E、S、O 进行全面垃圾回收</p><p>最终标记（Remark）会 STW</p><p>拷贝存活（Evacuation）会 STW</p><p>-XX:MaxGCPauseMillis=ms</p><p><strong>4）Full GC</strong></p><p>SerialGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p>ParallelGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p>CMS</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><p>G1</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><p><strong>5) Young Collection</strong> <strong>跨代引用</strong></p><p>新生代回收的跨代引用（老年代引用新生代）问题</p><p>卡表与 Remembered Set</p><p>在引用变更时通过 post-write barrier + dirty card queue </p><p>concurrent refinement threads 更新 Remembered Set</p><p>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p><p><strong>6) Remark</strong></p><p>pre-write barrier + satb_mark_queue</p><p>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p><p><strong>7) JDK 8u20</strong> <strong>字符串去重</strong></p><p>优点：节省大量内存</p><p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p><p>-XX:+UseStringDeduplication</p><p>将所有新分配的字符串放入一个队列</p><p>当新生代回收时，G1并发检查是否有字符串重复</p><p>如果它们值一样，让它们引用同一个 char[]</p><p>注意，与 String.intern() 不一样</p><p>String.intern() 关注的是字符串对象</p><p>而字符串去重关注的是 char[]</p><p>在 JVM 内部，使用了不同的字符串表</p><p><strong>8) JDK 8u40</strong> <strong>并发标记类卸载</strong></p><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸</p><p>载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用</p><p>String s1 = new String(“hello”); // char[]{‘h’,’e’,’l’,’l’,’o’} </p><p>String s2 = new String(“hello”); // char[]{‘h’,’e’,’l’,’l’,’o’}</p><p>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p><p><strong>9) JDK 8u60</strong> <strong>回收巨型对象</strong></p><p>一个对象大于 region 的一半时，称之为巨型对象</p><p>G1 不会对巨型对象进行拷贝</p><p>回收时被优先考虑</p><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生</p><p>代垃圾回收时处理掉</p><p><strong>10) JDK 9</strong> <strong>并发标记起始时间的调整</strong></p><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</p><p>JDK 9 可以动态调整</p><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p><p>进行数据采样并动态调整</p><p>总会添加一个安全的空档空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;垃圾回收&quot;&gt;&lt;a href=&quot;#垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收&quot;&gt;&lt;/a&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;java 中堆和方法区这两个区域有很明显的不确定性。内存的回收不随着线程的生命周期而进行。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM-内存结构</title>
    <link href="http://example.com/2022/03/25/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/03/25/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-25T04:03:30.000Z</published>
    <updated>2022-03-25T14:17:31.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>java的内存结构可以分成</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220325164905689.png" alt="image-20220325164905689"></p><p>\1. 程序计数器</p><p>\2. 虚拟机栈</p><p>\3. 本地方法栈</p><p>\4. 堆</p><p>\5. 方法区</p><p>下面逐一进行介绍：</p><h3 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h3><p>功能：程序分配时间片执行，一个程序由于时间片用完或其他原因导致执行下一条程序，用程序计数器记住下一条jvm指令执行地址</p><p>发送给解释器执行，生成机器码文件，由CPU进行执行。</p><ul><li>物理上通过寄存器实现。（加快读写速度）</li></ul><p>特点：</p><ul><li>线程私有的，为了线程切换之后能够回到正确的执行位置，每一个线程都应该有一个独立的程序计数器。</li><li>没有程序溢出</li></ul><h3 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h3><p>栈的操作有入栈出栈，后进先出，先进后出的逻辑结构。</p><p>栈</p><ul><li>Java会为每个线程分配的内存空间，每一个线程对应一个虚拟机栈。虚拟机栈的生命周期和线程是相同的。</li></ul><p>栈帧</p><ul><li>每个方法执行的时候，虚拟机都会同步创建一个栈帧。栈帧就是每个方法运行时需要的内存。</li><li>栈帧包含局部变量表、动态链接、返回地址（方法出口）等信息。</li><li>一个方法执行，定义一个栈帧，并且压入栈内。</li></ul><p>注：</p><p>​    局部变量表存放了各种java基本数据类型、对象指针、ReturnAdress类型。局部变量表所需内存在编译时分配，执行方法之前</p><p>其分配的局部变量空间就已经确定。</p><p>​    每个线程运行时只能有一个活动栈帧（对应正在执行的那个方法）</p><p>常见问题：</p><ul><li><p>垃圾回收只设计堆的内存，不涉及虚拟机栈的内存回收，栈会自动得回收掉。</p></li><li><p>栈内存不是越大越好，栈越大通常只能增加方法调用数量，同时会影响线程数量（物理内存是一定的）</p></li><li><p>方法内的局部变量，如果是多个线程共享的，那么就可能是线程不安全的，如果是被某个线程私有就是线程安全的，不受其他线程影响。</p><p>方法内的局部变量如果逃离了方法的作用范围，就会是线程不安全的。</p></li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><p>引起原因：</p><ul><li><p>栈帧过多（例如：方法的递归调用）</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220325162055182.png" alt="image-20220325162055182"></p></li><li><p>栈帧过大（不常见）：栈帧的太大超过了栈的大小</p></li></ul><p>报错显示：java.lang.StackOverflowError</p><h4 id="2-3线程运行诊断"><a href="#2-3线程运行诊断" class="headerlink" title="2.3线程运行诊断"></a>2.3线程运行诊断</h4><p>定位： </p><p>​        top 定位线程对于cpu的占用过高</p><ul><li>ps ：定位具体哪个线程的占用cpu情况</li><li>jstack + 线程 nid  ：显示具体线程信息，进行诊断<ul><li>根据线程id找到相关线程，最后找到相应代码行数。</li></ul></li></ul><h3 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h3><p>java代码运行时，为本地方法分配的内存空间。</p><p>本地方法：通过c或者c++编写的方法，方便和操作系统更好的进行交互。</p><ul><li>和虚拟机栈类似，不同点在于，本地方法栈是为了虚拟机使用到本地方法。</li><li>会出现栈溢出情况</li></ul><h3 id="四、堆"><a href="#四、堆" class="headerlink" title="四、堆"></a>四、堆</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>之前讲解的都是线程私有的。</p><p>堆是为所有线程共享的一片内存区域，因此需要考虑线程安全的问题。</p><p>有垃圾回收机制，回收堆中不在引用的对象。</p><p>创建目的：存放对象实例和数组。</p><ul><li>java堆可以存放在不连续的内存空间，但是逻辑上应该是连续的。</li></ul><h4 id="4-2-堆空间内存溢出"><a href="#4-2-堆空间内存溢出" class="headerlink" title="4.2 堆空间内存溢出"></a>4.2 堆空间内存溢出</h4><p>报错显示：java.lang.OutofMemoryError</p><p>如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1_5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            String a = &quot;hello&quot;;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(a); // hello, hellohello, hellohellohellohello ...</span><br><span class="line">                a = a + a;  // hellohellohellohello</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改堆空间大小：例如：-Xmx128M</p><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><ol><li>jps 工具</li></ol><ul><li>查看当前系统中有哪些 java 进程</li></ul><ol start="2"><li>jmap 工具</li></ol><ul><li>查看堆内存占用情况 jmap - heap 进程id</li></ul><ol start="3"><li>jconsole 工具</li></ol><ul><li>图形界面的，多功能的监测工具（监控堆内存，线程等），可以连续监测</li></ul><h3 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>java所有虚拟机线程共享的区域，存储了虚拟机加载的和类有关的数据：包括类型信息、常量、成员方法、构造器方法、方法数据、Field等。</p><ul><li>jvm启动时就被创建。</li><li>HotSpot在jdk1.6之前使用永久代来实现方法区，之后把存放在永久代中的字符串常量池和静态变量等移出，在本地内存中实现元空间代替。 </li></ul><h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>下图所示，在内存区中的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220325182024256.png" alt="image-20220325182024256"></p><p>jdk1.8之后方法区移到了本地内存中，不在JVM 中。串池StringTable移到了Heap中。</p><h4 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出"></a>5.3 方法区内存溢出</h4><p>1.8 以前会导致永久代内存溢出</p><p>1.8 之后会导致元空间内存溢出</p><p>由于原空间存放在内存之中，因此溢出效果并不容易发生。</p><p>演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace </p><p>因此设置内存方法区大小：  -XX:MaxMetaspaceSize=8m</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import jdk.internal.org.objectweb.asm.ClassWriter;</span><br><span class="line">import jdk.internal.org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="line"> * -XX:MaxMetaspaceSize=8m</span><br><span class="line"> */</span><br><span class="line">public class Demo1_8 extends ClassLoader &#123; // 可以用来加载类的二进制字节码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Demo1_8 test = new Demo1_8();</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++, j++) &#123;</span><br><span class="line">                // ClassWriter 作用是生成类的二进制字节码</span><br><span class="line">                ClassWriter cw = new ClassWriter(0);</span><br><span class="line">                // 版本号， public， 类名, 包名, 父类， 接口</span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">                // 返回 byte[]</span><br><span class="line">                byte[] code = cw.toByteArray();</span><br><span class="line">                // 执行了类的加载</span><br><span class="line">                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); // Class 对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会出现错误：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220325184305894.png" alt="image-20220325184305894"></p><p>发生场景：Spring 、MyBatis</p><h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>是方法区的一部分。</p><p>Class文件除了有类的版本、字段、方法、接口等信息，还有一项信息是常量池表，（Constant pool Table），存放编译期生成的字面量和符号引用。在类加载之后存放到运行常量池中</p><p>下面来看一个实例：</p><p>使用javac 反编译  </p><p> 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）</p><p>例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public cn.itcast.jvm.t5.HelloWorld();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String hello world</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</p><p>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量</p><p>池 。</p><p>jdk1.6之前，运行时常量池中有个重要的组成部分：StringTable（串池）</p><h3 id="六、直接内存"><a href="#六、直接内存" class="headerlink" title="六、直接内存"></a>六、直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分，但是这部分频繁的使用。也可能导致OutOfMemoryError出现。</p><p>Java中的NIO（New Input/Output）类，引入了基于通道和缓冲区的读写方式。</p><p> 它可以直接使⽤ Native 函数库直接分配堆外内存，然后通过⼀个存储在Java 堆中的 DirectByteBuffer 对象作为这块内存的引⽤进⾏操作。这样就能在⼀些场景中显著提⾼性能，因为<strong>避免了在</strong> <strong>Java</strong> <strong>堆和</strong> <strong>Native</strong> <strong>堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存⼤⼩以及处理器寻址空间的限制</p><h3 id="七、Java对象的创建"><a href="#七、Java对象的创建" class="headerlink" title="七、Java对象的创建"></a>七、Java对象的创建</h3><p>有了上面的基本了解。下面介绍一下java对象的创建。</p><p>下图是Java 对象的创建过程，：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220325214537864.png" alt="image-20220325214537864"></p><ul><li><p>类加载检查：⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p></li><li><p>分配内存： 虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。分配⽅式有指针碰撞”和 “空闲列表” 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽ Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。 </p></li><li><p>内存分配完成之后，虚拟机将分配的内存空间都设置成初始化成0。</p></li><li><p>还要对对象进行必要的设置。这些信息存放在对象头中。根据虚拟机的状态不同会有不同的设置方式。</p></li><li><p>执行init(),按照程序员的意愿进行初始化。（设置相关字段和其他资源、状态信息）</p></li></ul><p>关于类的创建还要掌握的是：</p><p><strong>1、</strong>内存分配的两种⽅式：（补充内容，需要掌握） </p><p>选择以上两种⽅式中的哪⼀种，取决于 Java 堆内存是否规整。⽽ Java 堆内存是否规整，取决于 GC</p><p>收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内</p><p>存也是规整的</p><p><strong>2、</strong>内存分配并发问题</p><p>在创建对象的时候有⼀个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的</p><p>事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采⽤两种⽅式来保证线程安全：</p><p>**CAS+**失败重试：CAS 是乐观锁的⼀种实现⽅式。所谓乐观锁就是，每次不加锁⽽是假设没有冲</p><p>突⽽去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。<strong>虚拟机采⽤</strong> <strong>CAS</strong> <strong>配上失败重</strong></p><p><strong>试的⽅式保证更新操作的原⼦性。</strong></p><p><strong>TLAB</strong>： 为每⼀个线程预先在Eden区分配⼀块⼉内存，JVM在给线程中的对象分配内存时，⾸先在</p><p>TLAB分配，当对象⼤于TLAB中的剩余内存或TLAB的内存已⽤尽时，再采⽤上述的CAS进⾏内存分</p><p>配 </p><p><strong>③</strong>初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象</p><p>头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这</p><p>些字段的数据类型所对应的零值。</p><p><strong>④</strong>设置对象头：初始化零值完成之后，<strong>虚拟机要对对象进⾏必要的设置</strong>，例如这个对象是那个类的实</p><p>例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对</strong></p><p><strong>象头中。</strong> 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅</p><p>式。</p><p>⑤执⾏ <strong>init</strong> <strong>⽅法：</strong> 在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从</p><p>Java 程序的视⻆来看，对象创建才刚开始， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀</p><p>般来说，执⾏ new 指令之后会接着执⾏ <init> ⽅法，把对象按照程序员的意愿进⾏初始化，这样</p><p>⼀个真正可⽤的对象才算完全产⽣出来。</p><p><strong>3、对象的访问定位有哪两种⽅式?</strong></p><p>建⽴对象就是为了使⽤对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对</p><p>象的访问⽅式有虚拟机实现⽽定，⽬前主流的访问⽅式有 句柄和使用直接指针两种：</p><p>\1. <strong>句柄：</strong> 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存</p><p>储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息</p><p>\2. <strong>直接指针：</strong> 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型</p><p>数据的相关信息，⽽reference 中存储的直接就是对象的地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存结构&quot;&gt;&lt;a href=&quot;#内存结构&quot; class=&quot;headerlink&quot; title=&quot;内存结构&quot;&gt;&lt;/a&gt;内存结构&lt;/h2&gt;&lt;p&gt;java的内存结构可以分成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/che</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git常见操作总结</title>
    <link href="http://example.com/2022/03/21/Git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/21/Git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-21T07:09:36.000Z</published>
    <updated>2022-03-21T08:24:22.962Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220321162417377.png" alt="image-20220321162417377"></p><p>首先是简单的操作：</p><ul><li><p>git init - 初始化仓库。</p></li><li><p>git add . - 添加文件到暂存区。</p></li><li><p>git commit - 将暂存区内容添加到仓库中。</p></li><li><p>git clone -拷贝一份远程仓库，也就是下载一个项目。</p></li><li><p>git  rm   删除工作区文件。</p></li><li><p>git  commit    提交暂存区到本地仓库。</p></li><li><p>git diff     比较文件的不同，即暂存区和工作区的差异。</p></li><li><p>git status    查看仓库当前的状态，显示有变更的文件。</p></li><li><p>git  mv  移动或重命名工作区文件。</p></li><li><p>git reset – hard HEAD^   回退到当前版本之前提交的版本（一个^相当于往前一个版本）。</p></li><li><p>git reset –hard  （部分）版本号    回退到任意一个之前提交的版本</p></li><li><p>git checkout – &lt;文件路径&gt;  回退到上一个版本提交的状态（此时是没有提交的状态，相当于Ctrl + z）</p></li><li><p>git  reset HEAD  &lt;文件路径文件名&gt;  将文件撤销追踪 ，撤出暂存区。</p></li><li><p>git log -查看提交本地仓库的记录日志</p></li><li><p>git tag -创建标签 格式：git tag &lt;标签名&gt;</p><p>标签默认加到最新的一次提交上。</p><p>git tag &lt;标签名&gt;  &lt;某一次commit的ID&gt;  ：给某一次的commit添加标签</p><p>git tag -d &lt;标签名&gt; : 标签名</p></li></ul><p>远程操作：</p><ul><li><p>git remote ：远程仓库操作</p></li><li><p>git fetch  ：从远程获取代码库</p></li><li><p>git push ：本地仓库文件推送到远程仓库</p><p>例如：git push origin master</p></li><li><p>git pull：拉取远程仓库到本地。</p></li></ul><p>分支</p><ul><li><p>git branch &lt;分支名&gt; -创建分支</p><p>git branch -查看所有分支</p><p>git checkout &lt;分支名字&gt; -切换分支</p><p>git branch -d &lt;分支名称&gt;   -删除分支，注意的是不能删除当前分支。并且分支有commit操作的时候也不能删除（必须经过合并）</p><p>git branch -D &lt;分支名称&gt;  强制删除某一分支</p><p>git checkout -b &lt;分支名称&gt;  -直接创建一个新的分支并且跳转。</p></li><li><p>git merge &lt;合并的分支名&gt; </p></li></ul><p>合并冲突：</p><ul><li>git merge -abort  ：忽略其他分支，保留现在分支代码（解决合并冲突）</li></ul><p>创建 远程仓库</p><p><a href="https://www.runoob.com/git/git-remote-repo.html">GIT教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们先来理解下 Git 工作区、暂存区和版本库概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作区：&lt;/strong&gt;就是你在电脑里能看到的目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂存区：&lt;/strong&gt;英文叫 stage 或 index。一般存放在 &lt;strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/21/vim/"/>
    <id>http://example.com/2022/03/21/vim/</id>
    <published>2022-03-21T06:07:52.732Z</published>
    <updated>2022-03-21T06:07:53.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>正常模式下：</p><p>（）：移动到上一句下一句</p><p>{}：移动到上一段下一段</p><p>H/J/K/L：左上下右移动光标</p><p>gg：移动到开头行第一个字符</p><p>G：移动到文本结尾行第一个字符</p><p>命令模式下：</p><p>:0   :跳转到行首</p><p>:$   :跳转到行尾</p><p>如果444你只关心当前屏幕的话，可以快速移动光标到屏幕的顶部、中间和底部：用 H（High）、</p><p>M（Middle）和 L（Low）就可以做到。</p><h3 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h3><p>熟练掌握这些按键 </p><p>正常模式下</p><p><strong>d 加动作来进行删除</strong>（dd 删除整行）；D 则相当于 d$，删除到行尾。 </p><p><strong>c 加动作来进行修改</strong>（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模</p><p>式。</p><p><strong>s</strong>     相当于 cl，删除一个字符然后进入插入模式；</p><p><strong>S</strong>     相当于 cc，替换整行的内容。</p><p>i     在<strong>当前字符前面</strong>进入插入模式；</p><p>I     则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。</p><p>a     在<strong>当前字符后面</strong>进入插入模式；</p><p>A     相当于 $a，把光标移到行尾然后进入插入模式。</p><p>o     在当前行下方插入一个新行，然后在这行进入插入模式；</p><p>O     在当前行上方插入一个新行，然后在这行进入插入模式。</p><p>r     替换光标下的字符；</p><p>R     则进入替换模式，每次按键（直到 <Esc>）替换一个字符。</p><p>u     撤销最近的一个修改动作；</p><p>U     撤销当前行上的所有修改。</p><p><strong>文本对象选择</strong></p><p> 还有几个动作只能在 c、d、v 这样命令之后用，我们也需要学习一下。</p><p>这些选择动作的基本附加键是 a 和 i。其中，a 可以简单理解为英文单词 a，表示选定后</p><p>续动作要求的完整内容，而 i 可理解为英文单词 inner，代表后续动作要求的内容的“内</p><p>部”。 我们来看一下具体的例子。</p><p>假设有下面的文本内容：</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>;     重复最近的字符查找（f、t 等）操作</p><p>,     重复最近的字符查找操作，反方向</p><p>n     重复最近的字符串查找操作（/ 和 ?） </p><p>N     重复最近的字符串查找操作（/ 和 ?），反方向</p><p>.     重复执行最近的修改操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h1&gt;&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis-集群</title>
    <link href="http://example.com/2022/03/17/Redis-%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2022/03/17/Redis-%E9%9B%86%E7%BE%A4/</id>
    <published>2022-03-17T07:33:57.000Z</published>
    <updated>2022-03-18T06:18:22.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Redis集群是Redis提供的分布式数据库方案， 通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><p>下面重点介绍：集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息等各个方面</p><h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><p>一个Redis集群通常由多个节点（node）组成。</p><p>刚开始时节点相互独立，组建集群就要将节点连接起来。构成多节点的集群。</p><p>连接节点的命令：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318114812146.png" alt="image-20220318114812146"></p><p>通过向节点发送命令，令其与指定的ip和端口的节点握手。从而将ip和port指向的节点加入当前所在集群。</p><p>下面详细介绍启动节点的方法、与集群有关的数据结构，以及CLUSTER MEET命令的实现原理</p><h3 id="1、启动节点"><a href="#1、启动节点" class="headerlink" title="1、启动节点"></a>1、启动节点</h3><p>一个结点就是一个Redis服务器，启动时根据cluster-enabled配置选项确定是否开启集群功能。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318115229354.png" alt="image-20220318115229354"></p><p>节点会继续使用单机模式使用的所有组件</p><p>包括：</p><ul><li>使用文件事件处理器来处理命令请求和返回命令回复。</li><li>使用时间事件处理器来执行serverCron函数</li><li>继续使用数据库来保存键值对数据</li><li>继续使用数据库来保存键值对数据</li><li>继续使用发布与订阅模块来执行PUBLISH、SUBSCRIBE等命令</li><li>继续使用复制模块来进行节点的复制工作</li><li>继续使用Lua脚本环境来执行客户端输入的Lua脚本。</li><li>继续使用redisServer结构来保存服务器的状态，使用redisClient结构来保存客户端的状态</li></ul><h3 id="2、集群数据结构"><a href="#2、集群数据结构" class="headerlink" title="2、集群数据结构"></a>2、集群数据结构</h3><p>上面介绍集群使用的常规单机组建，下面介绍集群模式下特有的数据结构。</p><p>集群模式下才会用到的数据，节点将它们保存到了cluster.h/clusterNode结构、cluster.h/clusterLink结构，以及cluster.h/clusterState结构里面 </p><p><strong>clusterNode结构</strong></p><p>用来保存节点的状态（每个节点都有），</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318115843866.png" alt="image-20220318115843866" style="zoom:67%;" /><p>其中的link属性是一个<strong>clusterLink结构</strong>，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：</p><p>注：redisClient结构和clusterLink结构的有什么异同呢？</p><p>同：都有自己的套接字描述符和输入、输出缓冲区</p><p>异：redisClient结构中的套接字和缓冲区是用于连接客户端的；</p><p>​        clusterLink结构中的套接字和缓冲区则是用于连接节点的。</p><p><strong>clusterState结构</strong></p><p>每个节点都保存着一个，这个结构记录了在当前节点的视角下，集群目前所处的状态</p><h3 id="3、CLUSTER-MEET命令的实现"><a href="#3、CLUSTER-MEET命令的实现" class="headerlink" title="3、CLUSTER MEET命令的实现"></a>3、CLUSTER MEET命令的实现</h3><p>假设向节点 A 发送命令，让节点 B加入集群。</p><p>那么要经过以下流程：</p><ul><li> 节点A会为节点B创建一个clusterNode结构，将该结构添加到自己的clusterState.nodes字典里面。</li><li>节点A将根据给定的IP地址和端口号，向节点B发送一条MEET消息（message）。</li><li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点B将向节点A返回一条PONG消息。</li><li>节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li><li>节点A将向节点B返回一条PING消息。</li><li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li></ul><p>类似三次握手协议，可以对比着进行记忆。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318120552027.png" alt="image-20220318120552027"></p><h2 id="二、槽指派"><a href="#二、槽指派" class="headerlink" title="二、槽指派"></a>二、槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对</p><p>具体形式：</p><ul><li>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽。</li><li>每个键都属于这16384个槽的其中一个。</li><li>每个节点可以处理0个或最多16384个槽</li></ul><p>集群中16384个槽只要有一个没有得到处理，那么集群就处于下线状态。（fail）。</p><p><strong>命令</strong></p><p>槽指派通过向节点发送CLUSTER ADDSLOTS命令，一个节点可以指多个槽。</p><p>举例：<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121224118.png" alt="image-20220318121224118" style="zoom:80%;" /></p><p>全部的槽指派成功之后，集群进入上线状态。</p><h3 id="1、记录节点的槽指派信息"><a href="#1、记录节点的槽指派信息" class="headerlink" title="1、记录节点的槽指派信息"></a>1、记录节点的槽指派信息</h3><p>clusterNode结构的<strong>slots属性</strong>和<strong>numslot属性</strong>记录了节点负责处理哪些槽。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121423532.png" alt="image-20220318121423532"></p><p>slots属性</p><p>Slot是一个数组</p><p>Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号</p><p>用数组元素的值是否为1确定是否被分配处理（1：表示处理）</p><p>示例如下：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318121607634.png" alt="image-20220318121607634"></p><p><strong>numslots属性</strong></p><p>记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制位的数量。</p><h3 id="2、传播节点的槽指派信息"><a href="#2、传播节点的槽指派信息" class="headerlink" title="2、传播节点的槽指派信息"></a>2、传播节点的槽指派信息</h3><p>一个节点会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。通过接受其他节点发送的节点slot数组，更新自身的clusterState.nodes字典中的clusterNode结构。</p><p>每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面。</p><h4 id="3、记录集群所有槽的指派信息"><a href="#3、记录集群所有槽的指派信息" class="headerlink" title="3、记录集群所有槽的指派信息"></a>3、记录集群所有槽的指派信息</h4><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318131756379.png" alt="image-20220318131756379"></p><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：</p><ul><li>如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。</li><li>如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。</li></ul><p>通过将所有槽的指派信息保存在clusterState.slots数组里面，程序要检查槽i是否已经被指派， 只需要访问clusterState.slots[i]的值即可，这个操作的复杂度仅为O（1）。</p><p>需要说明的是：虽然clusterState.slots数组记录了集群中所有槽的指派信息，但使用clusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的。</p><h4 id="4、CLUSTER-ADDSLOTS命令的实现"><a href="#4、CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="4、CLUSTER ADDSLOTS命令的实现"></a>4、CLUSTER ADDSLOTS命令的实现</h4><p>CLUSTER ADDSLOTS命令有一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318132213728.png" alt="image-20220318132213728"></p><p>用一段伪代码定义命令的实现：</p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318132247998.png" alt="image-20220318132247998" style="zoom:67%;" /></p><h2 id="三、在集群中执行命令"><a href="#三、在集群中执行命令" class="headerlink" title="三、在集群中执行命令"></a>三、在集群中执行命令</h2><p>集群处于上线状态，那么客户端就可以向集群中的节点发送数据命令了。</p><p>执行流程图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133044005.png" alt="image-20220318133044005" style="zoom:67%;" /></p><p>下面介绍计算所属槽的方法</p><h3 id="1、计算键属于哪个槽"><a href="#1、计算键属于哪个槽" class="headerlink" title="1、计算键属于哪个槽"></a>1、计算键属于哪个槽</h3><p>计算算法：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133200870.png" alt="image-20220318133200870"></p><p>CRC16（key）语句用于计算键key的CRC-16校验和。</p><p>使用CLUSTER KEYSLOT＜key＞命令可以查看一个给定键属于哪个槽</p><h3 id="2、判断槽是否由当前节点负责处理"><a href="#2、判断槽是否由当前节点负责处理" class="headerlink" title="2、判断槽是否由当前节点负责处理"></a>2、判断槽是否由当前节点负责处理</h3><p>上面计算出键所属的槽之后，节点就会检查自己的clusterState.slots数组中的项i，进行判断。</p><ul><li>如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令。</li><li>如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回<strong>MOVED错误</strong>，指引客户端转向至正在处理槽i的节点。</li></ul><h3 id="3、MOVED错误"><a href="#3、MOVED错误" class="headerlink" title="3、MOVED错误"></a>3、MOVED错误</h3><p>当节点发现键所在的槽并非由自己负责处理时，向客户端发送的错误。</p><p>格式：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133644636.png" alt="image-20220318133644636" style="zoom:67%;" /></p><p>客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点。</p><p>并且向其重新发送之前想要执行的命令。</p><h3 id="4、节点数据库的实现"><a href="#4、节点数据库的实现" class="headerlink" title="4、节点数据库的实现"></a>4、节点数据库的实现</h3><p>集群节点保存键值对以及键值对过期时间的方式和之前介绍的单机Redis的方式完全相同。</p><p>节点和单机服务器在数据库方面的一个区别是，<strong>节点只能使用0号数据库</strong>，而单机Redis服务器则没有这一限制。</p><p>另外，除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318133958399.png" alt="image-20220318133958399"></p><h2 id="四、重新分片"><a href="#四、重新分片" class="headerlink" title="四、重新分片"></a>四、重新分片</h2><p>将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片可以线上进行 ，集群不需要下线，可以继续处理命令请求。</p><h3 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h3><p>重新分片由集群管理软件redis-trib负责执行，通过向<strong>源节点</strong>和<strong>目标节点</strong>发送命令来进行重新分片操作。</p><p>首先是操作单个槽：</p><p>步骤如下：</p><ul><li>目标节点发送CLUSTER SETSLOT＜slot＞IMPORTING＜source_id＞命令，令其准备好接收slot</li></ul><p>键值对。</p><ul><li><p>对源节点发送CLUSTER SETSLOT＜slot＞MIGRATING＜target_id＞命令，令其准备好slot槽的键值对迁移。</p></li><li><p>向源节点发送CLUSTER GETKEYSINSLOT＜slot＞＜count＞命令，获得最多count个属于槽slot的键值对的键名（key name）。</p></li><li><p>对于获取的每一个键名，redis-trib都向源节点发送一个MIGRATE＜target_ip＞＜target_port＞＜key_name＞0＜timeout＞命令， 原子地从源节点迁移至目标节点。</p></li><li><p>重复执行获取键名和迁移的过程</p><p>如图所示：（迁移键的过程）</p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318134854939.png" alt="image-20220318134854939"></p></li><li><p>redis-trib向集群中的任意一个节点发送CLUSTERSETSLOT＜slot＞NODE＜target_id＞命令，通知槽slot已经指派给目标节点。</p></li></ul><p>对于多个槽的重新分配。需要对每个槽分别执行上述步骤。</p><h2 id="五、ASK错误"><a href="#五、ASK错误" class="headerlink" title="五、ASK错误"></a>五、ASK错误</h2><h3 id="1、ASK错误"><a href="#1、ASK错误" class="headerlink" title="1、ASK错误"></a>1、ASK错误</h3><p>重新分片期间，可能会发生这样的错误：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。</p><p>有趣的情况发生了:客户端向源节点请求命令含有的数据库建恰好属于被迁移的槽的时候。</p><ul><li>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</li><li> 如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，则返回ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</li></ul><p><strong>被隐藏的ASK错误</strong></p><p>和接到MOVED错误时的情况类似，集群模式的redis-cli在接到ASK错误时也不会打印错误，对用户来说是隐藏的。</p><p>接到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送原本想要执行的命令</p><h3 id="2、ASKING命令"><a href="#2、ASKING命令" class="headerlink" title="2、ASKING命令"></a>2、ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识</p><p>如果节点的clusterState.importing_slots_from[i]显示节点正在导入槽i，并且发送命令的客户端带有REDIS_ASKING标识，那么节点将破例执行这个关于槽i的命令一次。</p><p>如图所示：    </p><p>​                <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318135750323.png" alt="image-20220318135750323" style="zoom:67%;" /></p><h3 id="3、ASK错误和MOVED错误的区别"><a href="#3、ASK错误和MOVED错误的区别" class="headerlink" title="3、ASK错误和MOVED错误的区别"></a>3、ASK错误和MOVED错误的区别</h3><p>同：两者都会导致客户端转向。</p><p>异：MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，<strong>客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点</strong>。</p><p>​        与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施，<strong>这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响</strong>。</p><h2 id="六、复制与故障转移"><a href="#六、复制与故障转移" class="headerlink" title="六、复制与故障转移"></a>六、复制与故障转移</h2><p>Redis集群中的节点分为主节点（master）和从节点</p><p>主节点：用于处理槽</p><p>从节点：复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p><p>下面将介绍节点的复制方法，检测节点是否下线的方法，以及对下线主节点进行故障转移的方法。</p><h3 id="1、设置从节点"><a href="#1、设置从节点" class="headerlink" title="1、设置从节点"></a>1、设置从节点</h3><p>使用</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318140329801.png" alt="image-20220318140329801" style="zoom:67%;" /></p><p>命令</p><p>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p><p>从节点复制主节点，</p><p>:one:首先要查找自己的clusterState.nodes字典。找到node_id所对应节点的clusterNode结构，将自己的clusterState.myself.slaveof指针指向这个结构。</p><p>:two:修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识（自己已经变成了从节点）</p><p>:three: 节点调用复制代码，根据指向的那个clusterNode结构（主节点），进行赋值</p><p>从上面来看：从节点复制主节点相当于向从节点发送命令SLAVEOF。</p><h3 id="2、故障检测"><a href="#2、故障检测" class="headerlink" title="2、故障检测"></a>2、故障检测</h3><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><p>如果接收节点没能在规定时间内返回PONG消息，那么发送节点认定该节点<strong>疑似下线</strong>。</p><p>需要注意的是：集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息</p><p>（包括：某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL））</p><p>举个例子：</p><p>​    当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的</p><p>clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告</p><p>（failure report）添加到clusterNode结构的fail_reports链表里面：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220318141033674.png" alt="image-20220318141033674"></p><p>​        那么如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL）。</p><p>​    之后主节点通过广播的形式，通知集群中的所有节点，该节点下线的消息。</p><h3 id="3、-故障转移"><a href="#3、-故障转移" class="headerlink" title="3、 故障转移"></a>3、 故障转移</h3><p>发生条件：一个<strong>从节点</strong>发现自己正在复制的<strong>主节点</strong>进入了已下线状态时，从节点将开始对下线主节点进行故障转移</p><p>步骤如下：</p><p>​    1）复制下线主节点的所有从节点里面，会有一个从节点被选中。</p><p>​    2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p><p>​    3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</p><p>​    4）新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</p><p>​    5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p><h3 id="4、新的主节点的选取"><a href="#4、新的主节点的选取" class="headerlink" title="4、新的主节点的选取"></a>4、新的主节点的选取</h3><p>选举方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）集群的配置纪元是一个自增计数器，它的初始值为0。</span><br><span class="line">2）当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</span><br><span class="line">3）对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</span><br><span class="line">4）当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</span><br><span class="line">5）如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</span><br><span class="line">6）每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</span><br><span class="line">7）如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</span><br><span class="line">8）因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</span><br><span class="line">9）如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</span><br></pre></td></tr></table></figure><p>选举新主节点的方法和 选举领头Sentinel的方法非常相似， 都是基于Raft算法的领头选举（leader election）方法来实现的。</p><h2 id="七、消息"><a href="#七、消息" class="headerlink" title="七、消息"></a>七、消息</h2><p>集群中的各个节点通过发送和接收消息（message）来进行通信。</p><p>称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）</p><p>节点之间发送的消息种类：</p><ul><li>MEET消息：当发送者接到客户端发送的CLUSTERMEET命令时，发送者会向接收者发送MEET消息</li><li>PING消息：检测被选中的节点是否在线</li><li>PONG消息：回复PING</li><li>FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li><li>PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h1&gt;&lt;p&gt;Redis集群是Redis提供的分布式数据库方案， 通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。&lt;/p&gt;
&lt;p&gt;下</summary>
      
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-慢查询日志</title>
    <link href="http://example.com/2022/03/17/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2022/03/17/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-17T07:16:19.000Z</published>
    <updated>2022-03-17T07:29:20.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，通过这个功能产生的日志来监视和优化查询速度。</p><h3 id="一、配置选项"><a href="#一、配置选项" class="headerlink" title="一、配置选项"></a>一、配置选项</h3><p>有两个和慢查询日志相关的选项：</p><ul><li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。</li><li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</li></ul><p>服务器使用先进先出的方式保存多条慢查询日志，当 存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。</p><h3 id="二、慢查询记录的保存"><a href="#二、慢查询记录的保存" class="headerlink" title="二、慢查询记录的保存"></a>二、慢查询记录的保存</h3><p>服务器状态中包含了几个和慢查询日志功能有关的属性</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203171521925.png" alt="image-20220317152127766"></p><p>说明：</p><ul><li><p>slowlog_entry_id属性的初始值为0，随着新的日志的创建不断更新。</p></li><li><p>slowlog<strong>链表</strong>保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203171523416.png" alt="image-20220317152318278"></p></li></ul><h3 id="三、浏览和删除"><a href="#三、浏览和删除" class="headerlink" title="三、浏览和删除"></a>三、浏览和删除</h3><p>查看日志的SLOWLOG GET</p><p>查看日志数量的SLOWLOG LEN</p><p>清除所有慢查询日志的SLOWLOG RESET</p><p>打印和删除慢查询日志可以通过遍历slowlog链表实现。</p><h3 id="四、添加新日志"><a href="#四、添加新日志" class="headerlink" title="四、添加新日志"></a>四、添加新日志</h3><p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长。</p><p>这个时长传递给<strong>slowlogPushEntryIfNeeded函数</strong>，最终决定是否创建慢查询日志。</p><p>并且新创建的日志放到slowlog的链表头，并且将slowlog_entry_id的值增加1。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-15T07:19:11.000Z</published>
    <updated>2022-03-15T07:19:11.716Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统-内存管理</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-14T12:19:57.000Z</published>
    <updated>2022-03-15T10:45:27.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>需要了解的知识：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142030815.png" alt="image-20220314203051697"></p><p>1、什么是内存？作用？</p><p>内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾。</p><p>2、内存装入的三种方式</p><ul><li><p>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。</p><p>绝对装入只适用于单道程序环境。</p></li><li><p>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地 址、数据存放的地址都是相对于起始地址而言的逻辑地址。</p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求 的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申 请内存空间。</p></li><li><p>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装 入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。</p></li></ul><p>3、程序的运行</p><ul><li><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言） </p></li><li><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块 </p></li><li><p>装入（装载）：由装入程序将装入模块装入内存运行</p></li></ul><h3 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h3><ul><li>内存空间分配和回收</li><li>内存空间扩容</li><li>地址转换</li><li>内存保护</li></ul><p>1、内存空间分配和回收：操作系统负责<strong>内存空间的分配与回收</strong></p><p>2、内存空间扩容：操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></p><p>3、地址转换：操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换（三种装入方式）</p><p>4、内存保护：操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</p><p>（CPU检查是否越界）</p><h3 id="三、覆盖和交换"><a href="#三、覆盖和交换" class="headerlink" title="三、覆盖和交换"></a>三、覆盖和交换</h3><p>覆盖和交换是内存空间扩容的方法，此外还有虚拟内存技术。</p><p>1、覆盖技术</p><p>覆盖技术的思想：将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。 需要常驻内存的段放在“固定区”中，调入后就不再 调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存， 用不到时调出内存。</p><p>如图所示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142107600.png" alt="image-20220314210738510"></p><p>-缺点：对用户不透明，现在已经成为历史。</p><p>2、交换技术</p><p>​    设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中 某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>​    回忆之前的知识：中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>​    暂时换出外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p>​    总结之前的状态模型：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142109908.png" alt="image-20220314210948530"></p><p>注意：PCB 会常驻内存，不会被换出外存</p><h3 id="四、连续内存分配管理"><a href="#四、连续内存分配管理" class="headerlink" title="四、连续内存分配管理"></a>四、连续内存分配管理</h3><p>连续内存分配管理是内存空间分配和回收的方式之一</p><p>如图所示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142111790.png" alt="image-20220314211149486"></p><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><p><strong>分类</strong>：</p><p>可以分成单一连续分配、固定分区分配、动态分区分配。</p><p>1、单一连续分配</p><p>​    内存被分为系统区和用户区。 </p><p>​        系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；</p><p>​        用户区用于存放用户进程相关数据。 </p><p>​    内存中只能有一道用户程序，用户程序独占整个用户区 空间。 </p><p>​    优点：实现简单；无外部碎片；可以采用覆盖技术扩充 内存；不一定需要采取内存保护 </p><p>​    缺点：只能用于单用户、单任务的操作系统中；有内部 碎片；存储器利用率极低。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142119367.png" alt="image-20220314211952123"></p><p>2、固定分区分配</p><p>​        整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。</p><p>​    分成</p><ul><li><p>分区大小相同：</p><p>分区大小相等：缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合</p></li><li><p>分区大小不同：</p><p>增加了灵活性，可以满足不同大小的进 程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142118494.png" alt="image-20220314211830222"></p></li></ul><p><strong>3、动态分区分配</strong></p><p>​    又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。</p><p>​    动态分区分配没有内部碎片，但是有外部碎片。 </p><p>注：</p><ul><li><p>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 </p></li><li><p>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。（通过紧凑技术来解决）</p></li></ul><p>4、总结</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142115124.png" alt="image-20220314211520809"></p><h3 id="五、动态分区分配算法"><a href="#五、动态分区分配算法" class="headerlink" title="五、动态分区分配算法"></a>五、动态分区分配算法</h3><p>在上面学习的动态分区分配时，多个分区都空闲的时候，那么要选择哪个呢？</p><p>下面是解决这个问题的四种算法。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142121060.png" alt="image-20220314212136836"></p><p>1、首次适应算法</p><p>​        算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 </p><p>​        实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142123637.png" alt="image-20220314212314372"></p><p>2、最坏适应算法</p><p>​        算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区 域。 优先使用更小的空闲区。 </p><pre><code>     实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 </code></pre><p>表），找到大小能满足要求的第一个空闲分区。 </p><p>​        <strong>缺点： 这种方法会产生很多的外部碎片。</strong></p><p>3、最佳适应算法</p><p>​        算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，</p><pre><code>     实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 </code></pre><p>表），找到大小能满足要求的第一个空闲分区。</p><p><strong>缺点： 这种方式会导致较大的连续空闲区被</strong> <strong>迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong> </p><p>4、临近适应算法</p><p>​        算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲 分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 </p><pre><code>     实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查 找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</code></pre><p>5、总结</p><p>​        综合来看，四种算法中，首次适应算法的效果反而更好</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142122366.png" alt="image-20220314212231038"></p><h3 id="六、基本分页存储管理的基-本概念"><a href="#六、基本分页存储管理的基-本概念" class="headerlink" title="六、基本分页存储管理的基 本概念"></a>六、基本分页存储管理的基 本概念</h3><p>之前上面介绍到的都是连续分配的形式。下面介绍非连续分配。</p><p>连续分配：为用户进程分配的必须是一个连续的内存空间。 </p><p>非连续分配：为用户进程分配的可以是一些分散的内存空间。</p><p>​        关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142127675.png" alt="image-20220314212735413"></p><p>1、什么是分页存储？</p><ul><li><p>将内存空间分为一个个大小相等的分区，，每个分区就是一个“页框”</p><p>（页框号=页帧号=内存块号=物理块号=物理页号）</p></li><li><p>将进程的逻辑地址空间也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“页”或“页面” 。</p></li></ul><p>下面是几点说明：</p><ul><li><p>操作系统以页框为单位为各个进程分配内存空间。</p></li><li><p>进程的页面与内存的页框有一一对应的关系。</p></li><li><p>页面可以不是连续存放的，也可以不放到相邻的页框中。</p></li></ul><p>2、页表</p><p>​    下面是一个重要的概念，”页表“</p><p>​    页表通常存储在进程控制块中PCB 。</p><p>图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142147228.png" alt="image-20220314214751984"></p><p>说明：</p><p>   1.一个进程对应一张页表</p><ol start="2"><li><p>进程的每个页面对应一个页表项</p></li><li><p>每个页表项由“页号”和“块号”组成</p></li><li><p>页表记录进程页面和实际存放的内存块之间的映射关系</p></li><li><p>每个页表项的长度是相同的</p></li></ol><p>问题：</p><p> 问题一：每个页表多少字节？</p><p>​        计算机中内存块的数量——&gt;页表项中块号至少占多少字节</p><p>总结：        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142150512.png" alt="image-20220314215008122"></p><h3 id="七、虚拟内存"><a href="#七、虚拟内存" class="headerlink" title="七、虚拟内存"></a>七、虚拟内存</h3><p>之前了解了传统内存扩容的方式，加上覆盖和交换。下面学习虚拟内存技术。</p><p>基本概念：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142129890.png" alt="image-20220314212947614"></p><p>1、传统存储管理方式</p><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：</p><p>​    ①作业很大时，不能全 部装入内存，导致大作业无法运行；</p><p>​    ②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 </p><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。导致了内存中会驻留大量的、暂时用不到的 数据，浪费了内存资源。</p><p>2、局部性原理</p><p>时间局部性：如果执行了程序中的某条指令，那么不久后<strong>这条指令</strong>很有可能再次执行；（因为程序中存在大量的循环） </p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其<strong>附近的存储单元</strong>也很有可能被访问。 （因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><p>3、虚拟内存</p><p><strong>定义</strong>：（用一段文字说明）</p><p><strong>基于局部性原理</strong>，在程序装入时，可以将程序中很快 会用到的部分装入内存，暂时用不到的部分留在外存， 就可以让程序开始执行。 </p><p>在程序执行过程中，当所访问的信息不在内存时，由 操作系统负责将所需信息从外存调入内存，然后继续执行程序。 </p><p>若内存空间不够，由操作系统负责将内存中暂时用不 到的信息换出到外存。 在操作系统的管理下，在用户看来<strong>似乎有一个比实际 内存大得多的内存</strong>，这就是<strong>虚拟内存</strong></p><p>注：</p><ul><li><p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 </p></li><li><p>虚拟内存的实际容量 =    min（内存和外存容量之和，CPU寻址范围）</p></li></ul><p><strong>特征：</strong></p><ul><li><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 </p></li><li><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换 入、换出。 </p></li><li><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p></li></ul><p><strong>实现</strong></p><p>由于一个作业会分多次调入调出内存，因此连续内存分配不方便，因此<strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上</strong>。</p><p>实现如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142137261.png" alt="image-20220314213743950"></p><p>操作系统需要提供页面置换和请求调页的功能。</p><h3 id="八、基本地址变换机构"><a href="#八、基本地址变换机构" class="headerlink" title="八、基本地址变换机构"></a>八、基本地址变换机构</h3><p>基本地址编制机构可以借助进程把逻辑地址转换成物理地址。</p><p>通常会在系统设置页表寄存器(PTR),用来存放页表和内存的启示地址和页表长度。</p><p>程序未执行时，页表和起始地址存放在PCB中，进程被调用的时候后，操作系统会把他们调到页表寄存器中。</p><p>流程如下：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151057772.png" alt="image-20220315105732653"></p><p>总结：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151058482.png" alt="image-20220315105817409"></p><h3 id="九、具有快表的地址变换机构"><a href="#九、具有快表的地址变换机构" class="headerlink" title="九、具有快表的地址变换机构"></a>九、具有快表的地址变换机构</h3><p>是基本地址变换机构的改进版。</p><p>1、什么事快表？TLB</p><p>​    快表：（TLB）一种访问速度比内存刈很多的高速缓存（TLB不是内存！） 用来存放最近访问的页表项的副本，可以加速地址变换的速度。 </p><p>​    与此对应，内存中的页表常称为慢表。</p><p>2、引入快表的地址变换过程？</p><p>引入快表之后优先查询块表是否命中。加快速度。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151102229.png" alt="image-20220315110210155"></p><p>具体流程：</p><p>①算页号、页内偏移量 </p><p>②检查页号合法性 </p><p>③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤； </p><p>若未命中则进行④ </p><p>④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 </p><p>⑤根据内存块号与页内偏移量得到物理地址 </p><p>⑥访问目标内存单元 </p><h3 id="十、二级页表"><a href="#十、二级页表" class="headerlink" title="十、二级页表"></a>十、二级页表</h3><p>之前都是分配给进程单级页表。</p><p>1、那么单级页表存在什么问题呢？</p><p>单级页表要在所有的页表项都连续存放的基础上才能找到页表项。当页表很大时，需要占用很多个连续的页框。</p><p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面 就可以正常运行了。因此没有必要让整个页表都常驻内存。</p><p>2、二级页表</p><p>那么为了解决这两个问题，我们可以把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151109832.png" alt="image-20220315110906749"></p><p>可以分成以下几步：</p><p>①按照地址结构将逻辑地址拆分成三部分 </p><p>②从PCB 中读出页目录表始址，再根据一级页号查页目录 </p><p>表，找到下一级页表在内存中的存放位置 </p><p>③根据二级页号查二级页表，找到最终想访问的内存块号 </p><p>④结合页内偏移量得到物理地址</p><p>3、注意事项</p><p>两级页表的访存次数分析（假设没有快表机构） </p><p>第一次访存：访问内存中的页目录表 </p><p>第二次访存：访问内存中的二级页表 </p><p>第三次访存：访问目标内存单元</p><h3 id="十一、基本分段存储管理方式"><a href="#十一、基本分段存储管理方式" class="headerlink" title="十一、基本分段存储管理方式"></a>十一、基本分段存储管理方式</h3><h3 id="十二、请求分页管理方式"><a href="#十二、请求分页管理方式" class="headerlink" title="十二、请求分页管理方式"></a>十二、请求分页管理方式</h3><p>之前介绍的都是基本的分页存储管理。</p><p>下面介绍请求分页管理方式</p><p>两者存在一些差别：</p><ul><li><p>在程序执行过程中，当<strong>所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然 后继续执行程序。 </p></li><li><p>若内存空间不够，由操作系统负责将<strong>内存中暂时用不到的信息换出到外存</strong>。</p></li></ul><p>请求分页管理方式主要有以下几点注意事项：</p><ul><li>页表机制</li><li>缺页中断机构</li><li>地址变换机构（注意与基本分页存储管理的页表 机制、地址变换流程对比）</li></ul><p>1、页表机制</p><p>与基本分页管理相比，实现“请求调页”，操作系统需要 知道每个页面是<strong>否已经调入内存</strong>；如果还没调入，那么也需要知道该页面在<strong>外存中存放的位置</strong>。</p><p>​    当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到 底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页 面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面 <strong>是否被修改</strong>的信息。</p><p>因此两者的页表结构也所不同。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151118557.png" alt="image-20220315111813484"></p><p>2、缺页中断机构</p><p>​    在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然 后由操作系统的缺页中断处理程序处理中断。 </p><p>​    此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修 改页表中相应的页表项。</p><p>​    缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 </p><p>一条指令在执行期间，可能产生多次缺页中断。</p><p>3、地址变换机构</p><p>​    请求分页存储管理与基本分页存储管理的主要区别： </p><p>​    在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然 后继续执行程序。 </p><p>​    若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>注：新增步骤1：请求调页（查到页表项时进行判断） </p><p>​        新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行） </p><p>​        新增步骤3：需要修改请求页表中新增的表项</p><h3 id="十三、页面置换算法"><a href="#十三、页面置换算法" class="headerlink" title="十三、页面置换算法"></a>十三、页面置换算法</h3><p>​    之前说到操作系统要为请求页面分配管理的方式提供页面置换和请求调页的功能。</p><p>​    下面关注页面置换算法的实现。</p><p>好的页面置换算法应该追求更少的缺页率。</p><p>下面介绍五种页面置换算法。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151130032.png" alt="image-20220315113004952"></p><p>1、最佳置换算法</p><p>最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被 访问的页面，这样可以保证最低的缺页率。</p><p>根据算法思想我们可以知道最佳置换算法总是淘汰最先出现的那个页面。</p><p>这个算法有一定的局限性，操作系统无法提前预判页面访问序列的情况下，最佳置换算法无法实现。</p><p>2、先进先出置换算法</p><p>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面 </p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 </p><p>队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>缺点是虽然实现简单，但是可能会产生Belady异常，算法性能差</p><p>注：Belady 异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>3、最近最久未使用算法</p><p>​    最近最久未使用置换算法（LRU，least    recently    used）：每次淘汰的页面是最近最久未使用的页面 </p><p>​    实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</p><p>​    <strong>缺点</strong>：该算法的实现需要专门的硬 件支持，虽然算法性能好， 但是实现困难，开销大</p><p>4、时钟置换算法</p><p>​    时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，NotRecently Used）</p><p>​    实现有一些复杂</p><p>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫᧿ （第二轮扫描 中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描 ）</p><p>​        如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151138515.png" alt="image-20220315113846445"></p><p>5、改进型时钟置换算法</p><p>对于简单的时钟算法，对于是否页面被修改并不关心，只关注是否被访问。之后进行写入内存。可以设置一种算法，将没有修改的页面不写进内存。避免不必要的开销。</p><p>扫描的规则：</p><p>将所有可能被置换的页面排成一个循环队列 </p><p>第一轮：从当前位置开始扫᧿ 到第一个（0,    0）的帧用于替换。本轮扫᧿ </p><p>不修改任何标志位 </p><p>第二轮：若第一轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    1）的帧用于 </p><p>替换。本轮将所有扫᧿ 过的帧访问位设为0 </p><p>第三轮：若第二轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    0）的帧用于 </p><p>替换。本轮扫᧿ 不修改任何标志位 </p><p>第四轮：若第三轮扫᧿ 失败，则重新扫᧿ ，查找第一个（0,    1）的帧用于 </p><p>替换。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151141679.png" alt="image-20220315114139618"></p><p>此经过第三轮、第四轮扫᧿ 一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多 会进行四轮扫描。</p><h3 id="十四、页面分配策略"><a href="#十四、页面分配策略" class="headerlink" title="十四、页面分配策略"></a>十四、页面分配策略</h3><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151125804.png" alt="image-20220315112557721"></p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-文件管理</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-14T04:47:48.000Z</published>
    <updated>2022-03-15T10:45:17.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>文件——就是一组有意义的信息/数据集合</p><p>文件管理：</p><p>重点关注和解决以下问题：</p><ul><li><p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p></li><li><p>文件内部的数据应该怎样组织起来？</p></li><li><p>文件之间又应该又应该怎么组织起来？</p></li><li><p>从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？</p></li><li><p>从上往下看，文件数据应该怎么存放在外存（磁盘）上？</p></li></ul><p>文件属性：</p><p>常见的文件属性包括：</p><p>​    文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p><p>​    标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p><p>​    类型：指明文件的类型</p><p>​    位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p><p>​    大小：指明文件大小</p><p>​    创建时间、上次修改时间</p><p>​    文件所有者信息</p><p>​    保护信息：对文件进行保护的访问控制信息</p><p>重点回顾：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141642420.png" alt="image-20220314164225069"></p><h3 id="二、文件逻辑结构"><a href="#二、文件逻辑结构" class="headerlink" title="二、文件逻辑结构"></a>二、文件逻辑结构</h3><p>概念：指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p><p><strong>文件操作的具体实现与文件的逻辑结构、物理结构都有关</strong></p><p>分类：</p><p>​    分类标准：是否有结构</p><p>​    无结构文件、有结构文件文件</p><p>一、无结构文件</p><p>​    无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件。</p><p>​    因此也不用探讨无结构文件的“逻辑结构”问题。</p><p>​    举例：比如 .txt 文件</p><p>二、有结构文件</p><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。</p><p>1、定长记录、可变长记录</p><p>有结构文件是由一条条记录组成的。通常记录可以分成：定长记录和可变长记录。</p><p>​    定长记录：每条记录的长度相同。</p><p>​    可变长记录：各条记录的长度不确定，不一定是相同的。</p><p>2、<strong>有结构文件的逻辑结构</strong></p><p>分类标准： 根据有结构文件中的各条记录在逻辑上如何组织</p><p>:one:顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p>​    顺序文件的分类如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141700629.png" alt="image-20220314170005560"></p><p>​    一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件</p><p>​    缺点：删除一个记录比较困难。</p><p>:two:索引文件：索引文件本身是定长记录的顺序文件。(解决可变长记录文件，顺序查找的问题)</p><p>​    索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合</p><p>如图：</p><pre><code> &lt;img src=&quot;https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141704354.png&quot; alt=&quot;image-20220314170423294&quot; style=&quot;zoom:80%;&quot; /&gt;</code></pre><p>优点：可以使用不同的数据项创建多个索引表。</p><p>​            检索速度很快。</p><p>:three:索引顺序文件</p><p>​    索引顺序文件是索引文件和顺序文件思想的结合。</p><p>​    索引顺序文件，会为文件建立一张索引表，但是：并不是每个记录对应一个索引表项，而是<strong>一组</strong>记录对应一个索引表项。</p><p>如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141706960.png" alt="image-20220314170641899"></p><p>也就是说把相同组的文件索引放到一个新的索引文件中，组成一个顺序文件，由原来的索引文件进行索引。</p><p>:four:多级索引顺序文件</p><p>为了进一步提高效率，可以为顺序文件建立多级索引表。在此不做过多赘述。</p><h3 id="三、文件目录"><a href="#三、文件目录" class="headerlink" title="三、文件目录"></a>三、文件目录</h3><p>一层一层的文件目录对用户有什么好处？</p><p>​    文件组织清晰，易于查找</p><p>​    轻松的实现按名存取的目的。</p><p>那么文件目录是如何实现的呢？</p><p>随着计算机的发展文件目录的结构也在发生着变化。</p><h4 id="一、文件控制块"><a href="#一、文件控制块" class="headerlink" title="一、文件控制块"></a>一、文件控制块</h4><p>1、首先了解相关概念：文件控制块</p><p>​    文件控制块是为了实现目录的关键数据结构。</p><p>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件</p><p>目录文件中的一条记录就是一个<strong>文件控制块（FCB）</strong></p><p>2、需要对目录 进行哪些<strong>操作</strong>？</p><ul><li><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p></li><li><p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p></li><li><p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p></li><li><p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p></li><li><p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文</p></li></ul><p>件重命名）</p><h4 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a><strong>二、目录结构</strong></h4><p>:one:<strong>单级目录结构</strong></p><p>​    整个系统中值建立一张目录表</p><p>​    不允许文件重名；应用于早期操作系统。</p><p>:two:<strong>两级目录结构</strong></p><p>​    到了早期多用户操作系统使用两级目录结构。</p><p>​    分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User FlieDirectory）。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录</p><p>的用户名是否匹配）</p><p>​    <strong>缺点</strong>：用户不能对文件进行分类，灵活性不足。</p><p>:three:<strong>多级目录结构</strong></p><p>了解几个概念：</p><p>​    绝对路径：从根路径出发的路径</p><p>​    当前目录：当前所在的那一级目录</p><p>​    相对路径：指的是相对于当前目录的路径。</p><p>树型目录结构</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141721733.png" alt="image-20220314172144652"></p><p>​    如果查找文件时，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径” 。 <strong>引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</strong></p><p>缺点：不利于实现 文件的共享</p><p>​    树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><p>:four:无环图目录结构</p><p>具体思路是：</p><p>​    可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。需要为每个共享结点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。只有共享计数器减为0时，才删除结点。</p><p>​    因为文件是共享的，因此在共享文件中，一个用户修改了文件数据，那么所有用户都能看到文件变化。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141722761.png" alt="image-20220314172221700"></p><h4 id="三、索引节点"><a href="#三、索引节点" class="headerlink" title="三、索引节点"></a>三、索引节点</h4><p>FCB的改进：目录的使用只有文件名匹配之后才会读取其他信息。考虑让目录表“瘦身”来提升效率。</p><p>​    因此把目录中除了文件名之外的文件描述信息都放到一个索引节点。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141730554.png" alt="image-20220314173018481"></p><p>当找到文件名对应的目录项时，索引节点才调入内存。</p><p>注：存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="四、文件的物理结构"><a href="#四、文件的物理结构" class="headerlink" title="四、文件的物理结构 %*%"></a>四、文件的物理结构 %*%</h3><p>文件数据应该怎样存放在外存中？</p><p>文件的物理结构分类</p><p> 分类标准：文件分配方式</p><ul><li>连续分配</li><li><h2 id="连接分配"><a href="#连接分配" class="headerlink" title="连接分配"></a>连接分配</h2></li><li>索引分配</li></ul><p>一、文件块、磁盘块</p><p>操作系统为文件分配存储空间是以快为基本单位的。</p><p>类似于内存中的存储，也是分成一个个快/磁盘块</p><p>二、连续分配</p><p>​    连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><p>1、逻辑地址到物理地址的映射？</p><p>（逻辑块号，块内地址）——&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p><p>​    物理块号 = 起始块号 + 逻辑块号</p><p>​    当然还要检查是否逻辑块号合法（逻辑块号 ≥ 长度 就不合法）</p><p>2、图示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141836258.png" alt="image-20220314183641193"></p><p>​        分别存放块的起始地址和长度。不被包括的就是空的块</p><p>3、优缺点？</p><p>​    优点：<strong>支持随机读取和顺序读取</strong></p><p>​                连续分配在顺序读/写的速度最快。</p><p>​    缺点：连续分配物理上是连续的，因此想要拓展更改不方便。</p><p>​                存储空间利用率低，产生外部碎片。</p><p>三、链接分配</p><p>​    链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p>:one:显示链接</p><p>图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141926941.png" alt="image-20220314192635871"></p><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）</p><p>​    需要注意的是：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻内存。</p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，<strong>支持顺序存储</strong>，并且<strong>支持随机访问</strong>。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间</li></ul><p>:two:隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录</p><p>包括文件第一块的指针和最后一块的指针。</p><p>图示：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141839578.png" alt="image-20220314183941511"></p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点：<strong>只支持顺序访问，不支持随机访问</strong>，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><p>四、索引分配</p><p>文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文</p><p>件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间</p><p>的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p>若文件太大，单个磁盘块存储不下整张索引表，如何解决？</p><p>有三种方案：</p><ul><li><p>①<strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，这就导致磁盘I/O次数过多，查找效率低下。 </p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932482.png" alt="image-20220314193232419"></p></li><li><p>②<strong>多层索引</strong>：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作。</p><p>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932185.png" alt="image-20220314193219131"></p></li><li><p>③<strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。</p><p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141932230.png" alt="image-20220314193200149"></p></li></ul><h3 id="五、文件存储空间管理"><a href="#五、文件存储空间管理" class="headerlink" title="五、文件存储空间管理"></a>五、文件存储空间管理</h3><p>一、文件空间的划分和初始化</p><p>文件卷</p><p>文件区：存放文件数据。</p><p>目录区：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区</p><p>二、文件存储空间管理方法</p><p>学习时注意从三个方面进行理解：</p><ul><li><p>用什么方式记录、组织空闲块？</p></li><li><p>如何分配磁盘块？</p></li><li><p>如何回收磁盘块？</p></li></ul><p>:one:空闲表法</p><p>概述：（适用于连续表法分配方式）</p><ul><li><p>磁盘块分配：与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间</p></li><li><p>磁盘块回收：与内存管理中的动态分区分配很类似，当回收某个</p><p>存储区时需要有四种情况</p><ul><li>①回收区的前后都没有相邻空闲区；</li><li>②回收区的前后都是空闲区；</li><li>③回收区前面是空闲区；</li><li>④回收区后面是空闲区。总之，<strong>回收时需要注意表项的合并问题。</strong></li></ul></li></ul><p>:two:空闲链表法</p><p>具体如图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141949582.png" alt="image-20220314194930505"></p><ul><li><p>分配：若某文件申请 K 个盘块，则从链头开始依次摘</p><p>下 K 个盘块分配，并修改空闲链的链头指针。</p></li><li><p>回收：回收的盘块依次挂到链尾，并修改空闲链的链</p><p>尾指针。</p></li></ul><p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p><p>:three:位示图法</p><p>​    位示图：每个二进制位对应一个盘块。用0和1来表示盘快是否分配。</p><p>​    注意<strong>盘块号与（字号</strong><strong>,</strong> <strong>位号）相互转换的公式：</strong></p><p>​        (字号, 位号)=(i, j) 的二进制位对应的 盘块号 b = ni + j</p><ul><li><p>分配：若文件需要K个块，</p><ul><li>顺序扫描位示图，找到K个相邻或不相邻的“0”；</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件；</li><li>将相应位设置为“1”。</li></ul></li><li><p>回收：</p><ul><li>根据回收的盘块号计算出对应的字号、位号；</li><li>将相应二进制位设为“0”     </li></ul></li></ul><p>:four:成组链接法</p><p>​        空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。</p><p>因此诞生了成组链表法：</p><p>​    使用一个专用的磁盘作为<strong>超级块</strong>,指向下一级内存块，每一级内存块的大小都是有限制的。</p><p>超级块中包含下一组空闲盘的快数。</p><p>​    如图：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141958464.png" alt="image-20220314195800380"></p><h3 id="六、文件的基本操作"><a href="#六、文件的基本操作" class="headerlink" title="六、文件的基本操作"></a>六、文件的基本操作</h3><p>​    操作系统向上提供的基本功能：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141935390.png" alt="image-20220314193503323"></p><p>一、创建文件</p><p>​    调用Create，需要几个参数：</p><ul><li><p> 所需的外存空间大小（如：一个盘块，即1KB）</p></li><li><p>文件存放路径（“D:/Demo”）</p></li><li><p>文件名 </p></li></ul><p>Create的流程：</p><ul><li><p>在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</p></li><li><p>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中创建该文件对应的目录项。<strong>目录项中包含了文件名、文件在外存中的存放位置等信息。</strong></p></li></ul><p>二、删除文件</p><p>​    调用Delete，需要提供参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>Delete的流程：</p><ul><li><p> 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p></li><li><p>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</p><p>（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p></li><li><p>从目录表中删除文件对应的目录项。</p></li></ul><p>三、打开文件</p><p>​    在对文件进行操作之前，要求用户先使用 open 系统调用“打开文件”，需要提供的几个主要参数：</p><ul><li><p>文件存放路径</p></li><li><p>文件名</p></li><li><p>要对文件的操作类型（如：r 只读；rw 读写等）</p></li></ul><p>open 系统调用：</p><ul><li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p></li><li><p>将目录项复制到内存中的<strong>“打开文件表</strong>”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p></li></ul><p>打开文件之后，创建了打开文件表，用户再操作该文件就不需要重新查目录了。加快文件访问速度。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203141942606.png" alt="image-20220314194229529"></p><p>四、关闭文件</p><p>​    进程使用完文件后，要“关闭文件”</p><p>  Close 系统调用 ：</p><ul><li><p>将进程的打开文件表相应表项删除</p></li><li><p>回收分配给该文件的内存空间等资源</p></li><li><p>系统打开文件表的打开计数器count 减1，若 <strong>count = 0，则删除对应表项</strong>。</p></li></ul><p>五、读文件</p><p>​    根据读指针、读入数据量、内存位置将文件数据从外存读入内存。</p><p>六、写文件</p><p>​    根据写指针、写出数据量、内存位置将文件从文件数据从内存写出外存。</p><h3 id="七、文件共享"><a href="#七、文件共享" class="headerlink" title="七、文件共享"></a>七、文件共享</h3><p>文件共享意味着系统中只含有一份文件数据，由多个用户共享。注意和文件复制的区别。</p><p>文件共享：为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。</p><p>下面是共享文件的两种方式：</p><p>一、硬链接</p><p>基于索引节点。索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p><p>若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减 1。 </p><p>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p><p>当 count = 0 时系统负责删除文件。</p><p>​    图示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142000927.png" alt="image-20220314200030859"></p><p>二、软连接（符号链接）</p><p>基于符号链接的共享文件，相当于windows的桌面快捷方式。通过路径引用，定位到文件 。</p><p>图示：</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142001670.png" alt="image-20220314200143592"></p><h3 id="八、文件保护"><a href="#八、文件保护" class="headerlink" title="八、文件保护"></a>八、文件保护</h3><p>文件保护，是为了保护文件数据的安全。有三种常见方式。</p><p>一、口令保护</p><p>​    为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。</p><ul><li><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p></li><li><p>缺点：正确的“口令”存放在系统内部，不够安全。</p></li></ul><p>二、加密保护</p><p>​    使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p><ul><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码/译码，或者说加密/解密要花费一定时间。</li></ul><p>三、访问控制</p><p>​    在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。</p><p>例图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142005887.png" alt="image-20220314200523812"></p><p>​    精简的访问列表：（避免用户过多带来的负荷。）</p><p>​    系统会按照一定的分类标准 分组。每个组中的成员的权限是相同的。</p><h3 id="九、文进系统结构层次"><a href="#九、文进系统结构层次" class="headerlink" title="九、文进系统结构层次"></a>九、文进系统结构层次</h3><p>​        层次图：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142005582.png" alt="image-20220314200548502"></p><h3 id="十、磁盘"><a href="#十、磁盘" class="headerlink" title="十、磁盘"></a>十、磁盘</h3><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142006860.png" alt="image-20220314200640766"></p><h3 id="十一、磁盘调度算法"><a href="#十一、磁盘调度算法" class="headerlink" title="十一、磁盘调度算法"></a>十一、磁盘调度算法</h3><p>1、寻找时间</p><p>​    在读/写数据前，将磁头移动到指定磁道所花的时间。</p><ul><li><p>①启动磁头臂是需要时间的。假设耗时为 s； </p></li><li><p>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道。则：寻道时间 TS = s + m*n</p></li></ul><p>2、延迟时间</p><p>​    通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p><p>​    设磁盘转速为 r （单位：转/秒，或 转/分），则平均所需的延迟时间 </p><p>​            TR = (1/2)*(1/r) = 1/(2r)</p><p>3、传输时间</p><p>​    从磁盘读出或向磁盘写入数据所经历的时间，</p><p>​    假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N。</p><p>​        则：传输时间Tt = (1/r) * (b/N) = b/(rN)</p><p>一、先来先服务算法（FCFS）</p><p>​    根据进程请求访问磁盘的先后顺序进行调度。</p><ul><li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li><li>缺点：近似于随机寻道</li></ul><p>二、最短寻找时间算法（SSTF）</p><p>​        会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（贪心的思想）</p><ul><li><p>优点：性能较好，平均寻道时间短</p></li><li><p>缺点：可能产生“饥饿”现象</p></li></ul><p>三、扫描算法（电梯算法）（SCAN）</p><p>在SSTF的基础上，规定：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移 动。这就是扫描算法（SCAN）的思想</p><ul><li><p>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</p></li><li><p>缺点：</p><ul><li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均</li></ul></li></ul><p>四、look算法</p><p>​        在SCAN 算法基础上规定：如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。</p><p>例：    </p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142014944.png" alt="image-20220314201413868"></p><ul><li>优点：比起 SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul><p>五、循环扫描算法（C-SCAN ）</p><p>​        在SCAN 的基础上：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><ul><li><p>优点：比起SCAN 来，对于各个位置磁道的响应频率很平均。</p></li><li><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向；比起SCAN算法来，平均寻道时间更长</p></li></ul><p>六、C-look算法</p><p>​    C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>例：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142016716.png" alt="image-20220314201638648"></p><ul><li>优点：比起 C-SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间</li></ul><p>进一步缩短</p><h3 id="十二、磁盘管理"><a href="#十二、磁盘管理" class="headerlink" title="十二、磁盘管理"></a>十二、磁盘管理</h3><p>可以认为的减少磁盘寻道的时间（其余两个都和磁盘本身的转速有关）</p><p>常见的方法：</p><p> <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203142017014.png" alt="image-20220314201722940"></p><p>​    </p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-常见问题总结</title>
    <link href="http://example.com/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-13T12:29:59.000Z</published>
    <updated>2022-03-15T10:45:54.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见操作系统问题"><a href="#常见操作系统问题" class="headerlink" title="常见操作系统问题"></a>常见操作系统问题</h2><ul><li>进程和线程的区别？</li><li>进程调度算法有哪些</li><li>常见的进程通信方式</li><li>进程IPC问题</li><li>进程死锁</li><li>什么叫做内核进程？与普通用户进程有什么区别？</li><li>fork/vfork调用</li><li>孤儿进程/僵尸进程</li><li>时间片轮转算法的发展</li><li>常见的进程调度器</li><li>抢占式调度VS 协作式调度</li><li>系统调用</li><li>POSIX</li><li>系统调用参数传递过程</li><li>常用的内核数据结构有哪些？都是在什么场景使用</li><li>什么是中断</li><li>软中断和硬中断</li><li>描述一下中断处理程序的执行过程</li><li>使用网卡描述一下硬件使用中断来完成数据传输的过程</li><li>操作系统是如何感知中断并处理的</li><li>中断的上半部和下半部</li><li>介绍一下内核同步方法</li><li>Linux里面都有哪些锁？</li><li>悲观锁和乐观锁</li><li>说说Linux内存管理</li><li>内存映射策略</li><li>使用C 函数Malloc描述一下内存分配的过程</li><li>Linux虚拟文件系统</li><li>Linux IO调度程序 </li></ul>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-12T08:01:40.000Z</published>
    <updated>2022-03-15T10:45:36.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>下面是操作系统基本功能的进程管理。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1、概念：</p><p>​    例如windows的进程管理器中的每一条进程都是进程。</p><ul><li><p>程序是存放在磁盘中的可执行文件，是静态的。是一系列程序的集合。</p></li><li><p>进程是动态的，是程序的依次执行过程。</p></li></ul><p>2、组成</p><p>操作系统的进程由PCB 来控制。是进程存在的标志。</p><p>PCB中存放的都是操作系统对进程进行管理所需要的信息。是给操作系统用的</p><p>程序段、数据段是给进程自己用的。</p><p>通常PCB 中包含以下信息：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121609867.png" alt="image-20220312160940762" style="zoom:80%;" /></p><p>一个进程实体（进程映像 ）是由：PCB 、程序段、数据段组成。</p><p>注意：进程实体是动态的，进程是进程运行过程中某一时刻的状态。是资源分配和调度的独立单位。</p><p>3、特征</p><ul><li>动态性：最基本的特性</li><li>并发性</li><li>独立性</li><li>异步性</li><li>结构性</li></ul><h3 id="二、进程状态转换和组织"><a href="#二、进程状态转换和组织" class="headerlink" title="二、进程状态转换和组织"></a>二、进程状态转换和组织</h3><p>1、状态</p><ul><li>创建态：进程正在被创建，系统完成创建的一系列工作。</li><li>就绪态：进程准备好进行执行。</li><li>运行态：进程被调度。CPU 正好执行这个程序的程序序列</li><li>阻塞态：进程因为某些原因被阻塞了。</li><li>终止态：进程结束</li></ul><p>2、转换</p><p>转换图：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121644953.png" alt="image-20220312164405817" style="zoom:80%;" /><p>注意：</p><p>​    进程不能由阻塞态直接转换成运行态，也不能从就绪态直接转换成阻塞态。因为阻塞态是进程主动请求的，必须是运行态才能完成这个功能。</p><p>​    进程是可以从运行态转换成就绪态的。例如系统分配的时间片用完了。 </p><h3 id="三、进程控制"><a href="#三、进程控制" class="headerlink" title="三、进程控制"></a>三、进程控制</h3><p>进程控制：进程的状态转换，包括创建、撤销、实现转换等功能。</p><p>1、如何实现?</p><p>是使用原语实现的，原语的实现具有原子性。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-概述</title>
    <link href="http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-03-12T06:51:18.000Z</published>
    <updated>2022-03-15T10:45:47.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、操作系统基本特性"><a href="#一、操作系统基本特性" class="headerlink" title="一、操作系统基本特性"></a>一、操作系统基本特性</h2><p>​    操作系统基本特性：并发、共享、异步、虚拟</p><h3 id="一、并发"><a href="#一、并发" class="headerlink" title="一、并发"></a>一、并发</h3><p>​    首先区分并发和并行：</p><p>​        并发：两个或两个以上事件在同一时间间隔内，宏观上是同时发生，微观上交替发生。</p><p>​        并行：两个或两个以上事件在同一时刻发生 </p><p>​    那么下面进一步来看操作系统的并发性。</p><p>​    计算机系统上同时运行着多个程序，这些程序宏观上同时运行，微观上交替运行</p><p>注：</p><ul><li>单核CPU 同一时刻只能运行单个程序，各个程只能并发执行。</li></ul><h3 id="二、共享"><a href="#二、共享" class="headerlink" title="二、共享"></a>二、共享</h3><p>​    即资源共享，系统内的资源可供内存内多个程序共同使用。</p><p>1、共享方式</p><p>​    共享方式分成两种 ：互斥共享和同时共享方式</p><p>​    注：互斥共享指的是一个时间段内只允许一个进程访问该资源，例如摄像头。同时共享相反。</p><p>综上来看：并发性和共享性是互相为存在条件的。</p><h3 id="三、虚拟性"><a href="#三、虚拟性" class="headerlink" title="三、虚拟性"></a>三、虚拟性</h3><p>​    物理上的实体编程逻辑上的对应物。</p><p>​    举个例子：</p><p>​    QQ 需要254MB内存、迅雷需要500MB 内存，加入我的电脑只有2G，依然能够运行这些程序。</p><p>​    虚拟技术：</p><ul><li>空分复用技术（如虚拟存储器技术）</li><li>时分复用技术（如虚拟处理机）</li></ul><h3 id="四、异步"><a href="#四、异步" class="headerlink" title="四、异步"></a>四、异步</h3><p>​    多道程序下，允许多个进程并发执行，由于<strong>资源有限</strong>，之形式断断续续的，速度是不可知的。</p><p>只有系统拥有并发行，才会有异步性的特征。</p><h3 id="二、操作系统发展和分类"><a href="#二、操作系统发展和分类" class="headerlink" title="二、操作系统发展和分类"></a>二、操作系统发展和分类</h3><p>一、操作系统的发展：</p><p>1、手工操作阶段：</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121511147.png" alt="image-20220312151119952" style="zoom:80%;" /><p>2、脱机输入输出阶段</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121512463.png" alt="image-20220312151240260" style="zoom:80%;" /><p>3、批处理阶段</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121513288.png" alt="image-20220312151342171" style="zoom:80%;" /><p>但是还是没有提供人机交互的问题。</p><p>4、分时操作系统</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121515301.png" alt="image-20220312151500158" style="zoom:80%;" /><p>5、实时操作系统</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121515388.png" alt="image-20220312151525257" style="zoom:80%;" /><p>注：重点了解各个操作系统的优缺点。</p><h3 id="三、操作系统的运行"><a href="#三、操作系统的运行" class="headerlink" title="三、操作系统的运行"></a>三、操作系统的运行</h3><p>举个例子：一条代码在计算机运行，首先通过编译器翻译成CPU能够读懂的二进制机器指令，然后交由CPU 执行。</p><p>1、两种类型的程序</p><p>需要区分两种程序：</p><ul><li><p>内核程序：操作系统的组成部分，组成了操作系统内核</p></li><li><p>应用程序：运行在操作系统之上的程序。</p><p>需要注意的是，操作系统内核有时候会执行一些<strong>特权指令</strong>。影响重大，因此只能操作系统内核来使用。（这些特权指令都是提前定义好的，CPU 可以识别）</p></li></ul><p>2、两种状态</p><p>那么CPU如何区分，内核程序和应用程序呢？</p><p>​    CPU有两种状态：内核态和用户态</p><ul><li>处于内核态（管态）时，说明运行的是内核程序。</li><li>处于用户态（目态），说明运行的是应用程序，只能执行非特权指令</li></ul><p>拓展：CPU 中的PSW有一个二进制位，1表示处于内核态，0表示用户态。</p><p>3、状态的切换</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121529618.png" alt="image-20220312152912447" style="zoom:80%;" /></p><p>因此我们可以总结：内核态到用户态的转变，进行修改PSW的 特权指令；用户态到内核态的转变，由中断引起，硬件自动完成。</p><h3 id="四、中断和异常"><a href="#四、中断和异常" class="headerlink" title="四、中断和异常"></a>四、中断和异常</h3><p>一、中断</p><p>操作系统夺回CPU 是使用权的唯一途径。</p><p>类型：内中断和外中断</p><ul><li><p>内中断：也叫异常，CPU执行的当前指令，引发的内部中断信号，引起内部中断。</p><p>此外还有：陷入指令（程序故意引发的）：应用程序–&gt;系统内核（系统调用就是依赖于陷入指令完成，）</p><p>故障、终止</p></li></ul><ul><li>外中断：一般叫做中断，CPU外部的来的中断信号，与当前运行程序无关。</li></ul><p>例：时钟中断：由时钟部件发来的中断信号。</p><p>​        IO设备发来的中断信号。</p><p>二、中断的基本原理</p><p>1、检查中断信号（又分成内外中断两种检测机制）</p><p>2、找到相应的中断处理程序，通过查找中断向量表的方式执行。中断处理程序都运行在内核态。</p><h3 id="六、系统调用"><a href="#六、系统调用" class="headerlink" title="六、系统调用"></a>六、系统调用</h3><p>1、</p><p>是操作系统提供的。使上层应用能够请求操作系统内核提供服务。和函数调用很类似。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121546102.png" alt="image-20220312154614995" style="zoom:80%;" /></p><p>2、系统调用的分类</p><p>在此不过多叙述如图：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121547178.png" alt="image-20220312154749072" style="zoom:80%;" /></p><p>​    凡是对于共享资源的使用就要经过系统调用来实现。由操作系统内核提供服务，进行调度。这样可以提高操作系统的安全性和稳定性。</p><p> 3、<strong>系统调用过程</strong></p><p>以编辑的程序调用库函数的例子进行分析。</p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121552934.png" alt="image-20220312155236772" style="zoom:80%;" /><h3 id="七、操作系统内核"><a href="#七、操作系统内核" class="headerlink" title="七、操作系统内核"></a>七、操作系统内核</h3><p>1、</p><p>内核是操作系统最核心的部分，运行在内核态的程序叫做内核程序。</p><p>通过如下图示初步了解：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203121555711.png" alt="image-20220312155522618" style="zoom:80%;" /></p><p>2、<strong>大内核和微内核</strong></p><p>大内核和小内核的相关功能划分不同，某些内核包含的功能想要执行就要到核心态运行。用户态和内核态的切换需要相关的代价。微内核和大内核各有各的有缺低点。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题总结</title>
    <link href="http://example.com/2022/03/09/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/03/09/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-09T08:08:12.000Z</published>
    <updated>2022-03-15T10:39:29.249Z</updated>
    
    <content type="html"><![CDATA[<p>【数据库】数据库中什么时候用索引？（应用场景）索引的作用 </p><p>1、定义：数据库索引是数据库管理系统中一个排序的数据结构,以协助快速查询,更新数据库 </p><p>中表的数据。 </p><p>2、实现方式：索引的实现通常使用 B 树和变种的 B+树(mysql 常用的索引就是 B+树)；索引 </p><p>是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。 </p><p>3、什么时候该用索引？ </p><p> </p><p>主键自动建立唯一索引恐涉侵权，请勿传播 </p><p>269 </p><p> </p><p>在经常用在连接（</p><p>join）的列上，这些列主要是一些外键，可以加快连接的速度 </p><p> </p><p>在经常需要根据范围搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； </p><p> </p><p>频繁作为查询条件（经常 where）的字段应该创建索引 </p><p> </p><p>查询中经常（OrderBy）排序的字段（因为索引已经排序，这样查询可以利用索引的排 </p><p>序，加快排序查询时间） </p><p> </p><p>查询中统计（</p><p>Count）或者分组（Groupby）的字段； </p><p>4、什么时候不该用索引？ </p><p> </p><p>在查询中很少使用或者参考的列不应该创建索引。 </p><p> </p><p>只有很少数据值的列也不应该增加索引。例如性别列 </p><p> </p><p>定义为 text, image 和 bit 数据类型的列不应该增加索引。这些列的数据量要么相当大， </p><p>要么取值很少,不利于使用索引。 </p><p> </p><p>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保 </p><p>存索引文件 </p><p> </p><p>表记录太少，不需要创建索引； </p><p> </p><p>经常增删改的表； </p><p>5、索引的优缺点 </p><p>优点： </p><p> </p><p>通过创建索引,可以在查询的过程中,提高系统的性能 </p><p> </p><p>通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性 </p><p> </p><p>在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间 </p><p>缺点： </p><p> </p><p>创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大 </p><p> </p><p>索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大 </p><p> </p><p>在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护 </p><p>6、索引的种类 </p><p> </p><p>普通索引：MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复 </p><p>值和空值，纯粹为了查询数据更快一 点。 </p><p> </p><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。 </p><p> </p><p>主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引） </p><p> </p><p>组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的 </p><p>左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。例如，这里由 id、 </p><p>name 和 age3 个字段构成的索引，索引行中就按 id/name/age 的顺序存放，索引可以索 </p><p>引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引 </p><p>最左面的前缀，那么就不会是用索引，比如，age 或者（</p><p>name，age）组合就不会使用 </p><p>索引查询。 </p><p> </p><p>全文索引：全文索引，只有在 MyISAM 引擎上才能使用，只能在 CHAR,VARCHAR,TEXT </p><p>类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通 </p><p>过其中的某个关键字等，就能找到该字段所属的记录行。一般开发中，不贵用到全文索 </p><p>引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。 </p><p>7、为什么使用联合索引 </p><p> </p><p>减 少 开 销 。 建 一 个 联 合 索 引 (col1,col2,col3) ， 实 际 相 当 于 建 了 </p><p>(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁 </p><p>盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ </p><p> </p><p>覆盖索引。对联合索引(col1,col2,col3)，如果有如下的 sql: select col1,col2,col3 from test恐涉侵权，请勿传播 </p><p>270 </p><p>where col1=1 and col2=2。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表， </p><p>这减少了很多的随机 io 操作。减少 io 操作，特别的随机 io 其实是 dba 主要的优化策略。 </p><p>所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 </p><p> </p><p>效率高。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 </p><p>sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出 </p><p>10%的数据，如果只有单值索引，那么通过该索引能筛选出 1000W10%=100w 条数据， </p><p>然后再回表从 100w 条数据中找到符合 col2=2 and col3= 3 的数据，然后再排序，再分页； </p><p>如果是联合索引，通过索引筛选出 1000w10% 10% *10%=1w，效率提升可想而知！ </p><p>8、数据库中的索引一般是什么数据结构？ </p><p>B+Tree 是一种树数据结构，是一个 n 叉排序树，每个节点通常有多个孩子，一棵 B+Tree 包 </p><p>含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两 </p><p>个以上孩子节点的节点。B+Tree 几乎是数据库默认的索引实现。 </p><p>延伸问题 1：hash 的查找时间复杂度是 O(1)比 B+的 O(logn)查找时间更短，为什么索引不用 </p><p>hash？（可以从 B+树索引的有序性，叶节点被双向链表连接，方便支持范围查找，以及分 </p><p>批加载至内存这几个方面回答） </p><p>这和业务场景有关，如果只查找一个值的话，hash 是一个很好的选择，单数据库经常会选 </p><p>择多条，这时候由于 B+树索引有序，并且又有链表相连，它的查询效率比 hash 就快很多了。 </p><p>而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计 </p><p>可以允许数据分批加载，同时树的高度较低，提高查找效率 </p><p>延伸问题 2：为什么不用红黑树（可以从内存，以及树深度和 IO 次数方面讨论这个问题。） </p><p>红黑树必须存在内存里的，数据库表太大了，存不进去。 </p><p>在大规模数据存储的时候，红黑树（二叉查找树）往往出现由于树的深度过大而造成磁盘 IO </p><p>读写过于频繁，进而导致效率低下的情况。B 树可以有多个子女，从几十到上千，可以降低 </p><p>树的高度。 </p><p>磁盘 IO 代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘 IO 频繁读写。根据磁 </p><p>盘查找存取的次数往往由树的高度所决定，红黑树查找一个节点最多要查 logN 层，每一层 </p><p>都是一个内存页。虽然你只是想找一个节点，但硬盘必须一次读一个页，那么一共 logN 次 </p><p>IO，消耗太大。 </p><p>延伸问题 3：为什么不用 B 树（可以从叶节点是否存数据，占用内存空间大小和是否支持范 </p><p>围查询这三个方面解释。 ） </p><p>B+树的数据都集中在叶子节点，分支节点只负责索引。 b 树的分支节点也有数据 。所以 </p><p>b+树的树高会小于 B 树，平均的 Io 次数会远大于 B+树。 </p><p>(比如一个节点是一个页 4096 字节，其中每条数据 128 字节，那么一个节点只能存 32 个数 </p><p>据项，那么对应的孩子节点数最多为 33 个，这显然不够用。而 b+树内部节点只作为导向作 </p><p>用，只存一个整数就可以（</p><p>int 型整数 32 位，消耗 4 个字节），4096/4=1024 个数据项。这 </p><p>样 b+树的每个节点的孩子数更多，整个树的高度就更低，大大增加查询效率。) </p><p>B+树索引节点没有数据。比较小。B 树可以把索引完全加载至内存中。 </p><p>B+树更擅长范围查询。叶子节点数据是按顺序放置的双向链表。 B 树范围查询只能中序遍 </p><p>历，做不到范围查询。 </p><p>原文链接：<a href="https://blog.csdn.net/uonele/article/details/106963120">https://blog.csdn.net/uonele/article/details/106963120</a> </p><p>9、索引的实现方式？ </p><p>在数据库中，常见的索引实现方式有哈希表、有序数组、搜索树。</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091612123.png" alt="image-20220309161214865"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091612872.png" alt="image-20220309161241692"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091613097.png" alt="image-20220309161323946"></p><p>10、innodb 的索引模型</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091614652.png" alt="image-20220309161412514"></p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091614923.png" alt="image-20220309161435808"></p><p>11、索引维护</p><p><img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091615077.png" alt="image-20220309161515930"></p><p>【数据库】MySQL 的逻辑架构 </p><p>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。 </p><p>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等 </p><p>所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。 </p><p>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存 </p><p>储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会 </p><p>解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信， </p><p>276恐涉侵权，请勿传播 </p><p>277 </p><p>只是简单响应上层服务器请求。 </p><p>【数据库】MySQL 的读写锁 </p><p>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型 </p><p>的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户 </p><p>在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会 </p><p>阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正 </p><p>在写入的同一资源。 </p><p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL </p><p>会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会 </p><p>被插入到读锁队列的前面，但是读锁不能插入到写锁前面。 </p><p>【数据库】MySQL 的锁策略有什么 </p><p>表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户 </p><p>在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有 </p><p>写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。 </p><p>行锁可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他 </p><p>存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。 </p><p>【数据库】数据库死锁如何解决 </p><p>死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现 </p><p>象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资 </p><p>源时也会产生死锁。 </p><p>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如 </p><p>InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有 </p><p>效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待 </p><p>超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持 </p><p>有最少行级排它锁的事务进行回滚。 </p><p>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是 </p><p>无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行 </p><p>因死锁回滚的事务即可。 </p><p>【数据库】数据库中的事务是怎么回事？ </p><p>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地 </p><p>对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩 </p><p>溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行 </p><p>成功，要么全部执行失败。 </p><p>ACID </p><p>\1. 原子性（</p><p>Atomicity） </p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 </p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚 </p><p>时反向执行这些修改操作即可。 </p><p>\2. 一致性（</p><p>Consistency） </p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取 </p><p>结果都是相同的。 </p><p>\3. 隔离性（</p><p>Isolation） </p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。 </p><p>\4. 持久性（Durability）恐涉侵权，请勿传播 </p><p>278 </p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的 </p><p>结果也不能丢失。 </p><p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数 </p><p>据的逻辑修改不同，重做日志记录的是数据页的物理修改。 </p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： </p><p>只有满足一致性，事务的执行结果才是正确的。 </p><p>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定 </p><p>能满足一致性。 </p><p>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满 </p><p>足一致性。 </p><p>事务满足持久化是为了能应对系统崩溃的情况。 </p><p>【数据库】MySQL 的隔离级别 </p><p>（</p><p>1）未提交读 READ UNCOMMITTED </p><p>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修 </p><p>改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有 </p><p>比其他级别好很多，很少使用。 </p><p>（</p><p>2）提交读 READ COMMITTED </p><p>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能” </p><p>看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对 </p><p>其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。 </p><p>（</p><p>3）可重复读 REPEATABLE READ（MySQL 默认的隔离级别） </p><p>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。 </p><p>但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。 </p><p>InnoDB 存储引擎通过多版本并发控制 MVCC 解决幻读的问题。 </p><p>（</p><p>4）可串行化 SERIALIZABLE </p><p>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都 </p><p>加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常 </p><p>需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。 </p><p>【数据库】聚簇索引和辅助索引 </p><p>总结：InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，聚簇索引就是按照 </p><p>每张表的主键构造一颗 B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集 </p><p>索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分； </p><p>一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建，但是这个主键如果 </p><p>更改代价较高，故建表时要考虑自增 ID 不能频繁 update 这点。 </p><p>我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需找 </p><p>主键索引的二级索引，现在找到主键索引再通过主键索引找数据； </p><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式。 </p><p>MySQL 数据库中 innodb 存储引擎，B+树索引可以分为聚簇索引（也称聚集索引，clustered </p><p>index）和辅助索引（有时也称非聚簇索引或二级索引，</p><p>secondary index，non-clustered index）。 </p><p>这两种索引内部都是 B+树，聚集索引的叶子节点存放着一整行的数据。 </p><p>Innobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、 </p><p>唯一索引。 </p><p>Innodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引 </p><p>聚簇索引(聚集索引)恐涉侵权，请勿传播 </p><p>279 </p><p>聚簇索引就是按照每张表的主键构造一颗 B+树，同时叶子节点中存放的就是整张表的 </p><p>行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是 </p><p>索引的一部分，每张表只能拥有一个聚簇索引。 </p><p>Innodb 通过主键聚集数据，如果没有定义主键，innodb 会选择非空的唯一索引代替。 </p><p>如果没有这样的索引，innodb 会隐式的定义一个主键来作为聚簇索引。 </p><p>聚簇索引的优缺点 </p><p>优点：</p><p>1.数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+树中，因此从聚簇索 </p><p>引中获取数据比非聚簇索引更快 </p><p>2.聚簇索引对于主键的排序查找和范围查找速度非常快 </p><p>缺点：</p><p>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出 </p><p>现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主 </p><p>键 </p><p>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表， </p><p>我们一般定义主键为不可更新。 </p><p>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行 </p><p>数据。 </p><p>辅助索引（非聚簇索引） </p><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅 </p><p>助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键 </p><p>值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。 </p><p>Innodb 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外， </p><p>还包含了相应行数据的聚簇索引键。 </p><p>辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在 </p><p>innodb 中有时也称辅助索引为二级索引。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-设计原则</title>
    <link href="http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-02T08:20:42.000Z</published>
    <updated>2022-03-15T10:44:43.157Z</updated>
    
    <content type="html"><![CDATA[<p>下面了解一些经典的设计原则，包括，SOLID、KISS、YAGNI、DRY、LOD 等。</p><p>就SOLID原则来说，SOLID 原则并非单纯的 1 个原则，而是由 5个设计原则组成的，它们分别是：<strong>单一职责原则、开闭原则、里式替换原则、接口隔离原则</strong>和<strong>依赖反转原则</strong>。</p><h3 id="单一职责原则SRP"><a href="#单一职责原则SRP" class="headerlink" title="单一职责原则SRP"></a>单一职责原则SRP</h3><p>描述起来就是：一个类或者一个模块只完成一个功能（职责）</p><p>也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，</p><p>一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该</p><p>将它拆分成多个功能更加单一、粒度更细的类。</p><p>​    需要注意的是，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否</p><p>单一的判定，可能都是不一样的。具体场景具体分析，并没有一个明确的，一成不变的标准。</p><p>​    不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展</p><p>性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以</p><p>此作为最终的考量标准。</p><p>​    总结几个情况可能说明这类的设计不满足单一职责原则：</p><p>1、类中的代码行数、函数或者属性过多；</p><p>2、类依赖的其他类过多，或者依赖类的其他类过多；</p><p>3、私有方法过多；</p><p>4、比较难给类起一个合适的名字；</p><p>5、类中大量的方法都是集中操作类中的某几个属性。</p><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>上面介绍了单一职责原则，下面来看一下   第二个原则：开闭原则</p><p>大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设</p><p>计原则就是开闭原则。</p><p>开闭原则的英文全称是 Open Closed Principle，他所描述的原则是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><h3 id="里式替换原则LSP"><a href="#里式替换原则LSP" class="headerlink" title="里式替换原则LSP"></a><strong>里式替换原则</strong>LSP</h3><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。</p><p>原则的描述大致是：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”</p><p>原则描述为：<strong>客户端不应该强迫依赖它不需要的接口</strong>。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>]]></content>
    
    
    <summary type="html">some of my thinks</summary>
    
    
    
    <category term="Notes" scheme="http://example.com/categories/Notes/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
