---
title: Computer Network  summery：运输层
date: 2021-06-20 19:59:58
tags: 
- Network
categories: 
- Notes
keywords:
description: some of my thinks
top_img: 
comments: 
cover: https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151833189.jpg
toc:  
toc_number:
copyright:
mathjax:
katex:
---

# Computer Network  summery：运输层



## 一、概述

- 为运行在不同主机上的进程提供服务（逻辑通信）

- 运输层协议在端系统中实现，不是在路由器中实现。

- 应用层报文段 ：将应用层报文分块，添加运输层首部

- 应用层协议：TCP  / UDP

  - TCP :面向连接的，可靠的服务
  - UDP：无连接的，不可靠服务

- 网络层可能会使分组丢失，篡改，冗余，运输层可以提供可靠数据传输

- 多路复用和多路分解

  - 多路分解：运输层报文段正确交付到相应 套接字

  - 多路复用：主机收集套接字信息，生成运输层报文，并传输到网络层中

  - UDP 的多路复用和分解

    

    - 一个UDP套接字：二元组（目的IP，目的端口号）

- - tcp的多路复用和分解
    - TCP套接字（目的IP，目的端口号，源IP，源端口号）
      - 后续报文段与之匹配，发送到该端口
    - 服务器主机支持很多并行套接字，每个与一个进程相连

- == 端口扫描技术 == 

  

## 二、UDP协议

  1.概述

​	支持 一对一、一对多、多对一和多对多的交互通信。即使是出现网络拥堵的情况下，UDP 也无法 进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDP 也不负责重发。 甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交 给由采用 UDP 的应用程序去处理。换句话说，UDP 将部分控制转移到应用程序去处理，自 己却只提供作为传输层协议的最基本功能。UDP 有点类似于用户说什么听什么的机制，但是 需要用户充分考虑好上层协议类型并制作相应的应用程序。

- 特点
  - 无需建立连接：无连接传输
  - 分组首部开销小: 首部8个字节
  - 控制更加精细（与应用层相比）
  - 无连接的状态：无连接状态参数
- 用于承载网络管理数据SNMP
- 运行的协议和服务：DNS
- 远程文件服务器：NFS

2. 报文结构

   2.1 报文结构:

![image-20210526194949625](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526194949625.png)

​	 2.2 检验和：检测传输比特是否改变  

- 方法：

- 原因：端到端服务需要差错检测，各链路情况不同，无法逐链路确保可靠性   即:

3.UDP 应用场景

​	效率要求相对高、要求**网络通讯速度能尽量快**，但是对**准确性要求相对低** 且对**网络通讯质量要求不高**的场景。

例如：QQ 聊天、在线视频、网络语音电话（即时通讯， 速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播 通信（广播、多播）。

**UDP 中一个包的大小最大能多大?** 

1.以太网(Ethernet)数据帧的长度必须在46-1500字节之间，这是由以太网的物理特性决定的。 这个 1500 字节被称为链路层的 MTU(最大传输单元)。 但这并不是指链路层的长度被限制在 1500 字节，其实这个 MTU 指的是链路层的数据区。 

2.并不包括链路层的首部和尾部的 18 个字节。所以，事实上，这个 1500 字节就是网络层 IP 数据报的长度限制。因为 IP 数据报的首部为 20 字节,所以 IP 数据报的数据区长度最大为 1480 字节。 

3.而这个 1480 字节就是用来放 TCP 传来的 TCP 报文段或 UDP 传来的 UDP 数据报的。又因为 UDP 数据报的首部 8 字节，所以 UDP 数据报的数据区最大长度为 1472 字节。这个 **1472** 字 节就是我们可以使用的字节数。 （TCP 首部是 20 ~60 个字节）

## 三、可靠传输原理

1. 流水线可靠数据传输协议

   - 不使用停等方式运行，允许发送方发送多个分组而无需等待确认， 许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，这种技术被称为流水线( pipelining)

     

   ![image-20210526195644330](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526195644330.png)

   - 流水线可靠传输协议带来的问题：

     - 必须增加序号范围

     - 发送方和接收方两端也许必须缓存多个分组

     - 解决流水线的差错恢复有两种基本方法是:回退 (Go- Back- N)

       GBN) 和选择重传 (Selective Repeat. SR)

2. 回退N步





3. 选择重传



## 四、TCP协议

### 1.概述



- 提供的是全双工服务(full- duplex service)
- TCP 连接是点对点( point-to-point) 的
- 连接的建立：三次握手
- 连接的断开：四次挥手
- TCP  最大报文段长度 (Maximum Segmenl Size , MSS) ， MSS 的典型值为 1460 字节
- TCP/IP 首部字段长度20字节
- TCP 数据发送和接收依赖两端主机维护的接收缓存和发送缓存。应用程序从此缓存中读取数据流。（每一端都有各自的发送缓存和接收缓存）

应用：HTTP、FTP、TELNET、SMTP

### 2.报文结构

：通常是20个字节（选项部分可变长，平常是0）

![image-20210526201119908](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526201119908.png)

- 32 比特的序号字段 (sequence number field) 
  - 标记发送方数据报文段首字节的字节流编号
- 32 比特的确认号字段( acknowledgment number field) 
  - 主机 期望从主机 收到的下一字节的序号
- 16 比特的接收窗口字段 (receive window field)
  - 用于流量控制
- 可选与变长的选项字段（options field) 
- 4 比特的首部长度字段 (header length field)
- 6 比特的标志字段 (fLag field) 
  - RST SYN FIN 比特用于连接建立和拆除
  - PSH ： 指示接收方应立即尽可能得将数据交给上层
  - URG ：指示报文段存在着被发送端的上层实体置为"紧急"的数据 紧急数据的最后一个字节由 16 比特的数据指针字段指出。
- 接收窗口



### 3.累计确认





对客户到服务器的数据的确认被装载在

个承载服务器到客户的数据的报文段中;这种确认被称为是被捎带( piggybacked )在服务器到客户的数据报文段中的



### 4.超时重传

4.1往返时间的估计

- 样本RTT:某报文段的确认被收到之间的时间量

  - 为已发送，未确认的报文段估计 SampleRTT
  - 不为已被重传的报文段计算 SampleRTT; 

- SampleRTT 均值  (称为 EstimatedRTT)

  - 计算方法：

    EstÌmatedRTT = (1 -α) . EstimatedRTT +α. SampleRTT 

  - α的 参考值是α=0.125 

- RTT 偏差DevRTT

  - DevRTT = (1 -β) . DevRTT +β. I SampleRTT matedRTT I 
  - β 的推荐值为 0.25

- 重传超时间隔

  - 算法：TimeoutInterval = EstimatedRTI +4 . DevRTT
  - 推荐的初始 TimeoutInterval 值为1 秒

### 5.可靠数据传输：

- TCP 发送方与发送和重传有关的主要事件:从应用程序接收数据;定时器超时和收到 ACK 
  - 定时器：当报文段被传给 IP时， TCP 启动定时器
  - 超时：重传报文段，TCP重启定时器
  - ACK：包含了有效 ACK 字段值的报文段的接受和比较
- 一些特殊情况：
  - 

- 超时间隔加倍
- 快速重传：一旦收到 个冗余 ACK ，TCP 就执行快速重传(fast retransmil) 
  - 超时重传超时周期长，增加了端到端时延
  - 冗余 ACK(duplicate ACK)   （出现在报文丢失）对相同数据的 ACK
- TCP 确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的

### 6.流量控制

6.1概念：

流量控制服务( fl0w- control service) 以消除发送方使接收方缓存溢出的可能性。

- 接收缓存

  - 用RcvBuffer 来表示其大小

  - • LastByteReacl: 主机 上的应用进程从发送缓存读出的数据流的最后 个字节的编号

    • LastByteRcvd:  到达的并已放入主机 接收缓存中的数据流的最后字节编号

  - 算法：LasLByteRcvd - LastByteRead ~ RcvBuffer 

- 接收窗口用：rwnd 

  - 根据缓存可用空间的数量来设置:
  - rwnd = RcvBuffer - [LastByteRcvd - LastßyteRead ] 
  - ![image-20210526211048201](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211048201.png)

- 主机在该连接的整个生命周期应保证:

  ​				LastByteSent - LastByteAcked <=rwnd

### 7.TCP连接

7.1建立连接

![image-20210526211607326](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211607326.png)

7.2 连接的断开

![image-20210526211636290](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211636290.png)

7.3 状态的变迁

![image-20210526211720656](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526211720656.png)

7.4 SYN泛洪攻击

### 8.拥塞控制

7.1 概念：TCP 发送方因 网络的拥塞而被遏制;这种形式的发送方的控制被称为拥塞控制 (congestion control)

- 在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥塞窗口

  (congeslion window) 。

  - 拥塞窗口表示为 cwnd  对 TCP 发送方 发送流量的速率进行了限制 

  - 在一个发送方中未被确认的数据量不会超过 cwnd rwnd 中的最小值，即：

    LastyleSent - LastByteAcked<= min { cwnd ，rwnd }

 

7.2拥塞控制：

- 一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率

- 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此 ，当对先前未确认报文段的确认到达时，增加发送方的速率。

- 带宽探测：为探测拥塞开始出现的速率， TCP 发送方增加它的

  传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化



7.3拥塞控制算法

该算法包括 个主要部分 ①慢启动;②拥塞避免;③快速恢复

如图所示：

![image-20210526213509588](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526213509588.png)

1. 慢启动

   TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据包的数量

    

   慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 **ACK**，拥塞窗⼝ **cwnd** 的⼤⼩就会加 **1**。

   这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。

   当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个

   当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个

   当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发

   4 个，所以这⼀次能够发送 8 个。

2. 拥塞避免算法

- 当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。

- ⼀般来说 ssthresh 的⼤⼩是 65535 字节。

- 规则：每当收到⼀个 **ACK** 时，**cwnd** 增加 **1/cwnd**。
- 接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ： 

当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9

个 MSS ⼤⼩的数据，变成了线性增⻓。

- 拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶段，但是增⻓速度缓慢了。

就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

当触发了重传机制，也就进⼊了「拥塞发⽣算法」。

拥塞发⽣

当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：

超时重传

快速重传

这两种使⽤的拥塞发送算法是不同的， 

1. 发⽣超时重传的拥塞发⽣算法

当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。

- ssthresh 和 cwnd 的值会发⽣变化：

  ​				ssthresh 设为 cwnd/2 ，cwnd 重置为 1

2.发⽣快速重传的拥塞发⽣算法

还有更好的⽅式，前⾯我们讲过「快速重传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地᯿传，不必等待超时再重传。

TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：

cwnd = cwnd/2 ，也就是设置为原来的⼀半;

ssthresh = cwnd ;进⼊快速恢复算法

3.快速恢复

快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也不那么糟

糕，所以没有必要像 RTO 超时那么强烈。

正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：

cwnd = cwnd/2 ，也就是设置为原来的⼀半;

ssthresh = cwnd ;

然后，进⼊快速恢复算法如下：

拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；

重传丢失的数据包；

如果再收到重复的 ACK，那么 cwnd 增加 1；

如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说

明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进

⼊拥塞避免状态；也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。



4. 回顾

   TCP 的拥塞控制是:

每个 RTT cwnd 线性(加性)增加 lMSS ，然后出现 个冗余ACK 事件时 cwnd 减半(乘性减) 。

因此， TCP 拥塞控制常常被称为加性增、乘性减(Additive-lncrease , Multiplicati 吨- Decrease , AIMD) 拥塞控制方式 

- 整体流程

  ![image-20210526214305050](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210526214305050.png)

  

- 其他算法：Reno 算法、TCPVegas 算法

### 9.TCP 三次握手 

 三次握手的过程 

1. 第一次握手：一般由客户端发起(SYN=1,seq=x) 客户端发送一个 TCP 的 SYN 标志为 1 的 包，指明客户端打算连接的服务器的端口，以及初始化序列号为 x，保存在包头的序列 恐涉侵权，请勿传播 60 号字段中。 发送完毕后客户端进入 SYN_SEND 状态 
2.  第二次握手：服务器会送确认(ACK)包(SYN=1,ACK=1,seq=y,ACKnum=x+1) 服务器发送确认 包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器选择自己的 ISN 序列号，放 在 seq 域中，同时将确认序列号(ACKnum)设置为客户端的 ISN 加 1，即 x+1 发送完毕后 服务器进入 SYN_RCVD 状态 
3.  第三次握手：客户端再次发送确认(ACK)包(SYN=0，ACK=1，ACKNum = y+1) SYN 置为 1， ACK 标志为 1，并把服务器发来的 ACK 序号字段加 1，放在字段中发送给对方，并且在 数据段写 ISN 加一 发送完毕后客户端进入 ESTABLISH 状态，当服务器接收到这个包的时 候也进入 ESTABLISH 阶段，这个时候握手结束

流程图：![image-20220416035533961](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220416035533961.png)

参考文献  :计算机网络自顶向下方法



 
