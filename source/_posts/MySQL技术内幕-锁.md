---
title: MySQL技术内幕-锁
date: 2022-02-12 13:56:09
tags: 
- MySQL
categories: 
- Notes
keywords:
description: some of my thinks
top_img: 
comments: 
cover: https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151833187.jpg
toc:  
toc_number:
copyright:
mathjax:
katex:
---

开发多用户数据库应用时，最大的难点：最大程度的确保数据库程序的并发访问；确保每个用户能够以一致的方式读取修改数据。

​	锁是数据库区别于问及那系统的一个重要特性之一。

​	下面介绍各种存储引擎的锁进行比较，锁定数据的粒度等。

## 一、锁

InnoDB存储引擎不需要锁升级，一个锁和多个锁的开销是相同的。

InnoDB的锁是在行级别上对表数据上锁。

​	**数据库使用锁是为了保证对资源的并发访问，以及数据的完整性和一致性。**

不同数据库对于锁的底层实现一般是不相同的。

例如：MyISAM的锁设计是表锁设计；SQL server会有锁升级，行锁升级到表锁。



### 二、Lock、Latch

lock和latch到可以称为锁。**重点关注的是Lock**

- lock：锁定对象是事务，在commit或者rollback后释放；有死锁机制。
- latch： 闩锁（轻量级锁）；用来保证并线程操作临界资源的正确性；通常没有死锁检测。

两者的区别，总结大致如图：

 ![image-20220307193909474](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203071939557.png)



​	InnoDB存储引擎中的latch可以通过SHOW ENGINE INNODB MUTEX来进行查看。

### 三、InnoDB存储引擎中的锁

**一、锁的类型**

- 共享锁 S lock  :允许事务删除一行数据
- 排它锁 X lock：允许事务删除和更改一行数据。

:one:锁共享: 事务T1获取了行R 的共享锁，事务T2 可以立即获取R的共享锁。

:two:共享锁和排它锁的兼容性：

![image-20220309083113212](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090831300.png)

:three:意向锁：InnoDB支持多粒度锁定（允许锁在行级和表级同时存在）。意向锁将锁定的对象分成多个层次，意味着事务将在更细的粒度上加锁。

​	INNODB 对于意向锁的设计比较简单，即为表级的锁。支持两种意向锁：

- 意向共享锁：事物想要获得一张表中几行的共享锁
- 意向排它锁：事务想要获取一张表中几行的排它锁

InnoDB支持的行级别的锁，因此意向锁不会阻塞除了全表扫描以外的任何操作。

​	兼容性如下图：

![image-20220309083124141](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090831206.png)

:four:查看锁状态：

InnoDB1.0开始在INFOMATION_SCHEMA架构下有三个表用来简单监控当前事务和分析可能性存在的锁问题。分别是：

- INNODB_TRX:显示当前运行的事务信息

结构图：

​			![image-20220309083642071](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090836143.png)	

- INNODB_LOCKS:查看锁的情况

结构图：

​				![image-20220309083630941](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090836020.png)



注：lock_data很特殊，用户尽享范围查找，lock_data可能只返回第一行主键值。如果当期拿资源被锁住了，因为缓冲池容量而导致该页被刷出。查看innodb_lock表，lock_data会显示为Nu'll，说明没有对磁盘重新进行查找。



- INNODB_LOCKS_WAITS:直观反映当事务的等待情况。

事务量变大的时候依靠INNODB_LOCKS 就不那么容易的判断了。可以通过INNODB_LOCKS_WAITS

来进行判断。

结构图：

​			![image-20220309084443856](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090844915.png)

  

**二、一致性非锁定读**

指的是InnoDB通过多版本控制的方式来读取当前是执行时间数据库中的行数据。

​	如果当前操作是DELETE和UPDAE ，读取操作不会等待行锁的释放。而是直接读取一个**快照数据**。如图所示：

​						![image-20220309084955276](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090849337.png)

注：:one:快照数据根据undo段来进行完成，不会对当前事务增加额外开销

​	    :two:非锁定度机制极大的提高了数据库的并发性。

​		:three:InnoDB默认情况下，**默认使用一致性非锁定读**，读取不会占用等待表上的锁。

 **1、多版本并发控制 （MVCC）**：

​	一个行记录可能有多个不同版本的快照数据（多版本技术），在此条件下，进行的并发控制

叫做多版本并发控制。



**2、不同隔离界别一致性的的异同：**

READ COMMIT ：对于快照数据，总是读取被锁定行的最新版本数据。

REPEATABLE READ :对于快照数据读取，总是读取最开始的数据

注：READ COMMIT 条件下的读，违反了事务的隔离性



**3、一致性锁定读：**

有时候用户需要显示得对数据库读取进行加锁以保证数据逻辑的一致性。

​	InnoDB对于SELECT的只读操作提供了两种一致性的锁定读：

- SELECT....FOR UPDATE:(对读取的行加X锁)
- SELECT ...LOCK IN SHARE MODE ：（对读取的行加S锁）



**4、自增长和锁**：

InnoDB的内存结构，对于每个含有自增长值的表，都有一个自增长计数器。对含有自增的计数器的表进行插入时会初始化。

​	首先，我们来了解一下插入操作的过程。插入一行数据时，会对这个表加一个特殊的表锁，为了

提高性能，通常这个锁不是在事务完成之后释放，而是在完成插入SQL语句之后立即释放。

这种插入方式在插入大量数据的时候，会造成阻塞。

因此提供了一种轻量级互斥量的自增长机制。InnoDB提供了一个参数innodb_autoinc_lock_mode来控制自增长的模式，**默认值是1**。

如表所示：

​				![image-20220309091314542](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090913641.png)

此外集群模式下要考虑MyISAM存储引擎的自增长实现的不同（表锁设计，自增长不考虑并发插入的问题）



**五、外键和锁**

外键主要进行完整性约束检查。

​	对于外键的插入更新，会查询父表，但是不是使用一致性非锁定读的方式（会发生数据不一致的情况）。因此**子表的操作可能被同时存在的父表操作阻塞**。



### 四、锁的算法



**一、行锁的三种算法**

:one:Record lock:单个行记录上的锁

:two:Gap lock:间隙锁，锁定一个范围，而不是一个记录

:three:Next-Key Lock:锁定一个范围并且锁定记录本身

重点了解Next-Key Lock （是InnoDB为了解决幻读问题的解决方法）

举个例子了解Next-Key Lock

​			<img src="https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203090934782.png" alt="image-20220309093455714" style="zoom:80%;" />



对于索引的扫描，不仅锁住了扫描到的索引，还锁住了这些索引覆盖的范围。



**锁降级**：当查询的索引仅仅含有一条记录，会进行优化，将Next-Key Lock降级为Record Lock，仅仅锁住索引本身，而不是范围。从而提高并发性。

注：**这种锁降级是在查询的索引是唯一索引**的情况下，辅助索引则大有不同。



​	如果查询的是辅助索引：

:one:在与辅助索引对应的聚集索引加Record Lock

:two:在查询的辅助索引上加 Next-Key Lock

:three:对辅助索引下一个键值加间隙锁（为了阻止多个事务将记录插入到同一范围，会导致幻读问题的产生）



关闭间隙锁Gap lock方法：

- 将事务隔离级别设置成Read Commit
- 将参数innodb_locks_unsafe_for_binlog

因此Read Commit条件下，除了外键约束和唯一性检查，其余情况都使用Record Lock ，但是破坏了事物的隔离性，不建议这样操作。



**二、幻像问题（Phantom Problem）**

​	是指在同一事务下，连续执行两次相同的SQL 语句可能得到的结果不同，第二次可能返回之前不存在的行。



### 五、锁问题

**一、脏读**

脏读是指读取到了还未提交的数据（另一个事务），显然违背了事物的隔离性。

通常这个问题出现在 READ UNCOMMIT 隔离级别下。

**二、不可重复读**

​	假设有两个事务。由于第二个事务的修改，第一个事物先后两次独到的数据可能不同。

这种现象叫做不可重复读（**违背了事务的一致性**）。

**不可重复度和脏读的区别：**

脏读是读到未提交的数据，不可重复读是读到已经提交的数据。

通常设置成 READ REPEATABLE 隔离界别避免不可重复度。



### **六、阻塞**

​	阻塞是指：由于不同锁之间的兼容性关系，一个事务需要等待另一个事务的锁释放它所占用的资源。

有两个参数控制阻塞时的等待：

:one:innodb_rollback_on_timeout：（静态的）控制等待时间，默认50 秒

:two:innodb_lock_wait_timeout:(动态的) 控制等待时是否进行回滚操作



### 七、死锁

​	死锁是指两个或两个以上事务在执行过程中，争夺锁资源造成的一种互相等待的过程。



**解决死锁的方法：**

- 最简单的方法是不要有等待，将任何等待都化成回滚，事务重新开始。
- 超时：两个事务互相等待超过某一阈值，其中一个事务进行回滚，另一个事务继续进行
- 普遍采用wait-for graph的方式，相比于之前两种，这是以一种**主动的死锁检测方式**。

**wait-for graph**：

​	保存两种信息：

​	:one:锁的信息链表

​	:two:事务等待链表

通过上述链表构造一张图，如果图中存在环，则存在死锁，资源之间发生了互相等待。

若存在死锁优先回滚undo量最小的事务（权重）。

注：InnoDB存储引擎并不会回滚大部分错误异常，但是死锁除外。发现死锁立即回滚某个事务。



**锁升级**：

InnoDB不存在锁升级，对于每个事务的锁的访问管理，采用的是位图的方式。不管事务锁住页中有一个记录还是多个记录，开销都是相同的。
