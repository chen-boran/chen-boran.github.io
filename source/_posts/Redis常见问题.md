---
title: Redis常见问题
date: 2022-02-11 20:51:40
tags: 
- Redis
categories: 
- Notes
keywords:
description: some of my notes
top_img: 
comments: 
cover: https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151833185.jpg
toc:  
toc_number:
copyright:
mathjax:
katex:
---

- - -

    - - 如何解决缓存雪崩？
      - 如何解决缓存穿透？
      - 如何保证缓存与数据库双写时一致的问题？
    
    - # 一、缓存雪崩
    
    - ## 1.1什么是缓存雪崩？
    
    - 回顾一下我们为什么要用缓存(Redis)：
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112044559.webp)为什么要缓存
    
    - 现在有个问题，**如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了**。
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112045056.webp)如果缓存挂掉了，全部请求跑去数据库了
    
    - 在前面学习我们都知道Redis不可能把所有的数据都缓存起来(**内存昂贵且有限**)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。[Redis对过期键的策略+持久化](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484386&idx=1&sn=323ddc84dc851a975530090fcd6e2326&chksm=ebd742e3dca0cbf52bc65d430447e639d81cc13e0ac34613edf464dae3950b10e2e1df74dcc5&token=1834317504&lang=zh_CN&scene=21#wechat_redirect)
    
    - 如果缓存数据**设置的过期时间是相同**的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存**同时失效**，全部请求到数据库中。
    
    - **这就是缓存雪崩**：
    
    - - Redis挂掉了，请求全部走数据库。
      - 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。
    
    - 缓存雪崩如果发生了，很可能就把我们的数据库**搞垮**，导致整个服务瘫痪！
    
    - ## 1.2如何解决缓存雪崩？
    
    - 对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：
    
    - - 解决方法：在缓存的时候给过期时间加上一个**随机值**，这样就会大幅度的**减少缓存在同一时间过期**。
    
    - 对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：
    
    - - 事发前：实现Redis的**高可用**(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
      - 事发中：万一Redis真的挂了，我们可以设置**本地缓存(ehcache)+限流(hystrix)**，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
      - 事发后：redis持久化，重启后自动从磁盘上加载数据，**快速恢复缓存数据**。
    
    - # 二、缓存穿透
    
    - ## 2.1什么是缓存穿透
    
    - 比如，我们有一张数据库表，ID都是从1开始的(**正数**)：
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112046859.webp)随便找了一张数据库表
    
    - 但是可能有黑客想把我的数据库搞垮，每次请求的ID都是**负数**。这会导致我的缓存就没用了，请求全部都找数据库去了，但数据库也没有这个值啊，所以每次都返回空出去。
    
    - > 缓存穿透是指查询一个一定**不存在的数据**。由于缓存不命中，并且出于容错考虑，如果从**数据库查不到数据则不写入缓存**，这将导致这个不存在的数据**每次请求都要到数据库去查询**，失去了缓存的意义。
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112046860.webp)缓存穿透
    
    - **这就是缓存穿透**：
    
    - - 请求的数据在缓存大量不命中，导致请求走数据库。
    
    - 缓存穿透如果发生了，也可能把我们的数据库**搞垮**，导致整个服务瘫痪！
    
    - ## 2.1如何解决缓存穿透？
    
    - 解决缓存穿透也有两种方案：
    
    - - 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter**提前拦截**，不合法就不让这个请求到数据库层！
    
      - 当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。下次再请求的时候，就可以从缓存里边获取了。
    
      - - 这种情况我们一般会将空对象设置一个**较短的过期时间**。
    
    - 参考资料：
    
    - - 缓存系列文章--5.缓存穿透问题
    
      - - https://carlosfu.iteye.com/blog/2248185
    
    - # 三、缓存与数据库双写一致
    
    - ## 3.1对于读操作，流程是这样的
    
    - 上面讲缓存穿透的时候也提到了：如果从数据库查不到数据则不写入缓存。
    
    - 一般我们对**读操作**的时候有这么一个**固定的套路**：
    
    - - 如果我们的数据在缓存里边有，那么就直接取缓存的。
      - 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后**将数据库查出来的数据写到缓存中**。
      - 最后将数据返回给请求
    
    - ## 3.2什么是缓存与数据库双写一致问题？
    
    - 如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要**更新**时候呢？各种情况很可能就**造成数据库和缓存的数据不一致**了。
    
    - - 这里不一致指的是：**数据库的数据跟缓存的数据不一致**
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112046180.webp)数据库和缓存的数据不一致
    
    - 从理论上说，只要我们设置了**键的过期时间**，我们就能保证缓存和数据库的数据**最终是一致**的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。
    
    - 除了设置过期时间，我们还需要做更多的措施来**尽量避免**数据库与缓存处于不一致的情况发生。
    
    - ## 3.3对于更新操作
    
    - 一般来说，执行更新操作时，我们会有两种选择：
    
    - - 先操作数据库，再操作缓存
      - 先操作缓存，再操作数据库
    
    - 首先，要明确的是，无论我们选择哪个，我们都希望这**两个操作要么同时成功，要么同时失败**。所以，这会演变成一个**分布式事务**的问题。
    
    - 所以，**如果原子性被破坏了**，可能会有以下的情况：
    
    - - **操作数据库成功了，操作缓存失败了**。
      - **操作缓存成功了，操作数据库失败了**。
    
    - > 如果第一步已经失败了，我们直接返回Exception出去就好了，第二步根本不会执行。
    
    - 下面我们具体来分析一下吧。
    
    - ### 3.3.1操作缓存
    
    - 操作缓存也有两种方案：
    
    - - 更新缓存
      - 删除缓存
    
    - 一般我们都是采取**删除缓存**缓存策略的，原因如下：
    
    - 1. 高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就**更加容易**导致数据库与缓存数据不一致问题。(删除缓存**直接和简单**很多)
      2. 如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现**懒加载**)
    
    - 基于这两点，对于缓存在更新时而言，都是建议执行**删除**操作！
    
    - ### 3.3.2先更新数据库，再删除缓存
    
    - 正常的情况是这样的：
    
    - - 先操作数据库，成功；
      - 再删除缓存，也成功；
    
    - 如果原子性被破坏了：
    
    - - 第一步成功(操作数据库)，第二步失败(删除缓存)，会导致**数据库里是新数据，而缓存里是旧数据**。
      - 如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。
    
    - 如果在高并发的场景下，出现数据库与缓存数据不一致的**概率特别低**，也不是没有：
    
    - - 缓存**刚好**失效
      - 线程A查询数据库，得一个旧值
      - 线程B将新值写入数据库
      - 线程B删除缓存
      - 线程A将查到的旧值写入缓存
    
    - 要达成上述情况，还是说一句**概率特别低**：
    
    - > 因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，**而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存**，所有的这些条件都具备的概率基本并不大。
    
    - 对于这种策略，其实是一种设计模式：`Cache Aside Pattern`
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112044375.webp)先修改数据库，再删除缓存
    
    - **删除缓存失败的解决思路**：
    
    - - 将需要删除的key发送到消息队列中
      - 自己消费消息，获得需要删除的key
      - **不断重试删除操作，直到成功**
    
    - ### 3.3.3先删除缓存，再更新数据库
    
    - 正常情况是这样的：
    
    - - 先删除缓存，成功；
      - 再更新数据库，也成功；
    
    - 如果原子性被破坏了：
    
    - - 第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。
      - 如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。
    
    - 看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：
    
    - - 线程A删除了缓存
      - 线程B查询，发现缓存已不存在
      - 线程B去数据库查询得到旧值
      - 线程B将旧值写入缓存
      - 线程A将新值写入数据库
    
    - 所以也会导致数据库和缓存不一致的问题。
    
    - **并发下解决数据库与缓存不一致的思路**：
    
    - - 将删除缓存、修改数据库、读取缓存等的操作积压到**队列**里边，实现**串行化**。
    
    - ![图片](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202202112044508.webp)将操作积压到队列中
    
    - ## 3.4对比两种策略
    
    - 我们可以发现，两种策略各自有优缺点：
    
    - - 先删除缓存，再更新数据库
    
      - - 在高并发下表现不如意，在原子性被破坏时表现优异
    
      - 先更新数据库，再删除缓存(`Cache Aside Pattern`设计模式)
    
      - - 在高并发下表现优异，在原子性被破坏时表现不如意

## 3.5其他保障数据一致的方案与资料

可以用**databus**或者阿里的**canal监听binlog**进行更新。

参考资料：

- 缓存更新的套路

- - https://coolshell.cn/articles/17416.html

- 如何保证缓存与数据库双写时的数据一致性？

- - https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md

- 分布式之数据库和缓存双写一致性方案解析

- - https://zhuanlan.zhihu.com/p/48334686

- Cache Aside Pattern

- - https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/81008933







作者：走马观花AA
链接：https://www.nowcoder.com/discuss/864641?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=B72BE11AC5CE4285D6262E3B40B306F9-1647494144339
来源：牛客网



分布式缓存 

 缓存好处：高性能 + 高并 

​    

 数据库查询耗费了800ms，其他用户对同一个数据再次查询 ，假设该数据在10分钟以内没有变化过，并且 10 分钟之内有 1000 个用户 都查询了同一数据，10 分钟之内，那 1000 每个用户，每个人查询这个数据都感觉很慢 800ms 

 比如 ：某个商品信息，在 一天之内都不会改变，但是这个商品每次查询一次都要耗费2s，一天之内被浏览 100W次 

 mysql 单机也就 2000qps,缓存单机轻松几万几十万qps,单机 承载并发量是 mysql 单机的几十倍。 

 如果感觉小编写得不错，请素质三连：点赞+转发+关注。我会努力写出更好的作品分享给大家。更多[学习资料](https://docs.qq.com/doc/DVGJkS1lRRWdrV3hk)小编已打包好，可以找我领取哦！领取方式：私信回复暗号**【333】**即可免费领取更多完整版资料。 

 高并发 

 在中午高峰期，有 100W 个用户访问系统 A，每秒有 4000 个请求去查询数据库，数据库承载每秒 4000 个请求会宕机，加上缓存后，可以 3000 个请求走缓存 ，1000 个请求走数据库。 

 缓存是走内存的，内存天然可以支撑4w/s的请求，数据库（基于磁盘）一般建议并发请求不要超过 2000/s 

 缓存不良后果 

 缓存与数据库双写不一致 

 缓存雪崩 

 缓存穿透 

 缓存并发竞争 

 Redis 线程模型 

 [redis]() 单线程 ，memcached 多线程 

 [redis]() 是单线程 nio 异步线程模型 

 Redis 和 Memcached 区别 

 Redis 支持服务器端的数据操作：Redis比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络 IO 的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能支持更复杂的结构和操作，那么Redis会是不错的选择 

 集群模式：memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据，但是 Redis 目前是原生支持 cluster模式的 

 Redis 单线程模型 

 一个线程+一个队列 

 [redis]() 基于 reactor 模式开发了网络事件处理器，这个处理器叫做文件事件处理器，file event handler，这个文件事件处理器是单线程的，所以[redis]() 是单线程的模型，采用 io多路复用机制同时监听多个 socket,根据socket上的事件来选择对应的事件处理器来处理这个事件。 

 文件事件处理器包含：多个 socket,io多路复用程序，文件事件分派器，事件处理器（命令请求处理器、命令恢复处理器、连接应答处理器） 

 文件事件处理器是单线程的，通过 io 多路复用机制监听多个 socket，实现高性能和线程模型简单性 

 被监听的 socket 准备好执行 accept,read,write,close等操作的时候，会产生对应的文件事件，调用之前关联好的时间处理器处理 

 多个 socket并发操作，产生不同的文件事件，i/o多路复用会监听多个socket，将这些 socket放入一个队列中排队。事件分派器从队列中取出socket给对应事件处理器。 

 一个socket时间处理完后，事件分派器才能从队列中拿到下一个socket，给对应事件处理器来处理。 

 文件事件： 

 AE_READABLE 对应 socket变得可读（客户端对[redis]()执行 write操作） 

 AE_WRITABLE 对应 socket 变得可写（客户端对 [redis]()执行 read操作） 

 I/O 多路复用可以同时监听AE_REABLE和 AE_WRITABLE ，如果同时达到则优先处理 AE_REABLE 时间 

 文件事件处理器： 

 连接应答处理器 对应 客户端要连接 [redis]() 

 命令请求处理器 对应 客户端写数据到 [redis]() 

 命令恢复处理器 对应 客户端从 [redis]() 读数据 

 流程： 

 [redis]() 初始化时，会将连接应答处理器跟 AE_READABLE事件关联 

 客户端对 [redis]() 发起连接，产生一个 AE_READABLE 事件 

 连接应答处理器处理客户端 AE_READABLE 事件，创建客户端对应的 socket，同时将这个 socket的 AE_READABLE 事件和命令请求处理器关联 

 客户端对 [redis]() 发起读请求，会在 socket上产生一个 AE_READABLE 事件 

 绑定 AE_READABLE 事件的命令请求处理器会从 socket 中读取请求相关数据，执行对应操作，当执行完毕后，将 socket的 AE_WRITABLE 事件跟命令回复处理器关联 

 当客户端这边准备好读取响应时，会在 socket上产生一个AE_WRITABLE事件 

 绑定 AE_WRITABLE 事件的命令回复处理器将准备好的响应数据写入 socket，供客户端来读取 

 命令回复处理器写完后，删掉 socket的 AE_WRITABLE 事件和命令回复处理器的绑定关系 

 Redis 单线程模型效率高 

 一秒钟可以处理几万个请求 

 非阻塞 I/O 多路复用机制（不处理事件，只轮询请求压入队列） 

 纯内存操作（操作只有几微秒） 

 单线程反而 避免了多线程频繁上下文切换的问题 

 Redis 数据类型 

 string 

 普通的 set,get kv缓存 

 hash 

 类型 map结构，比如一个对象（没有嵌套对象）缓存到 [redis]()里面，然后读写缓存的时候，可以直接操作hash的字段（比如把 age 改成 21，其他的不变） 

 key=150 

 value = { 

```
"id":150, "name":"zhangsan", "age":20
```

 有序列表 ，元素可以重复 

 可以通过 list 存储一些列表型数据结构，类似粉丝列表，文章评论列表。 

 例如：微信大 V的粉丝，可以以 list 的格式放在 [redis]() 里去缓存 

 key=某大 V value=[zhangsan,lisi,wangwu] 

 比如 lrange 可以从某个元素开始读取多少个元素，可以基于 list 实现分页查询功能，基于 [redis]()实现高性能分页，类似[微博]()下来不断分页东西。 

 可以搞个简单的消息队列，从 list头怼进去（lpush），list尾巴出来 (brpop) 

 set 

 无序集合，自动去重 

 需要对一些数据快速全局去重，（当然也可以基于 HashSet，但是单机） 

 基于 set 玩差集、并集、交集的操作。比如：2 个人的粉丝列表整一个交集，看看 2 个人的共同好友是谁？ 

 把 2 个大 V 的粉丝都放在 2 个 set中，对 2 个 set做交集（sinter） 

 sorted set 

 [排序]()的 set，去重但是可以[排序]()，写进去的时候给一个分数，自动根据分数[排序]() 

 排行榜： 

 将每个用户以及其对应的分数写入进去 

 zadd board score username 

 zrevrange board 0 99 可以获取排名前 100 的用户 

 zrank board username 可以看到用户在排行榜里的排名 

 例如： 

 zadd board 85 zhangsan 

 zadd board 72 wangwu 

 zadd board 96 lis 

 zadd board 62 zhaoliu 

 自动[排序]()为： 

 96 lisi 

 85 zhangsan 

 72 wangwu 

 62 zhaoliu 

 获取排名前 3 的用户 ： zrevrange board 0 3 

 96 lisi 

 85 zhangsan 

 72 wangwu 

 查看zhaoliu的排行 ：zrank board zhaoliu 返回 4 

 Redis 过期策略 

 内存是宝贵的，磁盘是廉价的 

 给key设置过期时间后，[redis]()对这批key是定期删除+惰性删除 

 定期删除： 

 [redis]() 默认每隔 100ms随机抽取一些设置了过期时间的 key，检查其是否过期了，如果过期就删除。 

 注意：[redis]()是每隔100ms随机抽取一些 key来检查和删除，而不是遍历所有的设置过期时间的key（否则CPU 负载会很高，消耗在检查过期 key 上） 

 惰性删除： 

  获取某个key的时候， [redis]() 会检查一下，这个key如果设置了过期时间那么是否过期，如果过期了则删除。 

 如果定期删除漏掉了许多过期key，然后你也没及时去查，也没走惰性删除，如果大量过期的key堆积在内存里，导致 [redis]() 内存块耗尽，则走内存淘汰机制。 

 内存淘汰策略： 

 noeviction:当内存不足以容纳新写入数据时，新写入操作直接报错（没人用） 

 allkeys-LRU: 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（最常用） 

 allkeys-random: 当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，(没人用) 

 volatile-lru:当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key(不合适) 

 volatile-ttl:当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除(不合适) 

 LRU [算法]()： 

```
package com.mousycoder.mycode; import java.util.LinkedHashMap; import java.util.Map; /**
* @version 1.0
* @author: mousycoder
* @date: 2019/10/31 17:55
*/ public class lruCache<K,V> extends LinkedHashMap<K,V> { private final int CACHE_SIZE; public LRUCache( int cacheSize) { super((int)Math.ceil(cacheSize / 0.75) + 1 ,0.75f,true); this.CACHE_SIZE = cacheSize;
} @Override protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { return size() > CACHE_SIZE;
} public static void main(String[] args) {
LRUCache<integer,Integer> lruCache = new LRUCache<>(10); for (int i = 0; i < 15; i++) {
lruCache.put(i,i);
}
Integer integer1 = lruCache.get(0); for (Integer integer : lruCache.keySet()) {
System.out.println(integer);
}
}
}
```

 Redis 高并发和高可用 

 缓存架构（多级缓存架构、热点缓存） 

 [redis]() 高并发瓶颈在单机，读写分离，一般是支撑读高并发，写请求少，也就 一秒一两千，大量请求读，一秒钟二十万次。 

 主从架构 

 一主多从，主负责写，将数据同步复制到其他 slave节点，从节点负责读，所有读的请求全部走从节点。主要是解决读高并发。、 

 主从架构->读写分离->支撑10W+读QPS架构 

 Redis Replication 

 master->slave 复制，是异步的 

 核心机制： 

 [redis]() 采用异步方式复制数据到 slave 节点 

 一个 master node是可以配置多个 slave node的 

 slave node也可以连接其他的 slave node 

 slave node 做复制的时候，是不会 block master node的正常工作 

 slave node 在做复制的时候，也不会 block对自己的查询操作，它会用旧的数据集来提供服务。但是复制完成时，需要删除旧数据集，加载新的数据集，这个时候就会暂停对外服务了。 

 slave node 主要用来进行横向扩容，做读写分离，扩容 slave node 可以提高读的吞吐量 

 master持久化对主从架构的意义： 

 如果开启了主从架构，一定要开启 master node的持久化，不然 master宕机重启数据是空的，一经复制，slave的数据也丢了 

 主从复制原理： 

 第一次启动或者断开重连情况： 

 当启动一个 slave node的时候，它会发送一个 PSYNC 命令给 master node 

 master 会触发一次 full resynchronization （如果不是第一次连接，master 只会复制给 slave 部分缺少的数据，从backlog里找） 

 master会启动一个后台线程，开始生成一份 RDB 快照（ bgsave,也可以直接在内存中创建），同时将从客户端收到的所有写命令缓存在内存中。RDB 文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后 master会将内存中缓存的写命令发送给 slave,slave也会同步这些数据（slave如果跟 master网络故障，断开连接，会自动重连，master如果发现有多个 slave 来重新连接，仅仅只会启动一个 RDB save 操作，用一份数据服务所有 slave node） 

 正常情况下： 

 master 来一条数据，就异步给 slave 

 Redis高可用性 

 全年 99.99%的时间，都是出于可用的状态，那么就可以称为高可用性 

 [redis]() 高可用架构叫故障转移，failover，也可以叫做主备切换，切换的时间不可用，但是整体高可用。 

 sentinal node(哨兵) 

 Sentinal 

 作用： 

 集群监控，负责监控 [redis]() master 和 slave进程是否正常 

 消息通知，如果某个 [redis]() 实例有故障，那么哨兵负责发送消息作为报警通知给管理员 

 故障转移，如果 master 挂掉，会自动转移到 slave 

 配置中心，如果故障转移了，通知 client 客户端新的 master地址 

 两节点哨兵集群 

 quorum = 1 （代表哨兵最低个数可以尝试故障转移，选举执行的哨兵） 

 master 宕机，只有 S2 存活，因为 quorum =1 可以尝试故障转移，但是没达到 majority =2 （最低允许执行故障转移的哨兵存活数）的标准，无法执行故障转移 

 三节点哨兵集群（经典） 

 如果 M1 宕机了，S2,S3 认为 master宕机，选举一个执行故障转移，因为 3 个哨兵的 majority = 2，所以可以执行故障转移 

 Redis 主从 + 哨兵 

 丢数据： 

 master内存中数据异步同步到 slave master 就挂掉了,丢掉了 master 内存中的数据 

 脑裂，某个 master 所在机器突然脱离了正常的网络，其他 slave机器不能连接，但是实际上 master还在运行，哨兵认为 master 宕机，选举 slave为master，此时集群里有 2 个 master, client还没来得及切换到新的master，还继续写在旧的 master上，数据丢了，此时旧的 master再次恢复，被被作为一个 slave 挂到新的 master 上，自己的数据被清空 （脑裂，大脑一分为 2，同时指挥同一个人） 

 解决方案： 

 min-slaves-max-lag 10 （至少一个 slave同步的延迟不能超过 10s） 减少异步复制的数据丢失，发现slave复制数据和 ack延时过长，拒绝写入，减少同步数据损失。让client做降级写到本地磁盘里和限流，或者先暂存到消息队列，然后重新发回 master 

 min-slaves-to-write 1 减少脑裂带来的数据丢失，最多损失 10 s数据，假设master 不能继续给 slave发送数据，并且 slave 10s没给自己的 ack消息，直接拒绝客户端写请求，同时 client做降写到本地磁盘、限流，或者先暂存到消息队列，然后重新发回 master 

 哨兵 

 sdown 主观宕机，哨兵觉得一个 master 宕机（ping 超过了 


 is-master-down-after-milliseconds毫秒数） 

 odown 客观宕机，quorum数量的哨兵都觉得 master宕机 

 哨兵互相感知通过 [redis]()的 pub/sub系统，每隔 2 秒往同一个 channel里发消息（自己的 host,ip,runid），其他哨兵可以消费这个消息 

 以及同步交换master的监控信息。 

 哨兵确保其他slave修改master信息为新选举的master 

 当一个 master被认为 odown && marjority哨兵都同意，那么某个哨兵会执行主备切换，选举一个slave成为master（考虑 1. 跟master断开连接的时长 2. slave 优先级 3.复制 offset 4. runid） 

 选举[算法]()： 

 如果slave跟master断开连接已经超过 down-after-milliseconds * 10 + master宕机时间，则放弃 

 按 slave 优先级[排序]() ，slave-priority 越小越靠前 

 replica offset ，哪个slave复制越多的数据，越靠前 

 runid 越小，越靠前 

 quorum 数量哨兵认为odown->选举一个哨兵切换->获得 majority哨兵的授权（quorum < majority 需要 majority个哨兵授权，quorum >= majority 需要 quorum 哨兵授权） 

 第一个选举出来的哨兵切换失败了，其他哨兵等待 failover-time之后，重新拿confiuration epoch做为新的version 切换，保证拿到最新配置，用于 configuration传播（通过 pu/sub消息机制，其他哨兵对比 version 新旧更新 master配置） 

 Redis 优化方案 

 高并发：主从架构 

 高容量：Redis集群，支持每秒几十万的读写并发 

 高可用：主从+哨兵 

 Redis 持久化 

 持久化的意义在于故障恢复数据备份（到其他服务器）+故障恢复（遇到灾难，机房断电，电缆被切） 

 RDB 对 Redis 中的数据执行周期性的持久化。 

 AOF 机制，每条写命令作为日志，以 append-only模式写入一个日志文件总，在 [redis]()重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集 

 AOF 只有一个，Redis 中的数据是有一定限量的，内存大小是一定的,AOF 是存放写命令的，当大到一定的时候，AOF 做 rewrite 操作，就会基于当时 [redis]() 内存中的数据，来重新构造一个更小的 AOF 文件，然后将旧的膨胀很大的文件给删掉，AOF 文件一直会被限制在和Redis内存中一样的数据。AOF同步间隔比 RDB 小，数据更完整 

 RDB 

 优点： 

 RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 [redis]() 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，RDB 做冷备，生成多个文件，每个文件都代表某一个时刻的完整的数据快照，AOF 也可以做冷备，只有一个文件，每隔一定时间去 copy一份这个文件出来。 RDB 做冷备，由Redis控制固定时长去生成快照文件，比较方便。AOF，需要自己写脚本定时控制。 

 RDB 对 [redis]()对外提供的读写服务，影响非常小，可以让 [redis]() 保持高性能，因为 [redis]() 主进程只需要 fork一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化 

 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 [redis]() 进程，更加快速 

 缺点： 

 如果想要在 [redis]()故障时，尽可能少丢数据，那么 RDB 没有 AOF 好，一般 RDB 数据快照，都是间隔 5 分钟，或者更长的时候生成一次，这个时候就得接受一旦 [redis]() 进程宕机，那么会丢失最近 5 分钟数据 

 RDB 每次在 fork子进程来执行 RDB 快早数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，甚至数秒（RDB 生成间隔不要太长） 

 AOF 存放的指令日志，数据恢复的时候，需要回放执行所有指令日志，RDB 就是一份数据文件，直接加载到内存中。 

 AOF 

 优点： 

 更好保护数据不丢失，后台线程 fsync 操作，最多丢失一秒钟数据，保证 os cache中的数据写入磁盘中 

 AOF 用 append-only 模式，没有磁盘寻址开销，写入性能非常高，文件不容易损坏。 

 AOF 日志过大的时候，后台 rewrite log时候，老的日志文件照常写入，新的merge后的日志文件 ready的时候，再交换新老日志文件 

 适合灾难性恢复，某人不小心 flushall清空所有数据，只要后台 rewrite还没发生，那么可以立刻拷贝 AOF 文件，将最后一条 flushall命令给删了，然后再将该 AOF 文件放回去，可以通过恢复机制，自动恢复所有数据 

 缺点： 

 AOF 日志文件比 RDB 数据快照文件大 

 降低 Redis的写 QPS 

 AOF 复杂，Bug多 

 数据恢复比较慢 

 最佳方案 

 AOF 来保证数据不丢失，RDB 做不同时间的冷备 

 Redis Cluster 

 支持 N 个 Redis master node,每个 master node挂载多个 slave node 

 多master + 读写分离 + 高可用 

 数据量很少，高并发 -> replication + sentinal 集群 

 [海量数据]() + 高并发 + 高可用 -> [redis]() cluster 

 分布式[算法]() 

 hash[算法]()->一致性 hash [算法]()-> [redis]() cluster->hash slot[算法]() 

 [redis]() cluster :自动对数据进行分片，每个 master 上放一部分数据，提供内置的高可用支持，部分master不可用时，还是可以继续工作 

 cluster bus 通过 16379进行通信，故障检测，配置更新，故障转移授权，另外一种二进制协议，主要用于节点间进行高效数据交换，占用更少的网络带宽和处理时间 

 hash[算法]() 

 key进行hash，然后对节点数量取模，最大问题只有任意一个 master 宕机，大量数据就要根据新的节点数取模，会导致大量缓存失效。 

 一致性 hash [算法]() 

 key进行hash，对应圆环上一个点，顺时针寻找距离最近的一个点。保证任何一个 master 宕机，只受 master 宕机那台影响，其他节点不受影响，此时会瞬间去查数据库。 

 缓存热点问题： 

 可能集中在某个 hash区间内的值特别多，那么会导致大量的数据都涌入同一个 master 内，造成 master的热点问题，性能出现瓶颈。 

 解决方法： 

 给每个 master 都做了均匀分布的虚拟节点，这样每个区间内大量数据都会均匀的分布到不同节点内，而不是顺时针全部涌入到同一个节点中。 

 Hash Slot[算法]() 

 [redis]() cluster 有固定 16384 个 hash slot,对每个key计算 CRC16 值，然后对16384取模，可以获取 key对应的 hash slot 

 [redis]() cluster 中每个 master 都会持有部分 slot ,当一台 master 宕机时候，会最快速度迁移 hash slot到可用的机器上（只会短暂的访问不到） 

 走同一个 hash slot 通过 hash tag实现 

 Redis Cluster 核心 

 基础通信 

 通过 gossip 协议通信（小道留言，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其他节点，让其他节点也进行元数据的变更） 

 集群元数据：包括 hashslot->node之间的映射表关系，master->slave之间的关系，故障的信息 

 集群元数据集中式存储（storm），底层基于zoo[keep]()er（分布式协调中间件）集群所有元数据的维护。好处：元数据的更新和读取，时效性好，一旦变更，其他节点立刻可以感知。缺点：所有元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。 

 goosip: 好处：元数据的更新比较分散，有一定的延时，降低了压力。缺点：更新有延时，集群的一些操作会滞后。（reshared操作时configuration error） 

 10000 端口 

 自己提供服务的端口号+ 10000 ，每隔一段时间就会往另外几个节点发送ping消息，同时其他几点接收到ping之后返回pong 

 交换的信息 

 故障信息，节点的增加和移除， hash slot 信息 

 gossip协议 

 meet:某个节点发送 meet给新加入的节点，让新节点加入集群中，然后新节点就会开始于其他节点进行通信 

 ping:每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据 

 ping:返回ping和meet，包含自己的状态和其他信息 

 fail:某个节点判断另一个节点fail之后，就发送 fail 给其他节点，通知其他节点，指定的节点宕机了 

 ping消息 

 ping 很频繁，且携带元数据，会加重网络负担 

 每个节点每秒会执行 10 次 ping，每次选择 5 个最久没有通信的其他节点 

 当如果发现某个节点通信延迟达到了 cluster_node_timeout /2 ，那么立即发送 ping， 避免数据交换延迟过长，落后时间太长（2 个节点之间 10 分钟没有交换数据，整个集群处于严重的元数据不一致的情况）。 

 每次ping，一个是带上自己的节点信息，还有就是带上1/10其他节点的信息，发送出去，进行数据交换 

 至少包含 3 个其他节点信息，最多包含总节点-2 个其他节点的信息 

 JRedis原理 

 请求重定向 

 客户端发送到任意一个[redis]()实例发送命令，每个[redis]()实例接受到命令后，都会计算key对应的hash slot，如果在本地就本地处理，否则返回moved给客户端，让客户端进行重定向 （[redis]()-cli -c） 

 hash slot 

 通过tag指定key对应的slot,同一个 tag 下的 key，都会在一个 hash slot中，比如 set key1:{100} 和 set key2:{100} 

 smart jedis 

 本地维护一份hashslot->node的映射表。 

 JedisCluster 初始化的时候，随机选择一个 node，初始化 hashslot->node 映射表，同时为每个节点创建一个JedisPool连接池，每次基于JedisCluster执行操作，首先JedisCluster都会在本地计算key的hashslot，然后再本地映射表中找到对应的节点，如果发现对应的节点返回moved，那么利用该节点的元数据，更新 hashslot->node映射表（重试超过 5 次报错） 

 hashslot迁移和ask重定向 

 hash slot正在迁移，那么会返回ask 重定向给jedis,jedis 接受到ask重定向之后，，会重定向到目标节点去执行 

 高可用性和主备切换原理 

 判断节点宕机： 

 如果一个节点认为另外一个节点宕机了， 就是pfail,主观宕机 

 如果多个节点都认为另外一个节点宕机了，那么就是fail，客观宕机（跟哨兵原理一样） 

 在cluster-node-timeout内，某个节点一直没有返回 pong,那么就被认为是 pfail 

 如果一个节点认为某个节点pfail了，那么会在gossip消息中，ping给其他节点，如果超过半数的节点认为pfail了，那么就会变成fail。 

 从节点过滤： 

 对宕机的 mster node ，从其所有的 slave node中，选择一个切换成 master node 

 检查每个 slave node与master node断开连接的时间，如果超过了cluster-node-timeout * 


 cluster-slave-validity-factor，那么就没资格切换成 master（和哨兵一致） 

 从节点选举： 

 每个从节点，根据自己对 master 复制数据的 offset，设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，所有的 master node 开始投票，给要进行选举的 slave进行投票，如果大部分 master node(N/2 +1) 都投票给某个从节点，那么选举通过，从节点执行主备切换，从节点切换成主节点 

 总结：和哨兵很像，直接集成了 replication 和 sentinal 

 缓存雪崩 

 方案： 

 事前：保证 [redis]() 集群高可用性 （主从+哨兵或 [redis]() cluster），避免全盘崩溃 

 事中：本地 ehcache 缓存 + hystrix 限流（保护数据库） & 降级，避免 MySQL被打死 

 事后： [redis]()持久化，快速恢复缓存数据，继续分流高并发请求 

 限制组件每秒就 2000 个请求通过限流组件进入数据库，剩余的 3000 个请求走降级，返回一些默认 的值，或者友情提示 

 好处 ： 

 数据库绝对不会死，确保了每秒只会过去 2000 个请求 

 只要数据库不死，对于用户来说 2/5的请求可以被处理 

 系统没死，用户多点几次可能就刷出来了 

 缓存穿透 

 4000 个请求黑客攻击请求数据库里没有的数据 

 解决方案：把黑客查数据库中不存在的数据的值，写到缓存中，比如： set -999 UNKNOWN 

 缓存与数据库双写一致性 

 cache aside pattern 

 读的时候，先读缓存，缓存没有，就读数据库，然后取出数据后放入缓存，同时返回响应 

 更新的时候，删除缓存，更新数据库 

 为什么不更新缓存： 

 更新缓存代价太高（更新 20 次，只读 1 次），lazy思想，需要的时候再计算，不需要的时候不计算 

 修改数据库成功，删除缓存失败，导致数据库是新的数据，缓存中是旧的数据 

 方案：先删除缓存，再修改数据库 

 修改数据库还没修改完，同时又有查询请求，把旧的数据放到缓存中（高并发，每秒并发读几万，每秒只要有数据更新请求，就可能出现数据库+缓存不一致情况） 

 方案：写，读路由到相同的一个内存队列（唯一标识，hash，取模）里，更新和读操作进行串行化（后台线程异步执行队列串行化操作），（队列里只放一个更新查询操作即可，多余的过滤掉，内存队列里没有该数据更新操作，直接返回 ）有该数据更新操作则轮询取缓存值，超时取不到缓存值，直接取一次数据库的旧值 

 TP 99 意思是99%的请求可以在200ms内返回 

 注意点：多个商品的更新操作都积压在一个队列里面（太多操作积压只能增加机器），导致读请求发生大量的超时，导致大量的读请求走数据库 

 一秒 500 写操作，每200ms，100 个写操作，20 个内存队列，每个队列积压 5 个写操作，一般在20ms完成 

 Redis 并发竞争问题 

 方案：分布式锁 + 时间戳比较 

 Redis 集群部署架构 

 10台机器，5 主 5 从，每个节点QPS 5W ，一共 25W QPS（Redis cluster 32G + 8 核 ，Redis 进程不超过 10G）总内存 50g，每条数据10kb，10W 条数据1g，200W 条数据 20G，占用总内存不到50%，目前高峰期 3500 QPS









4.2 Redis

作者：Guide哥。

**介绍****:** Github 70k Star 项⽬ **JavaGuide**（公众号同名） 作者。每周都会在公众号更新⼀些⾃⼰原

创⼲货。公众号后台回复“1”领取Java⼯程师必备学习资料+⾯试突击pdf。

4.2.1 redis **简介**

简单来说 redis 就是⼀个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读

写速度⾮常快，因此 redis 被⼴泛应⽤于缓存⽅向。另外，redis 也经常⽤来做分布式锁。redis 提

供了多种数据类型来⽀持不同的业务场景。除此之外，redis ⽀持事务 、持久化、LUA脚本、LRU驱动

事件、多种集群⽅案。

**为什么要⽤** redis/**为什么要⽤缓存**

主要从“⾼性能”和“⾼并发”这两点来看待这个问题。

**⾼性能：**假如⽤户第⼀次访问数据库中的某些数据。这个过程会⽐᫾慢，因为是从硬盘上读取的。将该⽤户访问

的数据存在缓存中，这样下⼀次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接

操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

**⾼并发：**

直接操作缓存能够承受的请求是远远⼤于直接访问数据库的，所以我们可以考虑把数据库中的部分数据

转移到缓存中去，这样⽤户的⼀部分请求会直接到缓存这⾥⽽不⽤经过数据库。**为什么要⽤** redis **⽽不⽤** map/guava **做缓存**?

下⾯的内容来⾃ segmentfault ⼀位⽹友的提问，地址：https://segmentfault.com/q/1010000009

106416

缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最

主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都

需要各⾃保存⼀份缓存，缓存不具有⼀致性。

使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓

存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上᫾为复杂。

4.2.2 redis **的线程模型**

参考地址:https://www.javazhiyin.com/22943.html

redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以

redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制同时监听多个 socket，根据 socket 上的事件

来选择对应的事件处理器进⾏处理。

⽂件事件处理器的结构包含 4 个部分：

多个 socket

IO 多路复⽤程序

⽂件事件分派器

事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）多个 socket 可能会并发产⽣不同的操作，每个操作对应不同的⽂件事件，但是 IO 多路复⽤程序会监

听多个 socket，会将 socket 产⽣的事件放⼊队列中排队，事件分派器每次从队列中取出⼀个事件，

把该事件交给对应的事件处理器进⾏处理。

4.2.3 redis **和** memcached **的区别**

对于 redis 和 memcached 我总结了下⾯四点。现在公司⼀般都是⽤ redis 来实现缓存，⽽且 redis

⾃身也越来越强⼤了！

\1. **redis****⽀持更丰富的数据类型（⽀持更复杂的应⽤场景）**：Redis不仅仅⽀持简单的k/v类型的数

据，同时还提供list，set，zset，hash等数据结构的存储。memcache⽀持简单的数据类型，

String。

\2. **Redis****⽀持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进⾏使**

**⽤****,****⽽****Memecache****把数据全部存在内存之中。**

\3. **集群模式**：memcached没有原⽣的集群模式，需要依靠客户端来实现往集群中分⽚写⼊数据；但

是 redis ⽬前是原⽣⽀持 cluster 模式的.

\4. **Memcached****是多线程，⾮阻塞****IO****复⽤的⽹络模型；****Redis****使⽤单线程的多路** **IO** **复⽤模型。**

来⾃⽹络上的⼀张图，这⾥分享给⼤家！

4.2.4 redis **常⻅数据结构以及使⽤场景分析**

String

**常⽤命令****:** set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key

value缓存应⽤； 常规计数：微博数，粉丝数等。

Hash

**常⽤命令：** hget,hset,hgetall 等。hash 是⼀个 string 类型的 field 和 value 的映射表，hash 特别适合⽤于存储对象，后续操作的时

候，你可以直接仅仅修改这个对象中的某个字段的值。 ⽐如我们可以 hash 数据结构来存储⽤户信

息，商品信息等等。⽐如下⾯我就⽤ hash 类型存放了我本⼈的⼀些信息：

List

**常⽤命令****:** lpush,rpush,lpop,rpop,lrange等

list 就是链表，Redis list 的应⽤场景⾮常多，也是Redis最重要的数据结构之⼀，⽐如微博的关注

列表，粉丝列表，消息列表等功能都可以⽤Redis的 list 结构来实现。

Redis list 的实现为⼀个双向链表，即可以⽀持反向查找和遍历，更⽅便操作，不过带来了部分额外

的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分⻚查询，这

个很棒的⼀个功能，基于 redis 实现简单的⾼性能分⻚，可以做类似微博那种下拉不断分⻚的东⻄

（⼀⻚⼀⻚的往下⾛），性能⾼。

Set

**常⽤命令：** sadd,spop,smembers,sunion 等

set 对外提供的功能与list类似是⼀个列表的功能，特殊之处在于 set 是可以⾃动排重的。

当你需要存储⼀个列表数据，⼜不希望出现重复数据时，set是⼀个很好的选择，并且set提供了判断某

个成员是否在⼀个set集合内的重要接⼝，这个也是list所不能提供的。可以基于 set 轻易实现交集、

并集、差集的操作。

⽐如：在微博应⽤中，可以将⼀个⽤户所有的关注⼈存在⼀个集合中，将其所有粉丝存在⼀个集合。

Redis可以⾮常⽅便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，

具体命令如下：

Sorted Set

**常⽤命令：** zadd,zrange,zrem,zcard等 

和set相⽐，sorted set增加了⼀个权重参数score，使得集合中的元素能够按score进⾏有序排列。

**举例：** 在直播系统中，实时排⾏信息包含直播间在线⽤户列表，各种礼物排⾏榜，弹幕消息（可以理

解为按消息维度的消息排⾏榜）等信息，适合使⽤ Redis 中的 Sorted Set 结构进⾏存储。

key=JavaUser293847

value={

 “id”: 1,

 “name”: “SnailClimb”,

 “age”: 22,

 “location”: “Wuhan, Hubei”

}

sinterstore key1 key2 key3 将交集存在key1内4.2.5 redis **设置过期时间**

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。作为⼀个

缓存数据库，这是⾮常实⽤的。如我们⼀般项⽬中的 token 或者⼀些登录信息，尤其是短信验证码都

是有时间限制的，按照传统的数据库处理⽅式，⼀般都是⾃⼰判断过期，这样⽆疑会严重影响项⽬性

能。

我们 set key 的时候，都可以给⼀个 expire time，就是过期时间，通过过期时间我们可以指定这个

key 可以存活的时间。

如果假设你设置了⼀批 key 只能存活1个⼩时，那么接下来1⼩时后，redis是怎么对这批key进⾏删除

的？

**定期删除****+****惰性删除。**

通过名字⼤概就能猜出这两个删除⽅式的意思了。

**定期删除**：redis默认是每隔 100ms 就**随机抽取**⼀些设置了过期时间的key，检查其是否过期，

如果过期就删除。注意这⾥是随机抽取的。为什么要随机呢？你想⼀想假如 redis 存了⼏⼗万

个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很⼤的负载！

**惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删

除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那

个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

但是仅仅通过设置过期时间还是有问题的。我们想⼀下：如果定期删除漏掉了很多过期 key，然后你也

没及时去查，也就没⾛惰性删除，此时会怎么样？如果⼤量过期key堆积在内存⾥，导致redis内存块耗

尽了。怎么解决这个问题呢？ **redis** **内存淘汰机制。**

4.2.6 redis **内存淘汰机制**(MySQL**⾥有**2000w**数据，**Redis**中只存**20w**的数据，如何**

**保证**Redis**中的数据都是热点数据**?)

redis 配置⽂件 redis.conf 中有相关注释，我这⾥就不贴了，⼤家可以⾃⾏查阅或者通过这个⽹址查

看： http://download.redis.io/redis-stable/redis.conf

**redis** **提供** **6****种数据淘汰策略：**

\1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使⽤的数

据淘汰

\2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘

汰

\3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

\4. **allkeys-lru**：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是

最常⽤的）

\5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰

\6. **no-eviction**：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。

这个应该没⼈使⽤吧！

4.0版本后增加以下两种：

\7. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使⽤的数据

淘汰

\8. **allkeys-lfu**：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最不经常使⽤的key

**备注： 关于** **redis** **设置过期时间以及内存淘汰机制，我这⾥只是简单的总结⼀下，后⾯会专⻔写⼀篇**

**⽂章来总结！**4.2.7 redis **持久化机制**(**怎么保证** redis **挂掉之后再重启数据可以进⾏恢复**)

很多时候我们需要持久化数据也就是将内存中的数据写⼊到硬盘⾥⾯，⼤部分原因是为了之后重⽤数据

（⽐如重启机器、机器故障之后恢复数据），或者是为了防⽌系统故障⽽将数据备份到⼀个远程位置。

Redis不同于Memcached的很重⼀点就是，Redis⽀持持久化，⽽且⽀持两种不同的持久化操作。**Redis****的**

**⼀种持久化⽅式叫快照（****snapshotting****，****RDB****），另⼀种⽅式是只追加⽂件（****append-only**

**file,AOF****）**。这两种⽅法各有千秋，下⾯我会详细这两种持久化⽅法是什么，怎么⽤，如何选择适合⾃

⼰的持久化⽅法。

**快照（****snapshotting****）持久化（****RDB****）**

Redis可以通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本。Redis创建快照之后，可

以对快照进⾏备份，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本（Redis主从结

构，主要⽤来提⾼Redis性能），还可以将快照留在原地以便重启服务器的时候使⽤。

快照持久化是Redis默认采⽤的持久化⽅式，在redis.conf配置⽂件中默认有此下配置：

**AOF****（****append-only file****）持久化**

与快照持久化相⽐，AOF持久化 的实时性更好，因此已成为主流的持久化⽅案。默认情况下Redis没有

开启AOF（append only file）⽅式的持久化，可以通过appendonly参数开启：

开启AOF持久化后每执⾏⼀条会更改Redis中的数据的命令，Redis就会将该命令写⼊硬盘中的AOF⽂件。

AOF⽂件的保存位置和RDB⽂件的位置相同，都是通过dir参数设置的，默认的⽂件名是

appendonly.aof。 

在Redis的配置⽂件中存在三种不同的 AOF 持久化⽅式，它们分别是：

save 900 1 #在900秒(15分钟)之后，如果⾄少有1个key发⽣变化，

Redis就会⾃动触发BGSAVE命令创建快照。

save 300 10 #在300秒(5分钟)之后，如果⾄少有10个key发⽣变化，

Redis就会⾃动触发BGSAVE命令创建快照。

save 60 10000 #在60秒(1分钟)之后，如果⾄少有10000个key发⽣变化，

Redis就会⾃动触发BGSAVE命令创建快照。

appendonly yes

appendfsync always #每次有数据修改发⽣时都会写⼊AOF⽂件,这样会严重降

低Redis的速度

appendfsync everysec #每秒钟同步⼀次，显示地将多个写命令同步到硬盘

appendfsync no #让操作系统决定何时进⾏同步为了兼顾数据和写⼊性能，⽤户可以考虑 appendfsync everysec选项 ，让Redis每秒同步⼀次AOF⽂

件，Redis性能⼏乎没受到任何影响。⽽且这样即使出现系统崩溃，⽤户最多只会丢失⼀秒之内产⽣的

数据。当硬盘忙于执⾏写⼊操作的时候，Redis还会优雅的放慢⾃⼰的速度以便适应硬盘的最⼤写⼊速

度。

**Redis 4.0** **对于持久化机制的优化**

Redis 4.0 开始⽀持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb

preamble 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF ⽂件开头。这样做的好处是可

以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF ⾥⾯的

RDB 部分是压缩格式不再是 AOF 格式，可读性᫾差。

**补充内容：****AOF** **重写**

AOF重写可以产⽣⼀个新的AOF⽂件，这个新的AOF⽂件和原有的AOF⽂件所保存的数据库状态⼀样，但体

积更⼩。

AOF重写是⼀个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序⽆须对现有AOF⽂件

进⾏任何读⼊、分析或者写⼊操作。

在执⾏ BGREWRITEAOF 命令时，Redis 服务器会维护⼀个 AOF 重写缓冲区，该缓冲区会在⼦进程创建

新AOF⽂件期间，记录服务器执⾏的所有写命令。当⼦进程完成创建新AOF⽂件的⼯作之后，服务器会将

重写缓冲区中的所有内容追加到新AOF⽂件的末尾，使得新旧两个AOF⽂件所保存的数据库状态⼀致。最

后，服务器⽤新的AOF⽂件替换旧的AOF⽂件，以此来完成AOF⽂件重写操作

**更多内容可以查看我的这篇⽂章：**

Redis持久化

4.2.8 redis **事务**

Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了⼀种将多个命令

请求打包，然后⼀次性、按顺序地执⾏多个命令的机制，并且在事务执⾏期间，服务器不会中断事务⽽

改去执⾏其他客户端的命令请求，它会将事务中的所有命令都执⾏完毕，然后才去处理其他客户端的命

令请求。

在传统的关系式数据库中，常常⽤ ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务

总是具有原⼦性（Atomicity）、⼀致性（Consistency）和隔离性（Isolation），并且当 Redis 运⾏

在某种特定的持久化模式下时，事务也具有持久性（Durability）。

补充内容：

\1. redis同⼀个事务中如果有⼀条命令执⾏失败，其后的命令仍然会被执⾏，没有回滚。（来⾃

issue:关于Redis事务不是原⼦性问题 ）

4.2.9 **缓存雪崩和缓存穿透问题解决⽅案**

**缓存雪崩**

**什么是缓存雪崩？**

简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤

量请求⽽崩掉。**有哪些解决办法？**

（中华⽯杉⽼师在他的视频中提到过，视频地址在最后⼀个问题中有提到）：

事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策

略。

事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉

事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存

**缓存穿透**

**什么是缓存穿透？**

缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有

经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请

求落到数据库。下⾯⽤图⽚展示⼀下(这两张图⽚不是我画的，为了省事直接在⽹上找的，这⾥说明⼀

下)：

**正常缓存处理流程：****缓存穿透情况处理流程：**⼀般MySQL 默认的最⼤连接数在 150 左右，这个可以通过 show variables like

'%max_connections%'; 命令来查看。最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹络等

⽆⼒条件都是其运⾏指标，这些指标都会限制其并发能⼒！所以，⼀般 3000 个并发请求就能打死⼤部

分数据库了。

**有哪些解决办法？**

最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的

数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。

**1****）缓存⽆效** **key** : 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时

间，具体命令如下： SET key value EX 10086 。这种⽅式可以解决请求的 key 变化不频繁的情

况，如果⿊客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存⼤量⽆效的 key 。很明显，

这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key

的过期时间设置短⼀点⽐如 1 分钟。

另外，这⾥多说⼀嘴，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。

如果⽤ Java 代码展示的话，差不多是下⾯这样的：

public Object getObjectInclNullById(Integer id) {

 // 从缓存中获取数据

 Object cacheValue = cache.get(id);

 // 缓存为空

 if (cacheValue WX null) {

 // 从数据库中获取

 Object storageValue = storage.get(key);

 // 缓存空对象

 cache.set(key, storageValue);

 // 如果存储数据为空，需要设置⼀个过期时间(300秒)

 if (storageValue WX null) {

 // 必须设置过期时间，否则有被攻击的⻛险

 cache.expire(key, 60 * 5);

 }

 return storageValue;

 }

 return cacheValue; 

} 

**2****）布隆过滤器：**布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数

据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要

找的那个“⼈”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过

来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信

息给客户端，存在的话才会⾛下⾯的流程。总结⼀下就是下⾯这张图(这张图⽚不是我画的，为了省事

直接在⽹上找的)：更多关于布隆过滤器的内容可以看我的这篇原创：《不了解布隆过滤器？⼀⽂给你整的明明⽩⽩！》

，强烈推荐，个⼈感觉⽹上应该找不到总结的这么明明⽩⽩的⽂章了。

4.2.10 **如何解决** Redis **的并发竞争** Key **问题**

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对⼀个 key 进⾏操作，但是最后执⾏的顺序

和我们期望的顺序不同，这样也就导致了结果的不同！

推荐⼀种⽅案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发

竞争 Key 问题，不要使⽤分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。⼤致思想为：每个客户端对某个⽅法加锁时，在

zookeeper上的与该⽅法对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点。 判断是否获取锁的

⽅式很简单，只需要判断有序节点中序号最⼩的⼀个。 当释放锁的时候，只需将这个瞬时节点删除即

可。同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。完成业务流程后，删除对应的

⼦节点释放锁。

在实践中，当然是从以可靠性为主。所以⾸推Zookeeper。

参考：https://www.jianshu.com/p/8bddd381de06

4.2.11 **如何保证缓存与数据库双写时的数据⼀致性**?

⼀般情况下我们都是这样使⽤缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放

⼊缓存，同时返回响应。这种⽅式很明显会存在缓存和数据库的数据不⼀致的情况。

你只要⽤缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就⼀定会有数据⼀致性的问

题，那么你如何解决⼀致性问题？

⼀般来说，就是如果你的系统不是严格要求缓存+数据库必须⼀致性的话，缓存可以稍微的跟数据库偶

尔有不⼀致的情况，最好不要做这个⽅案，读请求和写请求串⾏化，串到⼀个内存队列⾥去，这样就可

以保证⼀定不会出现不⼀致的情况

串⾏化之后，就会导致系统的吞吐量会⼤幅度的降低，⽤⽐正常情况下多⼏倍的机器去⽀撑线上的⼀个

请求。

更多内容可以查看：https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency

/redis-consistence.md

**参考：** Java⼯程师⾯试突击第1季（可能是史上最好的Java⾯试突击课程）-中华⽯杉⽼师！公众号后

台回复关键字“1”即可获取该视频内容。

**参考**

《Redis开发与运维》

Redis 命令总结：http://redisdoc.com/string/set.html
