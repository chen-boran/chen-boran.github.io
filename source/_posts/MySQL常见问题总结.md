---
title: MySQL常见问题总结
date: 2022-03-09 16:08:12
tags: 
- MySQL
categories: 
- Notes
keywords:
description: some of my thinks
top_img: 
comments: 
cover: https://ae01.alicdn.com/kf/Ue5889eaf11594a4aabca090c5d5060798.jpg
toc:  
toc_number:
copyright:
mathjax:
katex:
---

【数据库】数据库中什么时候用索引？（应用场景）索引的作用 

1、定义：数据库索引是数据库管理系统中一个排序的数据结构,以协助快速查询,更新数据库 

中表的数据。 

2、实现方式：索引的实现通常使用 B 树和变种的 B+树(mysql 常用的索引就是 B+树)；索引 

是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。 

3、什么时候该用索引？ 

 

主键自动建立唯一索引恐涉侵权，请勿传播 

269 

 

在经常用在连接（

join）的列上，这些列主要是一些外键，可以加快连接的速度 

 

在经常需要根据范围搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 

 

频繁作为查询条件（经常 where）的字段应该创建索引 

 

查询中经常（OrderBy）排序的字段（因为索引已经排序，这样查询可以利用索引的排 

序，加快排序查询时间） 

 

查询中统计（

Count）或者分组（Groupby）的字段； 

4、什么时候不该用索引？ 

 

在查询中很少使用或者参考的列不应该创建索引。 

 

只有很少数据值的列也不应该增加索引。例如性别列 

 

定义为 text, image 和 bit 数据类型的列不应该增加索引。这些列的数据量要么相当大， 

要么取值很少,不利于使用索引。 

 

频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保 

存索引文件 

 

表记录太少，不需要创建索引； 

 

经常增删改的表； 

5、索引的优缺点 

优点： 

 

通过创建索引,可以在查询的过程中,提高系统的性能 

 

通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性 

 

在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间 

缺点： 

 

创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大 

 

索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大 

 

在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护 

6、索引的种类 

 

普通索引：MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复 

值和空值，纯粹为了查询数据更快一 点。 

 

唯一索引：索引列中的值必须是唯一的，但是允许为空值。 

 

主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引） 

 

组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的 

左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。例如，这里由 id、 

name 和 age3 个字段构成的索引，索引行中就按 id/name/age 的顺序存放，索引可以索 

引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引 

最左面的前缀，那么就不会是用索引，比如，age 或者（

name，age）组合就不会使用 

索引查询。 

 

全文索引：全文索引，只有在 MyISAM 引擎上才能使用，只能在 CHAR,VARCHAR,TEXT 

类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通 

过其中的某个关键字等，就能找到该字段所属的记录行。一般开发中，不贵用到全文索 

引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。 

7、为什么使用联合索引 

 

减 少 开 销 。 建 一 个 联 合 索 引 (col1,col2,col3) ， 实 际 相 当 于 建 了 

(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁 

盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ 

 

覆盖索引。对联合索引(col1,col2,col3)，如果有如下的 sql: select col1,col2,col3 from test恐涉侵权，请勿传播 

270 

where col1=1 and col2=2。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表， 

这减少了很多的随机 io 操作。减少 io 操作，特别的随机 io 其实是 dba 主要的优化策略。 

所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 

 

效率高。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 

sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出 

10%的数据，如果只有单值索引，那么通过该索引能筛选出 1000W10%=100w 条数据， 

然后再回表从 100w 条数据中找到符合 col2=2 and col3= 3 的数据，然后再排序，再分页； 

如果是联合索引，通过索引筛选出 1000w10% 10% *10%=1w，效率提升可想而知！ 

8、数据库中的索引一般是什么数据结构？ 

B+Tree 是一种树数据结构，是一个 n 叉排序树，每个节点通常有多个孩子，一棵 B+Tree 包 

含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两 

个以上孩子节点的节点。B+Tree 几乎是数据库默认的索引实现。 

延伸问题 1：hash 的查找时间复杂度是 O(1)比 B+的 O(logn)查找时间更短，为什么索引不用 

hash？（可以从 B+树索引的有序性，叶节点被双向链表连接，方便支持范围查找，以及分 

批加载至内存这几个方面回答） 

这和业务场景有关，如果只查找一个值的话，hash 是一个很好的选择，单数据库经常会选 

择多条，这时候由于 B+树索引有序，并且又有链表相连，它的查询效率比 hash 就快很多了。 

而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计 

可以允许数据分批加载，同时树的高度较低，提高查找效率 

延伸问题 2：为什么不用红黑树（可以从内存，以及树深度和 IO 次数方面讨论这个问题。） 

红黑树必须存在内存里的，数据库表太大了，存不进去。 

在大规模数据存储的时候，红黑树（二叉查找树）往往出现由于树的深度过大而造成磁盘 IO 

读写过于频繁，进而导致效率低下的情况。B 树可以有多个子女，从几十到上千，可以降低 

树的高度。 

磁盘 IO 代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘 IO 频繁读写。根据磁 

盘查找存取的次数往往由树的高度所决定，红黑树查找一个节点最多要查 logN 层，每一层 

都是一个内存页。虽然你只是想找一个节点，但硬盘必须一次读一个页，那么一共 logN 次 

IO，消耗太大。 

延伸问题 3：为什么不用 B 树（可以从叶节点是否存数据，占用内存空间大小和是否支持范 

围查询这三个方面解释。 ） 

B+树的数据都集中在叶子节点，分支节点只负责索引。 b 树的分支节点也有数据 。所以 

b+树的树高会小于 B 树，平均的 Io 次数会远大于 B+树。 

(比如一个节点是一个页 4096 字节，其中每条数据 128 字节，那么一个节点只能存 32 个数 

据项，那么对应的孩子节点数最多为 33 个，这显然不够用。而 b+树内部节点只作为导向作 

用，只存一个整数就可以（

int 型整数 32 位，消耗 4 个字节），4096/4=1024 个数据项。这 

样 b+树的每个节点的孩子数更多，整个树的高度就更低，大大增加查询效率。) 

B+树索引节点没有数据。比较小。B 树可以把索引完全加载至内存中。 

B+树更擅长范围查询。叶子节点数据是按顺序放置的双向链表。 B 树范围查询只能中序遍 

历，做不到范围查询。 

原文链接：https://blog.csdn.net/uonele/article/details/106963120 

9、索引的实现方式？ 

在数据库中，常见的索引实现方式有哈希表、有序数组、搜索树。

![image-20220309161214865](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091612123.png)





![image-20220309161241692](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091612872.png)

![image-20220309161323946](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091613097.png)

10、innodb 的索引模型

![image-20220309161412514](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091614652.png)

![image-20220309161435808](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091614923.png)

11、索引维护

![image-20220309161515930](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203091615077.png)



【数据库】MySQL 的逻辑架构 

第一层是服务器层，主要提供连接处理、授权认证、安全等功能。 

第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等 

所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。 

第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存 

储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会 

解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信， 

276恐涉侵权，请勿传播 

277 

只是简单响应上层服务器请求。 

【数据库】MySQL 的读写锁 

在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型 

的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户 

在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会 

阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正 

在写入的同一资源。 

在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 

会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会 

被插入到读锁队列的前面，但是读锁不能插入到写锁前面。 

【数据库】MySQL 的锁策略有什么 

表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户 

在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有 

写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。 

行锁可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他 

存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。 

【数据库】数据库死锁如何解决 

死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现 

象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资 

源时也会产生死锁。 

为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如 

InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有 

效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待 

超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持 

有最少行级排它锁的事务进行回滚。 

死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是 

无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行 

因死锁回滚的事务即可。 

【数据库】数据库中的事务是怎么回事？ 

事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地 

对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩 

溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行 

成功，要么全部执行失败。 

ACID 

\1. 原子性（

Atomicity） 

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚 

时反向执行这些修改操作即可。 

\2. 一致性（

Consistency） 

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取 

结果都是相同的。 

\3. 隔离性（

Isolation） 

一个事务所做的修改在最终提交以前，对其它事务是不可见的。 

\4. 持久性（Durability）恐涉侵权，请勿传播 

278 

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的 

结果也不能丢失。 

系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数 

据的逻辑修改不同，重做日志记录的是数据页的物理修改。 

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 

只有满足一致性，事务的执行结果才是正确的。 

在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定 

能满足一致性。 

在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满 

足一致性。 

事务满足持久化是为了能应对系统崩溃的情况。 

【数据库】MySQL 的隔离级别 

（

1）未提交读 READ UNCOMMITTED 

在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修 

改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有 

比其他级别好很多，很少使用。 

（

2）提交读 READ COMMITTED 

多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能" 

看见"已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对 

其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。 

（

3）可重复读 REPEATABLE READ（MySQL 默认的隔离级别） 

可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。 

但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。 

InnoDB 存储引擎通过多版本并发控制 MVCC 解决幻读的问题。 

（

4）可串行化 SERIALIZABLE 

最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都 

加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常 

需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。 

【数据库】聚簇索引和辅助索引 

总结：InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，聚簇索引就是按照 

每张表的主键构造一颗 B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集 

索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分； 

一般建表会用一个自增主键做聚簇索引，没有的话 MySQL 会默认创建，但是这个主键如果 

更改代价较高，故建表时要考虑自增 ID 不能频繁 update 这点。 

我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需找 

主键索引的二级索引，现在找到主键索引再通过主键索引找数据； 

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式。 

MySQL 数据库中 innodb 存储引擎，B+树索引可以分为聚簇索引（也称聚集索引，clustered 

index）和辅助索引（有时也称非聚簇索引或二级索引，

secondary index，non-clustered index）。 

这两种索引内部都是 B+树，聚集索引的叶子节点存放着一整行的数据。 

Innobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、 

唯一索引。 

Innodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引 

聚簇索引(聚集索引)恐涉侵权，请勿传播 

279 

聚簇索引就是按照每张表的主键构造一颗 B+树，同时叶子节点中存放的就是整张表的 

行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是 

索引的一部分，每张表只能拥有一个聚簇索引。 

Innodb 通过主键聚集数据，如果没有定义主键，innodb 会选择非空的唯一索引代替。 

如果没有这样的索引，innodb 会隐式的定义一个主键来作为聚簇索引。 

聚簇索引的优缺点 

优点：

1.数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+树中，因此从聚簇索 

引中获取数据比非聚簇索引更快 

2.聚簇索引对于主键的排序查找和范围查找速度非常快 

缺点：

1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出 

现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主 

键 

2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表， 

我们一般定义主键为不可更新。 

3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行 

数据。 

辅助索引（非聚簇索引） 

在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅 

助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键 

值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。 

Innodb 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外， 

还包含了相应行数据的聚簇索引键。 

辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在 

innodb 中有时也称辅助索引为二级索引。
