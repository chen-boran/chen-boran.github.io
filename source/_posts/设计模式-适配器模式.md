---
title: 设计模式-适配器模式
date: 2022-03-02 12:31:58
tags: 
- ["设计模式"]
categories: 
- [Notes]
keywords:
description: some of my thinks
top_img: 
comments: 
cover: https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151833183.jpg
toc:  
toc_number:
copyright:
mathjax:
katex:
---

前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常

用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很

具体，总体上来讲比较好掌握。

关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5

种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项

目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代

码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。

话不多说，让我们正式开始今天的学习吧！

 

**适配器模式的原理与实现**

**适配器模式**的英文翻译是 **Adapter Design Pattern**。顾名思义，这个模式就是用来做适

配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类

可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适

配器，把两种不兼容的接口，通过转接变得可以一起工作。

原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适

配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码

实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget

接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。

```
 

1 // 类适配器: 基于继承

2 public interface ITarget { 

3 void f1(); 

4 void f2(); 

5 void fc(); 

6 } 

7

8 public class Adaptee { 

9 public void fa() { //... } 

10 public void fb() { //... } 

11 public void fc() { //... } 

12 } 

13

14 public class Adaptor extends Adaptee implements ITarget { 

15 public void f1() { 

16 super.fa(); 

17 } 

18

19 public void f2() { 

20 //...重新实现f2()... 

21 } 

22

23 // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点

24 } 

25

26 // 对象适配器：基于组合

27 public interface ITarget { 

28 void f1(); 

29 void f2(); 

30 void fc(); 

31 } 

32

33 public class Adaptee {34 public void fa() { //... } 

35 public void fb() { //... } 

36 public void fc() { //... } 

37 } 

38

39 public class Adaptor implements ITarget { 

40 private Adaptee adaptee; 

41

42 public Adaptor(Adaptee adaptee) { 

43 this.adaptee = adaptee; 

44 } 

45

46 public void f1() { 

47 adaptee.fa(); //委托给Adaptee 

48 } 

49

50 public void f2() { 

51 //...重新实现f2()... 

52 } 

53

54 public void fc() { 

55 adaptee.fc(); 

56 } 

57 }
```

针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有

两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。

如果 Adaptee 接口并不多，那两种实现方式都可以。

如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推

荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方

式，Adaptor 的代码量要少一些。

如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们

推荐使用对象适配器，因为组合结构相对于继承更加灵活。

**适配器模式应用场景总结**

原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？

一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式

算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。

前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情

况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结

。

**1.** **封装有缺陷的接口设计**

假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影

响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进

行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。

具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：

```
 

1 public class CD { //这个类来自外部sdk，我们无权修改它的代码

2 //... 

3 public static void staticFunction1() { //... } 

4

5 public void uglyNamingFunction2() { //... } 

6

7 public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... } 

8

9 public void lowPerformanceFunction4() { //... } 

10 } 

11

12 // 使用适配器模式进行重构

13 public class ITarget { 

14 void function1(); 

15 void function2(); 

16 void fucntion3(ParamsWrapperDefinition paramsWrapper); 

17 void function4(); 

18 //... 

19 } 

20 // 注意：适配器类的命名不一定非得末尾带Adaptor 

21 public class CDAdaptor extends CD implements ITarget { 

22 //... 

23 public void function1() { 

24 super.staticFunction1(); 

25 } 

26

27 public void function2() { 

28 super.uglyNamingFucntion2(); 

29 } 

3031 public void function3(ParamsWrapperDefinition paramsWrapper) { 

32 super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...); 

33 } 

34

35 public void function4() { 

36 //...reimplement it... 

37 } 

38 }
```

**2.** **统一多个类的接口设计**

某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统

一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解

释一下。

假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入

了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感

词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用

各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定

义，这样我们可以复用调用敏感词过滤的代码。

你可以配合着下面的代码示例，来理解我刚才举的这个例子。

```
 

1 public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口

2 //text是原始文本，函数输出用***替换敏感词之后的文本

3 public String filterSexyWords(String text) { 

4 // ... 

5 } 

6

7 public String filterPoliticalWords(String text) { 

8 // ... 

9 } 

10 } 

11

12 public class BSensitiveWordsFilter { // B敏感词过滤系统提供的接口

13 public String filter(String text) { 

14 //... 

15 } 

16 } 

17

18 public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口

19 public String filter(String text, String mask) {20 //... 

21 } 

22 } 

23

24 // 未使用适配器模式之前的代码：代码的可测试性、扩展性不好

25 public class RiskManagement { 

26 private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter(); 

27 private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter(); 

28 private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter(); 

29

30 public String filterSensitiveWords(String text) { 

31 String maskedText = aFilter.filterSexyWords(text); 

32 maskedText = aFilter.filterPoliticalWords(maskedText); 

33 maskedText = bFilter.filter(maskedText); 

34 maskedText = cFilter.filter(maskedText, "***"); 

35 return maskedText; 

36 } 

37 } 

38

39 // 使用适配器模式进行改造

40 public interface ISensitiveWordsFilter { // 统一接口定义

41 String filter(String text); 

42 } 

43

44 public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter { 

45 private ASensitiveWordsFilter aFilter; 

46 public String filter(String text) { 

47 String maskedText = aFilter.filterSexyWords(text); 

48 maskedText = aFilter.filterPoliticalWords(maskedText); 

49 return maskedText; 

50 } 

51 } 

52 //...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor... 

53

54 // 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，

55 // 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。

56 public class RiskManagement { 

57 private List<ISensitiveWordsFilter> filters = new ArrayList<>(); 

58

59 public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) { 

60 filters.add(filter); 

61 } 

62

63 public String filterSensitiveWords(String text) { 

64 String maskedText = text; 

65 for (ISensitiveWordsFilter filter : filters) { 

66 maskedText = filter.filter(maskedText); 

67 } 

68 return maskedText; 

69 } 

70 }
```

**3.** **替换依赖的外部系统**

当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以

减少对代码的改动。具体的代码示例如下所示：

```
 1 // 外部系统A 

2 public interface IA { 

3 //... 

4 void fa(); 

5 } 

6 public class A implements IA { 

7 //... 

8 public void fa() { //... } 

9 } 

10 // 在我们的项目中，外部系统A的使用示例

11 public class Demo { 

12 private IA a; 

13 public Demo(IA a) { 

14 this.a = a; 

15 } 

16 //... 

17 } 

18 Demo d = new Demo(new A()); 

19

20 // 将外部系统A替换成外部系统B 

21 public class BAdaptor implemnts IA { 

22 private B b; 

23 public BAdaptor(B b) { 

24 this.b= b; 

25 } 

26 public void fa() { 

27 //... 

28 b.fb(); 

29 } 

30 } 

31 // 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，

32 // 只需要将BAdaptor如下注入到Demo即可。

33 Demo d = new Demo(new BAdaptor(new B()));
```



**4.** **兼容老版本接口**

在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且

标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用

场景。同样，我还是通过一个例子，来进一步解释一下。

JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它

改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接

从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为

了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使

用 Iterator 才行。

单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发

的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是

不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，

我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下

所示：

```
 

1 public class Collections { 

2 public static Emueration emumeration(final Collection c) { 

3 return new Enumeration() { 

4 Iterator i = c.iterator(); 

5

6 public boolean hasMoreElments() { 

7 return i.hashNext(); 

8 } 

9

10 public Object nextElement() { 

11 return i.next(): 

12 } 

13 } 

14 } 

15 }
```

**5.** **适配不同格式的数据**

前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之

间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方

便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类

型的数据转化为集合容器类型。 复制代码

1 List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");

**剖析适配器模式在** **Java** **日志中的应用**

Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常

用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的

JCL(Jakarta Commons Logging) 等。

大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、

erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不

像 JDBC 那样，一开始就制定了数据库操作的接口规范。

如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选

一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框

架的选择就没那么随意了。

比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是

logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志

框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比

如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框

架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要

统一日志打印框架。

如果你是做 Java 开发的，那 Slf4j 这个
