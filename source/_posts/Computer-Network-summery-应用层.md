---
title: Computer Network summery  应用层
date: 2021-06-20 20:01:24
tags: 
- Network
categories: 
- Notes
keywords:
description: some of my thinks
top_img: 
comments: 
cover: https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151833189.jpg
toc:  
toc_number:
copyright:
mathjax:
katex:
---

# Computer Network summery  应用层



 ## 一、 概述

### 1.协议原理

- 常见的网络应用程序： Web 、电子邮件、 DNS 、对等文件分发
- 主要概念：应用程序的网络服务、客户和服务器、进程、运输层接口

- 应用软件在端系统上运行 

### 2.应用程序体系结构

- 网络应用程序体系结构：

  - 客户-服务器体系结构：（配备大量数据中心，创建虚拟服务器）

    ​                常见应用程序Telnet 、电子邮件、Web/FTP

  - 对等P2P体系结构

    - 当前流行的、流量密集型应用  包括文件共享(例如 BitTorrenl) 、对等方协助下载加速器(例如迅雷)、因特网电话(例如 Skype) IPTV
    - P2P 的自扩展性 self- scalab i1 ity)

### 3.进程

- 进行通信的实际上是进程，而不是程序

- 客户和服务器进程

  - 客户进程/服务器进程   例：web服务中，浏览器：客户进程；web服务器：服务进程

    

- API

  - 进程通过一个称为**套接字** (socket)的软件接口向网络发送报文和从网络接收报文 

  - 套接字是建立网络应用程序的可编程接口，也称为应用程序和网络之间的**应用程序编程接口** (Application Programming Interface , API)

  - 可以控制套接字在**应用层端**，对套接字的**运输层端**几乎没有控制权 

    应用程序开发者对于运输层的控制仅限于：

    ①选择运输层协议;

    ②几个运输层参数

- 进程寻址

  - 标识进程：目的地端口号(port number)：用来标识 运行在主机上的进程

### 4.运输服务

#### 4.1应用程序



- 可靠数据传输：一端发送的应用数据正确、完全地交付给该应用程序的另一端

  - 容忍丢失的应用：能够接受不可靠传输的应用进程

    例如 多媒体应用

- 吞吐量：运输层协议能够以某种特定的速率提供确保的可用吞吐量

  - 具有吞吐量要求的应用程序被称为**带宽敏感的应用** (bandwidth- sensitive applicaLi on)

  - **弹性应用**( el皑白 applicaLi on) 能够根据情况或多或少地利用可供使用的吞吐量

    例如：电子邮件、文件传输以及 Web 传送 

- 定时 

  - 某些服务为了有效性 ，要求数据交付有严格的时间限制

    例如 :交互式实时应用程序

- 安全性

#### 4.2因特网

- 因特网(更一般的是 TCP/IP 网络)为应用程序提供两个运输层协议，即 UDP和 TCP

- ![image-20210527112725518](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527112725518.png)

- **TCP**

- **UDP**

- 互联网运输协议不能提供任何**定时**或**带宽保证**

- 流行的因特网应用及其应用层协议和支撑的运输协议

  ![image-20210527113131403](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527113131403.png)

#### 5.应用层协议

- 作用：定义了运行在不同端系统上的应用程序进程如何相互传递报文：

  - 交换的报文类型，
  - 各种报文类型的语法，
  - 字段的语义
  - 一个进程何时以及如何发送报文，对报文进行响应的规则

- 应用层协议只是网络应用的一部分

- 讨论几种重要的应用: Web 、文件传输、电子邮件、目录服务和P2P

  以及他们的相关协议。



#### 6. URL和URI

URI(Uniform Resource Identifier) 是统⼀资源标志符，可以唯⼀标识⼀个资源。 

URL(Uniform Resource Location) 是统⼀资源定位符，可以提供该资源的路径。它是⼀种具体 的 URI，即 URL 可以⽤来标识⼀个资源，⽽且还指明了如何 locate 这个资源。



## 二、Web与HTTP

### 1.http

#### 1.1概述



- Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) 

- 由两个程序实现：客户端程序和服务器程序
- 使用TCP 作为支撑运输协议
- 无状态协议：不保存关于客户的任何信息
- HTTP 既能够使用非持续连接，也能够使用持续连接，默认状态是持续性连接
  - 持续性连接
  - 非持续性连接

HTTP 是一个在计算机 世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和 规范」。 

HTTP 不止是从互联网服务器传输超文本到本地浏览器的协议，还是服务器到 服务器之间的传输协议。 特性（优缺点）

#### 1.2报文格式

​	分类:请求报文和响应报文

- 请求报文


```
GET / HTTP/1.1
Host: hackr.jp
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0
Accept-Language: ja,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT
If-None-Match: "45bae1-16a-46d776ac"
Cache-Control: max-age=0
```

HTTP 请求报文的第一行 **请求行** (request line) ，

后继的行叫做**首部行**( header line) 

请求行有3个字段:方法字段、 URL 字段和 HTTP 版本字段 

方法宇段可以取几种不同的值，包括 GET POST HEAD PUT DELETE

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。 

HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

Connection: close 首部行

User- agent: 首部行

Accept -language 首部行

首部行 Host: www. someschool. edu

- 请求报文通用首部格式

![image-20220416045545444](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220416045545444.png)

1.在原理方面的区别

一般我们在浏览器中输入一个网址访问网站都是GET请求；

在Form表单中，可以通过设置method 指定提交方式为GET或者POST,默认为GET提交方式。
GET 被称为安全方法，因为使用GET 的HTTP请求不会产什么动作。 即仅仅是只读的操作。
POST可能会修改服务器上的资源的请求。 或者说资源被修改了，这便是“不安全方法”。
2.表现形式的区别

搞清楚了两者的原理区别后，我们来看一下在实际应用中的区别。首先看一下HTTP请求的格式：

＜method> <request-URL> <version>
＜headers>

＜entity-body>

在HTTP请求中，第一行必须是一个请求行，包括请求方法、请求URL、报文所用HTTP版本信息。

紧接着是一个headers小节，可以有零或一个首部，用来说明服务器要使用的附加信息。

在首部之后就是一个空行，最后就是报文实体的主体部分，包含一个由任意数据组成的数据块，但是并不是所有的报文都包含实体的主体部分。

GET请求实例：

GET http: //weibo.com/signup/signup.php?inviteCode-2399493434

Host:weibo.com

Accept: text/html,application/xhtml+xml,application/xml;q-0. 9,image/webp, */*;q-0. 9

POST请求实例：

POST /Inventory-check.cq1 HTTP/1. 1

Host:www.joes-hardware.com

Content-Type:text/plain

Content-length: 191

tem-bandsaw 2647

接下来看看两种请求方式的区别：

（1)GET请求，请求的数据会附加在URL之后，以？分隔URL和传输数据，多个参数用＆连接。URL的编码格式采用的是ASCII编码，而不是Unicode,即是说所有的非ASCI字符都要编码之后再传输。

（2)POST 请求：POST 请求会把请求的数据放置在HTTP请求包的包体中。 GET请求的数据会暴露在地址栏中，而POST请求则不会。

（3)传输数据的大小。在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，GET会受到特定的浏览器和服务器对URL长度的限制。 POST 不是url传值，不会受到影响。



- 响应报文

```
HTTP/1.1 304 Not Modified
Date: Thu, 07 Jun 2012 07:21:36 GMT
Server: Apache
Connection: close
Etag: "45bae1-16a-46d776ac"
```

​	组成：一个初始状态行 (sLatus line) 、首部行 (header 1ine) 、实体体 				(enLity body)-----报文的主要部分

​				Connection: close 首部行

​				Date: 首部行

​				Server: 首部行

​				Last- Moclified: 首部行

​				Conlenl- Length: 首部行

​				Conlent- Type: 首部行





- 响应报文通用格式：

  ![image-20220416045522457](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220416045522457.png)

​	 



- 响应报文常见的状态码和相关的短语:

 200 OK: 请求成功信息在返回的响应报文中

• 301 Movecl Pennanenùy: 请求的对象已经被永久转移了，新的 URL 定义在响应报文的LocaLi oD: 首部行中 客户软件将自动获取新的 URL

• 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解72 

• 404 Not FO lll1 d: 被请求的文档不在服务器上

• 505 HTTP Version Not Supported: 服务器不支持请求报文使用的 HTTP 协议版本

首部字段一览：

通用首部字段

​	![](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220416045946738.png)

请求首部字段

![image-20220416050011909](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220416050011909.jpg)

响应首部字段

​	![image-20220416050039078](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220416050039078.jpg)

实体首部字段

​	![image-20220416050104951](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220416050104951.jpg)



**GET 和 POST 的区别？** 

（1）定义：Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、 图片视频等。比如，打开一个链接，浏览器就会发送 GET 请求给服务

器，服务器就会返回 链接中所有文字及资源。而 POST 方法则是相反操作，它向 URI 指定的资源提交数据，数 据就放在报文的 body 里。比如，在某链接中敲入

了留言后点击「提交」，浏览器就会执行 一次 POST 请求，把留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协 议发送给服务器。 

（2）安全和幂等：安全和幂等的概念【在 HTTP 协议里，所谓的「安全」是指请求方法不 会「破坏」服务器上的资源。所谓的「幂等」，意思是多次执行相同的

操作，结果都是「相 同」的。】那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多 少次，服务器上的数据都是安全的，且每次的结果

都是相同的。POST 因为是「新增或提交 数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资 源，所以不是幂等的。



#### 1.3Cookie

- cookie 技术的4个组件:

  - ①在 HTTP 响应报文中的 cookie 首部行;
  - ②在 HTTP 请求报文中的一个 cookie 首部行;
  - ③在用户端系统中保留有 cookie件，并由用户的浏览器进行管理;
  - ④位于 Web 站点的一个后端数据库

- 流程：

  ![image-20210527203342657](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527203342657.png)



- *****************************************************************************

  



1. 用户首次访问 个站点时，可能需要提供 个用户标识(可能是名字)

2. 在后继会话中，浏览器向服务器传递cookie 首部，从而向该服务器标识了用户

3. 因此 cookie 可以在无状态的 HTTP 之上建立个用户会话层 

4. 浏览器可以禁用Cookie,同时服务端也可以不使用Set-Cookie.

5. Cookie在生成时就会被指定一个Expire值， 就是Cookie的生存周期，在这个周期内cookie有效。有时候设置成0或者负值说明浏览器关闭马上清除cookie信息。

6. Cookie的缺陷

   （1)数量受到限制。一个浏览器能创建的Cookie 数量最多为300个，并且每个不能超过4KB ,每个Web站点能设置的Cookie总数不能超过20个。

   （2)安全性无法得到保障。 在受到跨站点脚本攻自时，脚本指令将会读取当前站点的所有Cookie内容 。一旦Cookie落入攻击者手中，它将会重现其价值。

**整体流程：**
客户端向服务器端发送一个请求时，服务端向客户端发送一个Cookie,然后浏览器将Cookie保存。

Cookie有两种保存方式：一种是浏览器会将Cookie保存在内存中：还有一种是保存在客户端的硬盘中，之后每次HTTP请求浏览器都会将Cookie发送给服务器端。

具体流程如下：

（1)客户端提交一个HTTP请求给服务端。服务端这个时候做了两件事：一是Set-Cookie;二是提交响应内容给客户端，客户端再次向服务器请求时会在请求头中携带一个Cookie.
（2)服务端提交响应内容给客户端。例如，可以分为登录前和登录后。登录前服务端给浏览器一个 Cookie,但是这个 Cookie里面没有用户信息，但是登录成功之后，服务端给浏览器一个Cookie,这个时候的Cookie已经记录了用户的信息，在系统内任意访问，可以实现免登录。



- 注:它的使用仍具有争议，因为它们被认为是对用户隐私的一种侵害

cookie 和 session 的区别：

 1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上. 简单的说，当你登录一个网站的时候，如果 web 服务器端使用的是

session,那么所有的数 据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的 session_id，服务 器根据当前

session_id 判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。 由于数据是存储在服务器 上面，所以你不能伪造，但是

如果你能够获取某个登录用户的 session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。 session_id 是服务器和客户端链接时

候随机分配的，一般来说是不会有重复，但如果有大量 的并发请求，也不是没有重复的可能性， Session 是由应用服务器维持的一个服务器端的存储

空间，用户在连接服务器时，会由服务 器生成一个唯一的 SessionID,用该 SessionID 为标识符来存取服务器端的 Session 存储空间。 而 

SessionID 这一数据则是保存到客户端，用 Cookie 保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数

据。这一过程，是不用开发人员干预的。所以 **一旦客户端禁用 Cookie，那么 Session 也会失效。** 

2、cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗。考虑到安全 应当使用 session。 

3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑 到减轻服务器性能方面，应当使用 COOKIE。 

4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。 (Session 对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)



#### 1.4Web缓存

- **Web 缓存器**也叫**代理服务器**

- 拥有自己的存储空间；

- Web 缓存器是服务器同时又是客户（可以发送和接收响应）

- 部署 Web 缓存器有两个原因：

  - 大大减少对客户请求的响应时间

    - 是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之

      间的瓶颈带宽时更是如此

  - 大大减少一个机构的接入链路到闲特网的通信量

    - 减少通信量， 不必急于增加带宽，降低了费用。

更多:https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching

**重定向和转发的区别** 

​	重定向：redirect 

​	 地址栏发生变化 

​	 重定向可以访问其他站点（服务器）的资源

​	  重定向是两次请求。不能使用 request 对象来共享数据 

​	转发：forward 

​	 转发地址栏路径不变 

​	 转发只能访问当前服务器下的资源 

​	 转发是一次请求，可以使用 request 对象共享数据

#### 1.5 Http的特点

特性（优缺点） 

优点是「简单、灵活和易于扩展、应用广泛和跨平台」。 

1. 简单 HTTP 基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式，易 于理解，降低了学习和使用的门槛。
2. 灵活和易于扩展 HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死， 都允许开发人员自定义和扩充。同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下 层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层， HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。
3.   应用广泛和跨平台 互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP， 从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优 越性。 

HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不 安全」。

1. 无状态双刃剑----解决：Cookie 

   无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态 信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。无状态的坏 处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如登录->添加购 物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这 些请求是有关联的，每次都要问一遍身份信息。这样每操作一次，都要验证信息，这样的购 物体验还能愉快吗？别问，问就是酸爽！对于无状态的问题，解法方案有很多种，其中比较 简单的方式用 Cookie 技术。Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户 端的状态。相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」， 后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了。

2. 明文传输双刃剑 ：解决：Https

   明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。但是这正是这样，HTTP 的 所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都 毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。

3. 不安全 ：解决：Https

   HTTP 比较严重的缺点就是不安全：通信使用明文（不加密），内容可能会被窃听。比如， 账号信息容易泄漏，那你号没了。不验证通信方的身份，因此有可能遭遇伪装。比如，访问 假的淘宝、拼多多，那你钱没了。无法证明报文的完整性，所以有可能已遭篡改。比如，网 页上植入垃圾广告，视觉污染，眼没了。HTTP 的安全问题，可以用 HTTPS 的方式解决， 也就是通过引入 入 SSL/TLS 层，使得在安全上达到了极致。

#### 1.6 Http的性能

HTTP 协议是基于 **TCP/IP**，并且使用了**「请求 - 应答」**的通信模式，所以性能的关键就在这 两点里。 

1. 长连接 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连 接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方 式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负 载。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
2.  管道网络传输 HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了能。即可在同一 个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来， 就可以发第二个请求出去，可以减少整体的响应时间。举例来说，客户端需要请求两个资源。 以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到 后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。但是服务器还是 按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有 许多请求排队等着。这称为「队头堵塞」。
3.  队头阻塞 「请求 - 应答」的模式加剧了 HTTP 的性能问题。因为当顺序发送的请求序列中的一个请 求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求 不到数据，这也就是「队头阻塞」。好比上班的路上塞车。 总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

**这里提到一种心跳监测机制**：

Socket 心跳包机制： 每隔固定时间向服务器发送一个包，以此来告诉服务器，这个客户端还活着。 目的是为了**保持长连接**，一般都是很小的包（节约流量）或者只有包头的空包。 

心跳检测步骤： 

1.客户端每隔一段时间间隔就发送一个探测包给服务器； 

2.客户端发包时启动一个超时定时器； 

3.服务端接收到探测包后会回应一个包； 

4.如果客户端收到服务器的应答包，则说明服务器正常，删除超时定时器；如果没有收到则 服务器异常。

#### 1.7 Https 

HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决Http可能的窃听风险， 篡改风险， 冒充风险。

![](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220416050515083.jpg)

 

过程：

```
 	客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。
 	客 户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是 RSA), 数据签名摘要算法 ( 一般是SHA或者MD5) , 加密传输数据的对称加密算法 ( 一般是 DES),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的 算法发送给客户端，完成协商。
 	客户端生成随机的字符串，通过协商好的非对称加密算法， 使用服务端的公钥对该字符串进行加密，发送给服务端。 
 	服务端接收到之后，使用自己的 私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。
```

![](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/image-20220416052221700.jpg)

步骤 1: 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。
步骤 2: 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
步骤 3: 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
步骤 4: 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。
步骤 5: SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
步骤 6: 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。
步骤 7: 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。
步骤 8: 服务器同样发送 Change Cipher Spec 报文。
步骤 9: 服务器同样发送 Finished 报文。
步骤 10: 服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。
步骤 11: 应用层协议通信,即发送 HTTP 响应。
步骤 12: 最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。



通过上面的概述，我们大致归纳：

SSL/TLS 协议基本流程： 

 客户端向服务器索要并验证服务器的公钥。 

 双方协商生产「会话秘钥」。 

 双方采用「会话秘钥」进行加密通信。 

前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。

1.7.1**https 缺点**

​	贵，慢，安全范围有限，ssl 证书需要绑定 IP，不能在同一 IP 上绑定多个域名， IPv4 资源不可能支撑这个消耗。



1.7.2 Https加密方式：

**混合加密**。

【传输数据用对称加密方式，对称加密生成的秘钥用非对称加密方 式】

 HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式： 

 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 

 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。   

**采用「混合加密」的方式的原因**： 

 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。 

 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交 换问题但速度慢。





**1.7.3  http 和 https 的区别**

 1、http 是超文本传输协议，其中的信息是明文传输的。https 是 http 协议再加上 SSL（安全 套接字层），具有安全性。

 2、http 不验证通信方的身份，通信方的身份有可能遭遇伪装；https 需要到 CA （证书颁发 机构）申请证书，一般免费证书较少，因而需要一定费用。

 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

 4、http 无法证明报文的完整性，报文有可能遭篡改。

 5、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、 身份认证的网络协议，比 http 协议安全。 

6、HTTPS 连接缓存不如 HTTP 高效，流量成本高。 

7、HTTPS 连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。 

8、根据 ACM CoNEXT 数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10% 到 20%的耗电。 

9、HTTPS 协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方 式是采用分而治之，类似 12306 网站的主页使用 HTTP 协议，有关于用户信息等方面使用 HTTPS。

#### 1.8 Http的版本

经过不断的演化，Http也有不同的版本： HTTP 1.0和HTTP 1.1 

HTTP1.0最早在⽹⻚中使⽤是在1996年，那个时候只是使⽤⼀些᫾为简单的⽹⻚上和⽹络请求上，⽽ HTTP1.1则在1999年才开始⼴泛应⽤于现在的各⼤浏览器⽹络请求中，同时HTTP1.1也是当前使⽤最为⼴ 泛的HTTP协议。 

**主要区别**主要体现在： 

1.  HTTP1.1 支持长连接和请求的流水线处理 HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建 立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记 录过去的请求。 HTTP 1.1 则支持持久连接 Persistent Connection, 并且默认使用 persistent connection。在 同一个 TCP 的连接中可以传送多个 HTTP 请求和响应。多个请求和响应可以重叠，多个请求 和响应可以同时进行。更加多的请求头和响应头(比如 HTTP1.0 没有 host 的字段)。 HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的 值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的 值为 close 时，客户端通知服务器返回本次请求结果后关闭连接。 请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应， 减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和 应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连 接。 HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服 务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出 每次请求的响应内容。 
2. 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第 二个请求出去，可以减少整体的响应时间。 
3.  HTTP 1.1 还提供了与身份认证、状态管理和 Cache 缓存等机制相关的请求头和响应头。 
4.  HTTP1.1 增加 host 字段 在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没 有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在 多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。 HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域 会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 
5. 100（Continue）Status（节约带宽） HTTP/1.1 加入了一个新的状态码 100（Continue）。客户端事先发送一个只带头域的请 求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接 收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状 态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server， 看 server 要不要接收 request body，再决定要不要发 request body。 
6.  HTTP/1.1 中引入了 Chunked transfer-coding 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长 度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片 段，避免缓冲整个消息带来的过载。 
7.  HTTP/1.1 在 1.0 的基础上加入了一些 cache 的新特性 当缓存对象的 Age 超过 Expire 时变为 stale 对象，cache 不需要直接抛弃 stale 对象，而是与 源服务器进行重新激活。
8. HTTP 断点重传 HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供 了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服 务器端响应时对应的是 Content-Range。

#### 1.9 Http响应状态码

参见：

https://blog.csdn.net/elevenqiao/article/details/6763040

1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 

100（继续）请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正 在等待其余部分。 

101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 

2xx （成功）表示成功处理了请求的状态码。 

200（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对 您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。  

 201（已创建）请求成功并且服务器创建了新的资源。 

202（已接受）服务器已接受请求，但尚未处理。 

203（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源。 

204（无内容）服务器成功处理了请求，但没有返回任何内容。 

205（重置内容） 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响 应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 

206（部分内容） 服务器成功处理了部分 GET 请求。 

3xx （重定向） 要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建 议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误 导致 Googlebot 无法抓取的网址。 

300（多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选 择一项操作，或提供操作列表供请求者选择。 

301（永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页 或网站已永久移动到新位置。 

302（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来 响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转 到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 

303（查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务 器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 

304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网 页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称 为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变 更，进而节省带宽和开销。 

305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请 求者应使用代理。 

307（临时重定向）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置 来 响 应 以 后 的 请 求 。 此 代 码 与 响 应 GET 和 HEAD 请 求 的 [301](answer.py?answer=) 代码类似，会自动将请求者转到不同的位置，但您不应使 用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位 置并编制索引。 

4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 

400（错误请求） 服务器不理解请求的语法。 

401（未授权）请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 

403（禁止）服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此 状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是 您的服务器或主机拒绝了 Googlebot 访问。 

404（未找到）服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此 代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签 的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而 又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当 位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断” 恐涉侵权，请勿传播 22 标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是 旧链接或输入有误的链接）。 

405（方法禁用） 禁用请求中指定的方法。 

406（不接受）无法使用请求的内容特性响应请求的网页。 

407（需要代理授权）此状态码与 [401（未授权）](answer.py?answer=35128)类似， 但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 

408（请求超时） 服务器等候请求时发生超时。 

409（冲突）服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服 务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列 表。 

410（已删除）如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找 到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如 果资源已永久移动，您应使用 301 指定资源的新位置。 

411（需要有效长度）服务器不接受不含有效内容长度标头字段的请求。 

412（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。 

413（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 

414（请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法处理。

 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 

416（请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态码。 

417（未满足期望值）服务器未满足”期望”请求标头字段的要求。 

5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服 务器本身的错误，而不是请求出错。 

500（服务器内部错误）服务器遇到错误，无法完成请求。 

501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会 返回此代码。 

502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 

503（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 

504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到

505（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。

具体详见 图解http



## 三、文件传输协议：FTP

#### 1. 协议运行

，用户通过一个阿?用户代理与交由该用

户首先提供远程主机的主机名，使本地主机的归?客户进程建立一个到远程主机凹?服务器进程的 TCP 连接。该用户接着提供用户标识和口令，作为 FTP 命令的一

部分在该 TCP连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统(反之亦然)。



#### 2. FTP 和HTTP 的区别

##### 2.1 连接

- FTP 使用了两个并行的 TCP 连接来传输文件
  - 控制连接 (control connection)：在两主机之间传输控制信息
  - 数据连接( data connection)：实际发送一个文件
  - ![image-20210527205305119](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210527205305119.png)
- HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行

##### 2.2 状态

- FTP 服务器必须在整个会话期间保留用户的状态( state)；
- HTTP 是无状态的，即它不必对任何用户状态进行追踪

#### 3.常见命令和回答

- 命令和回答都是7比特 ASCII格式在控制连接上传送

##### 3.1 命令



- 每个命令由 个大写字母 ASCII 字符组成，有些还具有可选参数

- 为常见的命令如下:

  - USER usemame: 用于向服务器传送用户标识

  - P ASS password: 用于向服务器发送用户口令

  - UST: 用于请求服务器回送当前远程目录中的所有文件列表 该文件列表是经一个(新建且非持续连接)数据连接传送的，而不是在控制 TCP 连接上传送。

  - RETR filename: 用于从远程主机当前目录检索(自 gel) 文件 该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件

  - STOR filename: 用于在远程主机的当前目录上存放(即 put) 文件

- 每个命令都对应着一个从服务器发向客户的回答。

##### 3.2 回答 

- 回答是一个三位数字，加上可选信息。

- 一些典型的回答连同它们可能的报文：
  - 331 Usemame OK , Password requüed (用户名 OK ，需要口令)
  - 125 Dala connection already open; transfer starting (数据连接已经打开，开始传送)
  - 425 Can' L open daLa connection (无法打开数据连接)
  - 452 Error writing (写文件差错)

## 四、电子邮件







## 五、DNS

**DNS 使用什么协议进行传输？**



DNS 在进行区域传输的时候使用 TCP 协议，其它时候则使用 UDP 协议； 

DNS 的规范规定了 2 种类型的 DNS 服务器，一个叫主 DNS 服务器，一个叫辅助 DNS 服务器。 在一个区中主 DNS 服务器从自己本机的数据文件中读取该区的 DNS 数据信息，而辅助 DNS 服务器则从区的主 DNS 服务器中读取该区的 DNS 数据信息。当一个辅助 DNS 服务器启动时， 它需要与主 DNS 服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 

**为什么既使用 TCP 又使用 UDP？** 

首先了解一下 TCP 与 UDP 传送字节的长度限制： UDP 报文的最大长度为 512 字节，而 TCP 则允许报文长度超过 512 字节。当 DNS 查询超过 512 字节时，协议的 TC 标志出现删除标志，这时则使用 **TCP 发送**。通常传统的 UDP 报文一 般不会大于 512 字节。 

区域传送时使用 TCP，主要有一下两点考虑： 

​	1.辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。 如有变动，则会执行

​	一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP，因为 数据同步传送的数据量比一个请求和应答的数据量要多得多。 

​	2.TCP 是一种可靠的连接，保证了数据的准确性。 

域名解析时使用 UDP 协议： 客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。不 用经过 TCP 三次握手，这样 DNS 服务

器负载更低，响应更快。虽然从理论上说，客户端也 可以指定向 DNS 服务器查询的时候使用 TCP，但事实上，很多 DNS 服务器进行配置的时候， 仅支持 UDP 查

询包。 

 使用 UDP 传输是由于效率高，传输小于等于 512 字节报文。 

 使用 TCP 传输是由于可以传输大于 512 字节报文。 

 使用签名是保证数据来源的可靠性。 

 使用 TCP 传输，同样是可以传输证书链、签名。 

 使用 UDP 同样可以传输远远大于 576 字节的数据，只要应用程序可以标识数据 ID。



**DNS 劫持是什么？**

 DNS 劫持是一种恶意攻击，DNS 劫持也称为 DNS 重定向，通过覆盖计算机的 TCP / IP 设置， 将个人查询重定向到域名服务器 DNS。这可以通过使用恶意软件或修改服务器的设置来实 现，一旦执行 DNS 劫持的个人控制了 DNS，他们就可以使用它来将流量引导到不同的网站。 DNS 劫持：在 DNS 服务器中，将 www..com 的域名对应的 IP 地址进行了变化。你解析 出来的域名对应的 IP，在劫持前后不一样。 HTTP 劫持：你 DNS 解析的域名的 IP 地址不变。在和网站交互过程中的劫持了你的请求。在 网站发给你信息前就给你返回了请求。





## 六、P2P



 





