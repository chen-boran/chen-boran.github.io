---
title: Redis 客户端与服务器
date: 2021-11-14 20:14:31
 
tags:
- Redis
categories:
- Notes
keywords:
description:
top_img:
comments:
cover:	https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203151833185.jpg
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside: 
---



## 一、客户端

### 概述

Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。



Redis使用单线程处理命令请求。

服务器 为每个与它进行连接的客户端创建redis.h/redisClient结构（客户端状态）

保存客户端状态，包括：

❑客户端的套接字描述符。

❑客户端的名字。

❑客户端的标志值（flag）。

❑指向客户端正在使用的数据库的指针，以及该数据库的号码。

❑客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。

❑客户端的输入缓冲区和输出缓冲区。

❑客户端的复制状态信息，以及进行复制所需的数据结构。

❑客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。

❑客户端的事务状态，以及执行WATCH命令时用到的数据结构。

❑客户端执行发布与订阅功能时用到的数据结构。

❑客户端的身份验证标志。

❑客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。

对于客户端的操作可以通过遍历Client链表完成。

### 一、属性

大致分成两类：

- 一类是比较通用的属性（所有客户端都会用到）
- 与特定功能有关的属性

下面主要介绍通用属性，其他属性会慢慢提到。

#### 1.1套接字描述符

使用fd属性来记录客户端正在使用的套接字描述符。

fd属性的值可以是-1或者是大于-1的整数：

- 伪客户端（fake client）的fd属性的值为-1
- 普通客户端的fd属性的值为大于-1的整数（使用套接字与服务器进行通信）

说明：合法的套接字描述符不能是-1

​			伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，不需要套接字连接。

**名字** 

默认情况下连接到服务器的客户端是没有名字的

使用CLIENT setname命令可以为客户端设置一个名字，便与鉴别和管理。

客户端的名字存放在客户端状态Clientname属性里面。

注：如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指针；相反地，如果客户端为自己设置了名字，那么name属性将指向一个字符串对象

**标志**

客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态

常见的标志：

:one:表示客户端角色信息：

- REDIS_MASTER标志表示客户端代表的是一个主服务器，
- REDIS_SLAVE标志表示客户端代表的是一个从服务器。

:two:表示状态信息

- REDIS_MONITOR标志表示客户端正在执行MONITOR命令
- REDIS_MULTI标志表示客户端正在执行事务
- REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端

举了几个例子，需要注意的是上面的标志都定义在redis.h中

值得一提的是：**PUBSUB命令和SCRIPT LOAD命令**具有特殊性，虽然没有对数据库进行了修改，但是也会强制写入AOF文件。

**输入缓冲区**

客户端状态的输入缓冲区**用于保存客户端发送的命令请求**：

![image-20220317200957406](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172009559.png)

输入缓冲区的大小会根据输入内容动态地缩小或者扩大， 不能超过1GB，否则服务器将关闭这个客户端。

**命令和命令参数**

 服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析， 将得出的命令参数以及命令参数的个数分别保存到客户端状态的**argv属性和argc属性：**

- argv ：一个数组，每一项都是一个字符串对象，argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。
- argc ：记录argv数组的长度。

**命令的实现函数**

当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数

流程：

- 程序在命令表中成功找到argv[0]所对应的redisCommand结构
- 客户端状态的cmd指针指向这个结构
- 服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。

**输出缓冲区**

执行命令所得的命令回复会被保存在客户端状态的输出缓冲区

每个客户端都有两个输出缓冲区可用 ：

- **固定大小的缓冲区**用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。
- **可变大小的缓冲区**用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。

**身份验证**

定义在客户端状态Client中;

![image-20220317202032396](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172020516.png)

客户端状态的authenticated属性用于记录客户端是否通过了身份验证：

- authenticated的值为0， 表示客户端未通过身份验证 
- authenticated的值为1， 表示客户端已经通过了身份验证。

**时间**

客户端还有几个和时间有关的属性：

![image-20220317202216334](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172022459.png)

- time属性记录了创建客户端的时间（与服务器连接的时间）
- lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间
- lastinteraction属性可以用来计算客户端的空转（idle）时间
- obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间

### 二、客户端的创建和关闭

#### **创建**

创建可以分成普通客户端和其他的客户端

首先是普通客户端的创建

**普通客户端**:客户端是通过网络连接与服务器进行连接的

那么客户端使用connect函数来津街道服务器，服务器就会调用连接事件处理器，为客户端创建客户端状态，并且添加到服务器状态结构Client链表末尾。

#### 关闭

关闭的原因：

一般来说关闭有好多种情形：

- 客户端进程退出或者被杀死
- 客户端进程退出或者被杀死，客户端被服务器关闭
- 客户端成为了CLIENT KILL命令的目标，那么它也会被关闭
- 用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关
- 客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB）
- 要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小

前面提到输出缓冲区中的可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上可以保存任意长的命令回复。但是为了避免客户端回复过大，服务器还是会监控并且限制其大小。



**服务器使用两种模式来限制客户端输出缓冲区的大小**

- 硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。
- 软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并obuf_soft_limit_reached_time属性的值也会被清零。

使用client-output-buffer-limit选项设置相关限制。

#### Lua脚本的伪客户端

服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端， 将这个伪客户端关联在服务器状态结构的lua_client属性中 。

#### AOF文件的伪客户端

服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。



## 二、服务器

### 一、概述

Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。



### 二、命令请求执行过程

一个命令从发送到回复，客户端和服务器需要完成一系列操作

下面举一个例子，便于更好理解。

客户端执行： SET KEY VALUE

客户端和服务器共需要执行以下操作：

1）客户端向服务器发送命令请求SET KEY VALUE。

2）服务器接收并处理客户端发来的命令请求SET KEYVALUE，在数据库中进行设置操作，并产生命令回复OK。

3）服务器将命令回复OK发送给客户端。

4）客户端接收服务器返回的命令回复OK，并将这个回复打印给用户观看。

这只是简要的执行流程，下面进行细化。



#### 发送命令请求

命令请求来自客户端，客户端感受到用户输入的命令，首先要转换成协议格式，然后通过连接到服务器的套接字发送。



流程如下：

![image-20220317205136214](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172051343.png)



#### 读取命令请求

客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：

1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。

2）对输入缓冲区中的命令请求进行分析，提取出**命令请求中包含的命令参数**，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。

3）调用命令执行器，执行客户端指定的命令。



不同的命令，命令执行器所做的工作也不同，下面详细介绍。

#### 命令执行器（1）：查找命令实现

根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的**cmd属性**里面。

**命令表**：是一个字典,**键**时命令的名字，**值**是redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息

举个例子便于理解：

还是之前的SET 命令

步骤如下：

- 程序以 argv[0]作为输入，在命令表中进行查找。

- 命令表将返回"set"键所对应的redisCommand结构

- 客户端状态的cmd指针会指向这个redisCommand结构

![image-20220317205904523](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172059662.png)

注：命令的查找**无关大小写**



#### 命令执行器（2）：执行预备操作

除了需要之前提到的执行命令所需的命令实现函数、参数、参数个数，真正执行命令之前，程序还需要进行一些预备操作。

常见的操作包括：

- 检查客户端状态的cmd指针是否指向NULL（没找到相关的命令实现，向客户端返回一个错误）
- 根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确（不正确直接向客户端返回错误）
- 检查客户端是否已经通过了身份验证（未通过身份验证的客户端只能执行AUTH命令）
- 如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收
- 如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误
- 如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令
- 如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行
- 如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWNnosave命令和SCRIPT KILL命令
- 客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中
- 服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器

全部执行之后，就开始真正执行命令了。

#### 命令执行器（3）：调用命令的实现函数

因为命令实现保存在cmd属性，命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性

因此当服务器决定要执行命令时，执行

![image-20220317210710763](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172107868.png)

命令的实现函数只需要一个指向客户端状态的指针作为参数即可。

#### 命令执行器（4）：执行后续工作

执行完实现函数之后，服务器还需要执行一些后续工作：

- 如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。

- 根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。

- 如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。

- 如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器

命令执行就基本告一段落了



#### 命令回复发送给客户端

:one:命令实现函数会将命令回复保存到客户端的输出缓冲区里面

:two:为客户端的套接字关联**命令回复处理器。**

:three:客户端套接字变为可写状态时，服务器就会执行命令回复处理器，

:four:命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区

####  客户端接收并打印命令回复

客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看

![image-20220317211105869](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172111993.png)

OK

### 二、serverCron函数

Redis服务器中的serverCron函数默认每隔**100毫秒**执行一次， 负责管理服务器的资源。



首先介绍serverCron函数的执行操作

#### 1、更新服务器时间缓存

不少功能需要用到系统当前时间。为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存。

ServerCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性。

因此这两个属性的精确度并不高。对于时间精确度不高的服务适用。

#### 2、更新LRU时钟

服务器状态中的lruclock属性保存了服务器的LRU时钟，也服务器时间缓存的一种。

此外，每个Redis对象都会有一个lru属性， 保存对象最后一次被命令访问的时间：

![image-20220317211638409](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202203172116544.png)

 serverCron函数默认会以每10秒一次的频率更新lruclock属性的值

因此LRU时间实际上只是一个模糊的估算值。

#### 3、更新服务器每秒执行命令次数

 #### 4、更新服务器内存峰值记录

#### 5、处理SIGTERM信号

#### 6、管理客户端资源

serverCron函数每次执行都会调用clientsCron函数对一定数量的客户端进行以下检查。

- 连接时间检查：超时就释放这个客户端
- 如果客户端执行命令导致输入缓冲区的大小超过了一定的长度， 程序就会释放客户端当前的输入缓冲区

#### 7、管理数据库资源

serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作

#### 8、执行被延迟的BGREWRITEAOF

#### 9、检查持久化操作的运行状态

#### 10、将AOF缓冲区中的内容写入AOF文件

如果开启了AOF持久化，那么就会将缓冲区内的数据写入AOF文件。

#### 11、关闭异步客户端

#### 12、增加cronloops计数器的值



### 三、初始化服务器

Redis服务器 启动到运行，需要经过一系列的初始化和设置过程

下面详细介绍：

#### 1、初始化服务器状态结构

首先创建一个struct redisServer类型的实例变量server 作为服务器的状态（根据默认值）

初始化server变量的工作由redis.c/initServerConfig函数完成

主要工作：

- 设置服务器的运行ID。
- 设置服务器的默认运行频率。
- 设置服务器的默认配置文件路径。
- 设置服务器的运行架构。
- 设置服务器的默认端口号。
- 设置服务器的默认RDB持久化条件和AOF持久化条件。
- 初始化服务器的LRU时钟。
- 创建命令表

#### 2、 载入配置选项

启动服务器，用户可以更改默认配置。

服务器在用initServerConfig函数初始化完server变量之后，就会开始载入用户给定的配置参数和配置文件，并作出相应更改。

#### 3、初始化服务器数据结构

执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构

当然还有其他数据结构。

例如：

- server.clients链表：记录了所有与服务器相连的客户端的状态结构

- server.db数组：包含了服务器的所有数据库。
- 包含了服务器的所有数据库。
- 用于保存慢查询日志的server.slowlog属性
- 用于保存频道订阅信息的server.pubsub_channels字典
- 用于保存模式订阅信息的server.pubsub_patterns链表

注：服务器将调用**initServer函数**，为以上提到的数据结构分配内存



**服务器运行到现在才进行初始化创建的原因在于：**

​	服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化

服务器选择了将server状态的初始化分为两步进行：

- initServerConfig函数主要负责初始化一般属性

- initServer函数主要负责初始化数据结构。

####  4、还原数据库状态

数据库初始化完成之后，要载入RDB文件或者AOF文件，完成数据库的还原。（优先使用 AOF文件还原）

#### 5、执行事件循环

初始化的最后一步：打印出日志，并开始执行服务器的事件循环（loop）

### 三、总结

- 一个命令请求从发送到完成主要包括以下步骤：

1）客户端将命令请求发送给服务器；

2）服务器读取命令请求，并分析出命令参数；

3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；

4）服务器将命令回复返回给客户端。



- serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。



- 服务器从启动到能够处理客户端的命令请求需要执行以下步骤：

1）初始化服务器状态；

2）载入服务器配置；

3）初始化服务器数据结构；

4）还原数据库状态；

5）执行事件循环。
