## 数据类型

**自动装箱/拆箱是什么？**

 每个基本数据类型都对应一个包装类，除了 int 和 char 对应 Integer 和 Character 外，其 余基本数据类型的包装类都是首字母大写即可。 

自动装箱： 将基本数据类型包装为一个包装类对象，

例如向一个泛型为 Integer 的集合添 加 int 元素。  

自动拆箱： 将一个包装类对象转换为一个基本数据类型

例如将一个包装类对象赋值给一 个基本数据类型的变量。

 比较两个包装类数值要用 equals ，而不能用 == 。 

 

Java 按值调用还是引用调用 ?

按值调用指方法接收调用者提供的值。

按引用调用指方法接收调用者提供的变量地址。

 **Java 总是按值调用**，方法得到的是所有参数值的副本，传递对象时实际上方法接收的是对 象引用的副本。

方法不能修改基本数据类型的参数，如果传递了一个 int 值 ，改变值不会 影响实参，因为改变的是值的一个副

本。 可以改变对象参数的状态，但不能让对象参数引用一个新的对象。

如果传递了一个 int 数 组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象。

**基本数据类型**：

![image-20220413052002623](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220413052002623.png)



**大数**：

基本数据类型或者浮点数不够精确的话，那么可以使用java.Math中的两个很有用的类：BigInteger、BigDecimal

BigInteger将实现任意精度的整数运算、BigDecimal实现任意精度的浮点数运算。

使用静态的valueOf方法可以将普通的数值转换为大数值：

​		BigInteger a =BigInteger.Valueof(100);

更大的数可以使用带字符串参数的构造器

BigInteger aa=new BigInteger（“65463213218679879746546464”）

注：不能使用 熟悉的算术运算符（如：+和*）处理大数值。而需要使用大数值类中的add和multiply方法。

常见的API 方法：

**API java.math.BigInteger 1.1**

● BigInteger add(BigInteger other)

● BigInteger subtract(BigInteger other)

● BigInteger multiply(BigInteger other)

● BigInteger divide(BigInteger other)

● BigInteger mod(BigInteger other)返回这个大整数和另一个大整数other的和、差、积、商以及余数。

● int compareTo(BigInteger other)如果这个大整数与另一个大整数other相等，返回0；如果这个大整数小于另一个大整数other，返回负数；否则，返回正数。

● static BigInteger valueOf(long x)返回值等于x的大整数。

 **java.math.BigDecimal 1.1**

● BigDecimal add(BigDecimal other)

● BigDecimal subtract(BigDecimal other)

● BigDecimal multiply(BigDecimal other)

● BigDecimal divide(BigDecimal other RoundingMode mode) 

返回这个大实数与另一个大实数other的和、差、积、商。要想计算商，必须给出舍入方式（rounding mode）。RoundingMode.HALF_UP是在学校中学习的四舍五入方式（即，数值0到4舍去，数值5到9进位）。它适用于常规的计算。有关其他的舍入方式请参看API文档。

● int compareTo(BigDecimal other)如果这个大实数与另一个大实数相等，返回0；如果这个大实数小于另一个大实数，返回负数；否则，返回正数。

● static BigDecimal valueOf(long x)

● static BigDecimal valueOf(long x, int scale)返回值为x或x / 10scale的一个大实数。



## 变量和常量

### 常量

使用final修饰的在程序运行中只能被赋值一次，之后值不会再改变的量。

通常使用大写字母定义名称；可以使用下划线、$、大小写字母、数字。

但是不能以数字开头。

### 变量

变量的作用域规定了变量所能使用的范围，只有在作用域范围内变量才能被使用。根据变量声明地点的不同，变量的作用域也不同。

 基本格式：

​	数据类型   变量名称

根据作用域的不同，一般将变量分为不同的类型：成员变量和局部变量。下面对这几种变量进行详细说明。

#### 成员变量

[Java](http://c.biancheng.net/java/) 的成员变量有两种，分别是全局变量和静态变量（类变量）。定义在方法体和语句块之外，不属于任何一个方法，作用域是整个类。



| 名称                 | 修饰           | 访问                       | 生命周期                                                     |
| -------------------- | -------------- | -------------------------- | ------------------------------------------------------------ |
| 全局变量（实例变量） | 无 static 修饰 | 对象名.变量名              | 只要对象被当作引用，实例变量就将存在                         |
| 静态变量（类变量）   | 用 static 修饰 | 类名.变量名或对象名.变量名 | 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 |


 ![image-20220410210924382](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/image-20220410210924382.png)

```

```

注：

实例方法可以对当前对象的实例变量进行操作，也可以对类变量进行操作。实例方法由实例对象调用。

类方法不能访问实例变量，只能访问类变量。类方法由类名或者实例对象调用。类方法中不能出现this或者super关键字




#### 局部变量

局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：

- 方法参数变量（形参）：在整个方法内有效。
- 方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。
- 代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。


局部变量在使用前必须被程序员主动初始化值。

#### 1）方法局部变量

声明两个局部变量并输出其值，其实现代码如下：

```
public class Test2 {    public static void main(String[] args) {        int a = 7;        if (5 > 3) {            int s = 3; // 声明一个 int 类型的局部变量            System.out.println("s=" + s);            System.out.println("a=" + a);        }        System.out.println("a=" + a);    }}
```

上述实例中定义了 a 和 s 两个局部变星，其中 int 类型的 a 的作用域是整个 main() 方法，而 int 类型的变量 s 的作用域是 if 语句的代码块内，其执行结果如图 2 所示：



 


如果在 if 方法外调用变量 s，则会报无法解析该变量的错误。

#### 2）方法参数变量

作为方法参数声明的变量的作用域是整个方法。

声明一个方法参数变量，实现代码如下：

```
public class Test3 {    public static void testFun(int n) {        System.out.println("n=" + n);    }    public static void main(String[] args) {        testFun(3);    }}
```

在上述实例中定义了一个 testFun() 方法，该方法中包含一个 int 类型的参数变量 n，其作用域是 testFun() 方法体内。当调用方法时传递进了一个参数 3，因此其输出控制台的 n 值是 3。

#### 3）代码块局部变量

代码块局部变量常用于 try catch 代码块中，成为异常处理参数变量。

异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似。

声明一个异常处理语句，实现代码如下：

```
纯文本复制
public class Test4 {    public static void test() {        try {            System.out.println("Hello!Exception!");        } catch (Exception e) { // 异常处理块，参数为 Exception 类型            e.printStackTrace();        }    }    public static void main(String[] args) {        test();    }}
```



**【java】static、final、static final 的区别** 

1、static static 表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态 static 代码块，但是 Java 语言中没有全局变量的概念。被 static 修饰的成员变量和成员方法 独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这 个类被加载，Java 虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static 对象可以在它的任何对象创建之前访问，无需引用任何对象。Public 修饰的 static 成员变量 和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成 static 变量的副本， 而是类的所有实例共享同一个 static 变量。 - 类成员变量 - 静态变量（类变量）: static 修饰 - 实例变量 : 无 static 修饰 - 局部变量

2、final final 类不能被继承，没有子类，final 类中的方法默认是 final 的； final 方法不能被子类的方法复盖，但可以被继承； final 成员变量表示常量，只能被赋值一次，赋值后不能再被改变； final 不能用于修饰构造方法； private 不能被子类方法覆盖，private 类型的方法默认是 final 类型的。 final 修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 注意：final 变量定义的时候，可以先声明，而不给初值，这中变量也称为 final 空白，无论 什么情况，编译器都确保空白 final 在使用之前必须被初始化。 3、static final static final 用来修饰成员变量和成员方法，可以理解为“全局变量”。 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 对于方法，表示不可覆盖，并且可以通过类名直接访问。 static 修饰的属性强调它们只有一个，final 修饰的属性表明是一个常数（创建后不能被修改）。 static final 修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final 也可 以修饰方法，表示该方法不能重写，可以在不 new 对象的情况下调用。 注意： 对于被 static 和 final 修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比 如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放 的对象。 static final 和 final static 语法和用法上没有任何区别，一般习惯 static 写在前面。

**局部变量和成员变量的区别？**

局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。
成员变量是指在类的体系结构的变量部分中定义的变量
局部变量和成员变最的区别
(1）定义的位置。
局部变量：定义在方法的内部。
成员变量：定义在方法的外部，即直接写在类中。
（2）作用范围。
局部变量：只适用于方法中，描述类的公共属性
成员变量：整个类中都可以通用。
（3）默认值（初始化）。
局部变量：没有默认初始值，需要手动进行赋值之后才能使用
成员变量：有默认初始值，如int类型的默认值为0:foat 类型的默认值为0.0f:double 类
型的默认值为0.0。
（4）内存的位置。
局部变量：位于栈内存。
成员变量：位于堆内存
（5）生命周期
局部变量：在调用对应的方法时，局部变量因为执行创建语句而存在，超出自己的作用域
之后会立即从内存消失。



## 运算符和表达式

### 算术运算符

### 关系运算符

### 逻辑运算符

### 赋值运算符

### 位运算符

## 流程控制语句

### 顺序语句

### 条件语句

if、if.....else 、if嵌套

### 选择语句

switch 

语句变量中的类型可以是：byte、short、char、int

每一个case之后加一个比较的值和一个冒号

可以在最后添加一个default分支

### 循环语句

while、do.....while 、for  

#  面向对象

面向对象的理解？
在解释面向对象之前，先介绍一下什么是对象
在Java语言中，把对象当作一种变量，它不仅可以存储数据，还可以对自身进行操作。每个对象都有各自的属性及方法，Java 就是通过对象之间行为的交互来解决问题的。
在我看来，而向对象就是把构成问题的所有事务分解成一个个的对象，建立这些对象去描述某个事务在解决问题中的行为。而类就是面向对象中很重要的一部分，类是很多个具有相同属性和行为特征的对象所抽象由来的，对象是类的一个实例。
类还具有三个特性，即封装、继承和多态。
（1）封装：将一类事务的属性和行为抽象成一个类，只提供符合开发者意愿的公有方法来
访问这些数据和逻辑，在提高数据的隐秘性的同时，使代码模块化。
（2）继承：子类可以维承父类的属性和方法，并对其进行拓展。
（3）多态：同一种类型的对象执行同一个方法时可以表现由不同的行为特征。通过继承的
上下转型、接口的回调以及方法的重写和重载可以实现多态。

## 三大特征

###  封装

面向对象的核心思想。

指的是将对象的属性和行为进行封装，不让外界知道具体的实现细节。

封装的好处：

- 安全性：把过程和数据封装，只能通过预定义的接口对数据进行访问。隐藏信息、实现细节。
- 减少耦合，类的内部结构可自由修改。

### 继承

指的是类与类之间的关系。

子类只能继承父类中的能够被访问的（public、protect）方法和属性；私有方法和属性能够被继承，但是无法访问。

好处：

高效的对原有类进行扩展。

提高代码的复用性

对于程序的修改，补充提供了便利条件。

继承使用extends关键字。

值得注意的是，Java中只支持使用单继承，这一点和C++中 不同。



### 多态

多态是把子类型对象主观的看成父类型的对象。因此不同子类继承父类，就会有很多种类型。

运行的时候会根据不同种类型调用相关类型中定义的方法

## 类和对象

java创建对象的方式：

（1）通过ncw 语句实例化一个对象。
使用 new 关键字创建对象是最常见的一种方式，但是使用 new 创建对象会增加帮合度。在使用new 时需要先查看new 后面的类型，然后再决定分配多大的内存空间：接着可以通过调用构造函数，来对对象的各个域进行充；根据构造方法的返回值进行对象的创建，最后把引用地址传递给外部。

例如：
package test;
/使用new 关使字创建对像
publlo class Newclass{
public static vold main(StringDargs){
Hello h = new Hel1o（）；
h.sayworld（）；

​	}

}

（2）通过反射机制创建对象。
使用反射机制的Class类的newInstance0方法。
（3）通过clonc0方法创建一个对象。
在使用 clone0方法时，不会调用构造函数，而是需要有一个分配了内存的源对象。在创建新对象时，首先应该分配一个和源对象一样大的内存空间。
（4）通过反序列化的方式创建对象。
序列化就是把对象通过流的方式存储到文件里面，那么反序列化就是把字节内容读出来并还原成Java对象，这里还原的过程就是反序列化。在使用反序列化时也不会调用构造方法。



## 抽象类和方法

抽象类可以实现接口，当一个类实现一个借口，但是没有实现接口中的所有方法，那么这个类必须是抽象类。

抽象类可以继承实体类，但是实体类中必须有明确的构造函数。

## 接口

接口和抽象类的异同：

- 相同点
  - 都可以被继承
  - 都不能直接实例化
  - 都可以包含抽象方法
  - 派生类都必须实现未实现的方法
- 不同点
  - 接口支持多继承
  - 一个类只能继承一个抽象类，但是可以实现多个接口
  - 接口中的成员变量只能是 pubic、static、final的，抽象类没有限制
  - 接口只能定义抽象方法，抽象类可以定义抽象方法，也可以定义实现方法
  - 接口中不能含有静态代码快以及静态方法。抽象类可以。

## java访问修饰符



Java 中有四种访问修饰符，分别为 publie、private、protected 和defaulte

- public：公有的。用 public 修饰的类、属性及方法，不仅可以踏类访问，而且允许路包
  （package）访间。

- private：私有的。用 private 修饰的类、属性以及方法只能被该类的对象访问，其子类
  不能访问，更不允许踏包访问。

- protected:介于 public 和 privale 之间的一种访问修饰符。用 prolected 修饰的类、属性
  以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访间。

- default：默认访问模式。在该模式下，只允许在同一个包中进行访问。

- 注意

  ☆ protected 修饰符所修饰的类属于成员变量和方法，只可以被子类访问，而不管
  子类是不是和父类位于同一个包中。

  defaullt修饰符所修饰的类也属于成员变量和方法，但只可被同一个包中的共他类访问，而不管其他类是不是该类的子类.

  protecled 属于子类限制修饰，而default 属于包限制修饰符。



