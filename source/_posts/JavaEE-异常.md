# 异常

什么是异常？

我们知道程序运行过程中，可能会因为外部问题导致程序异常，中断程序运行。

在Java等面向对象语言中，异常是一个对象，产生一个异常就是生成了一个异常对象。（java中异常不是错误） 

## 内置异常类

### Java中异常产生原因

-  java内部异常，即虚拟机异常。
- 编写代码错误导致的异常。例如空指针异常、数组越界异常。
- 通过Throw语句自动生成。被称为检查异常，来告知方法的调用者一些信息。

### 内置异常类

Java中所有异常都是java.lang.Throwable类的子类。Throwable有两个子类：Error和Exception

Exception又分成运行时异常和非运行时异常。

![](https://cdn.jsdelivr.net/gh/chen-boran/Picture_bed/img/202204122123319.png)




 Java标准库内建了一些通用的异常。

以Throwable为顶层父类。Throwable 又派生出Error类和 Exception类。

（1)错误：Error类以及它的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出

现。因此，程序员应该关注Exception为父类的分支下的各种异常类。

（2)异常：Exception以及它的子类，代表程序运行时发生的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。Java异常的分类如图6-4所示。总体上根据javac对异常的处理要求，将异常类分为两类。

- 非检查异常（unckecked exception):Error和 Runtime Exception以及它们的子类。

 	在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。 这样的异常多半是因为代码编写问题。

- 检查异常（checked exception):除了 Error和Runtime Exception的其他异常。

​	javac强制要求程序员为这样的异常做预备处理工作（使用try··catch···finally或者throws).在方法中要么用try···catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。

这样的异常一般是由程序的运行环境导致的。 

如SQLException、IOException、ClassNotFoundException异常等。 
**☆注意☆ 检查和非检查是对于javac来说的** 

### Java常见异常类型

![](/home/cbr/Documents/Blog/chen-boran.github.io/source/_posts/202204122200024.png)



## 异常处理机制





**异常处理机制**

通常分成两种 ：

- 抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。

  运行时系统负责寻找处置异常的代码并执行。

- 捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exceptionhandler).潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查并且调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器时，运行时系统终止。同时，意味着Java程序的终止。

总体来说：对于可查异常必须捕获或者声明抛出；允许忽略不可查的Runtime Exception和Error

抛出异常的方法有两种，分别为throws和throw

- throws：通常定义在方法生命的位置，制定方法可能抛出的异常，多个异常用逗号隔开。

  表示此方法不处理异常，由方法调用处进行处理。

  是将异常一层一层抛给上层代码，直到有能够处理异常的代码。

- throw：定义在方法体中，或者抛出用户自定义异常。

  作用就是抛出一个异常类的实例化对象。

  程序执行到throw停止，想要捕获throw异常，需要使用try...catch或者try ....catch.....finally


 **throw和throws的区别?**

①throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。

②throws 语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。

③throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。

④throw是具体向外抛异常的动作，所以它是抛出一个异常实例。

⑤throws 出现在方法函数头；而throw 出现在函数体。

⑥throws表示出现异常的一种可能性，并不一定会发生这些异常：throw则是抛出了异常，执行throw则一定抛出了某种异常。

⑦两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

## 自定义异常

**为什么要自定义异常呢？**

Java中的不同异常，分别代表不同类型的异常情况。具体开发中总会有没有定义好的但是同时需要的异常类型。

我们可以根据具体情况自定义异常类。

**如何定义？**

 （1)所有异常都必须是Throwable的子类。

（2)如果希望写一个检查异常类，则需要继承 Exception类。

（3)如果希望写一个运行时异常类，则需要继承 RuntimeException类。

例子：

public class CommonException extends RuntimeExceptionpublic  {

 public	CommonException(String msg) {

​		super (msg) ；

​	}

}

public void testCommonException (){

​	throw new CommonException(“错误”）；

}

**自定义异常的缺点？**

 发现异常、抛出异常和处理异常的工作必须靠编程人员在代码中利用异常处理机制自己完成。这样就相应地增加了一些开发成本和工作量，所以若没必要，也不一定非得要用自定义异常。 

 

## 常见问题

### finally代码块一定会执行吗？


Java程序中的finally块并不一定会被执行，至少有两种情况finally语句是不会执行的。

（1)try语句没有被执行到。即没有进入try代码块，对应的finally 自然不会执行。比如，在try语句之前retun就返回了，这样finally不会执行；或者在程序进入Java之前就出现异常，会直接结束，也不会执行finally块。 

（2)在try···catch块中有 System.exit(0)来退出JVM.System.exit(0)是终止JVM的，会强制退出程序，finally{}中的代码就不会被执行。

### 运行时异常和一般异常有什么区别？

Java提供了常出现的两类异常；检查异常和运行时异常。

（1)检查异常主要是指V/O异常、SQL异常等。对于这种异常，JVM要求我们必须对其进行catch处理，所以，面对

这种异常，不管我们是否愿意，都是要写一大堆的catch块去处理可能出现的异常。

（2)运行时异常一般不处理，当出现这类异常的时候程序会由虚拟机接管。 出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码。

如果没有catch块进行处理，到了最上层。如果是多线程就有ThreadO抛出，如果不是多线程那么就由main抛出。

 也就是说，如果不对运行时异常进行catch处理，那么结果不是线程退出就是主程序终止。 